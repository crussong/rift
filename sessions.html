<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="view-transition" content="same-origin">
    <title>RIFT – Sessions</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/sidebar.css">
    <link rel="stylesheet" href="assets/css/topbar.css">
    <link rel="stylesheet" href="assets/css/footer.css">
    <link rel="stylesheet" href="assets/css/hub.css">
    <link rel="stylesheet" href="assets/css/sessions.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
</head>
<body>
    <div class="app">
        <main class="main">
            <div class="main__content">
                
                <!-- Page Header -->
                <div class="page-header">
                    <div class="page-header__icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M21.8382 11.1263L21.609 13.5616C21.2313 17.5742 21.0425 19.5805 19.8599 20.7902C18.6773 22 16.9048 22 13.3599 22H10.6401C7.09517 22 5.32271 22 4.14009 20.7902C2.95748 19.5805 2.76865 17.5742 2.391 13.5616L2.16181 11.1263C1.9818 9.2137 1.8918 8.25739 2.21899 7.86207C2.39598 7.64823 2.63666 7.5172 2.89399 7.4946C3.36968 7.45282 3.96708 8.1329 5.16187 9.49307C5.77977 10.1965 6.08872 10.5482 6.43337 10.6027C6.62434 10.6328 6.81892 10.6018 6.99526 10.5131C7.31351 10.3529 7.5257 9.91812 7.95007 9.04852L10.1869 4.46486C10.9888 2.82162 11.3898 2 12 2C12.6102 2 13.0112 2.82162 13.8131 4.46485L16.0499 9.04851C16.4743 9.91812 16.6865 10.3529 17.0047 10.5131C17.1811 10.6018 17.3757 10.6328 17.5666 10.6027C17.9113 10.5482 18.2202 10.1965 18.8381 9.49307C20.0329 8.1329 20.6303 7.45282 21.106 7.4946C21.3633 7.5172 21.604 7.64823 21.781 7.86207C22.1082 8.25739 22.0182 9.2137 21.8382 11.1263ZM12.9524 12.699L12.8541 12.5227C12.4741 11.841 12.2841 11.5002 12 11.5002C11.7159 11.5002 11.5259 11.841 11.1459 12.5227L11.0476 12.699C10.9397 12.8927 10.8857 12.9896 10.8015 13.0535C10.7173 13.1174 10.6125 13.1411 10.4028 13.1886L10.2119 13.2318C9.47396 13.3987 9.10501 13.4822 9.01723 13.7645C8.92945 14.0468 9.18097 14.3409 9.68403 14.9291L9.81418 15.0813C9.95713 15.2485 10.0286 15.3321 10.0608 15.4355C10.0929 15.5389 10.0821 15.6504 10.0605 15.8734L10.0408 16.0765C9.96476 16.8613 9.92674 17.2538 10.1565 17.4282C10.3864 17.6027 10.7318 17.4436 11.4227 17.1255L11.6014 17.0432C11.7978 16.9528 11.8959 16.9076 12 16.9076C12.1041 16.9076 12.2022 16.9528 12.3986 17.0432L12.5773 17.1255C13.2682 17.4436 13.6136 17.6027 13.8435 17.4282C14.0733 17.2538 14.0352 16.8613 13.9592 16.0765L13.9395 15.8734C13.9179 15.6504 13.9071 15.5389 13.9392 15.4355C13.9714 15.3321 14.0429 15.2485 14.1858 15.0813L14.316 14.9291C14.819 14.3409 15.0706 14.0468 14.9828 13.7645C14.895 13.4822 14.526 13.3987 13.7881 13.2318L13.5972 13.1886C13.3875 13.1411 13.2827 13.1174 13.1985 13.0535C13.1143 12.9896 13.0603 12.8927 12.9524 12.699Z"/>
                        </svg>
                    </div>
                    <div class="page-header__divider"></div>
                    <h1 class="page-header__title">Sessions</h1>
                    <span class="page-header__tagline">Plane, spiele, erinnere dich</span>
                </div>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Hero: Create New Session -->
                <section class="sessions-hero">
                    <div class="sessions-hero__content">
                        <h2 class="sessions-hero__title">Bereit für ein neues Abenteuer?</h2>
                        <p class="sessions-hero__desc">Starte eine neue Session und lade deine Party ein.</p>
                        <button class="sessions-hero__btn" id="createSessionBtn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"/>
                                <line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Neue Session erstellen
                        </button>
                    </div>
                    <div class="sessions-hero__visual">
                        <div class="sessions-hero__dice">
                            <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M20.47 6.62L12.57 2.18C12.41 2.06 12.21 2 12 2S11.59 2.06 11.43 2.18L3.53 6.62C3.21 6.79 3 7.12 3 7.5V16.5C3 16.88 3.21 17.21 3.53 17.38L11.43 21.82C11.59 21.94 11.79 22 12 22S12.41 21.94 12.57 21.82L20.47 17.38C20.79 17.21 21 16.88 21 16.5V7.5C21 7.12 20.79 6.79 20.47 6.62Z"/>
                            </svg>
                        </div>
                    </div>
                </section>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Active Session (if running) -->
                <section class="active-session" id="activeSessionSection" style="display: none;">
                    <div class="active-session__header">
                        <span class="active-session__live" id="activeSessionStatus">● Live</span>
                        <h2 class="active-session__title" id="activeSessionTitle">Session läuft gerade</h2>
                    </div>
                    <div class="active-session__card">
                        <!-- Cover -->
                        <div class="active-session__cover" id="activeSessionCover">
                            <img src="" alt="" id="activeSessionCoverImg">
                            <div class="active-session__cover-fallback">
                                <svg width="64" height="64" viewBox="0 0 100 100">
                                    <path d="M20 20h25v60h-25zM55 20h25v25h-25zM55 55h25l-25 25z" fill="currentColor"/>
                                </svg>
                            </div>
                        </div>
                        
                        <div class="active-session__info">
                            <div class="ruleset-badge ruleset-badge--worldsapart" id="activeSessionRuleset">
                                <img src="assets/img/rulesets/ruleset_worldsapart.svg" alt="" id="activeSessionRulesetIcon">
                                <span id="activeSessionRulesetName">Worlds Apart</span>
                            </div>
                            <a href="#" class="active-session__name-link" id="activeSessionNameLink">
                                <h3 class="active-session__name" id="activeSessionName">Session laden...</h3>
                            </a>
                            <span class="active-session__meta" id="activeSessionMeta">Session 5 · 4 Spieler online</span>
                        </div>
                        <div class="active-session__timer">
                            <span class="active-session__time" id="activeSessionTime">0:00:00</span>
                            <span class="active-session__label">Spielzeit</span>
                        </div>
                        <div class="active-session__actions">
                            <a href="#" class="active-session__btn active-session__btn--primary" id="goToActiveSessionBtn">
                                Zur Session
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                            </a>
                            <!-- GM Only Actions -->
                            <div class="active-session__gm-actions" id="activeSessionGmActions">
                                <button class="active-session__btn active-session__btn--secondary" id="pauseActiveSessionBtn" style="display: none;">
                                    Pausieren
                                </button>
                                <button class="active-session__btn active-session__btn--primary" id="resumeActiveSessionBtn" style="display: none;">
                                    Fortsetzen
                                </button>
                                <button class="active-session__btn active-session__btn--stop" id="endSessionBtn">
                                    Session beenden
                                </button>
                            </div>
                        </div>
                    </div>
                </section>
                
                <!-- Divider (only if active session) -->
                <div class="section-divider" id="activeSessionDivider" style="display: none;"></div>
                
                <!-- Upcoming Sessions -->
                <section class="sessions-section">
                    <div class="sessions-section__header">
                        <h2 class="sessions-section__title">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                                <line x1="16" y1="2" x2="16" y2="6"/>
                                <line x1="8" y1="2" x2="8" y2="6"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                            </svg>
                            Geplante Sessions
                        </h2>
                        <span class="sessions-section__count" id="upcomingCount">0 geplant</span>
                    </div>
                    
                    <div class="sessions-list" id="upcomingSessions">
                        <!-- Sessions werden dynamisch geladen -->
                    </div>
                    
                    <!-- Empty State -->
                    <div class="sessions-empty" id="upcomingEmpty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                            <line x1="16" y1="2" x2="16" y2="6"/>
                            <line x1="8" y1="2" x2="8" y2="6"/>
                            <line x1="3" y1="10" x2="21" y2="10"/>
                        </svg>
                        <p>Keine Sessions geplant</p>
                        <button class="sessions-empty__btn" onclick="openCreateModal()">Session planen</button>
                    </div>
                </section>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Session History -->
                <section class="sessions-section">
                    <div class="sessions-section__header">
                        <h2 class="sessions-section__title">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <polyline points="12 6 12 12 16 14"/>
                            </svg>
                            Vergangene Sessions
                        </h2>
                        <div class="sessions-section__filter">
                            <select id="historyFilter" class="sessions-filter">
                                <option value="all">Alle Kampagnen</option>
                                <option value="worldsapart">Worlds Apart</option>
                                <option value="5e2024">D&D 5e</option>
                                <option value="htbah">How To Be A Hero</option>
                                <option value="cyberpunk">Cyberpunk Red</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="sessions-list sessions-list--history" id="pastSessions">
                        <!-- Sessions werden dynamisch geladen -->
                    </div>
                    
                    <!-- Empty State -->
                    <div class="sessions-empty" id="pastEmpty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12 6 12 12 16 14"/>
                        </svg>
                        <p>Noch keine vergangenen Sessions</p>
                        <span class="sessions-empty__hint">Abgeschlossene Sessions erscheinen hier</span>
                    </div>
                    
                    <!-- Load More (initial versteckt) -->
                    <div class="sessions-load-more" id="loadMoreContainer" style="display: none;">
                        <button class="sessions-load-more__btn" id="loadMoreSessions">
                            Ältere Sessions laden
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                        </button>
                    </div>
                </section>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Stats Overview -->
                <section class="sessions-stats">
                    <h2 class="sessions-stats__title">Deine Statistiken</h2>
                    <div class="sessions-stats__grid">
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statSessionsPlayed">0</span>
                            <span class="sessions-stat__label">Sessions gespielt</span>
                        </div>
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statTotalTime">0h</span>
                            <span class="sessions-stat__label">Gesamte Spielzeit</span>
                        </div>
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statAvgDuration">--</span>
                            <span class="sessions-stat__label">Ø Session-Dauer</span>
                        </div>
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statTotalDice">0</span>
                            <span class="sessions-stat__label">Würfe insgesamt</span>
                        </div>
                    </div>
                </section>
                
            </div>
        </main>
    </div>
    
    <!-- Create/Edit Session Modal -->
    <div class="session-modal" id="createSessionModal">
        <div class="session-modal__backdrop"></div>
        <div class="session-modal__content session-modal__content--large">
            <div class="session-modal__header">
                <h2 class="session-modal__title" id="sessionModalTitle">Neue Session erstellen</h2>
                <button class="session-modal__close" id="closeSessionModal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="session-modal__body">
                <!-- Step 1: Basics -->
                <div class="session-modal__section">
                    <h3 class="session-modal__section-title">
                        <span class="session-modal__section-num">1</span>
                        Grundlagen
                    </h3>
                    
                    <div class="form-group">
                        <label class="form-label">Regelwerk *</label>
                        <select class="form-select" id="sessionRuleset" required>
                            <option value="">Regelwerk wählen...</option>
                            <option value="5e2024">D&D 5e (2024)</option>
                            <option value="worldsapart">Worlds Apart</option>
                            <option value="htbah">How To Be A Hero</option>
                            <option value="cyberpunk">Cyberpunk Red</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Name des Abenteuers *</label>
                        <input type="text" class="form-input" id="sessionName" placeholder="z.B. Die verlorene Mine von Phandelver" required>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Kurzbeschreibung / Pitch</label>
                        <textarea class="form-textarea" id="sessionDescription" placeholder="Worum geht es? Was erwartet die Spieler?" rows="3"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Voice Chat Link (optional)</label>
                        <div class="form-input-with-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                                <line x1="12" y1="19" x2="12" y2="23"/>
                                <line x1="8" y1="23" x2="16" y2="23"/>
                            </svg>
                            <input type="url" class="form-input" id="sessionVoiceLink" placeholder="Discord, TeamSpeak, Zoom...">
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Geplante Sessions</label>
                            <input type="number" class="form-input" id="sessionCount" min="1" max="100" value="1" placeholder="∞ für unbegrenzt">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max. Spieler</label>
                            <input type="number" class="form-input" id="sessionMaxPlayers" min="1" max="12" value="4">
                        </div>
                    </div>
                    
                    <!-- Startlevel (nur für D&D) -->
                    <div class="form-group" id="startLevelGroup" style="display: none;">
                        <label class="form-label">Startlevel</label>
                        <input type="number" class="form-input" id="sessionStartLevel" min="1" max="20" value="1">
                    </div>
                </div>
                
                <!-- Step 2: Zeit & Wiederholung -->
                <div class="session-modal__section">
                    <h3 class="session-modal__section-title">
                        <span class="session-modal__section-num">2</span>
                        Termin
                    </h3>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Datum *</label>
                            <input type="date" class="form-input" id="sessionDate" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Uhrzeit *</label>
                            <input type="time" class="form-input" id="sessionTime" value="20:00" required>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Wiederholen</label>
                            <select class="form-select" id="sessionRecurring">
                                <option value="once">Einmalig</option>
                                <option value="spontan">Spontan / Flexibel</option>
                                <option value="daily">Täglich</option>
                                <option value="weekly">Wöchentlich</option>
                                <option value="biweekly">Alle 2 Wochen</option>
                                <option value="monthly">Monatlich</option>
                                <option value="yearly">Jährlich</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Geschätzte Dauer</label>
                            <select class="form-select" id="sessionDuration">
                                <option value="1">~1 Stunde</option>
                                <option value="2">~2 Stunden</option>
                                <option value="3" selected>~3 Stunden</option>
                                <option value="4">~4 Stunden</option>
                                <option value="5">5+ Stunden</option>
                                <option value="8">Ganztägig (8h+)</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Step 3: Extras -->
                <div class="session-modal__section">
                    <h3 class="session-modal__section-title">
                        <span class="session-modal__section-num">3</span>
                        Extras
                    </h3>
                    
                    <div class="form-group">
                        <label class="form-label">Header-Cover für Session-Übersicht</label>
                        <span class="form-hint">Optimale Größe: 1200×400px (3:1)</span>
                        <div class="form-upload form-upload--cover" id="coverUploadArea">
                            <input type="file" id="sessionCover" accept="image/*" hidden>
                            <div class="form-upload__preview" id="coverPreview" style="display: none;">
                                <img id="coverPreviewImg" src="" alt="">
                                <button type="button" class="form-upload__remove" id="removeCover">×</button>
                            </div>
                            <div class="form-upload__placeholder" id="coverPlaceholder">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <circle cx="8.5" cy="8.5" r="1.5"/>
                                    <polyline points="21 15 16 10 5 21"/>
                                </svg>
                                <span>Bild hochladen</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Thumbnail für Listen-Ansicht</label>
                        <span class="form-hint">Optimale Größe: 200×300px (2:3 hochkant)</span>
                        <div class="form-upload form-upload--thumbnail" id="thumbnailUploadArea">
                            <input type="file" id="sessionThumbnail" accept="image/*" hidden>
                            <div class="form-upload__preview" id="thumbnailPreview" style="display: none;">
                                <img id="thumbnailPreviewImg" src="" alt="">
                                <button type="button" class="form-upload__remove" id="removeThumbnail">×</button>
                            </div>
                            <div class="form-upload__placeholder" id="thumbnailPlaceholder">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <circle cx="8.5" cy="8.5" r="1.5"/>
                                    <polyline points="21 15 16 10 5 21"/>
                                </svg>
                                <span>Thumbnail hochladen</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Tags / Stil</label>
                        <div class="form-tags" id="sessionTags">
                            <label class="form-tag">
                                <input type="checkbox" value="roleplay"> Roleplay-heavy
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="combat"> Combat-focused
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="exploration"> Exploration
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="puzzle"> Rätsel / Puzzle
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="homebrew"> Homebrew
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="official"> Offizielles Abenteuer
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="newbie"> Anfängerfreundlich
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="experienced"> Erfahrene Spieler
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="serious"> Ernst / Düster
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="casual"> Casual / Locker
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="comedy"> Comedy / Humor
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="horror"> Horror
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="sandbox"> Sandbox / Open World
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="oneshot"> One-Shot
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="campaign"> Kampagne
                            </label>
                            <label class="form-tag">
                                <input type="checkbox" value="pvp"> PvP möglich
                            </label>
                        </div>
                        <!-- Custom Tags -->
                        <div class="form-custom-tags">
                            <div class="form-custom-tags__list" id="customTagsList"></div>
                            <div class="form-custom-tags__input">
                                <input type="text" class="form-input form-input--sm" id="customTagInput" placeholder="Eigenen Tag hinzufügen..." maxlength="20">
                                <button type="button" class="form-custom-tags__add" id="addCustomTagBtn">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Sichtbarkeit</label>
                        <div class="form-toggle-group">
                            <label class="form-toggle">
                                <input type="radio" name="visibility" value="public" checked>
                                <span class="form-toggle__box">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <line x1="2" y1="12" x2="22" y2="12"/>
                                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                                    </svg>
                                    <span>Öffentlich</span>
                                    <small>Im Raum sichtbar</small>
                                </span>
                            </label>
                            <label class="form-toggle">
                                <input type="radio" name="visibility" value="private">
                                <span class="form-toggle__box">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                    </svg>
                                    <span>Privat</span>
                                    <small>Nur mit Link</small>
                                </span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="session-modal__footer">
                <button class="session-modal__btn session-modal__btn--secondary" id="cancelSessionBtn">Abbrechen</button>
                <button class="session-modal__btn session-modal__btn--primary" id="saveSessionBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Session erstellen
                </button>
            </div>
        </div>
    </div>
    
    <!-- Session Created Modal (Erfolg mit Link) -->
    <div class="session-modal" id="sessionCreatedModal">
        <div class="session-modal__backdrop"></div>
        <div class="session-modal__content">
            <div class="session-modal__header">
                <h2 class="session-modal__title">Session erstellt!</h2>
                <button class="session-modal__close" id="closeCreatedModal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="session-modal__body">
                <div class="session-created">
                    <div class="session-created__icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                            <polyline points="22 4 12 14.01 9 11.01"/>
                        </svg>
                    </div>
                    <h3 class="session-created__title" id="createdSessionName">Die verlorene Mine</h3>
                    <p class="session-created__meta" id="createdSessionMeta">Worlds Apart · Sa, 18. Jan · 20:00 Uhr</p>
                    
                    <div class="session-created__link">
                        <label class="form-label">Einladungslink</label>
                        <div class="session-created__link-box">
                            <input type="text" class="form-input" id="sessionShareLink" readonly>
                            <button class="btn btn--icon" id="copySessionLink" title="Link kopieren">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                            </button>
                        </div>
                        <p class="form-hint">Teile diesen Link mit deinen Spielern</p>
                    </div>
                </div>
            </div>
            <div class="session-modal__footer">
                <button class="session-modal__btn session-modal__btn--secondary" id="closeCreatedBtn">Schließen</button>
                <button class="session-modal__btn session-modal__btn--primary" id="goToSessionBtn">
                    Zur Session
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="9 18 15 12 9 6"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Cropper Modal -->
    <div class="rift-crop-modal" id="cropperModal">
        <div class="rift-crop-modal__content">
            <div class="rift-crop-modal__header">
                <h3 class="rift-crop-modal__title" id="cropperTitle">Bild zuschneiden</h3>
                <button class="rift-crop-modal__close" id="closeCropper">×</button>
            </div>
            <div class="rift-crop-modal__body">
                <img id="cropperImage" src="" alt="">
            </div>
            <div class="rift-crop-modal__footer">
                <button class="rift-crop-modal__btn rift-crop-modal__btn--cancel" id="cancelCrop">Abbrechen</button>
                <button class="rift-crop-modal__btn rift-crop-modal__btn--save" id="saveCrop">Übernehmen</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- RIFT Services -->
    <script src="assets/js/firebase-config.js"></script>
    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/admin.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    <script>
        initLayout();
        
        // Get current room code
        const currentRoomCode = localStorage.getItem('rift_current_room') || null;
        console.log('[Sessions] Current room code:', currentRoomCode);
        
        // ========================================
        // MIGRATE OLD SESSIONS (add ownerId)
        // ========================================
        
        function migrateSessionsOwnerId() {
            const currentUserId = window.currentUser?.uid;
            if (!currentUserId) return;
            
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            let migrated = 0;
            
            sessions.forEach(session => {
                // Only add ownerId to sessions that don't have one AND match current room
                if (!session.ownerId && session.roomCode === currentRoomCode) {
                    session.ownerId = currentUserId;
                    migrated++;
                }
            });
            
            if (migrated > 0) {
                localStorage.setItem('rift_sessions', JSON.stringify(sessions));
                console.log('[Sessions] Migrated', migrated, 'sessions with ownerId');
            }
        }
        
        // Run migration after a short delay to ensure auth is ready
        setTimeout(migrateSessionsOwnerId, 1500);
        
        // ========================================
        // INDEXEDDB FOR COVER IMAGES
        // ========================================
        
        const CoverDB = {
            dbName: 'rift_covers',
            storeName: 'covers',
            
            async open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName, { keyPath: 'id' });
                        }
                    };
                });
            },
            
            async save(sessionId, imageData) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const request = store.put({ id: sessionId, image: imageData, timestamp: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            
            async get(sessionId) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    const request = store.get(sessionId);
                    request.onsuccess = () => resolve(request.result?.image || null);
                    request.onerror = () => reject(request.error);
                });
            },
            
            async delete(sessionId) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const request = store.delete(sessionId);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        };
        
        // ========================================
        // MODAL HANDLING
        // ========================================
        
        const createModal = document.getElementById('createSessionModal');
        const createdModal = document.getElementById('sessionCreatedModal');
        const createBtn = document.getElementById('createSessionBtn');
        
        let editingSessionId = null;
        
        function openSessionModal(sessionToEdit = null) {
            editingSessionId = sessionToEdit?.id || null;
            
            // Reset cover removed flag
            if (typeof coverRemoved !== 'undefined') {
                coverRemoved = false;
            }
            
            // Update modal title
            document.getElementById('sessionModalTitle').textContent = 
                editingSessionId ? 'Session bearbeiten' : 'Neue Session erstellen';
            
            // Update save button text
            const saveBtn = document.getElementById('saveSessionBtn');
            saveBtn.innerHTML = editingSessionId 
                ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                     <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                     <polyline points="17 21 17 13 7 13 7 21"/>
                     <polyline points="7 3 7 8 15 8"/>
                   </svg>
                   Änderungen speichern`
                : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                     <line x1="12" y1="5" x2="12" y2="19"/>
                     <line x1="5" y1="12" x2="19" y2="12"/>
                   </svg>
                   Session erstellen`;
            
            createModal.classList.add('open');
            document.body.style.overflow = 'hidden';
            
            if (sessionToEdit) {
                // Fill form with existing data
                document.getElementById('sessionRuleset').value = sessionToEdit.ruleset || '';
                document.getElementById('sessionName').value = sessionToEdit.name || '';
                document.getElementById('sessionDescription').value = sessionToEdit.description || '';
                document.getElementById('sessionVoiceLink').value = sessionToEdit.voiceLink || '';
                document.getElementById('sessionCount').value = sessionToEdit.sessionCount || '1';
                document.getElementById('sessionMaxPlayers').value = sessionToEdit.maxPlayers || '4';
                document.getElementById('sessionDate').value = sessionToEdit.date || '';
                document.getElementById('sessionTime').value = sessionToEdit.time || '20:00';
                document.getElementById('sessionRecurring').value = sessionToEdit.recurring || 'once';
                document.getElementById('sessionDuration').value = sessionToEdit.duration || '3';
                
                // Start level (only for 5e)
                if (sessionToEdit.ruleset === '5e2024') {
                    document.getElementById('startLevelGroup').style.display = 'block';
                    document.getElementById('sessionStartLevel').value = sessionToEdit.startLevel || '1';
                } else {
                    document.getElementById('startLevelGroup').style.display = 'none';
                }
                
                // Tags - check predefined ones and collect custom ones
                const predefinedTagValues = [];
                document.querySelectorAll('#sessionTags input').forEach(cb => {
                    predefinedTagValues.push(cb.value);
                    cb.checked = sessionToEdit.tags?.includes(cb.value) || false;
                });
                
                // Load custom tags (tags that are not predefined)
                if (typeof customTags !== 'undefined') {
                    customTags = sessionToEdit.tags?.filter(t => !predefinedTagValues.includes(t)) || [];
                    if (typeof renderCustomTags === 'function') renderCustomTags();
                }
                
                // Visibility
                const visibilityRadio = document.querySelector(`input[name="visibility"][value="${sessionToEdit.visibility || 'public'}"]`);
                if (visibilityRadio) visibilityRadio.checked = true;
                
                // Load cover from IndexedDB if exists
                if (sessionToEdit.hasCover) {
                    CoverDB.get(sessionToEdit.id).then(coverImage => {
                        if (coverImage) {
                            const previewImg = document.getElementById('coverPreviewImg');
                            if (previewImg) {
                                previewImg.src = coverImage;
                                document.getElementById('coverPreview').style.display = 'block';
                                document.getElementById('coverPlaceholder').style.display = 'none';
                            }
                        }
                    }).catch(err => console.warn('Failed to load cover:', err));
                }
                
                // Load thumbnail from IndexedDB if exists
                if (sessionToEdit.hasThumbnail) {
                    CoverDB.get('thumb_' + sessionToEdit.id).then(thumbImage => {
                        if (thumbImage) {
                            const previewImg = document.getElementById('thumbnailPreviewImg');
                            if (previewImg) {
                                previewImg.src = thumbImage;
                                document.getElementById('thumbnailPreview').style.display = 'block';
                                document.getElementById('thumbnailPlaceholder').style.display = 'none';
                            }
                        }
                    }).catch(err => console.warn('Failed to load thumbnail:', err));
                }
                
            } else {
                // Reset form for new session
                // Set default date to next Saturday
                const today = new Date();
                const daysUntilSat = (6 - today.getDay() + 7) % 7 || 7;
                const nextSat = new Date(today);
                nextSat.setDate(today.getDate() + daysUntilSat);
                document.getElementById('sessionDate').value = nextSat.toISOString().split('T')[0];
                
                document.getElementById('sessionRuleset').value = '';
                document.getElementById('sessionName').value = '';
                document.getElementById('sessionDescription').value = '';
                document.getElementById('sessionVoiceLink').value = '';
                document.getElementById('sessionCount').value = '1';
                document.getElementById('sessionMaxPlayers').value = '4';
                document.getElementById('sessionTime').value = '20:00';
                document.getElementById('sessionRecurring').value = 'once';
                document.getElementById('sessionDuration').value = '3';
                document.getElementById('startLevelGroup').style.display = 'none';
                
                // Reset tags (predefined and custom)
                document.querySelectorAll('#sessionTags input').forEach(cb => cb.checked = false);
                if (typeof customTags !== 'undefined') {
                    customTags = [];
                    if (typeof renderCustomTags === 'function') renderCustomTags();
                }
                
                // Reset visibility (default: public)
                document.querySelector('input[name="visibility"][value="public"]').checked = true;
            }
            
            // Reset cover (always - cover upload is separate)
            document.getElementById('coverPreview').style.display = 'none';
            document.getElementById('coverPlaceholder').style.display = 'flex';
            
            // Reset thumbnail
            document.getElementById('thumbnailPreview').style.display = 'none';
            document.getElementById('thumbnailPlaceholder').style.display = 'flex';
        }
        
        // Alias for backwards compatibility
        function openCreateModal() {
            openSessionModal(null);
        }
        
        function closeCreateModal() {
            createModal.classList.remove('open');
            document.body.style.overflow = '';
            editingSessionId = null;
        }
        
        // Edit session function (called from onclick)
        function editSession(sessionId) {
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const sessionData = sessions.find(s => s.id === sessionId);
            
            if (sessionData) {
                openSessionModal(sessionData);
            } else {
                console.error('Session not found:', sessionId);
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Session nicht gefunden');
                }
            }
        }
        
        // Check URL for edit parameter on page load
        const urlParams = new URLSearchParams(window.location.search);
        const editId = urlParams.get('edit');
        if (editId) {
            // Small delay to ensure DOM is ready
            setTimeout(() => editSession(editId), 100);
        }
        
        let lastCreatedSessionId = null;
        
        function openCreatedModal(sessionData) {
            lastCreatedSessionId = sessionData.id;
            createdModal.classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // Update display
            document.getElementById('createdSessionName').textContent = sessionData.name;
            
            const rulesetNames = {
                '5e2024': 'D&D 5e (2024)',
                'worldsapart': 'Worlds Apart',
                'htbah': 'How To Be A Hero',
                'cyberpunk': 'Cyberpunk Red'
            };
            
            const dateObj = new Date(sessionData.date + 'T' + sessionData.time);
            const weekdays = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
            const months = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
            const formattedDate = `${weekdays[dateObj.getDay()]}, ${dateObj.getDate()}. ${months[dateObj.getMonth()]}`;
            
            document.getElementById('createdSessionMeta').textContent = 
                `${rulesetNames[sessionData.ruleset] || sessionData.ruleset} · ${formattedDate} · ${sessionData.time} Uhr`;
            
            // Generate share link
            const roomCode = localStorage.getItem('rift_current_room') || '';
            const shareLink = `${window.location.origin}/login.html?room=${roomCode}`;
            document.getElementById('sessionShareLink').value = shareLink;
        }
        
        function closeCreatedModal() {
            createdModal.classList.remove('open');
            document.body.style.overflow = '';
        }
        
        // Event Listeners
        createBtn?.addEventListener('click', openCreateModal);
        
        document.getElementById('closeSessionModal')?.addEventListener('click', closeCreateModal);
        document.getElementById('cancelSessionBtn')?.addEventListener('click', closeCreateModal);
        createModal?.querySelector('.modal__backdrop')?.addEventListener('click', closeCreateModal);
        
        document.getElementById('closeCreatedModal')?.addEventListener('click', closeCreatedModal);
        document.getElementById('closeCreatedBtn')?.addEventListener('click', closeCreatedModal);
        createdModal?.querySelector('.modal__backdrop')?.addEventListener('click', closeCreatedModal);
        
        // ========================================
        // RULESET CHANGE (Show/Hide Startlevel)
        // ========================================
        
        document.getElementById('sessionRuleset')?.addEventListener('change', (e) => {
            const startLevelGroup = document.getElementById('startLevelGroup');
            if (startLevelGroup) {
                // Show startlevel for D&D
                startLevelGroup.style.display = e.target.value === '5e2024' ? 'block' : 'none';
            }
        });
        
        // ========================================
        // CROPPER SETUP
        // ========================================
        
        const cropperModal = document.getElementById('cropperModal');
        const cropperImage = document.getElementById('cropperImage');
        const cropperTitle = document.getElementById('cropperTitle');
        let currentCropper = null;
        let currentCropTarget = null; // 'cover' or 'thumbnail'
        
        function openCropper(imageSrc, target, aspectRatio, title) {
            currentCropTarget = target;
            cropperTitle.textContent = title;
            cropperImage.src = imageSrc;
            cropperModal.classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // Destroy existing cropper first
            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }
            
            // Wait for image to load
            cropperImage.onload = () => {
                currentCropper = new Cropper(cropperImage, {
                    aspectRatio: aspectRatio,
                    viewMode: 2,
                    dragMode: 'crop',
                    autoCropArea: 0.9,
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: true,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                    background: true,
                    modal: true,
                    responsive: true,
                    checkCrossOrigin: false,
                });
            };
        }
        
        function closeCropper() {
            cropperModal.classList.remove('open');
            document.body.style.overflow = '';
            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }
            currentCropTarget = null;
            // Reset input so same file can be selected again
            coverInput.value = '';
            thumbnailInput.value = '';
        }
        
        document.getElementById('closeCropper')?.addEventListener('click', closeCropper);
        document.getElementById('cancelCrop')?.addEventListener('click', closeCropper);
        
        document.getElementById('saveCrop')?.addEventListener('click', () => {
            if (!currentCropper || !currentCropTarget) return;
            
            const canvas = currentCropper.getCroppedCanvas({
                maxWidth: currentCropTarget === 'cover' ? 1200 : 200,
                maxHeight: currentCropTarget === 'cover' ? 400 : 300,
            });
            
            const croppedData = canvas.toDataURL('image/jpeg', 0.85);
            
            if (currentCropTarget === 'cover') {
                coverPreviewImg.src = croppedData;
                coverPreview.style.display = 'block';
                coverPlaceholder.style.display = 'none';
                coverRemoved = false;
            } else if (currentCropTarget === 'thumbnail') {
                thumbnailPreviewImg.src = croppedData;
                thumbnailPreview.style.display = 'block';
                thumbnailPlaceholder.style.display = 'none';
                thumbnailRemoved = false;
            }
            
            closeCropper();
        });
        
        // ========================================
        // COVER IMAGE UPLOAD
        // ========================================
        
        const coverUploadArea = document.getElementById('coverUploadArea');
        const coverInput = document.getElementById('sessionCover');
        const coverPreview = document.getElementById('coverPreview');
        const coverPreviewImg = document.getElementById('coverPreviewImg');
        const coverPlaceholder = document.getElementById('coverPlaceholder');
        const removeCoverBtn = document.getElementById('removeCover');
        
        // Track if cover was explicitly removed
        let coverRemoved = false;
        
        coverUploadArea?.addEventListener('click', () => {
            if (!coverPreview.style.display || coverPreview.style.display === 'none') {
                coverInput.click();
            }
        });
        
        coverInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Open cropper with 3:1 aspect ratio
                    openCropper(e.target.result, 'cover', 3/1, 'Header-Cover zuschneiden (3:1)');
                };
                reader.readAsDataURL(file);
            }
        });
        
        removeCoverBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            coverInput.value = '';
            coverPreviewImg.src = '';
            coverPreview.style.display = 'none';
            coverPlaceholder.style.display = 'flex';
            coverRemoved = true; // Mark as explicitly removed
        });
        
        // ========================================
        // THUMBNAIL IMAGE UPLOAD
        // ========================================
        
        const thumbnailUploadArea = document.getElementById('thumbnailUploadArea');
        const thumbnailInput = document.getElementById('sessionThumbnail');
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        const thumbnailPreviewImg = document.getElementById('thumbnailPreviewImg');
        const thumbnailPlaceholder = document.getElementById('thumbnailPlaceholder');
        const removeThumbnailBtn = document.getElementById('removeThumbnail');
        
        let thumbnailRemoved = false;
        
        thumbnailUploadArea?.addEventListener('click', () => {
            if (!thumbnailPreview.style.display || thumbnailPreview.style.display === 'none') {
                thumbnailInput.click();
            }
        });
        
        thumbnailInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Open cropper with 2:3 aspect ratio (portrait)
                    openCropper(e.target.result, 'thumbnail', 2/3, 'Thumbnail zuschneiden (2:3 hochkant)');
                };
                reader.readAsDataURL(file);
            }
        });
        
        removeThumbnailBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            thumbnailInput.value = '';
            thumbnailPreviewImg.src = '';
            thumbnailPreview.style.display = 'none';
            thumbnailPlaceholder.style.display = 'flex';
            thumbnailRemoved = true;
        });
        
        // ========================================
        // CUSTOM TAGS
        // ========================================
        
        let customTags = [];
        const customTagsList = document.getElementById('customTagsList');
        const customTagInput = document.getElementById('customTagInput');
        const addCustomTagBtn = document.getElementById('addCustomTagBtn');
        
        function renderCustomTags() {
            customTagsList.innerHTML = customTags.map((tag, index) => `
                <span class="form-custom-tag">
                    ${tag}
                    <button type="button" onclick="removeCustomTag(${index})">×</button>
                </span>
            `).join('');
        }
        
        function addCustomTag() {
            const value = customTagInput.value.trim();
            if (value && !customTags.includes(value) && customTags.length < 10) {
                customTags.push(value);
                renderCustomTags();
                customTagInput.value = '';
            }
        }
        
        window.removeCustomTag = function(index) {
            customTags.splice(index, 1);
            renderCustomTags();
        };
        
        addCustomTagBtn?.addEventListener('click', addCustomTag);
        customTagInput?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addCustomTag();
            }
        });
        
        // ========================================
        // SAVE SESSION (CREATE OR UPDATE)
        // ========================================
        
        document.getElementById('saveSessionBtn')?.addEventListener('click', () => {
            const ruleset = document.getElementById('sessionRuleset').value;
            const name = document.getElementById('sessionName').value.trim();
            const description = document.getElementById('sessionDescription').value.trim();
            const voiceLink = document.getElementById('sessionVoiceLink').value.trim();
            const sessionCount = document.getElementById('sessionCount').value;
            const maxPlayers = document.getElementById('sessionMaxPlayers').value;
            const date = document.getElementById('sessionDate').value;
            const time = document.getElementById('sessionTime').value;
            const recurring = document.getElementById('sessionRecurring').value;
            const duration = document.getElementById('sessionDuration').value;
            const startLevel = document.getElementById('sessionStartLevel')?.value || null;
            const visibility = document.querySelector('input[name="visibility"]:checked')?.value || 'public';
            
            // Get selected tags (predefined + custom)
            const tags = [];
            document.querySelectorAll('#sessionTags input:checked').forEach(cb => {
                tags.push(cb.value);
            });
            // Add custom tags
            customTags.forEach(tag => tags.push(tag));
            
            // Validation
            if (!ruleset) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Bitte wähle ein Regelwerk', 'Fehler');
                } else {
                    alert('Bitte wähle ein Regelwerk');
                }
                return;
            }
            
            if (!name) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Bitte gib einen Namen ein', 'Fehler');
                } else {
                    alert('Bitte gib einen Namen ein');
                }
                return;
            }
            
            if (!date) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Bitte wähle ein Datum', 'Fehler');
                } else {
                    alert('Bitte wähle ein Datum');
                }
                return;
            }
            
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            
            if (editingSessionId) {
                // UPDATE existing session
                const index = sessions.findIndex(s => s.id === editingSessionId);
                if (index >= 0) {
                    // Preserve existing fields like status, createdAt, startTime
                    const existing = sessions[index];
                    
                    // Determine hasCover: new upload = true, explicitly removed = false, else keep existing
                    let hasCover;
                    if (coverPreviewImg.src && coverPreviewImg.src.startsWith('data:')) {
                        hasCover = true;
                    } else if (coverRemoved) {
                        hasCover = false;
                    } else {
                        hasCover = existing.hasCover;
                    }
                    
                    // Determine hasThumbnail status
                    let hasThumbnail;
                    if (thumbnailPreviewImg.src && thumbnailPreviewImg.src.startsWith('data:')) {
                        hasThumbnail = true;
                    } else if (thumbnailRemoved) {
                        hasThumbnail = false;
                    } else {
                        hasThumbnail = existing.hasThumbnail;
                    }
                    
                    sessions[index] = {
                        ...existing,
                        ruleset,
                        name,
                        description,
                        voiceLink,
                        sessionCount: parseInt(sessionCount) || 1,
                        maxPlayers: parseInt(maxPlayers) || 4,
                        date,
                        time,
                        recurring,
                        duration: parseInt(duration),
                        startLevel: startLevel ? parseInt(startLevel) : null,
                        visibility,
                        tags,
                        hasCover,
                        hasThumbnail,
                        updatedAt: Date.now()
                    };
                    
                    localStorage.setItem('rift_sessions', JSON.stringify(sessions));
                    
                    // Save cover image to IndexedDB (if new cover uploaded)
                    if (coverPreviewImg.src && coverPreviewImg.src.startsWith('data:')) {
                        CoverDB.save(editingSessionId, coverPreviewImg.src).catch(err => {
                            console.warn('Failed to save cover:', err);
                        });
                    }
                    
                    // Delete cover from IndexedDB if explicitly removed
                    if (coverRemoved && existing.hasCover) {
                        CoverDB.delete(editingSessionId).catch(err => {
                            console.warn('Failed to delete cover:', err);
                        });
                    }
                    
                    // Save thumbnail to IndexedDB (if new thumbnail uploaded)
                    if (thumbnailPreviewImg.src && thumbnailPreviewImg.src.startsWith('data:')) {
                        CoverDB.save('thumb_' + editingSessionId, thumbnailPreviewImg.src).catch(err => {
                            console.warn('Failed to save thumbnail:', err);
                        });
                    }
                    
                    // Delete thumbnail from IndexedDB if explicitly removed
                    if (thumbnailRemoved && existing.hasThumbnail) {
                        CoverDB.delete('thumb_' + editingSessionId).catch(err => {
                            console.warn('Failed to delete thumbnail:', err);
                        });
                    }
                    
                    console.log('Session updated:', sessions[index]);
                    
                    closeCreateModal();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.success('Session aktualisiert!');
                    }
                    
                    // Refresh sessions list without page reload
                    loadSessions();
                }
            } else {
                // CREATE new session
                const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const currentUserId = window.currentUser?.uid || localStorage.getItem('rift_user_uid') || null;
                
                // Get current user data for GM info
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const gmName = userData.name || userData.displayName || window.currentUser?.displayName || 'Game Master';
                const gmColor = userData.color || '#FF4655';
                
                const sessionData = {
                    id: sessionId,
                    roomCode: currentRoomCode,
                    ownerId: currentUserId,
                    gmName: gmName,
                    gmColor: gmColor,
                    ruleset,
                    name,
                    description,
                    voiceLink,
                    sessionCount: parseInt(sessionCount) || 1,
                    maxPlayers: parseInt(maxPlayers) || 4,
                    date,
                    time,
                    recurring,
                    duration: parseInt(duration),
                    startLevel: startLevel ? parseInt(startLevel) : null,
                    visibility,
                    tags,
                    createdAt: Date.now(),
                    status: 'planned',
                    hasCover: coverPreviewImg.src && coverPreviewImg.src.startsWith('data:') ? true : false,
                    hasThumbnail: thumbnailPreviewImg.src && thumbnailPreviewImg.src.startsWith('data:') ? true : false
                };
                
                sessions.push(sessionData);
                localStorage.setItem('rift_sessions', JSON.stringify(sessions));
                
                // Save cover image to IndexedDB (if exists)
                if (coverPreviewImg.src && coverPreviewImg.src.startsWith('data:')) {
                    CoverDB.save(sessionId, coverPreviewImg.src).catch(err => {
                        console.warn('Failed to save cover:', err);
                    });
                }
                
                // Save thumbnail to IndexedDB (if exists)
                if (thumbnailPreviewImg.src && thumbnailPreviewImg.src.startsWith('data:')) {
                    CoverDB.save('thumb_' + sessionId, thumbnailPreviewImg.src).catch(err => {
                        console.warn('Failed to save thumbnail:', err);
                    });
                }
                
                console.log('Session created:', sessionData);
                
                // Close create modal, open success modal
                closeCreateModal();
                openCreatedModal(sessionData);
            }
        });
        
        // ========================================
        // COPY SHARE LINK
        // ========================================
        
        document.getElementById('copySessionLink')?.addEventListener('click', () => {
            const linkInput = document.getElementById('sessionShareLink');
            linkInput.select();
            navigator.clipboard.writeText(linkInput.value).then(() => {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success('Link kopiert!', 'Einladungslink');
                }
            });
        });
        
        // ========================================
        // GO TO SESSION
        // ========================================
        
        document.getElementById('goToSessionBtn')?.addEventListener('click', () => {
            closeCreatedModal();
            if (lastCreatedSessionId) {
                window.location.href = `session.html?id=${lastCreatedSessionId}`;
            }
        });
        
        // ========================================
        // RENDER SESSIONS
        // ========================================
        
        const rulesetConfig = {
            '5e2024': { name: 'D&D 5e (2024)', icon: 'ruleset_5e_2024.svg', class: '5e' },
            'worldsapart': { name: 'Worlds Apart', icon: 'ruleset_worldsapart.svg', class: 'worldsapart' },
            'htbah': { name: 'How To Be A Hero', icon: 'ruleset_htbah.svg', class: 'htbah' },
            'cyberpunk': { name: 'Cyberpunk Red', icon: 'ruleset_cyberpunkred.svg', class: 'cyberpunk' }
        };
        
        const weekdaysShort = ['SO', 'MO', 'DI', 'MI', 'DO', 'FR', 'SA'];
        const monthsShort = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
        
        function renderSessionCard(session, isPast = false) {
            const dateObj = new Date(session.date);
            const ruleset = rulesetConfig[session.ruleset] || { name: session.ruleset, icon: 'ruleset_worldsapart.svg', class: 'worldsapart' };
            
            // Build meta info for top row
            const sessionInfo = session.sessionCount > 1 
                ? `Session ${session.currentSession || 1}/${session.sessionCount}`
                : '';
            const playerInfo = `${session.maxPlayers || 4} Spieler`;
            
            // Description preview (truncate to ~100 chars)
            const descPreview = session.description 
                ? session.description.substring(0, 120) + (session.description.length > 120 ? '...' : '')
                : 'Keine Beschreibung vorhanden.';
            
            // RIFT Logo SVG for fallback
            const riftLogoSvg = `<svg width="64" height="64" viewBox="0 0 100 100" fill="currentColor" opacity="0.4">
                <path d="M20 20h25v60h-25zM55 20h25v25h-25zM55 55h25l-25 25z"/>
            </svg>`;
            
            // Determine which image to use: thumbnail first, then cover
            const thumbKey = session.hasThumbnail ? 'thumb_' + session.id : (session.hasCover ? session.id : null);
            
            return `
                <a href="session.html?id=${session.id}" class="session-card session-card--${isPast ? 'past' : 'upcoming'}" data-session-id="${session.id}">
                    <div class="session-card__cover session-card__cover--${ruleset.class}" data-cover-id="${session.id}">
                        <img class="session-card__cover-img" src="" alt="" data-cover-img="${thumbKey || session.id}" data-has-image="${thumbKey ? 'true' : 'false'}">
                        <div class="session-card__cover-fallback">
                            ${riftLogoSvg}
                        </div>
                    </div>
                    <div class="session-card__date">
                        <span class="session-card__day">${weekdaysShort[dateObj.getDay()]}</span>
                        <span class="session-card__num">${String(dateObj.getDate()).padStart(2, '0')}</span>
                        <span class="session-card__month">${monthsShort[dateObj.getMonth()]}</span>
                    </div>
                    <div class="session-card__content">
                        <div class="session-card__top">
                            <div class="ruleset-badge ruleset-badge--${ruleset.class} ruleset-badge--sm">
                                <img src="assets/img/rulesets/${ruleset.icon}" alt="">
                                <span>${ruleset.name}</span>
                            </div>
                            <div class="session-card__meta">
                                <span>${session.time || '20:00'} Uhr</span>
                                ${sessionInfo ? `<span class="session-card__meta-divider"></span><span>${sessionInfo}</span>` : ''}
                                <span class="session-card__meta-divider"></span>
                                <span>${playerInfo}</span>
                            </div>
                        </div>
                        <h3 class="session-card__title">${session.name}</h3>
                        <p class="session-card__desc">${descPreview}</p>
                    </div>
                    <div class="session-card__actions">
                        <button class="session-card__btn session-card__btn--primary" title="Session öffnen" onclick="event.stopPropagation(); window.location.href='session.html?id=${session.id}';">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                        </button>
                        <button class="session-card__btn session-card__edit-btn" title="Bearbeiten" onclick="event.preventDefault(); event.stopPropagation(); editSession('${session.id}');">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                    </div>
                </a>
            `;
        }
        
        function renderSessions() {
            // Get sessions from localStorage
            const allSessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const currentUserId = window.currentUser?.uid || null;
            
            // Filter sessions for current room AND/OR current user
            const sessions = allSessions.filter(s => {
                // If we have a room code, filter by room
                if (currentRoomCode) {
                    return s.roomCode === currentRoomCode;
                }
                
                // If no room code, show only sessions without room OR owned by current user
                if (currentUserId) {
                    return (!s.roomCode && s.ownerId === currentUserId) || s.ownerId === currentUserId;
                }
                
                // Fallback: show sessions without room code
                return !s.roomCode;
            });
            
            console.log('[Sessions] Showing', sessions.length, 'of', allSessions.length, 'sessions for room:', currentRoomCode, 'user:', currentUserId);
            
            // Separate upcoming and past sessions
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const upcoming = sessions.filter(s => {
                const sessionDate = new Date(s.date);
                return sessionDate >= today && s.status !== 'ended';
            }).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const past = sessions.filter(s => {
                const sessionDate = new Date(s.date);
                return sessionDate < today || s.status === 'ended';
            }).sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Render upcoming sessions
            const upcomingContainer = document.getElementById('upcomingSessions');
            const upcomingEmpty = document.getElementById('upcomingEmpty');
            const upcomingCount = document.getElementById('upcomingCount');
            
            if (upcoming.length > 0) {
                upcomingContainer.innerHTML = upcoming.map(s => renderSessionCard(s, false)).join('');
                upcomingEmpty.style.display = 'none';
            } else {
                upcomingContainer.innerHTML = '';
                upcomingEmpty.style.display = 'flex';
            }
            upcomingCount.textContent = `${upcoming.length} geplant`;
            
            // TODO: Render past sessions similarly
        }
        
        // Load cover images from IndexedDB after rendering
        async function loadSessionCovers() {
            const coverImgs = document.querySelectorAll('[data-cover-img]');
            
            for (const img of coverImgs) {
                const coverKey = img.dataset.coverImg;
                const hasImage = img.dataset.hasImage === 'true';
                
                if (!hasImage) continue; // No image to load
                
                try {
                    const coverData = await CoverDB.get(coverKey);
                    if (coverData) {
                        img.src = coverData;
                        img.classList.add('loaded');
                    }
                } catch (err) {
                    // No cover or error - fallback stays visible
                }
            }
        }
        
        // Initial render
        renderSessions();
        loadSessionCovers();
        
        // ========================================
        // ACTIVE SESSION
        // ========================================
        
        const activeSessionData = JSON.parse(localStorage.getItem('rift_active_session') || 'null');
        let activeTimerInterval = null;
        
        if (activeSessionData) {
            document.getElementById('activeSessionSection').style.display = 'block';
            document.getElementById('activeSessionDivider').style.display = 'block';
            
            // Load full session data
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const fullSession = sessions.find(s => s.id === activeSessionData.id);
            
            // Set link to session page
            const goToActiveBtn = document.getElementById('goToActiveSessionBtn');
            const nameLink = document.getElementById('activeSessionNameLink');
            if (activeSessionData.id) {
                const sessionUrl = `session.html?id=${activeSessionData.id}`;
                if (goToActiveBtn) goToActiveBtn.href = sessionUrl;
                if (nameLink) nameLink.href = sessionUrl;
            }
            
            // Update session name
            document.getElementById('activeSessionName').textContent = activeSessionData.name || 'Session';
            
            // Load cover image
            if (fullSession?.hasCover) {
                CoverDB.get(activeSessionData.id).then(coverData => {
                    if (coverData) {
                        const coverImg = document.getElementById('activeSessionCoverImg');
                        if (coverImg) {
                            coverImg.src = coverData;
                            coverImg.classList.add('loaded');
                        }
                    }
                });
            }
            
            // Update cover gradient based on ruleset
            const coverEl = document.getElementById('activeSessionCover');
            if (coverEl && fullSession?.ruleset) {
                const gradients = {
                    '5e2024': 'linear-gradient(135deg, #dc2626 0%, #7f1d1d 100%)',
                    'worldsapart': 'linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%)',
                    'htbah': 'linear-gradient(135deg, #059669 0%, #064e3b 100%)',
                    'cyberpunk': 'linear-gradient(135deg, #eab308 0%, #854d0e 100%)'
                };
                // Only set if not paused (paused has its own gradient)
                if (fullSession.status !== 'paused') {
                    coverEl.style.background = gradients[fullSession.ruleset] || gradients['worldsapart'];
                }
            }
            
            // Update ruleset if available
            if (fullSession?.ruleset) {
                const rulesetBadge = document.getElementById('activeSessionRuleset');
                const rulesetIcon = document.getElementById('activeSessionRulesetIcon');
                const rulesetName = document.getElementById('activeSessionRulesetName');
                
                const rulesetMap = {
                    '5e2024': { name: 'D&D 5e', icon: 'ruleset_5e_2024.svg', class: '5e' },
                    'worldsapart': { name: 'Worlds Apart', icon: 'ruleset_worldsapart.svg', class: 'worldsapart' },
                    'htbah': { name: 'How To Be A Hero', icon: 'ruleset_htbah.svg', class: 'htbah' },
                    'cyberpunk': { name: 'Cyberpunk Red', icon: 'ruleset_cyberpunkred.svg', class: 'cyberpunk' }
                };
                const rs = rulesetMap[fullSession.ruleset] || rulesetMap['worldsapart'];
                
                rulesetBadge.className = `ruleset-badge ruleset-badge--${rs.class}`;
                rulesetIcon.src = `assets/img/rulesets/${rs.icon}`;
                rulesetName.textContent = rs.name;
            }
            
            // Update meta
            if (fullSession) {
                const meta = `Session ${fullSession.currentSession || 1}${fullSession.sessionCount > 1 ? ' von ' + fullSession.sessionCount : ''} · ${fullSession.maxPlayers || 4} Spieler`;
                document.getElementById('activeSessionMeta').textContent = meta;
            }
            
            // Handle paused state - check both activeSessionData and fullSession
            const isPaused = activeSessionData.paused === true || fullSession?.status === 'paused';
            updateActiveSessionUI(isPaused, fullSession);
            
            // Update timer
            if (!isPaused) {
                startActiveTimer(fullSession);
            } else {
                // Show paused time
                updateActiveTimerDisplay(fullSession);
            }
        }
        
        function updateActiveSessionUI(isPaused, fullSession) {
            const statusEl = document.getElementById('activeSessionStatus');
            const titleEl = document.getElementById('activeSessionTitle');
            const pauseBtn = document.getElementById('pauseActiveSessionBtn');
            const resumeBtn = document.getElementById('resumeActiveSessionBtn');
            const sectionEl = document.getElementById('activeSessionSection');
            
            if (isPaused) {
                statusEl.textContent = '● Pausiert';
                statusEl.classList.add('active-session__live--paused');
                titleEl.textContent = 'Session pausiert';
                sectionEl.classList.add('active-session--paused');
                pauseBtn.style.display = 'none';
                resumeBtn.style.display = 'flex';
            } else {
                statusEl.textContent = '● Live';
                statusEl.classList.remove('active-session__live--paused');
                titleEl.textContent = 'Session läuft gerade';
                sectionEl.classList.remove('active-session--paused');
                pauseBtn.style.display = 'flex';
                resumeBtn.style.display = 'none';
            }
        }
        
        function startActiveTimer(fullSession) {
            const startTime = new Date(activeSessionData.startTime);
            const totalPausedMs = fullSession?.totalPausedMs || 0;
            
            activeTimerInterval = setInterval(() => {
                let elapsed = Date.now() - startTime.getTime() - totalPausedMs;
                if (elapsed < 0) elapsed = 0;
                
                const hours = Math.floor(elapsed / (1000 * 60 * 60));
                const mins = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
                const secs = Math.floor((elapsed % (1000 * 60)) / 1000);
                const timeEl = document.getElementById('activeSessionTime');
                if (timeEl) {
                    timeEl.textContent = `${hours}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        function updateActiveTimerDisplay(fullSession) {
            if (!fullSession) return;
            
            const startTime = new Date(activeSessionData.startTime);
            const pausedTime = fullSession.pausedTime ? new Date(fullSession.pausedTime) : new Date();
            const totalPausedMs = fullSession.totalPausedMs || 0;
            
            let elapsed = pausedTime.getTime() - startTime.getTime() - totalPausedMs;
            if (elapsed < 0) elapsed = 0;
            
            const hours = Math.floor(elapsed / (1000 * 60 * 60));
            const mins = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
            const secs = Math.floor((elapsed % (1000 * 60)) / 1000);
            const timeEl = document.getElementById('activeSessionTime');
            if (timeEl) {
                timeEl.textContent = `${hours}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }
        }
        
        // Pause session button
        document.getElementById('pauseActiveSessionBtn')?.addEventListener('click', () => {
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const index = sessions.findIndex(s => s.id === activeSessionData.id);
            
            if (index >= 0) {
                sessions[index].status = 'paused';
                sessions[index].pausedTime = Date.now();
                localStorage.setItem('rift_sessions', JSON.stringify(sessions));
                
                activeSessionData.paused = true;
                localStorage.setItem('rift_active_session', JSON.stringify(activeSessionData));
                
                if (activeTimerInterval) clearInterval(activeTimerInterval);
                updateActiveSessionUI(true, sessions[index]);
                updateActiveTimerDisplay(sessions[index]);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info('Session pausiert');
                }
            }
        });
        
        // Resume session button
        document.getElementById('resumeActiveSessionBtn')?.addEventListener('click', () => {
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const index = sessions.findIndex(s => s.id === activeSessionData.id);
            
            if (index >= 0) {
                // Calculate paused duration and add to total
                if (sessions[index].pausedTime) {
                    const pausedDuration = Date.now() - sessions[index].pausedTime;
                    sessions[index].totalPausedMs = (sessions[index].totalPausedMs || 0) + pausedDuration;
                }
                
                sessions[index].status = 'live';
                sessions[index].pausedTime = null;
                localStorage.setItem('rift_sessions', JSON.stringify(sessions));
                
                activeSessionData.paused = false;
                localStorage.setItem('rift_active_session', JSON.stringify(activeSessionData));
                
                updateActiveSessionUI(false, sessions[index]);
                startActiveTimer(sessions[index]);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success('Session fortgesetzt!');
                }
            }
        });
        
        // End session button
        document.getElementById('endSessionBtn')?.addEventListener('click', () => {
            if (!confirm('Session wirklich beenden?')) return;
            
            const sessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const index = sessions.findIndex(s => s.id === activeSessionData.id);
            
            if (index >= 0) {
                sessions[index].status = 'ended';
                sessions[index].endTime = Date.now();
                localStorage.setItem('rift_sessions', JSON.stringify(sessions));
            }
            
            localStorage.removeItem('rift_active_session');
            location.reload();
        });
        
        // ========================================
        // LOAD SESSIONS FROM LOCALSTORAGE
        // ========================================
        
        function loadSessions() {
            const allSessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const now = new Date();
            const currentUserId = window.currentUser?.uid || null;
            
            console.log('[Sessions] Loading sessions, roomCode:', currentRoomCode, 'userId:', currentUserId);
            console.log('[Sessions] Total sessions in storage:', allSessions.length);
            
            // Filter sessions for current room AND/OR current user
            const sessions = allSessions.filter(s => {
                // If we have a room code, filter by room
                if (currentRoomCode) {
                    return s.roomCode === currentRoomCode;
                }
                
                // If no room code, show only sessions without room OR owned by current user
                if (currentUserId) {
                    return (!s.roomCode && s.ownerId === currentUserId) || s.ownerId === currentUserId;
                }
                
                // Fallback: show sessions without room code
                return !s.roomCode;
            });
            
            console.log('[Sessions] Filtered sessions:', sessions.length);
            
            // Separate upcoming and past
            const upcoming = sessions.filter(s => {
                const sessionDate = new Date(s.date + 'T' + (s.time || '00:00'));
                return sessionDate >= now && s.status !== 'ended';
            }).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const past = sessions.filter(s => {
                const sessionDate = new Date(s.date + 'T' + (s.time || '00:00'));
                return sessionDate < now || s.status === 'ended';
            }).sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Update counts
            document.getElementById('upcomingCount').textContent = `${upcoming.length} geplant`;
            
            // Render upcoming
            const upcomingContainer = document.getElementById('upcomingSessions');
            const upcomingEmpty = document.getElementById('upcomingEmpty');
            
            if (upcoming.length > 0) {
                upcomingEmpty.style.display = 'none';
                upcomingContainer.innerHTML = upcoming.map(s => renderSessionCard(s, false)).join('');
            } else {
                upcomingEmpty.style.display = 'flex';
                upcomingContainer.innerHTML = '';
            }
            
            // Render past
            const pastContainer = document.getElementById('pastSessions');
            const pastEmpty = document.getElementById('pastEmpty');
            
            // Apply ruleset filter
            const historyFilter = document.getElementById('historyFilter');
            const filterValue = historyFilter?.value || 'all';
            const filteredPast = filterValue === 'all' 
                ? past 
                : past.filter(s => s.ruleset === filterValue);
            
            if (filteredPast.length > 0) {
                pastEmpty.style.display = 'none';
                pastContainer.innerHTML = filteredPast.map(s => renderSessionCard(s, true)).join('');
                document.getElementById('loadMoreContainer').style.display = filteredPast.length > 5 ? 'flex' : 'none';
            } else {
                pastEmpty.style.display = 'flex';
                pastContainer.innerHTML = '';
            }
            
            // Update stats
            document.getElementById('statSessionsPlayed').textContent = past.length;
            
            // Load cover images
            loadSessionCovers();
        }
        
        // Load sessions on page load
        loadSessions();
        
        // Filter event listener
        document.getElementById('historyFilter')?.addEventListener('change', () => {
            loadSessions();
        });
        
        // Make functions globally available for onclick handlers
        window.openCreateModal = openCreateModal;
        window.closeCreateModal = closeCreateModal;
        window.editSession = editSession;
        window.addCustomTag = addCustomTag;
    </script>
</body>
</html>
