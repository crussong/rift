<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/icon_rift_r.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="view-transition" content="same-origin">
    <title>RIFT – Würfel</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/sidebar.css">
    <link rel="stylesheet" href="assets/css/topbar.css">
    <link rel="stylesheet" href="assets/css/footer.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    <link rel="stylesheet" href="assets/css/dice.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
        /* Back to Sheet Button */
        .back-to-sheet-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            margin-left: auto;
            background: var(--bg-elevated, #2a2a2a);
            border: 1px solid var(--border-default, #3a3a3a);
            border-radius: 8px;
            color: var(--text-primary, #fff);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .back-to-sheet-btn:hover {
            background: var(--bg-card-hover, #3a3a3a);
            border-color: var(--accent-primary, #FF4655);
        }
        .back-to-sheet-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* Fix pointer-events for dice-result when visible */
        .dice-result.visible {
            pointer-events: auto !important;
        }
        
        /* Skill Check Display Styles */
        .dice-result__skill-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            display: none;
        }
        .dice-result__skill-label.visible {
            display: block;
        }
        .dice-result__target {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 4px;
            display: none;
        }
        .dice-result__target.visible {
            display: block;
        }
        .dice-result__outcome {
            font-family: 'Dharma Gothic', 'Inter', sans-serif;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 8px;
            padding: 6px 16px;
            border-radius: 4px;
            display: none;
        }
        .dice-result__outcome.visible {
            display: inline-block;
        }
        .dice-result__outcome.success {
            color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            text-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        .dice-result__outcome.failure {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        /* Color the total based on outcome */
        .dice-result.skill-success #resultTotal {
            color: #22c55e !important;
            text-shadow: 0 0 30px rgba(34, 197, 94, 0.6);
        }
        .dice-result.skill-failure #resultTotal {
            color: #ef4444 !important;
            text-shadow: 0 0 30px rgba(239, 68, 68, 0.6);
        }
        .dice-result__back-btn {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer !important;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999 !important;
            pointer-events: auto !important;
        }
        .dice-result__back-btn.visible {
            display: inline-flex;
        }
        .dice-result__back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-primary, #FF4655);
            color: #fff;
        }
        .dice-result__back-btn svg {
            width: 18px;
            height: 18px;
        }
    </style>

    <!-- Auth Guard: Hide until authenticated -->
    <style>
        body:not(.auth-ready) .app { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) .sheet-container { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) main { opacity: 0; pointer-events: none; }
        body.auth-ready .app { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready .sheet-container { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready main { opacity: 1; transition: opacity 0.15s ease; }
    </style>
</head>
<body>
    <div class="app">
        <main class="main">
            <div class="main__content">
                
                <!-- Page Header -->
                <div class="page-header">
                    <div class="page-header__icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20.47 6.62L12.57 2.18C12.41 2.06 12.21 2 12 2S11.59 2.06 11.43 2.18L3.53 6.62C3.21 6.79 3 7.12 3 7.5V16.5C3 16.88 3.21 17.21 3.53 17.38L11.43 21.82C11.59 21.94 11.79 22 12 22S12.41 21.94 12.57 21.82L20.47 17.38C20.79 17.21 21 16.88 21 16.5V7.5C21 7.12 20.79 6.79 20.47 6.62M11.45 15.96L6.31 15.93V14.91C6.31 14.91 9.74 11.58 9.75 10.57C9.75 9.33 8.73 9.46 8.73 9.46S7.75 9.5 7.64 10.71L6.14 10.76C6.14 10.76 6.18 8.26 8.83 8.26C11.2 8.26 11.23 10.04 11.23 10.5C11.23 12.18 8.15 14.77 8.15 14.77L11.45 14.76V15.96M17.5 13.5C17.5 14.9 16.35 16.05 14.93 16.05C13.5 16.05 12.36 14.9 12.36 13.5V10.84C12.36 9.42 13.5 8.27 14.93 8.27S17.5 9.42 17.5 10.84V13.5M16 10.77V13.53C16 14.12 15.5 14.6 14.92 14.6C14.34 14.6 13.86 14.12 13.86 13.53V10.77C13.86 10.18 14.34 9.71 14.92 9.71C15.5 9.71 16 10.18 16 10.77Z"/>
                        </svg>
                    </div>
                    <div class="page-header__divider"></div>
                    <h1 class="page-header__title">Würfel</h1>
                    <span class="page-header__tagline">Lass das Schicksal entscheiden</span>
                    <button class="back-to-sheet-btn" id="backToSheetBtn" style="display: none;" onclick="goBackToSheet()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 12H5M12 19l-7-7 7-7"/>
                        </svg>
                        Zurück zum Charakterbogen
                    </button>
                </div>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <div class="dice-page">
                    
                    <!-- 3D Arena -->
                    <div class="dice-arena empty" id="diceArena">
                        <!-- Pulse Effects Container (UNDER dice) -->
                        <div class="dice-pulses" id="dicePulses"></div>
                        
                        <!-- Empty State -->
                        <div class="dice-arena__empty">
                            <svg class="dice-arena__empty-icon" width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                                <circle cx="12" cy="12" r="2"/>
                            </svg>
                            <p>Wähle Würfel und ziehe zum Werfen</p>
                        </div>
                        
                        <!-- Swipe Hint -->
                        <div class="dice-arena__swipe-hint">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                            Wischen zum Würfeln
                        </div>
                        
                        <!-- Dice Value Labels (overlay) -->
                        <div class="dice-labels" id="diceLabels"></div>
                        
                        <!-- Result Display -->
                        <div class="dice-result" id="diceResult">
                            <div class="dice-result__player" id="resultPlayer"></div>
                            <div class="dice-result__skill-label" id="resultSkillLabel"></div>
                            <div class="dice-result__total" id="resultTotal">0</div>
                            <div class="dice-result__target" id="resultTarget"></div>
                            <div class="dice-result__outcome" id="resultOutcome"></div>
                            <div class="dice-result__breakdown" id="resultBreakdown"></div>
                            <button class="dice-result__back-btn" id="resultBackBtn" style="display: none;" onclick="goBackToSheet()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                    <polyline points="14 2 14 8 20 8"/>
                                    <line x1="16" y1="13" x2="8" y2="13"/>
                                    <line x1="16" y1="17" x2="8" y2="17"/>
                                    <polyline points="10 9 9 9 8 9"/>
                                </svg>
                                Zurück zum Charakterbogen
                            </button>
                        </div>
                        
                        <!-- Multiplayer Feed -->
                        <div class="dice-feed" id="diceFeed"></div>
                        
                        <!-- Particles -->
                        <div class="dice-particles" id="particlesContainer"></div>
                    </div>
                    
                    <!-- Controls -->
                    <div class="dice-controls">
                        
                        <!-- Toolbar -->
                        <div class="dice-toolbar">
                            <div class="dice-toolbar__left">
                                <!-- Presets -->
                                <div class="dice-presets-wrapper">
                                    <button class="dice-toggle" id="presetsBtn" onclick="DiceRoller.togglePresets()">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                                        </svg>
                                        Presets
                                    </button>
                                    
                                    <!-- Presets Popup -->
                                    <div class="dice-presets-popup" id="presetsPopup">
                                        <div class="dice-presets-popup__header">
                                            <span>Würfel-Presets</span>
                                            <button class="dice-presets-popup__close" onclick="DiceRoller.togglePresets()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                            </button>
                                        </div>
                                        <div class="dice-presets-popup__list" id="presetsList">
                                            <div class="dice-presets-popup__empty">Keine Presets gespeichert</div>
                                        </div>
                                        <div class="dice-presets-popup__hint">
                                            Tipp: Würfel auswählen, dann "Speichern"
                                        </div>
                                    </div>
                                </div>
                                
                                <button class="dice-toggle" id="savePresetBtn" onclick="DiceRoller.savePreset()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                        <polyline points="17 21 17 13 7 13 7 21"/>
                                        <polyline points="7 3 7 8 15 8"/>
                                    </svg>
                                    Speichern
                                </button>
                            </div>
                            <div class="dice-toolbar__right">
                                <!-- Sound Toggle -->
                                <button class="dice-toggle active" id="soundToggle" onclick="DiceRoller.toggleSound()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                    </svg>
                                    Sound
                                </button>
                                <!-- Secret Roll Toggle -->
                                <button class="dice-toggle" id="secretToggle" onclick="DiceRoller.toggleSecret()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                    </svg>
                                    Geheim
                                </button>
                            </div>
                        </div>
                        
                        <!-- Dice Orbit - Linksklick: hinzufügen, Rechtsklick: entfernen -->
                        <div class="dice-orbit">
                            <!-- Reset Button -->
                            <button class="dice-orbit__action dice-orbit__reset" onclick="DiceRoller.clearDice()" title="Zurücksetzen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                    <path d="M3 3v5h5"/>
                                </svg>
                            </button>
                            
                            <!-- Dice Buttons - Hero Cards -->
                            <div class="dice-orbit__dice">
                                <!-- D4 -->
                                <button class="dice-btn" data-dice="d4" onclick="DiceRoller.addDice('d4')" title="D4 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d4">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d4"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D4</span>
                                    </div>
                                </button>
                                
                                <!-- D6 -->
                                <button class="dice-btn" data-dice="d6" onclick="DiceRoller.addDice('d6')" title="D6 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d6">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d6"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D6</span>
                                    </div>
                                </button>
                                
                                <!-- D8 -->
                                <button class="dice-btn" data-dice="d8" onclick="DiceRoller.addDice('d8')" title="D8 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d8">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d8"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D8</span>
                                    </div>
                                </button>
                                
                                <!-- D10 -->
                                <button class="dice-btn" data-dice="d10" onclick="DiceRoller.addDice('d10')" title="D10 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d10">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d10"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D10</span>
                                    </div>
                                </button>
                                
                                <!-- D12 -->
                                <button class="dice-btn" data-dice="d12" onclick="DiceRoller.addDice('d12')" title="D12 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d12">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d12"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D12</span>
                                    </div>
                                </button>
                                
                                <!-- D20 -->
                                <button class="dice-btn" data-dice="d20" onclick="DiceRoller.addDice('d20')" title="D20 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d20">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d20"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D20</span>
                                    </div>
                                </button>
                                
                                <!-- D100 -->
                                <button class="dice-btn" data-dice="d100" onclick="DiceRoller.addDice('d100')" title="D100 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__particles"></div>
                                    <div class="dice-btn__badge"><span id="count-d100">0</span>x</div>
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d100"></canvas>
                                    </div>
                                    <div class="dice-btn__glass">
                                        <span class="dice-btn__label">D100</span>
                                    </div>
                                </button>
                            </div>
                            
                            <!-- Stats Button -->
                            <div class="dice-settings-wrapper">
                                <button class="dice-orbit__action dice-orbit__stats" id="statsBtn" title="Statistiken">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="20" x2="18" y2="10"/>
                                        <line x1="12" y1="20" x2="12" y2="4"/>
                                        <line x1="6" y1="20" x2="6" y2="14"/>
                                    </svg>
                                </button>
                                
                                <!-- Stats Popup -->
                                <div class="dice-settings-popup" id="statsPopup">
                                    <div class="dice-settings-popup__header">
                                        <span>Statistiken</span>
                                        <button class="dice-settings-popup__close" onclick="DiceRoller.toggleStatsPopup()">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                        </button>
                                    </div>
                                    <div class="dice-stats-grid">
                                        <div class="dice-stats-card">
                                            <span class="dice-stats-card__value" id="statTotal">0</span>
                                            <span class="dice-stats-card__label">Würfe</span>
                                        </div>
                                        <div class="dice-stats-card">
                                            <span class="dice-stats-card__value" id="statAvg">-</span>
                                            <span class="dice-stats-card__label">Durchschnitt</span>
                                        </div>
                                        <div class="dice-stats-card dice-stats-card--success">
                                            <span class="dice-stats-card__value" id="statCrits">0</span>
                                            <span class="dice-stats-card__label">Kritische Erfolge</span>
                                        </div>
                                        <div class="dice-stats-card dice-stats-card--failure">
                                            <span class="dice-stats-card__value" id="statFumbles">0</span>
                                            <span class="dice-stats-card__label">Patzer</span>
                                        </div>
                                        <div class="dice-stats-card">
                                            <span class="dice-stats-card__value" id="statMax">-</span>
                                            <span class="dice-stats-card__label">Maximum</span>
                                        </div>
                                        <div class="dice-stats-card">
                                            <span class="dice-stats-card__value" id="statMin">-</span>
                                            <span class="dice-stats-card__label">Minimum</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Hotkeys Button -->
                            <div class="dice-settings-wrapper">
                                <button class="dice-orbit__action dice-orbit__hotkeys" id="hotkeysBtn" title="Tastenkürzel">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="2" y="4" width="20" height="16" rx="2"/>
                                        <path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M6 16h12"/>
                                    </svg>
                                </button>
                                
                                <!-- Hotkeys Popup -->
                                <div class="dice-settings-popup dice-hotkeys-popup" id="hotkeysPopup">
                                    <div class="dice-settings-popup__header">
                                        <span>Tastenkürzel</span>
                                        <button class="dice-settings-popup__close" onclick="DiceRoller.toggleHotkeysPopup()">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                        </button>
                                    </div>
                                    <div class="dice-hotkeys-list">
                                        <div class="dice-hotkey"><kbd>Enter</kbd><span>Würfeln</span></div>
                                        <div class="dice-hotkey"><kbd>Space</kbd><span>Würfeln</span></div>
                                        <div class="dice-hotkey"><kbd>1-7</kbd><span>Würfel hinzufügen</span></div>
                                        <div class="dice-hotkey"><kbd>Shift+1-7</kbd><span>Würfel entfernen</span></div>
                                        <div class="dice-hotkey"><kbd>+/-</kbd><span>Modifier ±1</span></div>
                                        <div class="dice-hotkey"><kbd>Shift +/-</kbd><span>Modifier ±5</span></div>
                                        <div class="dice-hotkey"><kbd>A</kbd><span>Vorteil</span></div>
                                        <div class="dice-hotkey"><kbd>D</kbd><span>Nachteil</span></div>
                                        <div class="dice-hotkey"><kbd>R</kbd><span>Wiederholen</span></div>
                                        <div class="dice-hotkey"><kbd>Esc</kbd><span>Reset</span></div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Settings Button mit Popup -->
                            <div class="dice-settings-wrapper">
                                <button class="dice-orbit__action dice-orbit__settings" id="settingsBtn" title="Einstellungen">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="3"/>
                                        <path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/>
                                    </svg>
                                </button>
                                
                                <!-- Settings Popup -->
                                <div class="dice-settings-popup" id="settingsPopup">
                                    <div class="dice-settings-popup__header">
                                        <span>Einstellungen</span>
                                        <button class="dice-settings-popup__close" id="settingsClose">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                        </button>
                                    </div>
                                    
                                    <div class="dice-settings-popup__section">
                                        <span class="dice-settings-popup__label">Würfelfarbe</span>
                                        <div class="dice-theme-grid">
                                            <button class="dice-theme-card active" data-theme="classic">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--classic"></div>
                                                <span>Klassisch</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="blood">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--blood"></div>
                                                <span>Blut</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="ice">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--ice"></div>
                                                <span>Eis</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="nature">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--nature"></div>
                                                <span>Natur</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="royal">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--royal"></div>
                                                <span>Royal</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="gold">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--gold"></div>
                                                <span>Gold</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="fire">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--fire"></div>
                                                <span>Feuer</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="ocean">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--ocean"></div>
                                                <span>Ozean</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="toxic">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--toxic"></div>
                                                <span>Toxisch</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="nebula">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--nebula"></div>
                                                <span>Nebula</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="sunset">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--sunset"></div>
                                                <span>Sunset</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="cyber">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--cyber"></div>
                                                <span>Cyber</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="midnight">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--midnight"></div>
                                                <span>Mitternacht</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="copper">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--copper"></div>
                                                <span>Kupfer</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="void">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--void"></div>
                                                <span>Void</span>
                                            </button>
                                            <button class="dice-theme-card" data-theme="rainbow">
                                                <div class="dice-theme-card__preview dice-theme-card__preview--rainbow"></div>
                                                <span>Rainbow</span>
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="dice-settings-popup__section">
                                        <span class="dice-settings-popup__label">Optionen</span>
                                        <div class="dice-settings-popup__toggles">
                                            <button class="dice-settings-toggle active" id="soundToggle2" onclick="DiceRoller.toggleSound()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                                </svg>
                                                <span>Sound</span>
                                            </button>
                                            <button class="dice-settings-toggle" id="secretToggle2" onclick="DiceRoller.toggleSecret()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                                </svg>
                                                <span>Geheim</span>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div class="dice-quick-row">
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w20')">1W20</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('2w6')">2W6</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w20+5')">1W20+5</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('4w6')">4W6</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w100')">1W100</button>
                            
                            <button class="dice-adv-btn" onclick="DiceRoller.rollAdvantage()" title="2W20, höchsten nehmen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
                                Vorteil
                            </button>
                            <button class="dice-adv-btn dice-adv-btn--dis" onclick="DiceRoller.rollDisadvantage()" title="2W20, niedrigsten nehmen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                                Nachteil
                            </button>
                            
                            <button class="dice-repeat-btn" id="repeatBtn" onclick="DiceRoller.repeatLast()" disabled title="Letzten Wurf wiederholen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Nochmal
                            </button>
                        </div>
                        
                        <!-- Roll Zone -->
                        <div class="dice-roll-zone">
                            <!-- Custom Notation Input (hidden by default) -->
                            <div class="dice-notation">
                                <input type="text" 
                                       class="dice-notation__input" 
                                       id="notationInput" 
                                       placeholder="z.B. 2W6+3, 1W20+1W4..."
                                       onkeydown="if(event.key==='Enter') DiceRoller.rollFromNotation()">
                                <button class="dice-notation__clear" onclick="document.getElementById('notationInput').value=''; DiceRoller.clearDice();">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                </button>
                            </div>
                            
                            <!-- Modifier -->
                            <div class="dice-modifier">
                                <button class="dice-modifier__btn dice-modifier__btn--lg" onclick="DiceRoller.adjustModifier(-20)">−20</button>
                                <button class="dice-modifier__btn dice-modifier__btn--md" onclick="DiceRoller.adjustModifier(-10)">−10</button>
                                <button class="dice-modifier__btn" onclick="DiceRoller.adjustModifier(-5)">−5</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-1)">−1</button>
                                <div class="dice-modifier__display" id="modifierDisplay">+0</div>
                                <input type="number" class="dice-modifier__value" id="modifierInput" value="0" min="-99" max="99">
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(1)">+1</button>
                                <button class="dice-modifier__btn" onclick="DiceRoller.adjustModifier(5)">+5</button>
                                <button class="dice-modifier__btn dice-modifier__btn--md" onclick="DiceRoller.adjustModifier(10)">+10</button>
                                <button class="dice-modifier__btn dice-modifier__btn--lg" onclick="DiceRoller.adjustModifier(20)">+20</button>
                            </div>
                            
                            <!-- Roll Button -->
                            <button class="dice-roll-btn" id="rollBtn" onclick="DiceRoller.roll()" disabled>
                                Würfeln!
                            </button>
                            
                            <!-- Quick Actions -->
                            <div class="dice-action-group">
                                <button class="dice-action-btn dice-action-btn--adv" onclick="DiceRoller.rollAdvantage()" title="Vorteil (2W20↑)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="18 15 12 9 6 15"/></svg>
                                </button>
                                <button class="dice-action-btn dice-action-btn--dis" onclick="DiceRoller.rollDisadvantage()" title="Nachteil (2W20↓)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="6 9 12 15 18 9"/></svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- History -->
                        <div class="dice-history">
                            <div class="dice-history__header">
                                <span class="dice-history__title">Verlauf</span>
                                <div class="dice-history__actions">
                                    <button class="dice-history__export" onclick="DiceRoller.exportHistory()" title="Exportieren">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                            <polyline points="7 10 12 15 17 10"/>
                                            <line x1="12" y1="15" x2="12" y2="3"/>
                                        </svg>
                                    </button>
                                    <button class="dice-history__clear" onclick="DiceRoller.clearHistory()">Löschen</button>
                                </div>
                            </div>
                            
                            <div class="dice-history__list" id="historyList">
                                <div class="dice-history__empty">Noch keine Würfe</div>
                            </div>
                        </div>
                        
                    </div>
                    
                </div>
                
            </div>
        </main>
        
        <!-- Probability Tooltip -->
        <div class="dice-probability-tooltip" id="probTooltip">
            <div class="dice-probability-tooltip__title"></div>
            <div class="dice-probability-tooltip__content"></div>
        </div>
    </div>
    
    <!-- 3D Dice Libraries -->
    <script src="assets/libs/dice/teal.js"></script>
    <script src="assets/libs/dice/three.min.js"></script>
    <script src="assets/libs/dice/cannon.min.js"></script>
    <script src="assets/libs/dice/dice.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- RIFT Services -->
    <script src="assets/js/firebase-config.js"></script>
    <script>
        // Auth Guard - redirect to login if not authenticated
        (function() {
            function waitForAuth() {
                // Wait for Firebase SDK
                if (typeof firebase === 'undefined' || !firebase.auth) {
                    return setTimeout(waitForAuth, 50);
                }
                // Wait for Firebase app initialization
                try {
                    var auth = firebase.auth();
                    auth.onAuthStateChanged(function(user) {
                        if (!user) {
                            window.location.href = '/login';
                        } else {
                            document.body.classList.add('auth-ready');
                        }
                    });
                } catch(e) {
                    // Firebase not initialized yet, retry
                    setTimeout(waitForAuth, 50);
                }
            }
            waitForAuth();
        })();
    </script>

    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    
    <!-- Core Scripts -->
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    
    <script>
        // ========================================
        // RIFT DICE ROLLER - FULL FEATURED
        // ========================================
        
        // Global sound toggle for library
        window.RIFT_DICE_SOUND = true;
        
        const DiceRoller = {
            // State
            box: null,
            currentDice: {},
            history: [],
            lastRoll: null,
            isRolling: false,
            resultTimeout: null,
            
            // Skill Check State (Worlds Apart)
            skillCheckMode: false,
            skillCheckTarget: 0,
            skillCheckLabel: '',
            
            // Fokus Check State (Worlds Apart D20)
            fokusCheckMode: false,
            fokusCheckLabel: '',
            fokusCheckMod: 0,
            
            // Zweite Chance State (Worlds Apart D20)
            zweiteChanceMode: false,
            zweiteChanceDiceIndex: -1,
            
            // Last check result (for passing back to sheet)
            lastCheckResult: null,
            
            // Return URL (back to character sheet)
            returnUrl: null,
            
            // Settings
            soundEnabled: true,
            secretRoll: false,
            currentTheme: null,
            currentDiceColor: '#2a2a2a',
            
            // Theme colors for 3D dice
            themeColors: {
                // Basic
                classic: { primary: '#1a1a1a', secondary: '#f0f0f0', accent: '#2a2a2a' },
                blood: { primary: '#8b0000', secondary: '#ffd700', accent: '#ff4655' },
                ice: { primary: '#1a3a5c', secondary: '#a8d8ff', accent: '#00d4ff' },
                nature: { primary: '#2d4a1c', secondary: '#c8e6c9', accent: '#4caf50' },
                royal: { primary: '#2a1a4a', secondary: '#e8d5ff', accent: '#9c27b0' },
                gold: { primary: '#3d2c0a', secondary: '#ffd700', accent: '#ffab00' },
                // New themes
                nebula: { primary: '#1a0a2e', secondary: '#ff6bcb', accent: '#c56cf0' },
                fire: { primary: '#4a1c00', secondary: '#ffcc00', accent: '#ff5722' },
                toxic: { primary: '#0a2a0a', secondary: '#39ff14', accent: '#00ff00' },
                ocean: { primary: '#001a33', secondary: '#00ffff', accent: '#0099cc' },
                midnight: { primary: '#0a0a1a', secondary: '#b8c6db', accent: '#4a5568' },
                rainbow: { primary: '#2a1a2a', secondary: '#ff6b6b', accent: '#feca57' },
                void: { primary: '#000000', secondary: '#8b5cf6', accent: '#6d28d9' },
                copper: { primary: '#2a1a0a', secondary: '#b87333', accent: '#cd7f32' },
                sunset: { primary: '#2a0a1a', secondary: '#ff7e5f', accent: '#feb47b' },
                cyber: { primary: '#0a0a1a', secondary: '#00ffff', accent: '#ff00ff' }
            },
            
            // Firebase
            roomRef: null,
            diceRef: null,
            
            // ========================================
            // INITIALIZATION
            // ========================================
            
            init() {
                console.log('[DiceRoller] Initializing...');
                
                const container = document.getElementById('diceArena');
                if (!container) {
                    console.error('[DiceRoller] Container not found');
                    return;
                }
                
                // Wait for container to have dimensions
                if (container.clientWidth === 0 || container.clientHeight === 0) {
                    setTimeout(() => this.init(), 200);
                    return;
                }
                
                // Initialize 3D Dice
                if (typeof DICE !== 'undefined') {
                    try {
                        this.box = new DICE.dice_box(container);
                        this.initSwipe(container);
                        console.log('[DiceRoller] 3D Dice initialized');
                    } catch (e) {
                        console.error('[DiceRoller] 3D init failed:', e);
                    }
                }
                
                // Load settings
                this.loadSettings();
                this.loadHistory();
                this.initThemes();
                this.initSettings();
                this.initRightClick();
                this.initMultiplayer();
                this.initDragDrop();
                this.initKeyboard();
                this.initShakeToRoll();
                this.initProbabilityTooltips();
                this.updateUI();
                this.updateModifierDisplay(0);
                
                // Check for URL parameters (Auto-Roll from Charakterbogen)
                this.handleUrlParams();
            },
            
            // ========================================
            // URL PARAMETER HANDLING (Auto-Roll)
            // ========================================
            
            handleUrlParams() {
                const params = new URLSearchParams(window.location.search);
                
                // Check for return URL (back to character sheet)
                const returnUrl = params.get('return');
                if (returnUrl) {
                    this.returnUrl = decodeURIComponent(returnUrl);
                    const backBtn = document.getElementById('backToSheetBtn');
                    const resultBackBtn = document.getElementById('resultBackBtn');
                    if (backBtn) {
                        backBtn.style.display = 'inline-flex';
                    }
                    if (resultBackBtn) {
                        resultBackBtn.style.display = 'inline-flex';
                    }
                }
                
                // Check for auto-roll parameters
                const diceType = params.get('dice'); // e.g., "d20" or "d100"
                const modifier = parseInt(params.get('mod')) || 0;
                const label = params.get('label') ? decodeURIComponent(params.get('label')) : '';
                const autoRoll = params.get('roll') === '1';
                const checkType = params.get('check'); // 'fokus' for D20 fokus checks, 'zweitechance' for second chance
                const diceIndex = params.get('diceIndex'); // For Zweite Chance
                
                // Valid dice types
                const validDice = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20', 'd100'];
                
                if (diceType && autoRoll && validDice.includes(diceType)) {
                    console.log('[DiceRoller] Auto-roll from URL:', { diceType, modifier, label, checkType });
                    
                    // Reset all check modes
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                    this.zweiteChanceMode = false;
                    this.zweiteChanceDiceIndex = -1;
                    
                    // Check if this is a Zweite Chance check (D20 with check=zweitechance)
                    if (diceType === 'd20' && checkType === 'zweitechance') {
                        this.zweiteChanceMode = true;
                        this.zweiteChanceDiceIndex = parseInt(diceIndex) || 0;
                        console.log('[DiceRoller] Zweite Chance Mode:', { diceIndex: this.zweiteChanceDiceIndex });
                    }
                    // Check if this is a Fokus check (D20 with check=fokus)
                    else if (diceType === 'd20' && checkType === 'fokus' && label) {
                        this.fokusCheckMode = true;
                        this.fokusCheckLabel = label;
                        this.fokusCheckMod = modifier;
                        console.log('[DiceRoller] Fokus Check Mode:', { label, mod: modifier });
                    }
                    // Check if this is a Worlds Apart skill check (d100 with label)
                    else if (diceType === 'd100' && label) {
                        this.skillCheckMode = true;
                        this.skillCheckTarget = modifier; // For skill checks, mod is the target number
                        this.skillCheckLabel = label;
                        console.log('[DiceRoller] Skill Check Mode:', { target: modifier, label });
                    }
                    
                    // Clear current dice and set the requested one
                    this.currentDice = {};
                    this.currentDice[diceType] = 1;
                    
                    // Set modifier
                    if (this.skillCheckMode) {
                        // For D100 skill checks, mod is the target, not added to roll
                        document.getElementById('modifierInput').value = 0;
                        this.updateModifierDisplay(0);
                    } else {
                        // For fokus checks and normal rolls, use modifier
                        document.getElementById('modifierInput').value = modifier;
                        this.updateModifierDisplay(modifier);
                    }
                    
                    // Update UI
                    this.updateUI();
                    
                    // Show label as toast
                    if (label && window.RIFT?.ui?.Toast) {
                        if (this.skillCheckMode) {
                            RIFT.ui.Toast.info(`${label} – Zielwert: ${modifier}`);
                        } else if (this.fokusCheckMode) {
                            RIFT.ui.Toast.info(`${label} – W20${modifier >= 0 ? '+' : ''}${modifier}`);
                        } else {
                            RIFT.ui.Toast.info(`${label}: W${diceType.replace('d', '')} ${modifier >= 0 ? '+' : ''}${modifier}`);
                        }
                    }
                    
                    // Auto-roll after delay (wait for 3D box to be ready)
                    setTimeout(() => {
                        console.log('[DiceRoller] Auto-rolling now, box ready:', !!this.box);
                        this.roll();
                    }, 800);
                    
                    // Clean URL (remove params without reload)
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
            },
            
            // ========================================
            // KEYBOARD SHORTCUTS
            // ========================================
            
            initKeyboard() {
                document.addEventListener('keydown', (e) => {
                    // Ignoriere wenn in Input-Feld
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    const key = e.key.toLowerCase();
                    
                    // Enter = Würfeln
                    if (e.key === 'Enter' && !this.isRolling) {
                        e.preventDefault();
                        this.roll();
                        return;
                    }
                    
                    // Space = Würfeln (alternativ)
                    if (e.key === ' ' && !this.isRolling) {
                        e.preventDefault();
                        this.roll();
                        return;
                    }
                    
                    // 1-7 = Würfel hinzufügen
                    const diceMap = {
                        '1': 'd4',
                        '2': 'd6',
                        '3': 'd8',
                        '4': 'd10',
                        '5': 'd12',
                        '6': 'd20',
                        '7': 'd100'
                    };
                    
                    if (diceMap[key]) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.removeDice(diceMap[key]);
                        } else {
                            this.addDice(diceMap[key]);
                        }
                        return;
                    }
                    
                    // R = Repeat
                    if (key === 'r' && this.lastRoll) {
                        e.preventDefault();
                        this.repeatLast();
                        return;
                    }
                    
                    // Backspace/Delete/Escape = Reset
                    if (e.key === 'Backspace' || e.key === 'Delete' || e.key === 'Escape') {
                        e.preventDefault();
                        this.clearDice();
                        return;
                    }
                    
                    // +/= = Modifier erhöhen
                    if (key === '+' || key === '=') {
                        e.preventDefault();
                        this.adjustModifier(e.shiftKey ? 5 : 1);
                        return;
                    }
                    
                    // - = Modifier verringern
                    if (key === '-') {
                        e.preventDefault();
                        this.adjustModifier(e.shiftKey ? -5 : -1);
                        return;
                    }
                    
                    // A = Advantage
                    if (key === 'a' && !e.ctrlKey) {
                        e.preventDefault();
                        this.rollAdvantage();
                        return;
                    }
                    
                    // D = Disadvantage
                    if (key === 'd' && !e.ctrlKey) {
                        e.preventDefault();
                        this.rollDisadvantage();
                        return;
                    }
                });
            },
            
            // ========================================
            // SHAKE TO ROLL (Mobile)
            // ========================================
            
            shakeThreshold: 15,
            lastShakeTime: 0,
            
            initShakeToRoll() {
                // Check if DeviceMotion is available
                if (!('DeviceMotionEvent' in window)) {
                    console.log('[DiceRoller] DeviceMotion not available');
                    return;
                }
                
                // Request permission on iOS 13+
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    // Will be triggered on first touch
                    document.body.addEventListener('touchstart', () => {
                        DeviceMotionEvent.requestPermission()
                            .then(response => {
                                if (response === 'granted') {
                                    this.bindShakeListener();
                                }
                            })
                            .catch(console.error);
                    }, { once: true });
                } else {
                    this.bindShakeListener();
                }
            },
            
            bindShakeListener() {
                let lastX = null, lastY = null, lastZ = null;
                
                window.addEventListener('devicemotion', (e) => {
                    const acc = e.accelerationIncludingGravity;
                    if (!acc) return;
                    
                    if (lastX !== null) {
                        const deltaX = Math.abs(acc.x - lastX);
                        const deltaY = Math.abs(acc.y - lastY);
                        const deltaZ = Math.abs(acc.z - lastZ);
                        
                        const totalDelta = deltaX + deltaY + deltaZ;
                        
                        if (totalDelta > this.shakeThreshold) {
                            const now = Date.now();
                            // Debounce: mindestens 1 Sekunde zwischen Shakes
                            if (now - this.lastShakeTime > 1000 && !this.isRolling) {
                                this.lastShakeTime = now;
                                
                                // Check if dice are selected
                                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                                if (hasDice) {
                                    console.log('[DiceRoller] Shake detected!');
                                    this.roll();
                                }
                            }
                        }
                    }
                    
                    lastX = acc.x;
                    lastY = acc.y;
                    lastZ = acc.z;
                });
                
                console.log('[DiceRoller] Shake-to-Roll enabled');
            },
            
            // ========================================
            // PROBABILITY TOOLTIPS
            // ========================================
            
            initProbabilityTooltips() {
                const buttons = document.querySelectorAll('.dice-btn');
                const tooltip = document.getElementById('probTooltip');
                
                if (!tooltip) return;
                
                buttons.forEach(btn => {
                    btn.addEventListener('mouseenter', (e) => {
                        const diceType = btn.dataset.dice;
                        if (diceType) {
                            this.showProbabilityTooltip(diceType, btn);
                        }
                    });
                    
                    btn.addEventListener('mouseleave', () => {
                        this.hideProbabilityTooltip();
                    });
                });
            },
            
            showProbabilityTooltip(diceType, element) {
                const tooltip = document.getElementById('probTooltip');
                if (!tooltip) return;
                
                const titleEl = tooltip.querySelector('.dice-probability-tooltip__title');
                const contentEl = tooltip.querySelector('.dice-probability-tooltip__content');
                
                const sides = parseInt(diceType.replace('d', ''));
                const avg = ((sides + 1) / 2).toFixed(1);
                const probEach = (100 / sides).toFixed(1);
                
                titleEl.textContent = diceType.toUpperCase();
                
                let html = `<div class="prob-row"><span>Durchschnitt:</span><span>${avg}</span></div>`;
                html += `<div class="prob-row"><span>Pro Seite:</span><span>${probEach}%</span></div>`;
                
                // Special probabilities
                if (diceType === 'd20') {
                    html += `<div class="prob-row prob-row--crit"><span>Nat 20:</span><span>5%</span></div>`;
                    html += `<div class="prob-row prob-row--fumble"><span>Nat 1:</span><span>5%</span></div>`;
                    html += `<div class="prob-row"><span>≥10:</span><span>55%</span></div>`;
                    html += `<div class="prob-row"><span>≥15:</span><span>30%</span></div>`;
                } else if (diceType === 'd100') {
                    html += `<div class="prob-row"><span>≤25:</span><span>25%</span></div>`;
                    html += `<div class="prob-row"><span>≤50:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>≤75:</span><span>75%</span></div>`;
                } else if (diceType === 'd6') {
                    html += `<div class="prob-row"><span>≥4:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (6):</span><span>16.7%</span></div>`;
                }
                
                contentEl.innerHTML = html;
                
                // Position tooltip
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + rect.width / 2}px`;
                tooltip.style.top = `${rect.top - 10}px`;
                tooltip.classList.add('visible');
            },
            
            hideProbabilityTooltip() {
                const tooltip = document.getElementById('probTooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            },
            
            // ========================================
            // DRAG & DROP
            // ========================================
            
            initDragDrop() {
                const arena = document.getElementById('diceArena');
                const canvases = document.querySelectorAll('.dice-btn__canvas');
                
                // Track drag start position
                let dragStartPos = null;
                let dragStartTime = null;
                
                // Make canvases draggable
                canvases.forEach(canvas => {
                    canvas.setAttribute('draggable', 'true');
                    canvas.style.cursor = 'grab';
                    
                    canvas.addEventListener('dragstart', (e) => {
                        const diceType = canvas.dataset.type;
                        e.dataTransfer.setData('text/plain', diceType);
                        e.dataTransfer.effectAllowed = 'copy';
                        canvas.style.opacity = '0.5';
                        
                        // Track start position
                        dragStartPos = { x: e.clientX, y: e.clientY };
                        dragStartTime = Date.now();
                    });
                    
                    canvas.addEventListener('dragend', (e) => {
                        canvas.style.opacity = '1';
                    });
                });
                
                // Arena as drop target
                arena.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    arena.classList.add('drag-over');
                });
                
                arena.addEventListener('dragleave', (e) => {
                    arena.classList.remove('drag-over');
                });
                
                arena.addEventListener('drop', (e) => {
                    e.preventDefault();
                    arena.classList.remove('drag-over');
                    
                    const diceType = e.dataTransfer.getData('text/plain');
                    if (diceType && !this.isRolling) {
                        // Calculate throw vector from start to drop position
                        let throwVector = null;
                        
                        if (dragStartPos) {
                            const dropPos = { x: e.clientX, y: e.clientY };
                            const dx = dropPos.x - dragStartPos.x;
                            const dy = dropPos.y - dragStartPos.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const elapsed = Math.max(Date.now() - dragStartTime, 100);
                            
                            if (dist > 30) {
                                // Calculate boost based on drag speed
                                const timeInt = Math.min(elapsed, 2000);
                                const boost = Math.sqrt((2500 - timeInt) / 2500) * dist * 1.5;
                                
                                throwVector = {
                                    vector: { x: dx, y: -dy },
                                    boost: Math.max(boost, 200)
                                };
                            }
                        }
                        
                        // Check if the DROPPED dice is part of current selection
                        const droppedIsSelected = (this.currentDice[diceType] || 0) > 0;
                        const hasSelection = Object.values(this.currentDice).some(c => c > 0);
                        
                        console.log('[DiceRoller] Drop check:', {
                            diceType,
                            droppedIsSelected,
                            hasSelection,
                            currentDice: {...this.currentDice}
                        });
                        
                        if (hasSelection && droppedIsSelected) {
                            // Dropped die is in selection → roll ALL selected dice
                            const totalDice = Object.values(this.currentDice).reduce((a, b) => a + b, 0);
                            console.log('[DiceRoller] Drag & Drop - rolling all selected dice:', this.currentDice);
                            
                            if (totalDice > 1 && window.RIFT?.ui?.Toast) {
                                const parts = Object.entries(this.currentDice)
                                    .filter(([_, count]) => count > 0)
                                    .map(([type, count]) => `${count}${type.toUpperCase()}`)
                                    .join(' + ');
                                RIFT.ui.Toast.info(`Werfe ${parts}`);
                            }
                            
                            this.pendingThrowVector = throwVector;
                            this.roll();
                        } else {
                            // Dropped die is NOT in selection → roll only the dropped die
                            console.log('[DiceRoller] Drag & Drop - rolling single:', diceType);
                            this.quickRollWithVector(diceType, throwVector);
                        }
                    }
                    
                    // Reset tracking
                    dragStartPos = null;
                    dragStartTime = null;
                });
            },
            
            quickRollWithVector(diceType, throwVector) {
                // Roll a single die immediately with vector
                const notation = `1${diceType}`;
                this.clearDice();
                this.currentDice[diceType] = 1;
                this.updateUI();
                this.executeRoll(notation, null, throwVector);
            },
            
            // ========================================
            // SWIPE HANDLING
            // ========================================
            
            initSwipe(container) {
                let startPos = null;
                let startTime = null;
                
                const onStart = (e) => {
                    if (this.isRolling) return;
                    startPos = this.getEventPos(e);
                    startTime = Date.now();
                };
                
                const onEnd = (e) => {
                    if (!startPos || this.isRolling) return;
                    
                    const endPos = this.getEventPos(e);
                    const dx = endPos.x - startPos.x;
                    const dy = endPos.y - startPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const elapsed = Date.now() - startTime;
                    
                    const savedStartPos = { ...startPos };
                    startPos = null;
                    
                    // Minimum swipe distance
                    if (dist < 50) return;
                    
                    // Check if we have dice to roll
                    const hasDice = Object.values(this.currentDice).some(c => c > 0);
                    const hasNotation = document.getElementById('notationInput').value.trim().length > 0;
                    
                    if (!hasDice && !hasNotation) {
                        // Default to 1d20 if nothing selected
                        this.currentDice = { d20: 1 };
                        this.updateNotationFromDice();
                        this.updateUI();
                    }
                    
                    // Calculate boost based on speed
                    const timeInt = Math.min(elapsed, 2000);
                    const boost = Math.sqrt((2500 - timeInt) / 2500) * dist * 2;
                    
                    // Vector for throw direction (inverted y for 3D space)
                    const vector = { x: dx, y: -dy };
                    
                    console.log('[DiceRoller] Swipe detected, vector:', vector, 'boost:', boost);
                    
                    // Store throw vector for executeRoll
                    this.pendingThrowVector = { vector, boost };
                    this.roll();
                };
                
                container.addEventListener('mousedown', onStart);
                container.addEventListener('mouseup', onEnd);
                container.addEventListener('touchstart', (e) => { e.preventDefault(); onStart(e); });
                container.addEventListener('touchend', (e) => { e.preventDefault(); onEnd(e); });
            },
            
            getEventPos(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            },
            
            // ========================================
            // RIGHT CLICK TO REMOVE DICE
            // ========================================
            
            initRightClick() {
                document.querySelectorAll('.dice-btn').forEach(btn => {
                    btn.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const type = btn.dataset.dice;
                        if (type) this.removeDice(type);
                    });
                });
            },
            
            // ========================================
            // THEMES
            // ========================================
            
            initThemes() {
                // Theme buttons (alte + neue)
                document.querySelectorAll('.dice-theme-btn, .dice-theme-card').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const theme = btn.dataset.theme;
                        this.setTheme(theme, true); // true = show toast
                    });
                });
                
                // Load saved theme (no toast on initial load)
                const saved = localStorage.getItem('rift_dice_theme') || 'classic';
                this.setTheme(saved, false);
            },
            
            setTheme(theme, showNotification = false) {
                // Skip if already this theme
                if (this.currentTheme === theme && !showNotification) return;
                
                this.currentTheme = theme;
                
                // Set data attribute for CSS
                document.body.dataset.diceTheme = theme;
                
                // Update theme buttons (alte)
                document.querySelectorAll('.dice-theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === theme);
                });
                
                // Update theme cards (neue)
                document.querySelectorAll('.dice-theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.theme === theme);
                });
                
                // Update arena background gradient based on theme
                const arena = document.getElementById('diceArena');
                const colors = this.themeColors[theme] || this.themeColors.classic;
                
                if (arena) {
                    arena.style.setProperty('--theme-primary', colors.primary);
                    arena.style.setProperty('--theme-secondary', colors.secondary);
                }
                
                // Update 3D dice color - store for next roll
                this.currentDiceColor = colors.accent;
                
                // Set color on DICE module (nicht auf box Instanz)
                if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(colors.accent);
                }
                
                localStorage.setItem('rift_dice_theme', theme);
                
                // Only show toast when explicitly changing theme
                if (showNotification && window.RIFT?.ui?.Toast) {
                    const names = { 
                        classic: 'Klassisch', blood: 'Blut', ice: 'Eis', nature: 'Natur', royal: 'Royal', gold: 'Gold',
                        fire: 'Feuer', ocean: 'Ozean', toxic: 'Toxisch', nebula: 'Nebula', sunset: 'Sunset', cyber: 'Cyber',
                        midnight: 'Mitternacht', copper: 'Kupfer', void: 'Void', rainbow: 'Rainbow'
                    };
                    RIFT.ui.Toast.info(`Theme: ${names[theme] || theme}`);
                }
            },
            
            // ========================================
            // SETTINGS POPUP
            // ========================================
            
            initSettings() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsPopup = document.getElementById('settingsPopup');
                const settingsClose = document.getElementById('settingsClose');
                
                const statsBtn = document.getElementById('statsBtn');
                const statsPopup = document.getElementById('statsPopup');
                
                const hotkeysBtn = document.getElementById('hotkeysBtn');
                const hotkeysPopup = document.getElementById('hotkeysPopup');
                
                // Settings Button
                if (settingsBtn && settingsPopup) {
                    settingsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = settingsPopup.classList.contains('open');
                        this.closeAllPopups();
                        if (!isOpen) {
                            settingsPopup.classList.add('open');
                            settingsBtn.classList.add('active');
                        }
                    });
                    
                    settingsClose?.addEventListener('click', () => {
                        settingsPopup.classList.remove('open');
                        settingsBtn.classList.remove('active');
                    });
                }
                
                // Stats Button
                if (statsBtn && statsPopup) {
                    statsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleStatsPopup();
                    });
                }
                
                // Hotkeys Button
                if (hotkeysBtn && hotkeysPopup) {
                    hotkeysBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleHotkeysPopup();
                    });
                }
                
                // Click outside schließt alle Popups
                document.addEventListener('click', (e) => {
                    const allPopups = [settingsPopup, statsPopup, hotkeysPopup];
                    const allBtns = [settingsBtn, statsBtn, hotkeysBtn];
                    
                    let clickedInside = false;
                    allPopups.forEach(popup => {
                        if (popup?.contains(e.target)) clickedInside = true;
                    });
                    allBtns.forEach(btn => {
                        if (btn?.contains(e.target)) clickedInside = true;
                    });
                    
                    if (!clickedInside) {
                        this.closeAllPopups();
                    }
                });
                
                // Clicks in Popups nicht durchlassen
                [settingsPopup, statsPopup, hotkeysPopup].forEach(popup => {
                    popup?.addEventListener('click', (e) => e.stopPropagation());
                });
            },
            
            // ========================================
            // SOUND
            // ========================================
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                window.RIFT_DICE_SOUND = this.soundEnabled;
                
                // Update both toggle buttons
                document.getElementById('soundToggle')?.classList.toggle('active', this.soundEnabled);
                document.getElementById('soundToggle2')?.classList.toggle('active', this.soundEnabled);
                localStorage.setItem('rift_dice_sound', this.soundEnabled);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(this.soundEnabled ? 'Sound an' : 'Sound aus');
                }
            },
            
            // ========================================
            // SECRET ROLL
            // ========================================
            
            toggleSecret() {
                this.secretRoll = !this.secretRoll;
                
                // Update both toggle buttons
                document.getElementById('secretToggle')?.classList.toggle('active', this.secretRoll);
                document.getElementById('secretToggle2')?.classList.toggle('active', this.secretRoll);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(this.secretRoll ? 'Geheimer Wurf aktiviert' : 'Normaler Wurf');
                }
            },
            
            // ========================================
            // PRESETS
            // ========================================
            
            presets: [],
            presetsOpen: false,
            
            togglePresets() {
                this.presetsOpen = !this.presetsOpen;
                const popup = document.getElementById('presetsPopup');
                const btn = document.getElementById('presetsBtn');
                
                if (this.presetsOpen) {
                    this.loadPresets();
                    this.renderPresets();
                    popup.classList.add('visible');
                    btn.classList.add('active');
                } else {
                    popup.classList.remove('visible');
                    btn.classList.remove('active');
                }
            },
            
            loadPresets() {
                try {
                    this.presets = JSON.parse(localStorage.getItem('rift_dice_presets') || '[]');
                } catch (e) {
                    this.presets = [];
                }
            },
            
            savePresets() {
                localStorage.setItem('rift_dice_presets', JSON.stringify(this.presets));
            },
            
            savePreset() {
                // Check if there are dice selected
                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                if (!hasDice) {
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Keine Würfel ausgewählt');
                    }
                    return;
                }
                
                // Prompt for name
                const defaultName = this.buildNotationString();
                const name = prompt('Preset-Name:', defaultName);
                if (!name) return;
                
                // Build preset
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                const preset = {
                    name: name,
                    dice: { ...this.currentDice },
                    modifier: mod,
                    notation: this.buildNotationString()
                };
                
                this.loadPresets();
                this.presets.push(preset);
                this.savePresets();
                this.renderPresets();
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success(`Preset "${name}" gespeichert`);
                }
            },
            
            buildNotationString() {
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        const wType = type.replace('d', 'W').toUpperCase();
                        parts.push(`${count}${wType}`);
                    }
                }
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                let notation = parts.join('+');
                if (mod !== 0) notation += (mod > 0 ? '+' : '') + mod;
                return notation;
            },
            
            loadPreset(index) {
                const preset = this.presets[index];
                if (!preset) return;
                
                this.currentDice = { ...preset.dice };
                document.getElementById('modifierInput').value = preset.modifier || 0;
                this.updateModifierDisplay(preset.modifier || 0);
                this.updateNotationFromDice();
                this.updateUI();
                
                // Close popup
                this.togglePresets();
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(`"${preset.name}" geladen`);
                }
            },
            
            deletePreset(index, e) {
                e.stopPropagation();
                const preset = this.presets[index];
                if (!preset) return;
                
                if (confirm(`Preset "${preset.name}" löschen?`)) {
                    this.presets.splice(index, 1);
                    this.savePresets();
                    this.renderPresets();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.info('Preset gelöscht');
                    }
                }
            },
            
            renderPresets() {
                const list = document.getElementById('presetsList');
                if (!list) return;
                
                if (this.presets.length === 0) {
                    list.innerHTML = '<div class="dice-presets-popup__empty">Keine Presets gespeichert</div>';
                    return;
                }
                
                list.innerHTML = this.presets.map((preset, i) => `
                    <div class="dice-presets-popup__item" onclick="DiceRoller.loadPreset(${i})">
                        <div class="dice-presets-popup__item-info">
                            <span class="dice-presets-popup__item-name">${preset.name}</span>
                            <span class="dice-presets-popup__item-notation">${preset.notation}</span>
                        </div>
                        <button class="dice-presets-popup__item-delete" onclick="DiceRoller.deletePreset(${i}, event)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                `).join('');
            },
            
            // ========================================
            // DICE SELECTION
            // ========================================
            
            addDice(type) {
                if (!this.currentDice[type]) this.currentDice[type] = 0;
                this.currentDice[type]++;
                this.updateNotationFromDice();
                this.updateUI();
            },
            
            removeDice(type) {
                if (this.currentDice[type]) {
                    this.currentDice[type]--;
                    if (this.currentDice[type] <= 0) delete this.currentDice[type];
                }
                this.updateNotationFromDice();
                this.updateUI();
            },
            
            clearDice() {
                this.currentDice = {};
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '';
                this.updateUI();
            },
            
            updateNotationFromDice() {
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        // Use German W notation
                        const wType = type.replace('d', 'W');
                        parts.push(`${count}${wType}`);
                    }
                }
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                let notation = parts.join('+');
                if (mod > 0) notation += `+${mod}`;
                else if (mod < 0) notation += `${mod}`;
                
                document.getElementById('notationInput').value = notation;
            },
            
            // Parse notation - supports both D and W (German)
            parseDiceFromNotation(notation) {
                this.currentDice = {};
                let modifier = 0;
                
                // Normalize: replace W with D (case insensitive)
                const normalized = notation.toUpperCase().replace(/W/g, 'D');
                
                // Match dice patterns (now only D since we normalized)
                const diceRegex = /(\d*)D(\d+)/g;
                let match;
                while ((match = diceRegex.exec(normalized)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    const type = `d${sides}`;
                    this.currentDice[type] = (this.currentDice[type] || 0) + count;
                }
                
                // Match modifier at end (after all dice)
                const modMatch = normalized.match(/([+-]\d+)(?!D)(?:\s*$|\s*\()/);
                if (modMatch) {
                    modifier = parseInt(modMatch[1]);
                }
                
                document.getElementById('modifierInput').value = modifier;
                this.updateUI();
            },
            
            adjustModifier(delta) {
                const input = document.getElementById('modifierInput');
                let val = parseInt(input.value) || 0;
                val = Math.max(-99, Math.min(99, val + delta));
                input.value = val;
                this.updateModifierDisplay(val);
                this.updateNotationFromDice();
            },
            
            updateModifierDisplay(val) {
                const display = document.getElementById('modifierDisplay');
                if (!display) return;
                
                if (val === 0) {
                    display.textContent = '+0';
                    display.className = 'dice-modifier__display';
                } else if (val > 0) {
                    display.textContent = '+' + val;
                    display.className = 'dice-modifier__display dice-modifier__display--positive';
                } else {
                    display.textContent = val.toString();
                    display.className = 'dice-modifier__display dice-modifier__display--negative';
                }
            },
            
            // ========================================
            // ROLLING
            // ========================================
            
            roll() {
                if (this.isRolling) return;
                
                // Hide previous result
                this.hideResult();
                
                // Get notation from input or build from dice
                let notationStr = document.getElementById('notationInput').value.trim();
                
                if (notationStr) {
                    this.parseDiceFromNotation(notationStr);
                }
                
                // Build from selected dice
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) parts.push(`${count}${type}`);
                }
                if (parts.length === 0) return;
                
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                notationStr = parts.join('+');
                if (mod !== 0) notationStr += (mod > 0 ? '+' : '') + mod;
                
                // Use pending throw vector if available
                const throwVector = this.pendingThrowVector || null;
                this.pendingThrowVector = null;
                
                this.executeRoll(notationStr, null, throwVector);
            },
            
            rollFromNotation() {
                const notation = document.getElementById('notationInput').value.trim();
                if (!notation) return;
                this.parseDiceFromNotation(notation);
                this.roll();
            },
            
            quickRoll(notation) {
                this.hideResult();
                this.parseDiceFromNotation(notation);
                document.getElementById('notationInput').value = notation;
                setTimeout(() => this.roll(), 50);
            },
            
            rollAdvantage() {
                this.hideResult();
                this.currentDice = { d20: 2 };
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '2D20 (Vorteil)';
                this.updateUI();
                this.executeRoll('2d20', 'advantage');
            },
            
            rollDisadvantage() {
                this.hideResult();
                this.currentDice = { d20: 2 };
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '2D20 (Nachteil)';
                this.updateUI();
                this.executeRoll('2d20', 'disadvantage');
            },
            
            repeatLast() {
                if (!this.lastRoll) return;
                this.hideResult();
                document.getElementById('notationInput').value = this.lastRoll.notation;
                this.parseDiceFromNotation(this.lastRoll.notation);
                this.executeRoll(this.lastRoll.notationClean, this.lastRoll.special);
            },
            
            hideResult() {
                const result = document.getElementById('diceResult');
                result.classList.remove('visible', 'critical', 'fumble', 'secret');
                this.clearDiceLabels();
                if (this.resultTimeout) {
                    clearTimeout(this.resultTimeout);
                    this.resultTimeout = null;
                }
            },
            
            executeRoll(notationStr, special = null, throwVector = null) {
                if (this.isRolling) return;
                this.isRolling = true;
                
                // Clear previous labels immediately
                this.clearDiceLabels();
                
                // Set dice color before roll - DICE.setDiceColor (nicht this.box!)
                if (this.currentDiceColor && typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(this.currentDiceColor);
                }
                
                const arena = document.getElementById('diceArena');
                const result = document.getElementById('diceResult');
                const btn = document.getElementById('rollBtn');
                
                // UI Feedback
                arena.classList.remove('empty');
                arena.classList.add('throwing');
                result.classList.remove('visible', 'critical', 'fumble', 'secret');
                btn.classList.add('rolling');
                
                setTimeout(() => arena.classList.remove('throwing'), 300);
                
                // Save for repeat
                const displayNotation = document.getElementById('notationInput').value || notationStr;
                this.lastRoll = { notation: displayNotation, notationClean: notationStr, special };
                document.getElementById('repeatBtn').disabled = false;
                
                // Handle W100/D100 specially: Convert to d100 (tens) + d10 (ones) for library
                let libraryNotation = notationStr;
                const d100Count = this.currentDice.d100 || 0;
                if (d100Count > 0) {
                    libraryNotation = notationStr.replace(/(\d*)d100/gi, (match, count) => {
                        const c = parseInt(count) || 1;
                        return `${c}d100+${c}d10`;
                    });
                }
                
                console.log('[DiceRoller] Library notation:', libraryNotation);
                
                // Track when roll started for minimum animation time
                const rollStartTime = Date.now();
                const MIN_ANIMATION_TIME = 1500; // Minimum 1.5 seconds
                
                // Roll with 3D or fallback
                if (this.box) {
                    this.box.setDice(libraryNotation);
                    
                    // Use a flag to prevent double-callback
                    let resultHandled = false;
                    
                    const afterRoll = (notation) => {
                        if (resultHandled) return;
                        resultHandled = true;
                        
                        // Calculate how long animation actually took
                        const elapsed = Date.now() - rollStartTime;
                        const remainingTime = Math.max(0, MIN_ANIMATION_TIME - elapsed);
                        
                        console.log('[DiceRoller] Animation took', elapsed, 'ms, waiting additional', remainingTime, 'ms');
                        
                        // Ensure minimum animation time before showing result
                        setTimeout(() => {
                            btn.classList.remove('rolling');
                            
                            let rolls = notation.result;
                            let total = notation.resultTotal;
                            const rawRolls = [...notation.result];
                            
                            console.log('[DiceRoller] Raw results:', rolls);
                            
                            if (d100Count > 0) {
                                const d100Result = this.calculateD100Result(rolls, d100Count);
                                rolls = d100Result.rolls;
                                total = d100Result.total;
                                
                                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                                total += mod;
                            }
                            
                            this.handleResult(rolls, total, notation, special, rawRolls);
                        }, remainingTime);
                    };
                    
                    // Throw with vector if provided, otherwise random
                    if (throwVector && throwVector.vector && throwVector.boost) {
                        this.box.throw_with_vector(throwVector.vector, throwVector.boost, null, afterRoll);
                    } else {
                        this.box.start_throw(null, afterRoll);
                    }
                    
                    // Fallback timeout in case callback never fires
                    setTimeout(() => {
                        if (!resultHandled) {
                            console.warn('[DiceRoller] Callback timeout - using fallback');
                            resultHandled = true;
                            btn.classList.remove('rolling');
                            const results = this.simulateRoll(notationStr);
                            this.handleResult(results.rolls, results.total, { resultString: results.breakdown }, special, null);
                        }
                    }, 10000); // 10 second timeout
                    
                } else {
                    // Fallback without 3D
                    setTimeout(() => {
                        btn.classList.remove('rolling');
                        const results = this.simulateRoll(notationStr);
                        this.handleResult(results.rolls, results.total, { resultString: results.breakdown }, special, null);
                    }, MIN_ANIMATION_TIME);
                }
            },
            
            calculateD100Result(rawRolls, d100Count) {
                // Library returns:
                // - d100 (tens): 0, 10, 20, 30, 40, 50, 60, 70, 80, 90
                // - d10 (ones): 1-10 (where 10 means the "0" face was rolled)
                const rolls = [];
                let total = 0;
                let rollIndex = 0;
                
                for (let i = 0; i < d100Count; i++) {
                    const tens = rawRolls[rollIndex] || 0;           // 0, 10, 20, 30...90
                    const onesRaw = rawRolls[rollIndex + 1] || 1;    // 1-10
                    const ones = onesRaw === 10 ? 0 : onesRaw;       // Convert 10 back to 0
                    
                    let value = tens + ones;
                    // Special case: 00 + 0 = 100 (not 0)
                    if (value === 0) value = 100;
                    
                    console.log(`[DiceRoller] D100 #${i+1}: tens=${tens}, onesRaw=${onesRaw}, ones=${ones}, value=${value}`);
                    
                    rolls.push(value);
                    total += value;
                    rollIndex += 2;
                }
                
                // Add remaining rolls (non-d100 dice)
                while (rollIndex < rawRolls.length) {
                    rolls.push(rawRolls[rollIndex]);
                    total += rawRolls[rollIndex];
                    rollIndex++;
                }
                
                return { rolls, total };
            },
            
            simulateRoll(notation) {
                const rolls = [];
                let total = 0;
                
                // Normalize W to D
                const normalized = notation.toUpperCase().replace(/W/g, 'D');
                
                const diceRegex = /(\d*)D(\d+)/g;
                let match;
                while ((match = diceRegex.exec(normalized)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    
                    if (sides === 100) {
                        // D100: tens (00-90) + ones (0-9)
                        for (let i = 0; i < count; i++) {
                            const tens = Math.floor(Math.random() * 10) * 10; // 0, 10, 20...90
                            const ones = Math.floor(Math.random() * 10);       // 0-9
                            let value = tens + ones;
                            if (value === 0) value = 100; // 00 + 0 = 100
                            rolls.push(value);
                            total += value;
                        }
                    } else {
                        for (let i = 0; i < count; i++) {
                            const roll = Math.floor(Math.random() * sides) + 1;
                            rolls.push(roll);
                            total += roll;
                        }
                    }
                }
                
                const modMatch = normalized.match(/([+-]\d+)(?!D)(?:\s*$|\s*\()/);
                const mod = modMatch ? parseInt(modMatch[1]) : 0;
                total += mod;
                
                return { rolls, total, breakdown: `[${rolls.join(', ')}]${mod !== 0 ? (mod > 0 ? '+' : '') + mod : ''} = ${total}` };
            },
            
            handleResult(rolls, total, notation, special = null, rawRolls = null) {
                const arena = document.getElementById('diceArena');
                const resultEl = document.getElementById('diceResult');
                const totalEl = document.getElementById('resultTotal');
                const breakdownEl = document.getElementById('resultBreakdown');
                const playerEl = document.getElementById('resultPlayer');
                const skillLabelEl = document.getElementById('resultSkillLabel');
                const targetEl = document.getElementById('resultTarget');
                const outcomeEl = document.getElementById('resultOutcome');
                const backBtnEl = document.getElementById('resultBackBtn');
                
                // Reset skill check display classes
                resultEl.classList.remove('skill-success', 'skill-failure');
                skillLabelEl.classList.remove('visible');
                targetEl.classList.remove('visible');
                outcomeEl.classList.remove('visible', 'success', 'failure');
                backBtnEl.classList.remove('visible');
                
                // Get current modifier
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                // Handle advantage/disadvantage
                let finalTotal = total;
                let displayRolls = rolls;
                
                if (special === 'advantage' && rolls.length >= 2) {
                    finalTotal = Math.max(rolls[0], rolls[1]);
                    if (mod !== 0) finalTotal += mod;
                } else if (special === 'disadvantage' && rolls.length >= 2) {
                    finalTotal = Math.min(rolls[0], rolls[1]);
                    if (mod !== 0) finalTotal += mod;
                }
                
                // Check critical
                const isCritical = this.checkCritical(rolls, special);
                
                // Show dice labels above each die
                this.showDiceLabels(rolls, rawRolls);
                
                // Get user info
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const playerName = userData.name || 'Spieler';
                const playerColor = userData.color || '#FF4655';
                
                // Display
                playerEl.textContent = playerName;
                playerEl.style.color = playerColor;
                totalEl.textContent = finalTotal;
                
                // Skill Check Display (Worlds Apart D100)
                if (this.skillCheckMode && this.skillCheckTarget > 0) {
                    // Show skill label
                    skillLabelEl.textContent = this.skillCheckLabel;
                    skillLabelEl.classList.add('visible');
                    
                    // Determine success/failure (roll must be <= target)
                    const rollResult = rolls[0]; // D100 result
                    const isSuccess = rollResult <= this.skillCheckTarget;
                    
                    // Show target value
                    targetEl.textContent = `Zielwert: ${this.skillCheckTarget}`;
                    targetEl.classList.add('visible');
                    
                    // Show outcome
                    outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown: Gewürfelt vs Zielwert
                    breakdownEl.innerHTML = `Gewürfelt: ${rollResult} | Zielwert: ${this.skillCheckTarget}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    this.lastCheckResult = {
                        label: this.skillCheckLabel,
                        result: rollResult,
                        success: isSuccess,
                        outcome: isSuccess ? 'Erfolg' : 'Fehlschlag',
                        critical: false
                    };
                    
                    console.log('[DiceRoller] Skill Check Result:', { roll: rollResult, target: this.skillCheckTarget, success: isSuccess });
                }
                // Zweite Chance Display (Worlds Apart D20)
                else if (this.zweiteChanceMode) {
                    // Show label
                    skillLabelEl.textContent = 'Zweite Chance';
                    skillLabelEl.classList.add('visible');
                    
                    // Show threshold info
                    targetEl.textContent = '1–5 = Fehlschlag | 6–20 = Wiederholen';
                    targetEl.classList.add('visible');
                    
                    // Get natural roll
                    const rollValue = rolls[0];
                    const isSuccess = rollValue >= 6;
                    
                    // Show outcome
                    if (isSuccess) {
                        outcomeEl.textContent = 'WIEDERHOLEN ERLAUBT!';
                    } else {
                        outcomeEl.textContent = 'FEHLSCHLAG BLEIBT!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown
                    breakdownEl.innerHTML = `Gewürfelt: ${rollValue}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    this.lastCheckResult = {
                        label: 'Zweite Chance',
                        result: rollValue,
                        success: isSuccess,
                        outcome: isSuccess ? 'Wiederholen!' : 'Fehlschlag!',
                        critical: false,
                        zweiteChance: true,
                        diceIndex: this.zweiteChanceDiceIndex
                    };
                    
                    console.log('[DiceRoller] Zweite Chance Result:', { roll: rollValue, success: isSuccess, diceIndex: this.zweiteChanceDiceIndex });
                }
                // Fokus Check Display (Worlds Apart D20)
                else if (this.fokusCheckMode) {
                    // Show fokus label
                    skillLabelEl.textContent = 'Fokus-Fähigkeit';
                    skillLabelEl.classList.add('visible');
                    
                    // Show threshold info
                    targetEl.textContent = `≥11 Erfolg | ≤10 Fehlschlag`;
                    targetEl.classList.add('visible');
                    
                    // Get natural roll
                    const rollValue = rolls[0];
                    const isNat20 = rollValue === 20;
                    const isNat1 = rollValue === 1;
                    
                    // Determine success/failure (total must be >= 11, but nat 20 always success, nat 1 always fail)
                    const isSuccess = isNat20 || (!isNat1 && finalTotal >= 11);
                    const isCritical = isNat20 || isNat1;
                    
                    // Show outcome
                    if (isNat20) {
                        outcomeEl.textContent = 'KRITISCHER ERFOLG!';
                        resultEl.classList.add('critical');
                    } else if (isNat1) {
                        outcomeEl.textContent = 'PATZER!';
                        resultEl.classList.add('fumble');
                    } else {
                        outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown with roll + modifier = total
                    const modSign = mod >= 0 ? '+' : '';
                    breakdownEl.innerHTML = `${rollValue} ${modSign} ${mod} = ${finalTotal}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    let outcomeText = isSuccess ? 'Erfolg' : 'Fehlschlag';
                    if (isNat20) outcomeText = 'Kritisch!';
                    if (isNat1) outcomeText = 'Patzer!';
                    
                    this.lastCheckResult = {
                        label: 'Fokus-Fähigkeit',
                        result: finalTotal,
                        success: isSuccess,
                        outcome: outcomeText,
                        critical: isCritical
                    };
                    
                    console.log('[DiceRoller] Fokus Check Result:', { roll: rollValue, mod: mod, total: finalTotal, success: isSuccess, critical: isCritical });
                } else {
                    // Normal roll - show breakdown
                    breakdownEl.style.display = '';
                }
                
                // Format modifier string with color
                let modStr = '';
                if (mod !== 0) {
                    const modClass = mod > 0 ? 'positive' : 'negative';
                    const modSign = mod > 0 ? '+' : '';
                    modStr = ` <span class="dice-result__mod dice-result__mod--${modClass}">${modSign}${mod}</span>`;
                }
                
                if (special === 'advantage') {
                    const baseResult = Math.max(rolls[0], rolls[1]);
                    breakdownEl.innerHTML = `[${rolls[0]}, ${rolls[1]}] → höchste: ${baseResult}${modStr}`;
                } else if (special === 'disadvantage') {
                    const baseResult = Math.min(rolls[0], rolls[1]);
                    breakdownEl.innerHTML = `[${rolls[0]}, ${rolls[1]}] → niedrigste: ${baseResult}${modStr}`;
                } else {
                    // Calculate base total (without modifier)
                    const baseTotal = rolls.reduce((a, b) => a + b, 0);
                    breakdownEl.innerHTML = `[${rolls.join(', ')}]${modStr} = ${total}`;
                }
                
                // Secret roll styling
                if (this.secretRoll) {
                    resultEl.classList.add('secret');
                }
                
                // Scan-line effect through arena
                arena.classList.add('resolving');
                setTimeout(() => arena.classList.remove('resolving'), 1500);
                
                // Critical/Fumble styling and effects
                if (isCritical === 'success') {
                    resultEl.classList.add('critical');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('success');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                } else if (isCritical === 'failure') {
                    resultEl.classList.add('fumble');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('failure');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                }
                
                resultEl.classList.add('visible');
                
                // Auto-hide result after 8 seconds
                this.resultTimeout = setTimeout(() => {
                    resultEl.classList.remove('visible', 'critical', 'fumble', 'secret', 'skill-success', 'skill-failure');
                    skillLabelEl.classList.remove('visible');
                    targetEl.classList.remove('visible');
                    outcomeEl.classList.remove('visible', 'success', 'failure');
                    backBtnEl.classList.remove('visible');
                    breakdownEl.style.display = '';
                    this.clearDiceLabels();
                    
                    // Reset skill check mode
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    
                    // Reset fokus check mode
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                }, 8000);
                
                // Build notation string for history (German W notation)
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        const wType = type.replace('d', 'W');
                        parts.push(`${count}${wType}`);
                    }
                }
                let histNotation = parts.join('+');
                if (mod !== 0) histNotation += (mod > 0 ? '+' : '') + mod;
                if (special) histNotation += ` (${special === 'advantage' ? 'V' : 'N'})`;
                
                // Add to history
                this.addToHistory({
                    player: playerName,
                    color: userData.color || '#FF4655',
                    total: finalTotal,
                    notation: histNotation,
                    rolls: displayRolls,
                    critical: isCritical,
                    secret: this.secretRoll,
                    special,
                    timestamp: Date.now()
                });
                
                // Sync to multiplayer
                this.syncRoll({
                    player: playerName,
                    color: userData.color || '#FF4655',
                    diceTheme: this.currentTheme || 'classic',
                    total: finalTotal,
                    notation: histNotation,
                    rolls: displayRolls,
                    critical: isCritical,
                    secret: this.secretRoll,
                    timestamp: Date.now()
                });
                
                this.isRolling = false;
            },
            
            checkCritical(rolls, special) {
                // Get the dice type being rolled
                const diceTypes = Object.entries(this.currentDice).filter(([type, count]) => count > 0);
                const isOnlyD20 = diceTypes.length === 1 && diceTypes[0][0] === 'd20' && diceTypes[0][1] === 1;
                const isOnlyD100 = diceTypes.length === 1 && diceTypes[0][0] === 'd100' && diceTypes[0][1] === 1;
                
                // D&D 5e: D20 critical
                if (isOnlyD20 || (special && diceTypes.some(([type]) => type === 'd20'))) {
                    // Nat 20 = Critical Success
                    if (rolls.length === 1 && rolls[0] === 20) return 'success';
                    if (rolls.length === 2 && special && (rolls[0] === 20 || rolls[1] === 20)) return 'success';
                    // Nat 1 = Critical Failure
                    if (rolls.length === 1 && rolls[0] === 1) return 'failure';
                    if (rolls.length === 2 && special && (rolls[0] === 1 || rolls[1] === 1)) return 'failure';
                }
                
                // Worlds Apart: D100 critical
                if (isOnlyD100) {
                    // 1 on d100 = Critical Success
                    if (rolls.length === 1 && rolls[0] === 1) return 'success';
                    // 100 on d100 = Critical Failure
                    if (rolls.length === 1 && rolls[0] === 100) return 'failure';
                }
                
                return false;
            },
            
            showCritFlash(type) {
                const flash = document.createElement('div');
                flash.className = `crit-flash crit-flash--${type}`;
                document.body.appendChild(flash);
                
                // Remove after animation
                setTimeout(() => {
                    flash.remove();
                }, 600);
            },
            
            // ========================================
            // MULTIPLAYER
            // ========================================
            
            initMultiplayer() {
                const roomCode = localStorage.getItem('rift_current_room');
                if (!roomCode || typeof firebase === 'undefined') {
                    console.log('[DiceRoller] No room or Firebase, skipping multiplayer');
                    return;
                }
                
                // Store normalized room code for Firestore
                this.roomCode = roomCode.replace(/-/g, '').toUpperCase();
                
                try {
                    this.roomRef = firebase.database().ref(`rooms/${roomCode}`);
                    this.diceRef = this.roomRef.child('dice_rolls');
                    
                    // Listen for new rolls
                    this.diceRef.orderByChild('timestamp').limitToLast(10).on('child_added', (snapshot) => {
                        const roll = snapshot.val();
                        if (roll && Date.now() - roll.timestamp < 30000) {
                            this.showFeedItem(roll);
                        }
                    });
                    
                    console.log('[DiceRoller] Multiplayer connected');
                } catch (e) {
                    console.error('[DiceRoller] Multiplayer init failed:', e);
                }
            },
            
            syncRoll(rollData) {
                if (!this.diceRef) return;
                
                // Don't sync if secret and not GM
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                if (rollData.secret && !userData.isGM) {
                    return;
                }
                
                try {
                    // 1. Push to Realtime Database (for live feed)
                    this.diceRef.push(rollData);
                    
                    // 2. Also write to Firestore (for GM logs)
                    this.logRollToFirestore(rollData);
                } catch (e) {
                    console.error('[DiceRoller] Sync failed:', e);
                }
            },
            
            async logRollToFirestore(rollData) {
                if (!this.roomCode) return;
                
                try {
                    // Ensure Firestore is available
                    if (typeof firebase === 'undefined' || !firebase.firestore) {
                        console.log('[DiceRoller] Firestore not available for logging');
                        return;
                    }
                    
                    const db = firebase.firestore();
                    const diceCollection = db.collection('rooms').doc(this.roomCode).collection('dice');
                    
                    // Build log entry
                    const logEntry = {
                        player: rollData.player || 'Unbekannt',
                        playerId: rollData.playerId || null,
                        color: rollData.color || '#8b5cf6',
                        notation: rollData.notation || '',
                        total: rollData.total || 0,
                        results: rollData.results || [],
                        diceTheme: rollData.diceTheme || 'classic',
                        secret: rollData.secret || false,
                        critical: rollData.critical || null,
                        label: rollData.label || null,
                        success: rollData.success || null,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        clientTimestamp: rollData.timestamp || Date.now()
                    };
                    
                    await diceCollection.add(logEntry);
                    console.log('[DiceRoller] Roll logged to Firestore');
                    
                    // Send toast notification (only for non-secret rolls)
                    if (!logEntry.secret && window.RIFTToast?.send) {
                        const isSuccess = logEntry.critical === 'success' ? true : logEntry.critical === 'failure' ? false : null;
                        RIFTToast.diceRoll(logEntry.player, logEntry.total, logEntry.notation, isSuccess);
                    }
                    
                } catch (e) {
                    console.warn('[DiceRoller] Firestore log failed:', e);
                    // Don't throw - Firestore logging is optional
                }
            },
            
            showFeedItem(roll) {
                const feed = document.getElementById('diceFeed');
                if (!feed) return;
                
                // Don't show own rolls in feed
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                if (roll.player === userData.name) return;
                
                const item = document.createElement('div');
                let itemClass = 'dice-feed__item';
                if (roll.secret) itemClass += ' secret';
                if (roll.critical === 'success') itemClass += ' critical';
                if (roll.critical === 'failure') itemClass += ' fumble';
                item.className = itemClass;
                
                // Get dice theme color
                const themeColors = {
                    classic: '#ffffff',
                    blood: '#ff4655',
                    ice: '#00d4ff',
                    nature: '#4caf50',
                    royal: '#9c27b0',
                    gold: '#ffab00',
                    fire: '#ff5722',
                    ocean: '#00ffff',
                    toxic: '#39ff14',
                    nebula: '#ff6bcb',
                    sunset: '#ff7e5f',
                    cyber: '#00ffff',
                    midnight: '#b8c6db',
                    copper: '#cd7f32',
                    void: '#8b5cf6',
                    rainbow: '#ff6b6b'
                };
                const diceColor = themeColors[roll.diceTheme] || '#ffffff';
                
                const initial = roll.player.charAt(0).toUpperCase();
                const critIndicator = roll.critical === 'success' ? '!' : (roll.critical === 'failure' ? '💀' : '');
                
                item.innerHTML = `
                    <div class="dice-feed__avatar" style="background: ${roll.color}">${initial}</div>
                    <div class="dice-feed__info">
                        <div class="dice-feed__name" style="color: ${roll.color}">${roll.player}</div>
                        <div class="dice-feed__roll">${roll.notation} <span class="dice-feed__dice-color" style="background: ${diceColor}"></span></div>
                    </div>
                    <div class="dice-feed__result">${roll.secret ? '?' : roll.total}${critIndicator}</div>
                `;
                
                feed.insertBefore(item, feed.firstChild);
                
                // Trigger effects for critical rolls from other players
                if (roll.critical === 'success' || roll.critical === 'failure') {
                    const arena = document.getElementById('diceArena');
                    if (arena) {
                        arena.classList.add('shake');
                        this.spawnParticles(30);
                        this.showCritFlash(roll.critical);
                        setTimeout(() => arena.classList.remove('shake'), 500);
                    }
                }
                
                // Remove after 10s
                setTimeout(() => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateX(20px)';
                    setTimeout(() => item.remove(), 300);
                }, 10000);
                
                // Keep max 5 items
                while (feed.children.length > 5) {
                    feed.lastChild.remove();
                }
            },
            
            // ========================================
            // DICE VALUE LABELS
            // ========================================
            
            clearDiceLabels() {
                const container = document.getElementById('diceLabels');
                const pulseContainer = document.getElementById('dicePulses');
                if (container) container.innerHTML = '';
                if (pulseContainer) pulseContainer.innerHTML = '';
            },
            
            showDiceLabels(rolls, rawRolls = null) {
                this.clearDiceLabels();
                
                if (!this.box) return;
                
                const container = document.getElementById('diceLabels');
                const pulseContainer = document.getElementById('dicePulses');
                if (!container) return;
                
                // Clear pulse container
                if (pulseContainer) pulseContainer.innerHTML = '';
                
                // Get screen positions from the library
                const positions = this.box.getDiceScreenPositions();
                if (!positions || positions.length === 0) return;
                
                console.log('[DiceRoller] Dice positions:', positions);
                console.log('[DiceRoller] Rolls to display:', rolls, 'Raw:', rawRolls);
                
                // Use rawRolls if available (for d100 we need the individual dice values)
                const valuesToShow = rawRolls || rolls;
                
                // Create labels and pulses for each die
                for (let i = 0; i < Math.min(positions.length, valuesToShow.length); i++) {
                    const pos = positions[i];
                    const value = valuesToShow[i];
                    
                    if (pos.x < 0 || pos.y < 0) continue; // Skip if off-screen
                    
                    // Create pulse effect in separate container (UNDER dice)
                    // Multiple rings for better effect
                    if (pulseContainer) {
                        for (let r = 0; r < 4; r++) {
                            const pulse = document.createElement('div');
                            pulse.className = `dice-pulse dice-pulse--${pos.type}`;
                            pulse.style.left = `${pos.x}px`;
                            pulse.style.top = `${pos.y + 40}px`;
                            pulse.style.animationDelay = `${i * 0.08 + r * 0.1}s`;
                            pulseContainer.appendChild(pulse);
                        }
                    }
                    
                    // Create label
                    const label = document.createElement('div');
                    label.className = `dice-label dice-label--${pos.type}`;
                    
                    // Check for critical (nat 20 or nat 1 on d20)
                    if (pos.type === 'd20' && value === 20) {
                        label.classList.add('dice-label--crit-success');
                    } else if (pos.type === 'd20' && value === 1) {
                        label.classList.add('dice-label--crit-failure');
                    }
                    
                    // Format value for display
                    let displayValue = value;
                    if (pos.type === 'd100') {
                        // Tens die: 0, 10, 20... display as "00", "10", "20"...
                        displayValue = value === 0 ? '00' : value;
                    } else if (pos.type === 'd10') {
                        // Ones die: library returns 1-10, display 0-9 (10 becomes 0)
                        displayValue = value === 10 ? '0' : value;
                    }
                    
                    label.textContent = displayValue;
                    label.style.left = `${pos.x}px`;
                    label.style.top = `${pos.y}px`;
                    label.style.animationDelay = `${i * 0.1}s`;
                    
                    container.appendChild(label);
                }
            },
            
            // ========================================
            // PARTICLES
            // ========================================
            
            spawnParticles(count = 20) {
                const container = document.getElementById('particlesContainer');
                if (!container) return;
                
                const colors = ['#FF4655', '#FF6B6B', '#FFE66D', '#4ECDC4', '#45B7D1', '#DDA0DD'];
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'dice-particle';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 80 + Math.random() * 120;
                    
                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                    particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                    particle.style.width = particle.style.height = `${5 + Math.random() * 8}px`;
                    
                    container.appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }
            },
            
            // ========================================
            // UI
            // ========================================
            
            updateUI() {
                // Update button counts
                ['d4', 'd6', 'd8', 'd10', 'd12', 'd20', 'd100'].forEach(type => {
                    const countEl = document.getElementById(`count-${type}`);
                    const btn = document.querySelector(`.dice-btn[data-dice="${type}"]`);
                    const count = this.currentDice[type] || 0;
                    
                    if (countEl) countEl.textContent = count;
                    if (btn) {
                        const hadCount = btn.classList.contains('has-count');
                        btn.classList.toggle('has-count', count > 0);
                        
                        // Start/stop particles
                        if (count > 0 && !hadCount) {
                            this.startParticles(btn);
                        } else if (count === 0 && hadCount) {
                            this.stopParticles(btn);
                        }
                    }
                });
                
                // Update roll button
                const btn = document.getElementById('rollBtn');
                const hasInput = document.getElementById('notationInput').value.trim().length > 0;
                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                btn.disabled = !hasInput && !hasDice;
            },
            
            // Partikel-System
            particleIntervals: {},
            
            startParticles(btn) {
                const container = btn.querySelector('.dice-btn__particles');
                if (!container) return;
                
                const type = btn.dataset.dice;
                
                // Spawn particles mit variablem Timing
                const spawnLoop = () => {
                    if (!btn.classList.contains('has-count')) {
                        this.stopParticles(btn);
                        return;
                    }
                    this.spawnParticle(container);
                    
                    // Nächster Spawn in 250-500ms
                    const nextSpawn = 250 + Math.random() * 250;
                    this.particleIntervals[type] = setTimeout(spawnLoop, nextSpawn);
                };
                
                this.particleIntervals[type] = setTimeout(spawnLoop, 100);
                
                // Spawn first few immediately
                this.spawnParticle(container);
                setTimeout(() => this.spawnParticle(container), 80);
                setTimeout(() => this.spawnParticle(container), 180);
            },
            
            stopParticles(btn) {
                const type = btn.dataset.dice;
                if (this.particleIntervals[type]) {
                    clearTimeout(this.particleIntervals[type]);
                    delete this.particleIntervals[type];
                }
            },
            
            spawnParticle(container) {
                const particle = document.createElement('div');
                particle.className = 'dice-btn__particle';
                
                // Random position innerhalb des Containers (über dem Counter)
                const xPos = Math.random() * 35; // 0-35px von links im Container
                const size = 2 + Math.random() * 2.5; // 2-4.5px
                const duration = 1.8 + Math.random() * 1.2; // 1.8-3s
                const delay = Math.random() * 0.15;
                const drift = -10 + Math.random() * 20; // -10 bis +10px seitlich
                
                particle.style.cssText = `
                    left: ${xPos}px;
                    top: 0;
                    width: ${size}px;
                    height: ${size}px;
                    --drift: ${drift}px;
                    animation: particleFloat ${duration}s ease-out ${delay}s forwards;
                `;
                
                container.appendChild(particle);
                
                // Remove after animation
                setTimeout(() => particle.remove(), (duration + delay) * 1000 + 100);
            },
            
            // ========================================
            // HISTORY
            // ========================================
            
            addToHistory(roll) {
                this.history.unshift(roll);
                if (this.history.length > 50) this.history = this.history.slice(0, 50);
                this.saveHistory();
                this.renderHistory();
                this.updateStats();
            },
            
            renderHistory() {
                const list = document.getElementById('historyList');
                if (!list) return;
                
                if (this.history.length === 0) {
                    list.innerHTML = '<div class="dice-history__empty">Noch keine Würfe</div>';
                    return;
                }
                
                list.innerHTML = this.history.slice(0, 15).map(roll => {
                    const time = new Date(roll.timestamp);
                    const timeStr = time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    let critClass = '';
                    let critIndicator = '';
                    if (roll.critical === 'success') {
                        critClass = ' dice-history__item--crit';
                        critIndicator = '!';
                    } else if (roll.critical === 'failure') {
                        critClass = ' dice-history__item--fumble';
                        critIndicator = '💀';
                    } else if (roll.critical === true) {
                        // Legacy support
                        critClass = ' dice-history__item--crit';
                        critIndicator = '!';
                    }
                    const playerName = roll.player || 'Spieler';
                    const playerColor = roll.color || '#FF4655';
                    
                    return `
                        <div class="dice-history__item${critClass}" title="${playerName} • ${roll.notation} • ${timeStr}">
                            <div class="dice-history__player" style="color: ${playerColor}">${playerName}</div>
                            <div class="dice-history__value">${roll.total}${critIndicator}</div>
                            <div class="dice-history__notation">${roll.notation}</div>
                        </div>
                    `;
                }).join('');
            },
            
            // ========================================
            // PERSISTENCE
            // ========================================
            
            loadSettings() {
                // Sound
                this.soundEnabled = localStorage.getItem('rift_dice_sound') !== 'false';
                window.RIFT_DICE_SOUND = this.soundEnabled;
                document.getElementById('soundToggle')?.classList.toggle('active', this.soundEnabled);
                document.getElementById('soundToggle2')?.classList.toggle('active', this.soundEnabled);
            },
            
            saveHistory() {
                localStorage.setItem('rift_dice_history', JSON.stringify(this.history));
            },
            
            loadHistory() {
                try {
                    this.history = JSON.parse(localStorage.getItem('rift_dice_history') || '[]');
                } catch { this.history = []; }
                this.renderHistory();
                this.updateStats();
            },
            
            clearHistory() {
                this.history = [];
                this.saveHistory();
                this.renderHistory();
                this.updateStats();
                if (typeof showToast === 'function') showToast('Verlauf gelöscht', 'info');
            },
            
            statsPopupOpen: false,
            hotkeysPopupOpen: false,
            
            toggleStatsPopup() {
                this.statsPopupOpen = !this.statsPopupOpen;
                const popup = document.getElementById('statsPopup');
                const btn = document.getElementById('statsBtn');
                
                // Close other popups
                if (this.statsPopupOpen) {
                    this.closeAllPopups('stats');
                }
                
                if (this.statsPopupOpen) {
                    popup?.classList.add('open');
                    btn?.classList.add('active');
                    this.updateStats();
                } else {
                    popup?.classList.remove('open');
                    btn?.classList.remove('active');
                }
            },
            
            toggleHotkeysPopup() {
                this.hotkeysPopupOpen = !this.hotkeysPopupOpen;
                const popup = document.getElementById('hotkeysPopup');
                const btn = document.getElementById('hotkeysBtn');
                
                // Close other popups
                if (this.hotkeysPopupOpen) {
                    this.closeAllPopups('hotkeys');
                }
                
                if (this.hotkeysPopupOpen) {
                    popup?.classList.add('open');
                    btn?.classList.add('active');
                } else {
                    popup?.classList.remove('open');
                    btn?.classList.remove('active');
                }
            },
            
            closeAllPopups(except = null) {
                if (except !== 'stats') {
                    this.statsPopupOpen = false;
                    document.getElementById('statsPopup')?.classList.remove('open');
                    document.getElementById('statsBtn')?.classList.remove('active');
                }
                if (except !== 'hotkeys') {
                    this.hotkeysPopupOpen = false;
                    document.getElementById('hotkeysPopup')?.classList.remove('open');
                    document.getElementById('hotkeysBtn')?.classList.remove('active');
                }
                if (except !== 'settings') {
                    document.getElementById('settingsPopup')?.classList.remove('open');
                    document.getElementById('settingsBtn')?.classList.remove('active');
                }
            },
            
            updateStats() {
                const totalEl = document.getElementById('statTotal');
                const avgEl = document.getElementById('statAvg');
                const critsEl = document.getElementById('statCrits');
                const fumblesEl = document.getElementById('statFumbles');
                const maxEl = document.getElementById('statMax');
                const minEl = document.getElementById('statMin');
                
                if (!totalEl) return;
                
                totalEl.textContent = this.history.length;
                
                if (this.history.length === 0) {
                    avgEl.textContent = '-';
                    critsEl.textContent = '0';
                    fumblesEl.textContent = '0';
                    maxEl.textContent = '-';
                    minEl.textContent = '-';
                    return;
                }
                
                const totals = this.history.map(r => r.total);
                const avg = (totals.reduce((a, b) => a + b, 0) / totals.length).toFixed(1);
                const crits = this.history.filter(r => r.critical === 'success').length;
                const fumbles = this.history.filter(r => r.critical === 'failure').length;
                const max = Math.max(...totals);
                const min = Math.min(...totals);
                
                avgEl.textContent = avg;
                critsEl.textContent = crits;
                fumblesEl.textContent = fumbles;
                maxEl.textContent = max;
                minEl.textContent = min;
            },
            
            exportHistory() {
                if (this.history.length === 0) {
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Keine Würfe zum Exportieren');
                    }
                    return;
                }
                
                // Build text format
                const lines = ['RIFT Würfel-Protokoll', '=' .repeat(40), ''];
                
                const now = new Date();
                lines.push(`Exportiert: ${now.toLocaleDateString('de-DE')} ${now.toLocaleTimeString('de-DE')}`);
                lines.push(`Anzahl Würfe: ${this.history.length}`);
                lines.push('');
                lines.push('-'.repeat(40));
                lines.push('');
                
                this.history.forEach((roll, i) => {
                    const time = new Date(roll.timestamp).toLocaleTimeString('de-DE');
                    const critMarker = roll.critical === 'success' ? ' ⭐ KRITISCH!' : 
                                       roll.critical === 'failure' ? ' 💀 PATZER!' : '';
                    lines.push(`[${time}] ${roll.player}: ${roll.notation} = ${roll.total}${critMarker}`);
                });
                
                lines.push('');
                lines.push('-'.repeat(40));
                
                // Calculate stats
                const totals = this.history.map(r => r.total);
                const avg = (totals.reduce((a, b) => a + b, 0) / totals.length).toFixed(1);
                const max = Math.max(...totals);
                const min = Math.min(...totals);
                const crits = this.history.filter(r => r.critical === 'success').length;
                const fumbles = this.history.filter(r => r.critical === 'failure').length;
                
                lines.push('');
                lines.push('STATISTIK');
                lines.push(`Durchschnitt: ${avg}`);
                lines.push(`Maximum: ${max}`);
                lines.push(`Minimum: ${min}`);
                lines.push(`Kritische Erfolge: ${crits}`);
                lines.push(`Kritische Fehlschläge: ${fumbles}`);
                
                // Create download
                const text = lines.join('\n');
                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rift-wuerfel-${now.toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success('Verlauf exportiert');
                }
            }
        };
        
        // Global function for back button
        function goBackToSheet() {
            if (DiceRoller.returnUrl) {
                // Build URL with result parameters if we have a check result
                let url = DiceRoller.returnUrl;
                
                if (DiceRoller.lastCheckResult) {
                    const r = DiceRoller.lastCheckResult;
                    const params = new URLSearchParams();
                    params.set('result', r.result);
                    params.set('label', r.label);
                    params.set('success', r.success);
                    params.set('outcome', r.outcome);
                    if (r.critical) params.set('critical', 'true');
                    if (r.zweiteChance) {
                        params.set('zweiteChance', 'true');
                        params.set('diceIndex', r.diceIndex);
                    }
                    
                    // Append to URL
                    const separator = url.includes('?') ? '&' : '?';
                    url += separator + params.toString();
                }
                
                window.location.href = url;
            }
        }
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        initLayout();
        
        // Init after layout is ready
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                DiceRoller.init();
            });
        });
        
        // Update UI when notation input changes
        document.getElementById('notationInput')?.addEventListener('input', (e) => {
            // Parse as user types
            DiceRoller.parseDiceFromNotation(e.target.value);
        });
        
        // ========================================
        // DICE PREVIEW - 3D rotating dice in buttons
        // ========================================
        const DicePreview = {
            previews: [],
            animationId: null,
            
            init() {
                console.log('DicePreview init starting...');
                
                // Check if THREE is available
                if (typeof THREE === 'undefined') {
                    console.error('THREE.js not loaded!');
                    return;
                }
                
                const canvases = document.querySelectorAll('.dice-btn__canvas');
                console.log('Found canvases:', canvases.length);
                
                canvases.forEach((canvas, index) => {
                    const type = canvas.dataset.type;
                    console.log('Creating preview for:', type);
                    try {
                        this.createPreview(canvas, type);
                    } catch(e) {
                        console.error('Error creating preview for ' + type, e);
                    }
                });
                
                if (this.previews.length > 0) {
                    this.animate();
                    console.log('Animation started with', this.previews.length, 'previews');
                }
            },
            
            createPreview(canvas, type) {
                const size = 100;
                
                // Set canvas size
                canvas.width = size * 2;
                canvas.height = size * 2;
                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
                canvas.style.display = 'block';
                
                // Create renderer
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true, 
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                renderer.setSize(size * 2, size * 2);
                renderer.setPixelRatio(1);
                renderer.setClearColor(0x000000, 0);
                renderer.sortObjects = true;
                
                // Create scene
                const scene = new THREE.Scene();
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(28, 1, 0.1, 100);
                camera.position.set(0, 0, type === 'd100' ? 4.8 : 4.2);
                camera.lookAt(0, 0, 0);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 3);
                scene.add(directionalLight);
                
                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-1, -1, -2);
                scene.add(backLight);
                
                let mesh;
                let isD100 = type === 'd100';
                
                if (isD100) {
                    // D100: Two D10s side by side
                    mesh = this.createD100Group();
                    scene.add(mesh);
                } else {
                    // Normal dice
                    const geometry = this.createGeometry(type);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        shininess: 30,
                        shading: THREE.FlatShading,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
                    
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.renderOrder = 0;
                    
                    // Add gray edges - HELLER + depth fix
                    const edges = new THREE.EdgesGeometry(geometry, 1);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xaaaaaa,
                        depthTest: true
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    wireframe.renderOrder = 1;
                    mesh.add(wireframe);
                    
                    scene.add(mesh);
                    
                    // Random starting rotation
                    mesh.rotation.x = Math.random() * Math.PI * 2;
                    mesh.rotation.y = Math.random() * Math.PI * 2;
                    mesh.rotation.z = Math.random() * Math.PI;
                }
                
                // Store preview data
                this.previews.push({
                    renderer,
                    scene,
                    camera,
                    mesh,
                    type,
                    isD100,
                    rotationSpeed: {
                        x: 0.0005 + Math.random() * 0.0005,
                        y: 0.0008 + Math.random() * 0.0005,
                        z: 0.0003 + Math.random() * 0.0003
                    }
                });
                
                // Initial render
                renderer.render(scene, camera);
            },
            
            createGeometry(type) {
                switch(type) {
                    case 'd4':
                        return new THREE.TetrahedronGeometry(1.1);
                    case 'd6':
                        return new THREE.BoxGeometry(1.0, 1.0, 1.0);
                    case 'd8':
                        return new THREE.OctahedronGeometry(0.95);
                    case 'd10':
                        return this.createD10Geometry(0.85);
                    case 'd100':
                        return null; // Handled separately
                    case 'd12':
                        return new THREE.DodecahedronGeometry(0.95);
                    case 'd20':
                        return new THREE.IcosahedronGeometry(1.0);
                    default:
                        return new THREE.BoxGeometry(1.0, 1.0, 1.0);
                }
            },
            
            // Special handling for D100 (two D10s)
            createD100Group() {
                const group = new THREE.Group();
                
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    shininess: 30,
                    shading: THREE.FlatShading,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });
                
                // Left D10 (tens) - GRÖSSER
                const geom1 = this.createD10Geometry(0.7);
                const mesh1 = new THREE.Mesh(geom1, material);
                mesh1.position.x = -0.6;
                mesh1.renderOrder = 0;
                
                // Add edges - HELLER
                const edges1 = new THREE.EdgesGeometry(geom1, 1);
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: 0xaaaaaa,
                    depthTest: true
                });
                const lines1 = new THREE.LineSegments(edges1, lineMat);
                lines1.renderOrder = 1;
                mesh1.add(lines1);
                
                // Right D10 (ones) - GRÖSSER
                const geom2 = this.createD10Geometry(0.7);
                const mesh2 = new THREE.Mesh(geom2, material.clone());
                mesh2.position.x = 0.6;
                mesh2.renderOrder = 0;
                
                // Add edges - HELLER
                const edges2 = new THREE.EdgesGeometry(geom2, 1);
                const lines2 = new THREE.LineSegments(edges2, lineMat.clone());
                lines2.renderOrder = 1;
                mesh2.add(lines2);
                
                // Different starting rotations
                mesh1.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                mesh2.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                
                group.add(mesh1);
                group.add(mesh2);
                
                // Store references for individual rotation
                group.userData.dice = [mesh1, mesh2];
                
                return group;
            },
            
            // D10 - Pentagonal Bipyramid
            createD10Geometry(radius) {
                const geometry = new THREE.Geometry();
                const sides = 5;
                const h = radius * 1.3;
                
                // Top vertex (index 0)
                geometry.vertices.push(new THREE.Vector3(0, h, 0));
                
                // Middle ring (indices 1-5)
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    geometry.vertices.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }
                
                // Bottom vertex (index 6)
                geometry.vertices.push(new THREE.Vector3(0, -h, 0));
                
                // Top faces (counter-clockwise when viewed from outside)
                for (let i = 0; i < sides; i++) {
                    const next = (i + 1) % sides;
                    geometry.faces.push(new THREE.Face3(0, 1 + next, 1 + i));
                }
                
                // Bottom faces (counter-clockwise when viewed from outside)
                for (let i = 0; i < sides; i++) {
                    const next = (i + 1) % sides;
                    geometry.faces.push(new THREE.Face3(6, 1 + i, 1 + next));
                }
                
                geometry.computeFaceNormals();
                geometry.computeVertexNormals();
                
                return geometry;
            },
            
            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                this.previews.forEach(preview => {
                    if (preview.isD100 && preview.mesh.userData.dice) {
                        // D100: Rotate each die independently
                        preview.mesh.userData.dice.forEach((die, i) => {
                            const speed = i === 0 ? 1 : 1.3; // Slightly different speeds
                            die.rotation.x += preview.rotationSpeed.x * speed;
                            die.rotation.y += preview.rotationSpeed.y * speed;
                            die.rotation.z += preview.rotationSpeed.z * speed;
                        });
                    } else {
                        // Normal dice
                        preview.mesh.rotation.x += preview.rotationSpeed.x;
                        preview.mesh.rotation.y += preview.rotationSpeed.y;
                        preview.mesh.rotation.z += preview.rotationSpeed.z;
                    }
                    preview.renderer.render(preview.scene, preview.camera);
                });
            },
            
            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        };
        
        // Initialize after everything is loaded
        if (document.readyState === 'complete') {
            setTimeout(() => DicePreview.init(), 200);
        } else {
            window.addEventListener('load', () => {
                setTimeout(() => DicePreview.init(), 200);
            });
        }
    </script>
    <script src="assets/js/broadcast.js"></script>
</body>
</html>
