<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/icon_rift_r.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="view-transition" content="same-origin">
    <title>RIFT – Würfel</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/dock.css">
    <link rel="stylesheet" href="assets/css/hub.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    <link rel="stylesheet" href="assets/css/dice.css?v=11">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
        /* Back to Sheet Button */
        .back-to-sheet-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            margin-left: auto;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .back-to-sheet-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            color: var(--accent);
        }
        .back-to-sheet-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* Fix pointer-events for dice-result when visible */
        .dice-result.visible {
            pointer-events: auto !important;
        }
        
        /* Skill Check Display Styles */
        .dice-result__skill-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            display: none;
        }
        .dice-result__skill-label.visible {
            display: block;
        }
        .dice-result__target {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 4px;
            display: none;
        }
        .dice-result__target.visible {
            display: block;
        }
        .dice-result__outcome {
            font-family: 'Dharma Gothic', 'Inter', sans-serif;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 8px;
            padding: 6px 16px;
            border-radius: 4px;
            display: none;
        }
        .dice-result__outcome.visible {
            display: inline-block;
        }
        .dice-result__outcome.success {
            color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            text-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        .dice-result__outcome.failure {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        /* Color the total based on outcome */
        .dice-result.skill-success #resultTotal {
            color: #22c55e !important;
            text-shadow: 0 0 30px rgba(34, 197, 94, 0.6);
        }
        .dice-result.skill-failure #resultTotal {
            color: #ef4444 !important;
            text-shadow: 0 0 30px rgba(239, 68, 68, 0.6);
        }
        .dice-result__back-btn {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer !important;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999 !important;
            pointer-events: auto !important;
        }
        .dice-result__back-btn.visible {
            display: inline-flex;
        }
        .dice-result__back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-primary, #FF4655);
            color: #fff;
        }
        .dice-result__back-btn svg {
            width: 18px;
            height: 18px;
        }
    </style>

    <!-- Auth Guard: Hide until authenticated -->
    <style>
        body:not(.auth-ready) .app { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) .sheet-container { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) main { opacity: 0; pointer-events: none; }
        body.auth-ready .app { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready .sheet-container { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready main { opacity: 1; transition: opacity 0.15s ease; }
    </style>
    
    <!-- Theme Preview Styles (inline fallback) -->
    <style>
        .dice-theme-card__preview--fire {
            background: linear-gradient(135deg, #ff5722 0%, #ff9800 50%, #4a1c00 100%) !important;
        }
        .dice-theme-card__preview--ocean {
            background: linear-gradient(135deg, #00ffff 0%, #0099cc 50%, #001a33 100%) !important;
        }
        .dice-theme-card__preview--toxic {
            background: linear-gradient(135deg, #39ff14 0%, #00ff00 50%, #0a2a0a 100%) !important;
            box-shadow: inset 0 0 10px rgba(57, 255, 20, 0.5);
        }
        .dice-theme-card__preview--nebula {
            background: linear-gradient(135deg, #ff6bcb 0%, #c56cf0 50%, #1a0a2e 100%) !important;
            box-shadow: inset 0 0 10px rgba(197, 108, 240, 0.5);
        }
        .dice-theme-card__preview--sunset {
            background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 50%, #2a0a1a 100%) !important;
        }
        .dice-theme-card__preview--cyber {
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%) !important;
            animation: cyber-pulse 2s ease-in-out infinite alternate;
        }
        .dice-theme-card__preview--midnight {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%) !important;
        }
        .dice-theme-card__preview--copper {
            background: linear-gradient(135deg, #cd7f32 0%, #b87333 50%, #2a1a0a 100%) !important;
        }
        .dice-theme-card__preview--void {
            background: radial-gradient(circle at 30% 30%, #6d28d9 0%, #4c1d95 30%, #000000 100%) !important;
        }
        .dice-theme-card__preview--rainbow {
            background: linear-gradient(135deg, #ff6b6b 0%, #feca57 20%, #48dbfb 40%, #ff9ff3 60%, #54a0ff 80%, #5f27cd 100%) !important;
            animation: rainbow-shift 3s ease infinite;
            background-size: 200% 200%;
        }
        @keyframes cyber-pulse {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.3); }
        }
        @keyframes rainbow-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
    </style>
</head>
<body class="page-dice">
    <!-- Unified Layout Placeholders -->
    <div id="topnav-placeholder"></div>
    <div id="meganav-placeholder"></div>
    
    <div class="app">
        <main class="main main--hub">
            <div class="main__content">
                
                <!-- Announcement Banner -->
                <div id="announcementBanner" style="display: none;"></div>
                
                <div class="dice-page">
                    
                    <!-- 3D Arena -->
                    <div class="dice-arena empty" id="diceArena">
                        <!-- Pulse Effects Container (UNDER dice) -->
                        <div class="dice-pulses" id="dicePulses"></div>
                        
                        <!-- Empty State -->
                        <div class="dice-arena__empty">
                            <svg class="dice-arena__empty-icon" width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                                <circle cx="12" cy="12" r="2"/>
                            </svg>
                            <p>Wähle Würfel und ziehe zum Werfen</p>
                        </div>
                        
                        <!-- Swipe Hint -->
                        <div class="dice-arena__swipe-hint">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                            Wischen zum Würfeln
                        </div>
                        
                        <!-- Dice Value Labels (overlay) -->
                        <div class="dice-labels" id="diceLabels"></div>
                        
                        <!-- Result Display -->
                        <div class="dice-result" id="diceResult">
                            <div class="dice-result__player" id="resultPlayer"></div>
                            <div class="dice-result__skill-label" id="resultSkillLabel"></div>
                            <div class="dice-result__total" id="resultTotal">0</div>
                            <div class="dice-result__target" id="resultTarget"></div>
                            <div class="dice-result__outcome" id="resultOutcome"></div>
                            <div class="dice-result__breakdown" id="resultBreakdown"></div>
                            <button class="dice-result__back-btn" id="resultBackBtn" style="display: none;" onclick="goBackToSheet()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                    <polyline points="14 2 14 8 20 8"/>
                                    <line x1="16" y1="13" x2="8" y2="13"/>
                                    <line x1="16" y1="17" x2="8" y2="17"/>
                                    <polyline points="10 9 9 9 8 9"/>
                                </svg>
                                Zurück zum Charakterbogen
                            </button>
                        </div>
                        
                        <!-- Multiplayer Feed -->
                        <div class="dice-feed" id="diceFeed"></div>
                        
                        <!-- Particles -->
                        <div class="dice-particles" id="particlesContainer"></div>
                    </div>
                    
                    <!-- Controls -->
                    <div class="dice-controls">
                        
                        <!-- Toolbar -->
                        <div class="dice-toolbar">
                            <div class="dice-toolbar__left">
                                <!-- Presets -->
                                <div class="dice-presets-wrapper">
                                    <button class="dice-toggle" id="presetsBtn" onclick="DiceRoller.togglePresets()">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                                        </svg>
                                        Presets
                                    </button>
                                    
                                    <!-- Presets Popup -->
                                    <div class="dice-presets-popup" id="presetsPopup">
                                        <div class="dice-presets-popup__header">
                                            <span>Würfel-Presets</span>
                                            <button class="dice-presets-popup__close" onclick="DiceRoller.togglePresets()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                            </button>
                                        </div>
                                        <div class="dice-presets-popup__list" id="presetsList">
                                            <div class="dice-presets-popup__empty">Keine Presets gespeichert</div>
                                        </div>
                                        <div class="dice-presets-popup__hint">
                                            Tipp: Würfel auswählen, dann "Speichern"
                                        </div>
                                    </div>
                                </div>
                                
                                <button class="dice-toggle" id="savePresetBtn" onclick="DiceRoller.savePreset()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                        <polyline points="17 21 17 13 7 13 7 21"/>
                                        <polyline points="7 3 7 8 15 8"/>
                                    </svg>
                                    Speichern
                                </button>
                            </div>
                            <div class="dice-toolbar__right">
                                <!-- Sound Toggle -->
                                <button class="dice-toggle active" id="soundToggle" onclick="DiceRoller.toggleSound()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                    </svg>
                                    Sound
                                </button>
                                <!-- Secret Roll Toggle -->
                                <button class="dice-toggle" id="secretToggle" onclick="DiceRoller.toggleSecret()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                    </svg>
                                    Geheim
                                </button>
                            </div>
                        </div>
                        
                        <!-- Dice Orbit - Linksklick: hinzufügen, Rechtsklick: entfernen -->
                        <div class="dice-orbit">
                            <!-- Reset Button -->
                            <button class="dice-orbit__action dice-orbit__reset" onclick="DiceRoller.clearDice()" title="Zurücksetzen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                    <path d="M3 3v5h5"/>
                                </svg>
                            </button>
                            
                            <!-- Dice Buttons - Hero Cards -->
                            <div class="dice-orbit__dice">
                                <!-- D4 -->
                                <button class="dice-btn" data-dice="d4" onclick="DiceRoller.addDice('d4')" title="D4 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d4"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D4</span>
                                    <div class="dice-btn__badge"><span id="count-d4">0</span></div>
                                </button>
                                
                                <!-- D6 -->
                                <button class="dice-btn" data-dice="d6" onclick="DiceRoller.addDice('d6')" title="D6 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d6"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D6</span>
                                    <div class="dice-btn__badge"><span id="count-d6">0</span></div>
                                </button>
                                
                                <!-- D8 -->
                                <button class="dice-btn" data-dice="d8" onclick="DiceRoller.addDice('d8')" title="D8 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d8"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D8</span>
                                    <div class="dice-btn__badge"><span id="count-d8">0</span></div>
                                </button>
                                
                                <!-- D10 -->
                                <button class="dice-btn" data-dice="d10" onclick="DiceRoller.addDice('d10')" title="D10 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d10"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D10</span>
                                    <div class="dice-btn__badge"><span id="count-d10">0</span></div>
                                </button>
                                
                                <!-- D12 -->
                                <button class="dice-btn" data-dice="d12" onclick="DiceRoller.addDice('d12')" title="D12 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d12"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D12</span>
                                    <div class="dice-btn__badge"><span id="count-d12">0</span></div>
                                </button>
                                
                                <!-- D20 -->
                                <button class="dice-btn" data-dice="d20" onclick="DiceRoller.addDice('d20')" title="D20 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d20"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D20</span>
                                    <div class="dice-btn__badge"><span id="count-d20">0</span></div>
                                </button>
                                
                                <!-- D100 -->
                                <button class="dice-btn" data-dice="d100" onclick="DiceRoller.addDice('d100')" title="D100 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d100"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D100</span>
                                    <div class="dice-btn__badge"><span id="count-d100">0</span></div>
                                </button>
                                
                                <!-- Divider -->
                                <div class="dice-orbit__divider"></div>
                                
                                <!-- Settings Group: 2 rows -->
                                <div class="dice-orbit__settings-group">
                                    <!-- Row 1: Settings (full width) -->
                                    <div class="dice-settings-wrapper dice-settings-wrapper--full">
                                        <button class="dice-orbit__action dice-orbit__settings" id="settingsBtn" title="Einstellungen">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <circle cx="12" cy="12" r="3"/>
                                                <path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/>
                                            </svg>
                                        </button>
                                    </div>
                                    
                                    <!-- Row 2: Stats + Hotkeys -->
                                    <div class="dice-orbit__settings-row">
                                        <!-- Stats Button -->
                                        <div class="dice-settings-wrapper">
                                            <button class="dice-orbit__action dice-orbit__stats" id="statsBtn" title="Statistiken">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <line x1="18" y1="20" x2="18" y2="10"/>
                                                    <line x1="12" y1="20" x2="12" y2="4"/>
                                                    <line x1="6" y1="20" x2="6" y2="14"/>
                                                </svg>
                                            </button>
                                        </div>
                                        
                                        <!-- Hotkeys Button -->
                                        <div class="dice-settings-wrapper">
                                            <button class="dice-orbit__action dice-orbit__hotkeys" id="hotkeysBtn" title="Tastenkürzel">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <rect x="2" y="4" width="20" height="16" rx="2"/>
                                                    <path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M6 16h12"/>
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div class="dice-quick-row">
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w20')">1W20</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('2w6')">2W6</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w20+5')">1W20+5</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('4w6')">4W6</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w100')">1W100</button>
                            
                            <button class="dice-adv-btn" onclick="DiceRoller.rollAdvantage()" title="2W20, höchsten nehmen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
                                Vorteil
                            </button>
                            <button class="dice-adv-btn dice-adv-btn--dis" onclick="DiceRoller.rollDisadvantage()" title="2W20, niedrigsten nehmen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                                Nachteil
                            </button>
                            
                            <button class="dice-repeat-btn" id="repeatBtn" onclick="DiceRoller.repeatLast()" disabled title="Letzten Wurf wiederholen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Nochmal
                            </button>
                        </div>
                        
                        <!-- Roll Zone -->
                        <div class="dice-roll-zone">
                            <!-- Custom Notation Input (hidden by default) -->
                            <div class="dice-notation">
                                <input type="text" 
                                       class="dice-notation__input" 
                                       id="notationInput" 
                                       placeholder="z.B. 2W6+3, 1W20+1W4..."
                                       onkeydown="if(event.key==='Enter') DiceRoller.rollFromNotation()">
                                <button class="dice-notation__clear" onclick="document.getElementById('notationInput').value=''; DiceRoller.clearDice();">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                </button>
                            </div>
                            
                            <!-- Modifier -->
                            <div class="dice-modifier">
                                <button class="dice-modifier__btn dice-modifier__btn--lg" onclick="DiceRoller.adjustModifier(-20)">−20</button>
                                <button class="dice-modifier__btn dice-modifier__btn--md" onclick="DiceRoller.adjustModifier(-10)">−10</button>
                                <button class="dice-modifier__btn" onclick="DiceRoller.adjustModifier(-5)">−5</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-4)">−4</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-3)">−3</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-2)">−2</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-1)">−1</button>
                                <div class="dice-modifier__display" id="modifierDisplay">+0</div>
                                <input type="number" class="dice-modifier__value" id="modifierInput" value="0" min="-99" max="99">
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(1)">+1</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(2)">+2</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(3)">+3</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(4)">+4</button>
                                <button class="dice-modifier__btn" onclick="DiceRoller.adjustModifier(5)">+5</button>
                                <button class="dice-modifier__btn dice-modifier__btn--md" onclick="DiceRoller.adjustModifier(10)">+10</button>
                                <button class="dice-modifier__btn dice-modifier__btn--lg" onclick="DiceRoller.adjustModifier(20)">+20</button>
                            </div>
                            
                            <!-- Roll Button -->
                            <button class="dice-roll-btn" id="rollBtn" onclick="DiceRoller.roll()" disabled>
                                Würfeln!
                            </button>
                            
                            <!-- Quick Actions -->
                            <div class="dice-action-group">
                                <button class="dice-action-btn dice-action-btn--adv" onclick="DiceRoller.rollAdvantage()" title="Vorteil (2W20↑)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="18 15 12 9 6 15"/></svg>
                                </button>
                                <button class="dice-action-btn dice-action-btn--dis" onclick="DiceRoller.rollDisadvantage()" title="Nachteil (2W20↓)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="6 9 12 15 18 9"/></svg>
                                </button>
                            </div>
                            
                            <!-- Reset Button -->
                            <button class="dice-mobile-reset" onclick="DiceRoller.clearDice();">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                    <path d="M3 3v5h5"/>
                                </svg>
                            </button>
                            
                            <!-- Mobile Settings Button -->
                            <button class="dice-mobile-settings" onclick="document.getElementById('mobileSettingsPopup').classList.add('open'); document.getElementById('mobileSettingsOverlay').classList.add('open');">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                                </svg>
                                Einstellungen
                            </button>
                        </div>
                        
                        <!-- History -->
                        <div class="dice-history">
                            <div class="dice-history__header">
                                <span class="dice-history__title">Verlauf</span>
                                <div class="dice-history__actions">
                                    <button class="dice-history__export" onclick="DiceRoller.exportHistory()" title="Exportieren">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                            <polyline points="7 10 12 15 17 10"/>
                                            <line x1="12" y1="15" x2="12" y2="3"/>
                                        </svg>
                                    </button>
                                    <button class="dice-history__clear" onclick="DiceRoller.clearHistory()">Löschen</button>
                                </div>
                            </div>
                            
                            <div class="dice-history__list" id="historyList">
                                <div class="dice-history__empty">Noch keine Würfe</div>
                            </div>
                        </div>
                        
                    </div>
                    
                </div>
                
                <!-- Footer Placeholder -->
                <div id="footer-placeholder"></div>
                
            </div>
        </main>
        
        <!-- Probability Tooltip -->
        <div class="dice-probability-tooltip" id="probTooltip">
            <div class="dice-probability-tooltip__title"></div>
            <div class="dice-probability-tooltip__content"></div>
        </div>
    </div>
    
    <!-- Dock Placeholder -->
    <div id="dock-placeholder"></div>
    
    <!-- 3D Dice Libraries -->
    <script src="assets/libs/dice/teal.js"></script>
    <script src="assets/libs/dice/three.min.js"></script>
    <script src="assets/libs/dice/cannon.min.js"></script>
    <script src="assets/libs/dice/dice.js?v=11"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- RIFT Services -->
    <script src="assets/js/firebase-config.js"></script>
    <script>
        // Auth Guard - redirect to login if not authenticated
        (function() {
            function waitForAuth() {
                // Wait for Firebase SDK
                if (typeof firebase === 'undefined' || !firebase.auth) {
                    return setTimeout(waitForAuth, 50);
                }
                // Wait for Firebase app initialization
                try {
                    var auth = firebase.auth();
                    auth.onAuthStateChanged(function(user) {
                        if (!user) {
                            window.location.href = '/login';
                        } else {
                            document.body.classList.add('auth-ready');
                        }
                    });
                } catch(e) {
                    // Firebase not initialized yet, retry
                    setTimeout(waitForAuth, 50);
                }
            }
            waitForAuth();
        })();
    </script>

    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    
    <!-- Core Scripts -->
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/layout-unified.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    
    <script>
        // ========================================
        // RIFT DICE ROLLER - FULL FEATURED
        // ========================================
        
        // Global sound toggle for library
        window.RIFT_DICE_SOUND = true;
        
        const DiceRoller = {
            // State
            box: null,
            currentDice: {},
            history: [],
            lastRoll: null,
            isRolling: false,
            resultTimeout: null,
            
            // Skill Check State (Worlds Apart)
            skillCheckMode: false,
            skillCheckTarget: 0,
            skillCheckLabel: '',
            
            // Fokus Check State (Worlds Apart D20)
            fokusCheckMode: false,
            fokusCheckLabel: '',
            fokusCheckMod: 0,
            
            // Zweite Chance State (Worlds Apart D20)
            zweiteChanceMode: false,
            zweiteChanceDiceIndex: -1,
            
            // Last check result (for passing back to sheet)
            lastCheckResult: null,
            
            // Return URL (back to character sheet)
            returnUrl: null,
            
            // Settings
            soundEnabled: true,
            secretRoll: false,
            currentTheme: null,
            currentDiceColor: '#2a2a2a',
            currentLabelColor: 'auto', // 'auto' oder Hex-Farbe
            
            // Theme colors for 3D dice
            themeColors: {
                // ═══════════════════════════════════════
                // BASIC
                // ═══════════════════════════════════════
                classic: { primary: '#1a1a1a', secondary: '#f0f0f0', accent: '#2a2a2a' },
                blood: { 
                    primary: '#8b0000', secondary: '#ffd700', accent: '#8b0000',
                    gradient: { type: 'linear', colors: ['#ff4655', '#cc2233', '#8b0000'] }
                },
                ice: { 
                    primary: '#1a3a5c', secondary: '#a8d8ff', accent: '#1a3a5c',
                    gradient: { type: 'linear', colors: ['#00d4ff', '#0099cc', '#1565c0'] }
                },
                nature: { 
                    primary: '#2d4a1c', secondary: '#c8e6c9', accent: '#2d4a1c',
                    gradient: { type: 'linear', colors: ['#4caf50', '#388e3c', '#2e7d32'] }
                },
                royal: { 
                    primary: '#2a1a4a', secondary: '#e8d5ff', accent: '#2a1a4a',
                    gradient: { type: 'linear', colors: ['#9c27b0', '#7b1fa2', '#6a1b9a'] }
                },
                gold: { 
                    primary: '#3d2c0a', secondary: '#ffd700', accent: '#3d2c0a',
                    gradient: { type: 'linear', colors: ['#ffd700', '#ffb300', '#ff8f00'] }
                },
                
                // ═══════════════════════════════════════
                // ELEMENTAL
                // ═══════════════════════════════════════
                fire: { 
                    primary: '#4a1c00', secondary: '#ffcc00', accent: '#4a1c00',
                    gradient: { type: 'linear', colors: ['#ff5722', '#ff9800', '#e65100'] }
                },
                ocean: { 
                    primary: '#001a33', secondary: '#00ffff', accent: '#001a33',
                    gradient: { type: 'linear', colors: ['#00ffff', '#0099cc', '#006064'] }
                },
                toxic: { 
                    primary: '#0a2a0a', secondary: '#39ff14', accent: '#0a2a0a',
                    gradient: { type: 'radial', colors: ['#39ff14', '#00ff00', '#1b5e20'] }
                },
                lava: {
                    primary: '#1a0500', secondary: '#ff4500', accent: '#1a0500',
                    gradient: { type: 'radial', colors: ['#ffcc00', '#ff4500', '#bf360c'] }
                },
                frost: {
                    primary: '#0a1a2a', secondary: '#e0ffff', accent: '#0a1a2a',
                    gradient: { type: 'linear', colors: ['#ffffff', '#b3e5fc', '#4fc3f7'] }
                },
                storm: {
                    primary: '#0a0a1a', secondary: '#b0c4de', accent: '#0a0a1a',
                    gradient: { type: 'linear', colors: ['#ffd700', '#87ceeb', '#546e7a'] }
                },
                earth: {
                    primary: '#2d1f0a', secondary: '#d2691e', accent: '#2d1f0a',
                    gradient: { type: 'linear', colors: ['#d2691e', '#8b4513', '#5d4037'] }
                },
                shadow: {
                    primary: '#000000', secondary: '#2d2d2d', accent: '#000000',
                    gradient: { type: 'radial', colors: ['#4a4a4a', '#2d2d2d', '#1a1a1a'] }
                },
                
                // ═══════════════════════════════════════
                // GEMS & METALS
                // ═══════════════════════════════════════
                ruby: {
                    primary: '#4a0020', secondary: '#ff1744', accent: '#4a0020',
                    gradient: { type: 'radial', colors: ['#ff4081', '#e91e63', '#c2185b'] }
                },
                sapphire: {
                    primary: '#001040', secondary: '#2979ff', accent: '#001040',
                    gradient: { type: 'radial', colors: ['#82b1ff', '#2979ff', '#1565c0'] }
                },
                emerald: {
                    primary: '#003020', secondary: '#00e676', accent: '#003020',
                    gradient: { type: 'radial', colors: ['#69f0ae', '#00e676', '#00897b'] }
                },
                amethyst: {
                    primary: '#1a0030', secondary: '#e040fb', accent: '#1a0030',
                    gradient: { type: 'radial', colors: ['#ea80fc', '#e040fb', '#8e24aa'] }
                },
                diamond: {
                    primary: '#1a1a2e', secondary: '#ffffff', accent: '#1a1a2e',
                    gradient: { type: 'linear', colors: ['#ffffff', '#e8f4f8', '#90caf9'] }
                },
                opal: {
                    primary: '#1a1a2a', secondary: '#ff9ff3', accent: '#1a1a2a',
                    gradient: { type: 'linear', colors: ['#a8edea', '#fed6e3', '#f48fb1'] }
                },
                silver: {
                    primary: '#1a1a1a', secondary: '#c0c0c0', accent: '#1a1a1a',
                    gradient: { type: 'linear', colors: ['#e8e8e8', '#c0c0c0', '#78909c'] }
                },
                bronze: {
                    primary: '#1a1008', secondary: '#cd7f32', accent: '#1a1008',
                    gradient: { type: 'linear', colors: ['#daa06d', '#cd7f32', '#8d6e63'] }
                },
                platinum: {
                    primary: '#1a1a1a', secondary: '#e5e4e2', accent: '#1a1a1a',
                    gradient: { type: 'linear', colors: ['#f5f5f5', '#e5e4e2', '#90a4ae'] }
                },
                obsidian: {
                    primary: '#000000', secondary: '#1a1a2e', accent: '#000000',
                    gradient: { type: 'linear', colors: ['#37474f', '#263238', '#1c313a'] }
                },
                copper: { 
                    primary: '#2a1a0a', secondary: '#b87333', accent: '#2a1a0a',
                    gradient: { type: 'linear', colors: ['#cd7f32', '#b87333', '#6d4c41'] }
                },
                
                // ═══════════════════════════════════════
                // FANTASY
                // ═══════════════════════════════════════
                dragon: {
                    primary: '#2a0a00', secondary: '#ff4500', accent: '#2a0a00',
                    gradient: { type: 'linear', colors: ['#ffd700', '#ff4500', '#bf360c'] }
                },
                necro: {
                    primary: '#000a00', secondary: '#00ff00', accent: '#000a00',
                    gradient: { type: 'radial', colors: ['#00ff00', '#4caf50', '#2e7d32'] }
                },
                fey: {
                    primary: '#1a2a1a', secondary: '#98fb98', accent: '#1a2a1a',
                    gradient: { type: 'linear', colors: ['#ffd1f7', '#b8ffc8', '#81c784'] }
                },
                infernal: {
                    primary: '#0a0000', secondary: '#ff0000', accent: '#0a0000',
                    gradient: { type: 'radial', colors: ['#ff4444', '#cc0000', '#b71c1c'] }
                },
                celestial: {
                    primary: '#0a0a2a', secondary: '#fffacd', accent: '#0a0a2a',
                    gradient: { type: 'radial', colors: ['#fffacd', '#ffd700', '#ffa000'] }
                },
                eldritch: {
                    primary: '#0a0a1a', secondary: '#7b68ee', accent: '#0a0a1a',
                    gradient: { type: 'radial', colors: ['#9370db', '#7b68ee', '#5e35b1'] }
                },
                
                // ═══════════════════════════════════════
                // COSMIC & NATURE
                // ═══════════════════════════════════════
                nebula: { 
                    primary: '#1a0a2e', secondary: '#ff6bcb', accent: '#1a0a2e',
                    gradient: { type: 'radial', colors: ['#ff6bcb', '#c56cf0', '#7b1fa2'] }
                },
                void: { 
                    primary: '#000000', secondary: '#8b5cf6', accent: '#000000',
                    gradient: { type: 'radial', colors: ['#8b5cf6', '#6a1b9a', '#4a148c'] }
                },
                galaxy: {
                    primary: '#0a0a1a', secondary: '#e0b0ff', accent: '#0a0a1a',
                    gradient: { type: 'radial', colors: ['#fff8dc', '#dda0dd', '#7b1fa2'] }
                },
                aurora: {
                    primary: '#0a1a2a', secondary: '#00ff7f', accent: '#0a1a2a',
                    gradient: { type: 'linear', colors: ['#00ff7f', '#00ced1', '#00838f'] }
                },
                sunset: { 
                    primary: '#2a0a1a', secondary: '#ff7e5f', accent: '#2a0a1a',
                    gradient: { type: 'linear', colors: ['#ff7e5f', '#feb47b', '#e65100'] }
                },
                bloodmoon: {
                    primary: '#0a0000', secondary: '#8b0000', accent: '#0a0000',
                    gradient: { type: 'radial', colors: ['#dc143c', '#8b0000', '#b71c1c'] }
                },
                forest: {
                    primary: '#0a1a0a', secondary: '#228b22', accent: '#0a1a0a',
                    gradient: { type: 'linear', colors: ['#90ee90', '#228b22', '#1b5e20'] }
                },
                cherry: {
                    primary: '#2a0a1a', secondary: '#ffb7c5', accent: '#2a0a1a',
                    gradient: { type: 'linear', colors: ['#ffc0cb', '#ffb7c5', '#ec407a'] }
                },
                autumn: {
                    primary: '#1a0a00', secondary: '#ff8c00', accent: '#1a0a00',
                    gradient: { type: 'linear', colors: ['#ffd700', '#ff8c00', '#e65100'] }
                },
                
                // ═══════════════════════════════════════
                // TECH & RETRO
                // ═══════════════════════════════════════
                cyber: { 
                    primary: '#0a0a1a', secondary: '#00ffff', accent: '#0a0a1a',
                    gradient: { type: 'linear', colors: ['#00ffff', '#ff00ff', '#7b1fa2'] }
                },
                midnight: { 
                    primary: '#0a0a1a', secondary: '#b8c6db', accent: '#0a0a1a',
                    gradient: { type: 'linear', colors: ['#607d8b', '#455a64', '#37474f'] }
                },
                matrix: {
                    primary: '#000a00', secondary: '#00ff00', accent: '#000a00',
                    gradient: { type: 'linear', colors: ['#00ff00', '#4caf50', '#2e7d32'] }
                },
                hologram: {
                    primary: '#0a0a1a', secondary: '#00ffff', accent: '#0a0a1a',
                    gradient: { type: 'linear', colors: ['#00ffff', '#ff00ff', '#ffff00'] }
                },
                plasma: {
                    primary: '#1a001a', secondary: '#ff00ff', accent: '#1a001a',
                    gradient: { type: 'radial', colors: ['#ff00ff', '#8b008b', '#6a1b9a'] }
                },
                neon: {
                    primary: '#0a0a0a', secondary: '#ff1493', accent: '#0a0a0a',
                    gradient: { type: 'linear', colors: ['#ff1493', '#00ff00', '#00897b'] }
                },
                synthwave: {
                    primary: '#1a0a2a', secondary: '#ff6ec7', accent: '#1a0a2a',
                    gradient: { type: 'linear', colors: ['#00d9ff', '#ff6ec7', '#9c27b0'] }
                },
                steampunk: {
                    primary: '#1a1408', secondary: '#b87333', accent: '#1a1408',
                    gradient: { type: 'linear', colors: ['#d4af37', '#b87333', '#795548'] }
                },
                vaporwave: {
                    primary: '#1a1a2e', secondary: '#ff71ce', accent: '#1a1a2e',
                    gradient: { type: 'linear', colors: ['#01cdfe', '#ff71ce', '#9c27b0'] }
                },
                
                // ═══════════════════════════════════════
                // FUN & SPECIAL
                // ═══════════════════════════════════════
                rainbow: { 
                    primary: '#2a1a2a', secondary: '#ff6b6b', accent: '#2a1a2a',
                    gradient: { type: 'linear', colors: ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#9c27b0'] }
                },
                candy: {
                    primary: '#2a1a2a', secondary: '#ff69b4', accent: '#2a1a2a',
                    gradient: { type: 'linear', colors: ['#ff69b4', '#87ceeb', '#98fb98', '#f48fb1'] }
                },
                prism: {
                    primary: '#1a1a1a', secondary: '#ffffff', accent: '#1a1a1a',
                    gradient: { type: 'linear', colors: ['#ff0000', '#ff8000', '#ffff00', '#00ff00', '#0080ff', '#8000ff'] }
                },
                bubblegum: {
                    primary: '#2a0a2a', secondary: '#ff77aa', accent: '#2a0a2a',
                    gradient: { type: 'radial', colors: ['#ffaacc', '#ff77aa', '#ec407a'] }
                },
                coral: {
                    primary: '#2a1a1a', secondary: '#ff7f50', accent: '#2a1a1a',
                    gradient: { type: 'linear', colors: ['#ff9a8b', '#ff7f50', '#e64a19'] }
                },
                lavender: {
                    primary: '#1a1a2a', secondary: '#e6e6fa', accent: '#1a1a2a',
                    gradient: { type: 'linear', colors: ['#e6e6fa', '#d8bfd8', '#9575cd'] }
                },
                mint: {
                    primary: '#0a2a2a', secondary: '#98ff98', accent: '#0a2a2a',
                    gradient: { type: 'linear', colors: ['#98ff98', '#00fa9a', '#00897b'] }
                },
                peach: {
                    primary: '#2a1a1a', secondary: '#ffcba4', accent: '#2a1a1a',
                    gradient: { type: 'linear', colors: ['#ffe5b4', '#ffcba4', '#ff8a65'] }
                },
                
                // ═══════════════════════════════════════
                // TEXTURED - Mit Mustern
                // ═══════════════════════════════════════
                marbleWhite: {
                    primary: '#e0e0e0', secondary: '#ffffff', accent: '#9e9e9e',
                    gradient: { type: 'linear', colors: ['#ffffff', '#f5f5f5', '#e0e0e0'], texture: 'marble' }
                },
                marbleBlack: {
                    primary: '#1a1a1a', secondary: '#424242', accent: '#000000',
                    gradient: { type: 'linear', colors: ['#424242', '#303030', '#1a1a1a'], texture: 'marble' }
                },
                marbleGreen: {
                    primary: '#1b5e20', secondary: '#4caf50', accent: '#2e7d32',
                    gradient: { type: 'linear', colors: ['#81c784', '#4caf50', '#2e7d32'], texture: 'marble' }
                },
                marbleRose: {
                    primary: '#c2185b', secondary: '#f48fb1', accent: '#e91e63',
                    gradient: { type: 'linear', colors: ['#f8bbd9', '#f48fb1', '#ec407a'], texture: 'marble' }
                },
                woodOak: {
                    primary: '#5d4037', secondary: '#a1887f', accent: '#4e342e',
                    gradient: { type: 'linear', colors: ['#bcaaa4', '#8d6e63', '#5d4037'], texture: 'wood' }
                },
                woodCherry: {
                    primary: '#6d4c41', secondary: '#d7a86e', accent: '#4e342e',
                    gradient: { type: 'linear', colors: ['#d4a574', '#a1887f', '#6d4c41'], texture: 'wood' }
                },
                woodEbony: {
                    primary: '#1a1a1a', secondary: '#3e3e3e', accent: '#000000',
                    gradient: { type: 'linear', colors: ['#4a4a4a', '#2d2d2d', '#1a1a1a'], texture: 'wood' }
                },
                stoneGranite: {
                    primary: '#616161', secondary: '#9e9e9e', accent: '#424242',
                    gradient: { type: 'linear', colors: ['#bdbdbd', '#9e9e9e', '#757575'], texture: 'noise' }
                },
                stoneSandstone: {
                    primary: '#8d6e63', secondary: '#d7ccc8', accent: '#6d4c41',
                    gradient: { type: 'linear', colors: ['#efebe9', '#d7ccc8', '#a1887f'], texture: 'noise' }
                },
                glitterGold: {
                    primary: '#ff8f00', secondary: '#ffd700', accent: '#ff6f00',
                    gradient: { type: 'linear', colors: ['#ffd700', '#ffb300', '#ff8f00'], texture: 'sparkle' }
                },
                glitterSilver: {
                    primary: '#607d8b', secondary: '#eceff1', accent: '#455a64',
                    gradient: { type: 'linear', colors: ['#eceff1', '#cfd8dc', '#90a4ae'], texture: 'sparkle' }
                },
                glitterRose: {
                    primary: '#c2185b', secondary: '#f8bbd9', accent: '#ad1457',
                    gradient: { type: 'linear', colors: ['#fce4ec', '#f8bbd9', '#f48fb1'], texture: 'sparkle' }
                },
                glitterBlue: {
                    primary: '#1565c0', secondary: '#90caf9', accent: '#0d47a1',
                    gradient: { type: 'radial', colors: ['#90caf9', '#64b5f6', '#42a5f5'], texture: 'sparkle' }
                },
                glitterPurple: {
                    primary: '#7b1fa2', secondary: '#e1bee7', accent: '#6a1b9a',
                    gradient: { type: 'radial', colors: ['#e1bee7', '#ce93d8', '#ba68c8'], texture: 'sparkle' }
                },
                stripesRed: {
                    primary: '#c62828', secondary: '#ef5350', accent: '#b71c1c',
                    gradient: { type: 'linear', colors: ['#ef5350', '#e53935', '#c62828'], texture: 'stripes' }
                },
                stripesBlue: {
                    primary: '#1565c0', secondary: '#64b5f6', accent: '#0d47a1',
                    gradient: { type: 'linear', colors: ['#64b5f6', '#42a5f5', '#1e88e5'], texture: 'stripes' }
                },
                stripesGreen: {
                    primary: '#2e7d32', secondary: '#81c784', accent: '#1b5e20',
                    gradient: { type: 'linear', colors: ['#81c784', '#66bb6a', '#4caf50'], texture: 'stripes' }
                },
                polkaDots: {
                    primary: '#e91e63', secondary: '#fce4ec', accent: '#c2185b',
                    gradient: { type: 'linear', colors: ['#fce4ec', '#f8bbd9', '#f48fb1'], texture: 'dots' }
                },
                polkaBlack: {
                    primary: '#212121', secondary: '#616161', accent: '#000000',
                    gradient: { type: 'linear', colors: ['#616161', '#424242', '#212121'], texture: 'dots' }
                },
                checkerRed: {
                    primary: '#b71c1c', secondary: '#f44336', accent: '#c62828',
                    gradient: { type: 'linear', colors: ['#f44336', '#e53935', '#d32f2f'], texture: 'checker' }
                },
                checkerGreen: {
                    primary: '#1b5e20', secondary: '#4caf50', accent: '#2e7d32',
                    gradient: { type: 'linear', colors: ['#66bb6a', '#4caf50', '#43a047'], texture: 'checker' }
                },
                camoForest: {
                    primary: '#2e7d32', secondary: '#8bc34a', accent: '#1b5e20',
                    gradient: { type: 'linear', colors: ['#8bc34a', '#689f38', '#558b2f'], texture: 'camo' }
                },
                camoDesert: {
                    primary: '#8d6e63', secondary: '#d7ccc8', accent: '#6d4c41',
                    gradient: { type: 'linear', colors: ['#d7ccc8', '#bcaaa4', '#a1887f'], texture: 'camo' }
                },
                camoArctic: {
                    primary: '#78909c', secondary: '#eceff1', accent: '#546e7a',
                    gradient: { type: 'linear', colors: ['#eceff1', '#cfd8dc', '#b0bec5'], texture: 'camo' }
                },
                waveOcean: {
                    primary: '#0277bd', secondary: '#4fc3f7', accent: '#01579b',
                    gradient: { type: 'linear', colors: ['#4fc3f7', '#29b6f6', '#03a9f4'], texture: 'waves' }
                },
                waveAqua: {
                    primary: '#00838f', secondary: '#80deea', accent: '#006064',
                    gradient: { type: 'linear', colors: ['#80deea', '#4dd0e1', '#26c6da'], texture: 'waves' }
                },
                hexTech: {
                    primary: '#0d47a1', secondary: '#42a5f5', accent: '#1565c0',
                    gradient: { type: 'linear', colors: ['#42a5f5', '#2196f3', '#1e88e5'], texture: 'hexagon' }
                },
                hexGold: {
                    primary: '#ff6f00', secondary: '#ffc107', accent: '#e65100',
                    gradient: { type: 'linear', colors: ['#ffc107', '#ffb300', '#ffa000'], texture: 'hexagon' }
                },
                dragonScales: {
                    primary: '#1b5e20', secondary: '#4caf50', accent: '#2e7d32',
                    gradient: { type: 'linear', colors: ['#66bb6a', '#4caf50', '#388e3c'], texture: 'scales' }
                },
                fishScales: {
                    primary: '#00838f', secondary: '#4dd0e1', accent: '#006064',
                    gradient: { type: 'linear', colors: ['#4dd0e1', '#26c6da', '#00bcd4'], texture: 'scales' }
                },
                
                // ═══════════════════════════════════════
                // SPECIAL EFFECTS
                // ═══════════════════════════════════════
                starryNight: {
                    primary: '#1a237e', secondary: '#7986cb', accent: '#0d47a1',
                    gradient: { type: 'radial', colors: ['#3f51b5', '#303f9f', '#1a237e'], texture: 'starfield' }
                },
                galaxy2: {
                    primary: '#4a148c', secondary: '#ce93d8', accent: '#6a1b9a',
                    gradient: { type: 'radial', colors: ['#9c27b0', '#7b1fa2', '#4a148c'], texture: 'starfield' }
                },
                thunderstorm: {
                    primary: '#37474f', secondary: '#90a4ae', accent: '#263238',
                    gradient: { type: 'linear', colors: ['#78909c', '#546e7a', '#455a64'], texture: 'lightning' }
                },
                electricBlue: {
                    primary: '#0277bd', secondary: '#4fc3f7', accent: '#01579b',
                    gradient: { type: 'linear', colors: ['#29b6f6', '#03a9f4', '#0288d1'], texture: 'lightning' }
                },
                
                // ═══════════════════════════════════════
                // METALLIC VARIATIONS
                // ═══════════════════════════════════════
                chrome: {
                    primary: '#9e9e9e', secondary: '#fafafa', accent: '#616161',
                    gradient: { type: 'linear', colors: ['#fafafa', '#e0e0e0', '#9e9e9e', '#e0e0e0'] }
                },
                titanium: {
                    primary: '#546e7a', secondary: '#b0bec5', accent: '#37474f',
                    gradient: { type: 'linear', colors: ['#b0bec5', '#78909c', '#546e7a'] }
                },
                rosegold: {
                    primary: '#bf8970', secondary: '#f5d0c5', accent: '#a67563',
                    gradient: { type: 'linear', colors: ['#f5d0c5', '#e8b4a6', '#d4a594'] }
                },
                brushedSteel: {
                    primary: '#757575', secondary: '#e0e0e0', accent: '#424242',
                    gradient: { type: 'linear', colors: ['#e0e0e0', '#bdbdbd', '#9e9e9e'], texture: 'stripes' }
                },
                rust: {
                    primary: '#bf360c', secondary: '#e64a19', accent: '#8d3612',
                    gradient: { type: 'linear', colors: ['#e64a19', '#d84315', '#bf360c'], texture: 'noise' }
                },
                patina: {
                    primary: '#00695c', secondary: '#4db6ac', accent: '#004d40',
                    gradient: { type: 'linear', colors: ['#80cbc4', '#4db6ac', '#26a69a'], texture: 'noise' }
                },
                
                // ═══════════════════════════════════════
                // FOOD & DRINK
                // ═══════════════════════════════════════
                chocolate: {
                    primary: '#4e342e', secondary: '#8d6e63', accent: '#3e2723',
                    gradient: { type: 'linear', colors: ['#8d6e63', '#6d4c41', '#4e342e'] }
                },
                caramel: {
                    primary: '#e65100', secondary: '#ffb74d', accent: '#bf360c',
                    gradient: { type: 'linear', colors: ['#ffb74d', '#ffa726', '#ff9800'] }
                },
                strawberry: {
                    primary: '#c62828', secondary: '#ef9a9a', accent: '#b71c1c',
                    gradient: { type: 'linear', colors: ['#ef9a9a', '#ef5350', '#e53935'] }
                },
                blueberry: {
                    primary: '#283593', secondary: '#7986cb', accent: '#1a237e',
                    gradient: { type: 'linear', colors: ['#9fa8da', '#7986cb', '#5c6bc0'] }
                },
                grape: {
                    primary: '#4a148c', secondary: '#ab47bc', accent: '#38006b',
                    gradient: { type: 'linear', colors: ['#ce93d8', '#ab47bc', '#8e24aa'] }
                },
                lemon: {
                    primary: '#f9a825', secondary: '#fff59d', accent: '#f57f17',
                    gradient: { type: 'linear', colors: ['#fff59d', '#ffee58', '#ffeb3b'] }
                },
                lime: {
                    primary: '#689f38', secondary: '#c5e1a5', accent: '#558b2f',
                    gradient: { type: 'linear', colors: ['#c5e1a5', '#aed581', '#9ccc65'] }
                },
                orange2: {
                    primary: '#e65100', secondary: '#ffb74d', accent: '#bf360c',
                    gradient: { type: 'linear', colors: ['#ffb74d', '#ffa726', '#ff9800'] }
                },
                
                // ═══════════════════════════════════════
                // SEASONAL
                // ═══════════════════════════════════════
                springBlossom: {
                    primary: '#ec407a', secondary: '#f8bbd9', accent: '#d81b60',
                    gradient: { type: 'linear', colors: ['#f8bbd9', '#f48fb1', '#f06292'], texture: 'sparkle' }
                },
                summerSun: {
                    primary: '#ff8f00', secondary: '#ffeb3b', accent: '#ff6f00',
                    gradient: { type: 'radial', colors: ['#ffeb3b', '#ffc107', '#ff9800'] }
                },
                autumnLeaves: {
                    primary: '#bf360c', secondary: '#ff8a65', accent: '#8d3612',
                    gradient: { type: 'linear', colors: ['#ff8a65', '#ff7043', '#f4511e'] }
                },
                winterFrost: {
                    primary: '#b3e5fc', secondary: '#ffffff', accent: '#81d4fa',
                    gradient: { type: 'linear', colors: ['#ffffff', '#e1f5fe', '#b3e5fc'], texture: 'sparkle' }
                },
                christmas: {
                    primary: '#1b5e20', secondary: '#c62828', accent: '#2e7d32',
                    gradient: { type: 'linear', colors: ['#c62828', '#2e7d32', '#c62828'] }
                },
                halloween: {
                    primary: '#e65100', secondary: '#1a1a1a', accent: '#bf360c',
                    gradient: { type: 'linear', colors: ['#ff9800', '#e65100', '#1a1a1a'] }
                },
                valentine: {
                    primary: '#c2185b', secondary: '#f8bbd9', accent: '#ad1457',
                    gradient: { type: 'radial', colors: ['#f8bbd9', '#f48fb1', '#ec407a'], texture: 'sparkle' }
                },
                
                // ═══════════════════════════════════════
                // GAMING SPECIALS
                // ═══════════════════════════════════════
                critSuccess: {
                    primary: '#ffd700', secondary: '#ffeb3b', accent: '#ffc107',
                    gradient: { type: 'radial', colors: ['#ffeb3b', '#ffc107', '#ff9800'], texture: 'sparkle' }
                },
                critFail: {
                    primary: '#d32f2f', secondary: '#212121', accent: '#b71c1c',
                    gradient: { type: 'radial', colors: ['#f44336', '#b71c1c', '#212121'] }
                },
                lucky: {
                    primary: '#388e3c', secondary: '#81c784', accent: '#2e7d32',
                    gradient: { type: 'radial', colors: ['#a5d6a7', '#81c784', '#4caf50'], texture: 'sparkle' }
                },
                cursed: {
                    primary: '#4a148c', secondary: '#7b1fa2', accent: '#38006b',
                    gradient: { type: 'radial', colors: ['#7b1fa2', '#6a1b9a', '#4a148c'], texture: 'noise' }
                },
                blessed: {
                    primary: '#ffc107', secondary: '#fff9c4', accent: '#ffb300',
                    gradient: { type: 'radial', colors: ['#fff9c4', '#fff59d', '#ffee58'], texture: 'sparkle' }
                },
                ethereal: {
                    primary: '#b2ebf2', secondary: '#e0f7fa', accent: '#80deea',
                    gradient: { type: 'radial', colors: ['#e0f7fa', '#b2ebf2', '#80deea'] }
                },
                
                // ═══════════════════════════════════════
                // DARK & MOODY
                // ═══════════════════════════════════════
                charcoal: {
                    primary: '#263238', secondary: '#546e7a', accent: '#1c252a',
                    gradient: { type: 'linear', colors: ['#546e7a', '#37474f', '#263238'] }
                },
                slate: {
                    primary: '#455a64', secondary: '#78909c', accent: '#37474f',
                    gradient: { type: 'linear', colors: ['#90a4ae', '#78909c', '#607d8b'] }
                },
                graphite: {
                    primary: '#424242', secondary: '#757575', accent: '#212121',
                    gradient: { type: 'linear', colors: ['#757575', '#616161', '#424242'], texture: 'noise' }
                },
                carbon: {
                    primary: '#1a1a1a', secondary: '#424242', accent: '#000000',
                    gradient: { type: 'linear', colors: ['#424242', '#303030', '#1a1a1a'], texture: 'hexagon' }
                },
                onyx: {
                    primary: '#0a0a0a', secondary: '#2d2d2d', accent: '#000000',
                    gradient: { type: 'radial', colors: ['#3a3a3a', '#1a1a1a', '#0a0a0a'] }
                },
                
                // ═══════════════════════════════════════
                // PASTEL & SOFT
                // ═══════════════════════════════════════
                pastelPink: {
                    primary: '#f48fb1', secondary: '#fce4ec', accent: '#ec407a',
                    gradient: { type: 'linear', colors: ['#fce4ec', '#f8bbd9', '#f48fb1'] }
                },
                pastelBlue: {
                    primary: '#81d4fa', secondary: '#e1f5fe', accent: '#4fc3f7',
                    gradient: { type: 'linear', colors: ['#e1f5fe', '#b3e5fc', '#81d4fa'] }
                },
                pastelGreen: {
                    primary: '#a5d6a7', secondary: '#e8f5e9', accent: '#81c784',
                    gradient: { type: 'linear', colors: ['#e8f5e9', '#c8e6c9', '#a5d6a7'] }
                },
                pastelYellow: {
                    primary: '#fff59d', secondary: '#fffde7', accent: '#ffee58',
                    gradient: { type: 'linear', colors: ['#fffde7', '#fff9c4', '#fff59d'] }
                },
                pastelPurple: {
                    primary: '#ce93d8', secondary: '#f3e5f5', accent: '#ba68c8',
                    gradient: { type: 'linear', colors: ['#f3e5f5', '#e1bee7', '#ce93d8'] }
                },
                pastelRainbow: {
                    primary: '#f8bbd9', secondary: '#b2ebf2', accent: '#c8e6c9',
                    gradient: { type: 'linear', colors: ['#ffcdd2', '#fff9c4', '#c8e6c9', '#b3e5fc', '#e1bee7'] }
                },
                
                // ═══════════════════════════════════════
                // NATURE EXTENDED
                // ═══════════════════════════════════════
                deepSea: {
                    primary: '#01579b', secondary: '#0277bd', accent: '#014377',
                    gradient: { type: 'linear', colors: ['#0288d1', '#0277bd', '#01579b'] }
                },
                coralReef: {
                    primary: '#e65100', secondary: '#ff8a65', accent: '#bf360c',
                    gradient: { type: 'linear', colors: ['#ffab91', '#ff8a65', '#ff7043'] }
                },
                jungle: {
                    primary: '#1b5e20', secondary: '#66bb6a', accent: '#2e7d32',
                    gradient: { type: 'linear', colors: ['#81c784', '#66bb6a', '#4caf50'], texture: 'noise' }
                },
                desert: {
                    primary: '#bf8040', secondary: '#f5deb3', accent: '#a67c52',
                    gradient: { type: 'linear', colors: ['#f5deb3', '#deb887', '#d2b48c'], texture: 'noise' }
                },
                volcanic: {
                    primary: '#bf360c', secondary: '#ff5722', accent: '#8d3612',
                    gradient: { type: 'radial', colors: ['#ff9800', '#ff5722', '#bf360c'], texture: 'noise' }
                },
                arctic: {
                    primary: '#b3e5fc', secondary: '#e1f5fe', accent: '#81d4fa',
                    gradient: { type: 'linear', colors: ['#e1f5fe', '#b3e5fc', '#81d4fa'] }
                },
                tundra: {
                    primary: '#78909c', secondary: '#cfd8dc', accent: '#607d8b',
                    gradient: { type: 'linear', colors: ['#cfd8dc', '#b0bec5', '#90a4ae'], texture: 'noise' }
                },
                swamp: {
                    primary: '#33691e', secondary: '#7cb342', accent: '#2e5016',
                    gradient: { type: 'linear', colors: ['#8bc34a', '#7cb342', '#689f38'], texture: 'noise' }
                }
            },
            
            // Firebase
            roomRef: null,
            diceRef: null,
            
            // ========================================
            // INITIALIZATION
            // ========================================
            
            init() {
                console.log('[DiceRoller] Initializing...');
                
                const container = document.getElementById('diceArena');
                if (!container) {
                    console.error('[DiceRoller] Container not found');
                    return;
                }
                
                // Wait for container to have dimensions
                if (container.clientWidth === 0 || container.clientHeight === 0) {
                    setTimeout(() => this.init(), 200);
                    return;
                }
                
                // Initialize 3D Dice
                if (typeof DICE !== 'undefined') {
                    try {
                        this.box = new DICE.dice_box(container);
                        this.initSwipe(container);
                        console.log('[DiceRoller] 3D Dice initialized');
                    } catch (e) {
                        console.error('[DiceRoller] 3D init failed:', e);
                    }
                }
                
                // Load settings
                this.loadSettings();
                this.loadHistory();
                this.initThemes();
                this.initSettings();
                this.initRightClick();
                this.initMultiplayer();
                this.initDragDrop();
                this.initKeyboard();
                this.initShakeToRoll();
                this.initProbabilityTooltips();
                this.updateUI();
                this.updateModifierDisplay(0);
                
                // Check for URL parameters (Auto-Roll from Charakterbogen)
                this.handleUrlParams();
            },
            
            // ========================================
            // URL PARAMETER HANDLING (Auto-Roll)
            // ========================================
            
            handleUrlParams() {
                const params = new URLSearchParams(window.location.search);
                
                // Check for return URL (back to character sheet)
                const returnUrl = params.get('return');
                if (returnUrl) {
                    this.returnUrl = decodeURIComponent(returnUrl);
                    const backBtn = document.getElementById('backToSheetBtn');
                    const resultBackBtn = document.getElementById('resultBackBtn');
                    if (backBtn) {
                        backBtn.style.display = 'inline-flex';
                    }
                    if (resultBackBtn) {
                        resultBackBtn.style.display = 'inline-flex';
                    }
                }
                
                // Check for auto-roll parameters
                const diceType = params.get('dice'); // e.g., "d20" or "d100"
                const modifier = parseInt(params.get('mod')) || 0;
                const label = params.get('label') ? decodeURIComponent(params.get('label')) : '';
                const autoRoll = params.get('roll') === '1';
                const checkType = params.get('check'); // 'fokus' for D20 fokus checks, 'zweitechance' for second chance
                const diceIndex = params.get('diceIndex'); // For Zweite Chance
                
                // Valid dice types
                const validDice = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20', 'd100'];
                
                if (diceType && autoRoll && validDice.includes(diceType)) {
                    console.log('[DiceRoller] Auto-roll from URL:', { diceType, modifier, label, checkType });
                    
                    // Reset all check modes
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                    this.zweiteChanceMode = false;
                    this.zweiteChanceDiceIndex = -1;
                    
                    // Check if this is a Zweite Chance check (D20 with check=zweitechance)
                    if (diceType === 'd20' && checkType === 'zweitechance') {
                        this.zweiteChanceMode = true;
                        this.zweiteChanceDiceIndex = parseInt(diceIndex) || 0;
                        console.log('[DiceRoller] Zweite Chance Mode:', { diceIndex: this.zweiteChanceDiceIndex });
                    }
                    // Check if this is a Fokus check (D20 with check=fokus)
                    else if (diceType === 'd20' && checkType === 'fokus' && label) {
                        this.fokusCheckMode = true;
                        this.fokusCheckLabel = label;
                        this.fokusCheckMod = modifier;
                        console.log('[DiceRoller] Fokus Check Mode:', { label, mod: modifier });
                    }
                    // Check if this is a Worlds Apart skill check (d100 with label)
                    else if (diceType === 'd100' && label) {
                        this.skillCheckMode = true;
                        this.skillCheckTarget = modifier; // For skill checks, mod is the target number
                        this.skillCheckLabel = label;
                        console.log('[DiceRoller] Skill Check Mode:', { target: modifier, label });
                    }
                    
                    // Clear current dice and set the requested one
                    this.currentDice = {};
                    this.currentDice[diceType] = 1;
                    
                    // Set modifier
                    if (this.skillCheckMode) {
                        // For D100 skill checks, mod is the target, not added to roll
                        document.getElementById('modifierInput').value = 0;
                        this.updateModifierDisplay(0);
                    } else {
                        // For fokus checks and normal rolls, use modifier
                        document.getElementById('modifierInput').value = modifier;
                        this.updateModifierDisplay(modifier);
                    }
                    
                    // Update UI
                    this.updateUI();
                    
                    // Show label as toast
                    if (label && window.RIFT?.ui?.Toast) {
                        if (this.skillCheckMode) {
                            RIFT.ui.Toast.info(`${label} – Zielwert: ${modifier}`);
                        } else if (this.fokusCheckMode) {
                            RIFT.ui.Toast.info(`${label} – W20${modifier >= 0 ? '+' : ''}${modifier}`);
                        } else {
                            RIFT.ui.Toast.info(`${label}: W${diceType.replace('d', '')} ${modifier >= 0 ? '+' : ''}${modifier}`);
                        }
                    }
                    
                    // Auto-roll after delay (wait for 3D box to be ready)
                    setTimeout(() => {
                        console.log('[DiceRoller] Auto-rolling now, box ready:', !!this.box);
                        this.roll();
                    }, 800);
                    
                    // Clean URL (remove params without reload)
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
            },
            
            // ========================================
            // KEYBOARD SHORTCUTS
            // ========================================
            
            initKeyboard() {
                document.addEventListener('keydown', (e) => {
                    // Ignoriere wenn in Input-Feld
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    const key = e.key.toLowerCase();
                    
                    // Enter = Würfeln
                    if (e.key === 'Enter' && !this.isRolling) {
                        e.preventDefault();
                        this.roll();
                        return;
                    }
                    
                    // Space = Würfeln (alternativ)
                    if (e.key === ' ' && !this.isRolling) {
                        e.preventDefault();
                        this.roll();
                        return;
                    }
                    
                    // 1-7 = Würfel hinzufügen
                    const diceMap = {
                        '1': 'd4',
                        '2': 'd6',
                        '3': 'd8',
                        '4': 'd10',
                        '5': 'd12',
                        '6': 'd20',
                        '7': 'd100'
                    };
                    
                    if (diceMap[key]) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.removeDice(diceMap[key]);
                        } else {
                            this.addDice(diceMap[key]);
                        }
                        return;
                    }
                    
                    // R = Repeat
                    if (key === 'r' && this.lastRoll) {
                        e.preventDefault();
                        this.repeatLast();
                        return;
                    }
                    
                    // Backspace/Delete/Escape = Reset
                    if (e.key === 'Backspace' || e.key === 'Delete' || e.key === 'Escape') {
                        e.preventDefault();
                        this.clearDice();
                        return;
                    }
                    
                    // +/= = Modifier erhöhen
                    if (key === '+' || key === '=') {
                        e.preventDefault();
                        this.adjustModifier(e.shiftKey ? 5 : 1);
                        return;
                    }
                    
                    // - = Modifier verringern
                    if (key === '-') {
                        e.preventDefault();
                        this.adjustModifier(e.shiftKey ? -5 : -1);
                        return;
                    }
                    
                    // A = Advantage
                    if (key === 'a' && !e.ctrlKey) {
                        e.preventDefault();
                        this.rollAdvantage();
                        return;
                    }
                    
                    // D = Disadvantage
                    if (key === 'd' && !e.ctrlKey) {
                        e.preventDefault();
                        this.rollDisadvantage();
                        return;
                    }
                });
            },
            
            // ========================================
            // SHAKE TO ROLL (Mobile)
            // ========================================
            
            shakeThreshold: 15,
            lastShakeTime: 0,
            
            initShakeToRoll() {
                // Check if DeviceMotion is available
                if (!('DeviceMotionEvent' in window)) {
                    console.log('[DiceRoller] DeviceMotion not available');
                    return;
                }
                
                // Request permission on iOS 13+
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    // Will be triggered on first touch
                    document.body.addEventListener('touchstart', () => {
                        DeviceMotionEvent.requestPermission()
                            .then(response => {
                                if (response === 'granted') {
                                    this.bindShakeListener();
                                }
                            })
                            .catch(console.error);
                    }, { once: true });
                } else {
                    this.bindShakeListener();
                }
            },
            
            bindShakeListener() {
                let lastX = null, lastY = null, lastZ = null;
                
                window.addEventListener('devicemotion', (e) => {
                    const acc = e.accelerationIncludingGravity;
                    if (!acc) return;
                    
                    if (lastX !== null) {
                        const deltaX = Math.abs(acc.x - lastX);
                        const deltaY = Math.abs(acc.y - lastY);
                        const deltaZ = Math.abs(acc.z - lastZ);
                        
                        const totalDelta = deltaX + deltaY + deltaZ;
                        
                        if (totalDelta > this.shakeThreshold) {
                            const now = Date.now();
                            // Debounce: mindestens 1 Sekunde zwischen Shakes
                            if (now - this.lastShakeTime > 1000 && !this.isRolling) {
                                this.lastShakeTime = now;
                                
                                // Check if dice are selected
                                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                                if (hasDice) {
                                    console.log('[DiceRoller] Shake detected!');
                                    this.roll();
                                }
                            }
                        }
                    }
                    
                    lastX = acc.x;
                    lastY = acc.y;
                    lastZ = acc.z;
                });
                
                console.log('[DiceRoller] Shake-to-Roll enabled');
            },
            
            // ========================================
            // PROBABILITY TOOLTIPS
            // ========================================
            
            initProbabilityTooltips() {
                const buttons = document.querySelectorAll('.dice-btn');
                const tooltip = document.getElementById('probTooltip');
                
                if (!tooltip) return;
                
                // Add info button to each dice card
                buttons.forEach(btn => {
                    // Create info button
                    const infoBtn = document.createElement('button');
                    infoBtn.className = 'dice-btn__info';
                    infoBtn.innerHTML = '?';
                    infoBtn.type = 'button';
                    
                    // Prevent click from propagating to dice button
                    infoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                    });
                    
                    // Show tooltip on hover
                    infoBtn.addEventListener('mouseenter', (e) => {
                        e.stopPropagation();
                        const diceType = btn.dataset.dice;
                        if (diceType) {
                            this.showProbabilityTooltip(diceType, infoBtn);
                        }
                    });
                    
                    infoBtn.addEventListener('mouseleave', (e) => {
                        e.stopPropagation();
                        this.hideProbabilityTooltip();
                    });
                    
                    btn.appendChild(infoBtn);
                });
            },
            
            showProbabilityTooltip(diceType, element) {
                const tooltip = document.getElementById('probTooltip');
                if (!tooltip) return;
                
                const titleEl = tooltip.querySelector('.dice-probability-tooltip__title');
                const contentEl = tooltip.querySelector('.dice-probability-tooltip__content');
                
                const sides = parseInt(diceType.replace('d', ''));
                const avg = ((sides + 1) / 2).toFixed(1);
                const probEach = (100 / sides).toFixed(1);
                
                titleEl.textContent = diceType.toUpperCase();
                
                let html = `<div class="prob-row"><span>Durchschnitt:</span><span>${avg}</span></div>`;
                html += `<div class="prob-row"><span>Pro Seite:</span><span>${probEach}%</span></div>`;
                
                // Special probabilities - D&D 5e optimiert
                if (diceType === 'd20') {
                    html += `<div class="prob-section">Kritisch</div>`;
                    html += `<div class="prob-row prob-row--crit"><span>Nat 20:</span><span>5%</span></div>`;
                    html += `<div class="prob-row prob-row--fumble"><span>Nat 1:</span><span>5%</span></div>`;
                    html += `<div class="prob-section">DC Erfolg</div>`;
                    html += `<div class="prob-row"><span>DC 5:</span><span>80%</span></div>`;
                    html += `<div class="prob-row"><span>DC 10:</span><span>55%</span></div>`;
                    html += `<div class="prob-row"><span>DC 15:</span><span>30%</span></div>`;
                    html += `<div class="prob-row"><span>DC 20:</span><span>5%</span></div>`;
                    html += `<div class="prob-section">Mit Vorteil</div>`;
                    html += `<div class="prob-row prob-row--adv"><span>Nat 20:</span><span>9.75%</span></div>`;
                    html += `<div class="prob-row prob-row--adv"><span>DC 10:</span><span>~80%</span></div>`;
                    html += `<div class="prob-row prob-row--adv"><span>DC 15:</span><span>~51%</span></div>`;
                } else if (diceType === 'd100') {
                    html += `<div class="prob-section">Schwellen</div>`;
                    html += `<div class="prob-row"><span>≤25:</span><span>25%</span></div>`;
                    html += `<div class="prob-row"><span>≤50:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>≤75:</span><span>75%</span></div>`;
                    html += `<div class="prob-row"><span>≤95:</span><span>95%</span></div>`;
                    html += `<div class="prob-hint">Wild Magic, Zufallstabellen</div>`;
                } else if (diceType === 'd12') {
                    html += `<div class="prob-row"><span>≥7:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (12):</span><span>8.3%</span></div>`;
                    html += `<div class="prob-hint">Greataxe, Barbarian</div>`;
                } else if (diceType === 'd10') {
                    html += `<div class="prob-row"><span>≥6:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (10):</span><span>10%</span></div>`;
                    html += `<div class="prob-hint">Glaive, Halberd, Firebolt</div>`;
                } else if (diceType === 'd8') {
                    html += `<div class="prob-row"><span>≥5:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (8):</span><span>12.5%</span></div>`;
                    html += `<div class="prob-hint">Longsword, Rapier, Cure Wounds</div>`;
                } else if (diceType === 'd6') {
                    html += `<div class="prob-row"><span>≥4:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (6):</span><span>16.7%</span></div>`;
                    html += `<div class="prob-hint">Shortsword, Fireball, Sneak Attack</div>`;
                } else if (diceType === 'd4') {
                    html += `<div class="prob-row"><span>≥3:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (4):</span><span>25%</span></div>`;
                    html += `<div class="prob-hint">Dagger, Magic Missile, Guidance</div>`;
                }
                
                contentEl.innerHTML = html;
                
                // Position tooltip
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + rect.width / 2}px`;
                tooltip.style.top = `${rect.top - 10}px`;
                tooltip.classList.add('visible');
            },
            
            hideProbabilityTooltip() {
                const tooltip = document.getElementById('probTooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            },
            
            // ========================================
            // DRAG & DROP
            // ========================================
            
            initDragDrop() {
                const arena = document.getElementById('diceArena');
                const canvases = document.querySelectorAll('.dice-btn__canvas');
                
                // Track drag start position
                let dragStartPos = null;
                let dragStartTime = null;
                
                // Make canvases draggable
                canvases.forEach(canvas => {
                    canvas.setAttribute('draggable', 'true');
                    canvas.style.cursor = 'grab';
                    
                    canvas.addEventListener('dragstart', (e) => {
                        const diceType = canvas.dataset.type;
                        e.dataTransfer.setData('text/plain', diceType);
                        e.dataTransfer.effectAllowed = 'copy';
                        canvas.style.opacity = '0.5';
                        
                        // Track start position
                        dragStartPos = { x: e.clientX, y: e.clientY };
                        dragStartTime = Date.now();
                    });
                    
                    canvas.addEventListener('dragend', (e) => {
                        canvas.style.opacity = '1';
                    });
                });
                
                // Arena as drop target
                arena.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    arena.classList.add('drag-over');
                });
                
                arena.addEventListener('dragleave', (e) => {
                    arena.classList.remove('drag-over');
                });
                
                arena.addEventListener('drop', (e) => {
                    e.preventDefault();
                    arena.classList.remove('drag-over');
                    
                    const diceType = e.dataTransfer.getData('text/plain');
                    if (diceType && !this.isRolling) {
                        // Calculate throw vector from start to drop position
                        let throwVector = null;
                        
                        if (dragStartPos) {
                            const dropPos = { x: e.clientX, y: e.clientY };
                            const dx = dropPos.x - dragStartPos.x;
                            const dy = dropPos.y - dragStartPos.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const elapsed = Math.max(Date.now() - dragStartTime, 100);
                            
                            if (dist > 30) {
                                // Calculate boost based on drag speed
                                const timeInt = Math.min(elapsed, 2000);
                                const boost = Math.sqrt((2500 - timeInt) / 2500) * dist * 1.5;
                                
                                throwVector = {
                                    vector: { x: dx, y: -dy },
                                    boost: Math.max(boost, 200)
                                };
                            }
                        }
                        
                        // Check if the DROPPED dice is part of current selection
                        const droppedIsSelected = (this.currentDice[diceType] || 0) > 0;
                        const hasSelection = Object.values(this.currentDice).some(c => c > 0);
                        
                        if (hasSelection && droppedIsSelected) {
                            // Dropped die is in selection → roll ALL selected dice
                            const totalDice = Object.values(this.currentDice).reduce((a, b) => a + b, 0);
                            
                            if (totalDice > 1 && window.RIFT?.ui?.Toast) {
                                const parts = Object.entries(this.currentDice)
                                    .filter(([_, count]) => count > 0)
                                    .map(([type, count]) => `${count}${type.toUpperCase()}`)
                                    .join(' + ');
                                RIFT.ui.Toast.info(`Werfe ${parts}`);
                            }
                            
                            this.pendingThrowVector = throwVector;
                            this.roll();
                        } else {
                            // Dropped die is NOT in selection → roll only the dropped die
                            this.quickRollWithVector(diceType, throwVector);
                        }
                    }
                    
                    // Reset tracking
                    dragStartPos = null;
                    dragStartTime = null;
                });
            },
            
            quickRollWithVector(diceType, throwVector) {
                // Save modifier BEFORE clearDice (which resets it to 0)
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                // Roll a single die immediately with vector
                this.clearDice();
                this.currentDice[diceType] = 1;
                
                // Restore modifier
                document.getElementById('modifierInput').value = mod;
                this.updateModifierDisplay(mod);
                
                this.updateUI();
                
                // Build notation with modifier
                let notation = `1${diceType}`;
                if (mod !== 0) notation += (mod > 0 ? '+' : '') + mod;
                
                this.executeRoll(notation, null, throwVector);
            },
            
            // ========================================
            // SWIPE HANDLING
            // ========================================
            
            initSwipe(container) {
                let startPos = null;
                let startTime = null;
                
                const onStart = (e) => {
                    if (this.isRolling) return;
                    startPos = this.getEventPos(e);
                    startTime = Date.now();
                };
                
                const onEnd = (e) => {
                    if (!startPos || this.isRolling) return;
                    
                    const endPos = this.getEventPos(e);
                    const dx = endPos.x - startPos.x;
                    const dy = endPos.y - startPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const elapsed = Date.now() - startTime;
                    
                    const savedStartPos = { ...startPos };
                    startPos = null;
                    
                    // Minimum swipe distance
                    if (dist < 50) return;
                    
                    // Check if we have dice to roll
                    const hasDice = Object.values(this.currentDice).some(c => c > 0);
                    const hasNotation = document.getElementById('notationInput').value.trim().length > 0;
                    
                    if (!hasDice && !hasNotation) {
                        // Default to 1d20 if nothing selected
                        this.currentDice = { d20: 1 };
                        this.updateNotationFromDice();
                        this.updateUI();
                    }
                    
                    // Calculate boost based on speed
                    const timeInt = Math.min(elapsed, 2000);
                    const boost = Math.sqrt((2500 - timeInt) / 2500) * dist * 2;
                    
                    // Vector for throw direction (inverted y for 3D space)
                    const vector = { x: dx, y: -dy };
                    
                    console.log('[DiceRoller] Swipe detected, vector:', vector, 'boost:', boost);
                    
                    // Store throw vector for executeRoll
                    this.pendingThrowVector = { vector, boost };
                    this.roll();
                };
                
                container.addEventListener('mousedown', onStart);
                container.addEventListener('mouseup', onEnd);
                container.addEventListener('touchstart', (e) => { e.preventDefault(); onStart(e); });
                container.addEventListener('touchend', (e) => { e.preventDefault(); onEnd(e); });
            },
            
            getEventPos(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            },
            
            // ========================================
            // RIGHT CLICK TO REMOVE DICE
            // ========================================
            
            initRightClick() {
                document.querySelectorAll('.dice-btn').forEach(btn => {
                    btn.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const type = btn.dataset.dice;
                        if (type) this.removeDice(type);
                    });
                });
            },
            
            // ========================================
            // THEMES
            // ========================================
            
            initThemes() {
                // Theme buttons (alte + neue)
                document.querySelectorAll('.dice-theme-btn, .dice-theme-card').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const theme = btn.dataset.theme;
                        this.setTheme(theme, true); // true = show toast
                    });
                });
                
                // Load saved theme (no toast on initial load)
                const saved = localStorage.getItem('rift_dice_theme') || 'classic';
                this.setTheme(saved, false);
                
                // Load saved label color
                this.loadLabelColor();
                
                // Load saved arena theme
                this.loadArenaTheme();
            },
            
            setTheme(theme, showNotification = false) {
                // Skip if already this theme
                if (this.currentTheme === theme && !showNotification) return;
                
                this.currentTheme = theme;
                
                // Set data attribute for CSS
                document.body.dataset.diceTheme = theme;
                
                // Update theme buttons (alte)
                document.querySelectorAll('.dice-theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === theme);
                });
                
                // Update theme cards (neue)
                document.querySelectorAll('.dice-theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.theme === theme);
                });
                
                // Update arena background gradient based on theme
                const arena = document.getElementById('diceArena');
                const colors = this.themeColors[theme] || this.themeColors.classic;
                
                if (arena) {
                    arena.style.setProperty('--theme-primary', colors.primary);
                    arena.style.setProperty('--theme-secondary', colors.secondary);
                }
                
                // Update 3D dice color + gradient - store for next roll
                this.currentDiceColor = colors.accent;
                this.currentDiceGradient = colors.gradient || null;
                
                // Set color AND gradient on DICE module
                if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(colors.accent, colors.gradient);
                }
                
                // Update preview dice with new gradient texture
                if (typeof DicePreview !== 'undefined' && DicePreview.updateColors) {
                    DicePreview.updateColors();
                }
                
                localStorage.setItem('rift_dice_theme', theme);
                
                // Only show toast when explicitly changing theme
                if (showNotification && window.RIFT?.ui?.Toast) {
                    const names = { 
                        // Basic
                        classic: 'Klassisch', blood: 'Blut', ice: 'Eis', nature: 'Natur', royal: 'Royal', gold: 'Gold',
                        // Elemental
                        fire: 'Feuer', ocean: 'Ozean', toxic: 'Toxisch', lava: 'Lava', frost: 'Frost', 
                        storm: 'Sturm', earth: 'Erde', shadow: 'Schatten',
                        // Gems & Metals
                        ruby: 'Rubin', sapphire: 'Saphir', emerald: 'Smaragd', amethyst: 'Amethyst',
                        diamond: 'Diamant', opal: 'Opal', silver: 'Silber', bronze: 'Bronze',
                        platinum: 'Platin', copper: 'Kupfer', obsidian: 'Obsidian',
                        // Fantasy
                        dragon: 'Drache', necro: 'Nekro', fey: 'Fey', infernal: 'Höllisch',
                        celestial: 'Himmlisch', eldritch: 'Eldritch',
                        // Cosmic & Nature
                        nebula: 'Nebula', void: 'Void', galaxy: 'Galaxy', aurora: 'Aurora',
                        sunset: 'Sunset', bloodmoon: 'Blutmond', forest: 'Wald', cherry: 'Kirsche', autumn: 'Herbst',
                        // Tech & Retro
                        cyber: 'Cyber', midnight: 'Mitternacht', matrix: 'Matrix', hologram: 'Hologramm',
                        plasma: 'Plasma', neon: 'Neon', synthwave: 'Synthwave', steampunk: 'Steampunk', vaporwave: 'Vaporwave',
                        // Fun & Special
                        rainbow: 'Rainbow', candy: 'Candy', prism: 'Prisma', bubblegum: 'Bubblegum',
                        coral: 'Koralle', lavender: 'Lavendel', mint: 'Minze', peach: 'Pfirsich',
                        // Textured
                        marbleWhite: 'Marmor Weiß', marbleBlack: 'Marmor Schwarz', marbleGreen: 'Marmor Grün', marbleRose: 'Marmor Rosé',
                        woodOak: 'Holz Eiche', woodCherry: 'Holz Kirsche', woodEbony: 'Holz Ebenholz',
                        stoneGranite: 'Granit', stoneSandstone: 'Sandstein',
                        // Glitter
                        glitterGold: 'Glitzer Gold', glitterSilver: 'Glitzer Silber', glitterRose: 'Glitzer Rosé',
                        glitterBlue: 'Glitzer Blau', glitterPurple: 'Glitzer Lila',
                        // Patterns
                        stripesRed: 'Streifen Rot', stripesBlue: 'Streifen Blau', stripesGreen: 'Streifen Grün',
                        polkaDots: 'Punkte Pink', polkaBlack: 'Punkte Schwarz',
                        checkerRed: 'Karo Rot', checkerGreen: 'Karo Grün',
                        camoForest: 'Camo Wald', camoDesert: 'Camo Wüste', camoArctic: 'Camo Arktis',
                        waveOcean: 'Wellen Ozean', waveAqua: 'Wellen Aqua',
                        hexTech: 'Hex Tech', hexGold: 'Hex Gold',
                        dragonScales: 'Drachenschuppen', fishScales: 'Fischschuppen',
                        // Special Effects
                        starryNight: 'Sternennacht', galaxy2: 'Galaxie II', thunderstorm: 'Gewitter', electricBlue: 'Elektrisch',
                        // Metallic
                        chrome: 'Chrom', titanium: 'Titan', rosegold: 'Roségold', brushedSteel: 'Gebürsteter Stahl',
                        rust: 'Rost', patina: 'Patina',
                        // Food
                        chocolate: 'Schokolade', caramel: 'Karamell', strawberry: 'Erdbeere', blueberry: 'Blaubeere',
                        grape: 'Traube', lemon: 'Zitrone', lime: 'Limette', orange2: 'Orange',
                        // Seasonal
                        springBlossom: 'Frühling', summerSun: 'Sommer', autumnLeaves: 'Herbstlaub', winterFrost: 'Winterfrost',
                        christmas: 'Weihnachten', halloween: 'Halloween', valentine: 'Valentinstag',
                        // Gaming
                        critSuccess: 'Krit. Erfolg', critFail: 'Krit. Patzer', lucky: 'Glückswürfel',
                        cursed: 'Verflucht', blessed: 'Gesegnet', ethereal: 'Ätherisch',
                        // Dark
                        charcoal: 'Kohle', slate: 'Schiefer', graphite: 'Graphit', carbon: 'Carbon', onyx: 'Onyx',
                        // Pastel
                        pastelPink: 'Pastell Rosa', pastelBlue: 'Pastell Blau', pastelGreen: 'Pastell Grün',
                        pastelYellow: 'Pastell Gelb', pastelPurple: 'Pastell Lila', pastelRainbow: 'Pastell Regenbogen',
                        // Nature Extended
                        deepSea: 'Tiefsee', coralReef: 'Korallenriff', jungle: 'Dschungel', desert: 'Wüste',
                        volcanic: 'Vulkanisch', arctic: 'Arktis', tundra: 'Tundra', swamp: 'Sumpf'
                    };
                    RIFT.ui.Toast.info(`Theme: ${names[theme] || theme}`);
                }
                
                // Update preview dice colors
                if (typeof DicePreview !== 'undefined' && DicePreview.updateColors) {
                    DicePreview.updateColors();
                }
            },
            
            // ========================================
            // SETTINGS POPUP
            // ========================================
            
            initSettings() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsPopup = document.getElementById('settingsPopup');
                const settingsClose = document.getElementById('settingsClose');
                
                const statsBtn = document.getElementById('statsBtn');
                const statsPopup = document.getElementById('statsPopup');
                
                const hotkeysBtn = document.getElementById('hotkeysBtn');
                const hotkeysPopup = document.getElementById('hotkeysPopup');
                
                // Settings Button
                if (settingsBtn && settingsPopup) {
                    settingsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = settingsPopup.classList.contains('open');
                        this.closeAllPopups();
                        if (!isOpen) {
                            settingsPopup.classList.add('open');
                            settingsBtn.classList.add('active');
                            // Scroll to top when opening
                            settingsPopup.scrollTop = 0;
                            // Reset to first tab
                            this.switchSettingsTab('diceColor');
                            // Open overlay behind popup
                            const overlay = document.getElementById('diceSettingsOverlay');
                            if (overlay) overlay.classList.add('open');
                        }
                    });
                    
                    settingsClose?.addEventListener('click', () => {
                        settingsPopup.classList.remove('open');
                        settingsBtn.classList.remove('active');
                        // Close overlay
                        const overlay = document.getElementById('diceSettingsOverlay');
                        if (overlay) overlay.classList.remove('open');
                    });
                }
                
                // Stats Button
                if (statsBtn && statsPopup) {
                    statsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleStatsPopup();
                    });
                }
                
                // Hotkeys Button
                if (hotkeysBtn && hotkeysPopup) {
                    hotkeysBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleHotkeysPopup();
                    });
                }
                
                // Click outside schließt alle Popups
                document.addEventListener('click', (e) => {
                    const allPopups = [settingsPopup, statsPopup, hotkeysPopup];
                    const allBtns = [settingsBtn, statsBtn, hotkeysBtn];
                    
                    let clickedInside = false;
                    allPopups.forEach(popup => {
                        if (popup?.contains(e.target)) clickedInside = true;
                    });
                    allBtns.forEach(btn => {
                        if (btn?.contains(e.target)) clickedInside = true;
                    });
                    
                    if (!clickedInside) {
                        this.closeAllPopups();
                    }
                });
                
                // Clicks in Popups nicht durchlassen
                [settingsPopup, statsPopup, hotkeysPopup].forEach(popup => {
                    popup?.addEventListener('click', (e) => e.stopPropagation());
                });
            },
            
            // ========================================
            // SOUND
            // ========================================
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                window.RIFT_DICE_SOUND = this.soundEnabled;
                
                // Update both toggle buttons
                document.getElementById('soundToggle')?.classList.toggle('active', this.soundEnabled);
                document.getElementById('soundToggle2')?.classList.toggle('active', this.soundEnabled);
                localStorage.setItem('rift_dice_sound', this.soundEnabled);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(this.soundEnabled ? 'Sound an' : 'Sound aus');
                }
            },
            
            // ========================================
            // SECRET ROLL
            // ========================================
            
            toggleSecret() {
                this.secretRoll = !this.secretRoll;
                
                // Update both toggle buttons
                document.getElementById('secretToggle')?.classList.toggle('active', this.secretRoll);
                document.getElementById('secretToggle2')?.classList.toggle('active', this.secretRoll);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(this.secretRoll ? 'Geheimer Wurf aktiviert' : 'Normaler Wurf');
                }
            },
            
            // ========================================
            // THEME FILTER
            // ========================================
            
            filterThemes(query) {
                const cards = document.querySelectorAll('.dice-theme-card');
                const searchTerm = query.toLowerCase().trim();
                let visibleCount = 0;
                
                cards.forEach(card => {
                    const themeName = card.querySelector('span')?.textContent?.toLowerCase() || '';
                    const themeKey = card.dataset.theme?.toLowerCase() || '';
                    const matches = themeName.includes(searchTerm) || themeKey.includes(searchTerm);
                    
                    card.style.display = matches ? '' : 'none';
                    if (matches) visibleCount++;
                });
                
                // Update count
                const countEl = document.getElementById('themeCount');
                if (countEl) {
                    countEl.textContent = `(${visibleCount})`;
                }
            },
            
            // ========================================
            // SETTINGS TABS
            // ========================================
            
            switchSettingsTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.dice-settings-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Update tab content
                document.querySelectorAll('.dice-settings-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const tabMap = {
                    'diceColor': 'tabDiceColor',
                    'labelColor': 'tabLabelColor',
                    'arenaTheme': 'tabArenaTheme'
                };
                
                const targetContent = document.getElementById(tabMap[tabName]);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            },
            
            // ========================================
            // LABEL COLOR (Zahlenfarbe)
            // ========================================
            
            setLabelColor(color, showNotification = true) {
                this.currentLabelColor = color;
                
                // Update DICE library
                if (typeof DICE !== 'undefined' && DICE.setLabelColor) {
                    DICE.setLabelColor(color === 'auto' ? null : color);
                }
                
                // Update preview dice
                if (typeof DicePreview !== 'undefined' && DicePreview.updateColors) {
                    DicePreview.updateColors();
                }
                
                // Update UI buttons
                document.querySelectorAll('.dice-label-color-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.color === color);
                });
                
                // Save to localStorage
                localStorage.setItem('rift_dice_label_color', color);
                
                // Show toast
                if (showNotification && window.RIFT?.ui?.Toast) {
                    const colorNames = {
                        'auto': 'Automatisch',
                        '#ffffff': 'Weiß',
                        '#1a1a1a': 'Schwarz',
                        '#ff4444': 'Rot',
                        '#ff9800': 'Orange',
                        '#ffeb3b': 'Gelb',
                        '#4caf50': 'Grün',
                        '#00bcd4': 'Cyan',
                        '#2196f3': 'Blau',
                        '#9c27b0': 'Lila',
                        '#e91e63': 'Pink',
                        '#ffd700': 'Gold'
                    };
                    RIFT.ui.Toast.show(`Zahlenfarbe: ${colorNames[color] || color}`, 'success');
                }
            },
            
            loadLabelColor() {
                const saved = localStorage.getItem('rift_dice_label_color');
                if (saved) {
                    this.setLabelColor(saved, false);
                }
            },
            
            // ========================================
            // ARENA THEME
            // ========================================
            
            currentArenaTheme: 'default',
            
            setArenaTheme(theme, showNotification = true) {
                this.currentArenaTheme = theme;
                
                // Apply to arena
                const arena = document.getElementById('diceArena');
                if (arena) {
                    arena.dataset.arenaTheme = theme;
                }
                
                // Update UI
                document.querySelectorAll('.dice-arena-theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.arenaTheme === theme);
                });
                
                // Save preference
                localStorage.setItem('rift_dice_arena_theme', theme);
                
                // Toast notification
                if (showNotification && window.RIFT?.ui?.Toast) {
                    const themeNames = {
                        'default': 'Standard',
                        'tavern': 'Taverne',
                        'casino': 'Casino',
                        'dungeon': 'Kerker',
                        'arcane': 'Arkane Magie',
                        'cyber': 'Cyber-Grid',
                        'nebula': 'Nebula',
                        'lava': 'Lavahöhle',
                        'frost': 'Frostreich',
                        'parchment': 'Pergament',
                        'ocean': 'Ozean',
                        'forest': 'Wald',
                        'bloodmoon': 'Blutmond',
                        'desert': 'Wüste',
                        'void': 'Leere',
                        'marble': 'Marmor',
                        'gothic': 'Gotik',
                        'steampunk': 'Steampunk',
                        'neonpink': 'Neon Pink',
                        'matrix': 'Matrix',
                        'starfield': 'Sternenhimmel',
                        'sakura': 'Sakura',
                        'inferno': 'Inferno',
                        'twilight': 'Dämmerung',
                        'crystal': 'Kristall',
                        'mossy': 'Moosstein',
                        'royal': 'Königlich',
                        'eclipse': 'Finsternis',
                        'aurora': 'Nordlicht',
                        'storm': 'Gewitter',
                        'toxic': 'Toxisch',
                        'copper': 'Kupfer'
                    };
                    RIFT.ui.Toast.show(`Arena: ${themeNames[theme] || theme}`, 'success');
                }
            },
            
            loadArenaTheme() {
                const saved = localStorage.getItem('rift_dice_arena_theme');
                if (saved) {
                    this.setArenaTheme(saved, false);
                }
            },
            
            // ========================================
            // PRESETS
            // ========================================
            
            presets: [],
            presetsOpen: false,
            
            togglePresets() {
                this.presetsOpen = !this.presetsOpen;
                const popup = document.getElementById('presetsPopup');
                const btn = document.getElementById('presetsBtn');
                
                if (this.presetsOpen) {
                    this.loadPresets();
                    this.renderPresets();
                    popup.classList.add('visible');
                    btn.classList.add('active');
                } else {
                    popup.classList.remove('visible');
                    btn.classList.remove('active');
                }
            },
            
            loadPresets() {
                try {
                    this.presets = JSON.parse(localStorage.getItem('rift_dice_presets') || '[]');
                } catch (e) {
                    this.presets = [];
                }
            },
            
            savePresets() {
                localStorage.setItem('rift_dice_presets', JSON.stringify(this.presets));
            },
            
            savePreset() {
                // Check if there are dice selected
                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                if (!hasDice) {
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Keine Würfel ausgewählt');
                    }
                    return;
                }
                
                // Prompt for name
                const defaultName = this.buildNotationString();
                const name = prompt('Preset-Name:', defaultName);
                if (!name) return;
                
                // Build preset
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                const preset = {
                    name: name,
                    dice: { ...this.currentDice },
                    modifier: mod,
                    notation: this.buildNotationString()
                };
                
                this.loadPresets();
                this.presets.push(preset);
                this.savePresets();
                this.renderPresets();
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success(`Preset "${name}" gespeichert`);
                }
            },
            
            buildNotationString() {
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        const wType = type.replace('d', 'W').toUpperCase();
                        parts.push(`${count}${wType}`);
                    }
                }
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                let notation = parts.join('+');
                if (mod !== 0) notation += (mod > 0 ? '+' : '') + mod;
                return notation;
            },
            
            loadPreset(index) {
                const preset = this.presets[index];
                if (!preset) return;
                
                this.currentDice = { ...preset.dice };
                document.getElementById('modifierInput').value = preset.modifier || 0;
                this.updateModifierDisplay(preset.modifier || 0);
                this.updateNotationFromDice();
                this.updateUI();
                
                // Close popup
                this.togglePresets();
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(`"${preset.name}" geladen`);
                }
            },
            
            deletePreset(index, e) {
                e.stopPropagation();
                const preset = this.presets[index];
                if (!preset) return;
                
                if (confirm(`Preset "${preset.name}" löschen?`)) {
                    this.presets.splice(index, 1);
                    this.savePresets();
                    this.renderPresets();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.info('Preset gelöscht');
                    }
                }
            },
            
            renderPresets() {
                const list = document.getElementById('presetsList');
                if (!list) return;
                
                if (this.presets.length === 0) {
                    list.innerHTML = '<div class="dice-presets-popup__empty">Keine Presets gespeichert</div>';
                    return;
                }
                
                list.innerHTML = this.presets.map((preset, i) => `
                    <div class="dice-presets-popup__item" onclick="DiceRoller.loadPreset(${i})">
                        <div class="dice-presets-popup__item-info">
                            <span class="dice-presets-popup__item-name">${preset.name}</span>
                            <span class="dice-presets-popup__item-notation">${preset.notation}</span>
                        </div>
                        <button class="dice-presets-popup__item-delete" onclick="DiceRoller.deletePreset(${i}, event)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                `).join('');
            },
            
            // ========================================
            // DICE SELECTION
            // ========================================
            
            addDice(type) {
                if (!this.currentDice[type]) this.currentDice[type] = 0;
                this.currentDice[type]++;
                this.updateNotationFromDice();
                this.updateUI();
            },
            
            removeDice(type) {
                if (this.currentDice[type]) {
                    this.currentDice[type]--;
                    if (this.currentDice[type] <= 0) delete this.currentDice[type];
                }
                this.updateNotationFromDice();
                this.updateUI();
            },
            
            clearDice() {
                this.currentDice = {};
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '';
                this.updateUI();
            },
            
            updateNotationFromDice() {
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        // Use German W notation
                        const wType = type.replace('d', 'W');
                        parts.push(`${count}${wType}`);
                    }
                }
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                let notation = parts.join('+');
                if (mod > 0) notation += `+${mod}`;
                else if (mod < 0) notation += `${mod}`;
                
                document.getElementById('notationInput').value = notation;
            },
            
            // Parse notation - supports both D and W (German)
            parseDiceFromNotation(notation) {
                this.currentDice = {};
                let modifier = 0;
                
                // Normalize: replace W with D (case insensitive)
                const normalized = notation.toUpperCase().replace(/W/g, 'D');
                
                // Match dice patterns (now only D since we normalized)
                const diceRegex = /(\d*)D(\d+)/g;
                let match;
                while ((match = diceRegex.exec(normalized)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    const type = `d${sides}`;
                    this.currentDice[type] = (this.currentDice[type] || 0) + count;
                }
                
                // Match modifier at end (after all dice)
                const modMatch = normalized.match(/([+-]\d+)(?!D)(?:\s*$|\s*\()/);
                if (modMatch) {
                    modifier = parseInt(modMatch[1]);
                }
                
                document.getElementById('modifierInput').value = modifier;
                this.updateUI();
            },
            
            adjustModifier(delta) {
                const input = document.getElementById('modifierInput');
                let val = parseInt(input.value) || 0;
                val = Math.max(-99, Math.min(99, val + delta));
                input.value = val;
                this.updateModifierDisplay(val);
                this.updateNotationFromDice();
            },
            
            updateModifierDisplay(val) {
                const display = document.getElementById('modifierDisplay');
                if (!display) return;
                
                if (val === 0) {
                    display.textContent = '+0';
                    display.className = 'dice-modifier__display';
                } else if (val > 0) {
                    display.textContent = '+' + val;
                    display.className = 'dice-modifier__display dice-modifier__display--positive';
                } else {
                    display.textContent = val.toString();
                    display.className = 'dice-modifier__display dice-modifier__display--negative';
                }
            },
            
            // ========================================
            // ROLLING
            // ========================================
            
            roll() {
                if (this.isRolling) return;
                
                // Hide previous result
                this.hideResult();
                
                // Get notation from input or build from dice
                let notationStr = document.getElementById('notationInput').value.trim();
                
                if (notationStr) {
                    this.parseDiceFromNotation(notationStr);
                }
                
                // Build from selected dice
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) parts.push(`${count}${type}`);
                }
                if (parts.length === 0) return;
                
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                notationStr = parts.join('+');
                if (mod !== 0) notationStr += (mod > 0 ? '+' : '') + mod;
                
                // Use pending throw vector if available
                const throwVector = this.pendingThrowVector || null;
                this.pendingThrowVector = null;
                
                this.executeRoll(notationStr, null, throwVector);
            },
            
            rollFromNotation() {
                const notation = document.getElementById('notationInput').value.trim();
                if (!notation) return;
                this.parseDiceFromNotation(notation);
                this.roll();
            },
            
            quickRoll(notation) {
                this.hideResult();
                this.parseDiceFromNotation(notation);
                document.getElementById('notationInput').value = notation;
                setTimeout(() => this.roll(), 50);
            },
            
            rollAdvantage() {
                this.hideResult();
                this.currentDice = { d20: 2 };
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '2D20 (Vorteil)';
                this.updateUI();
                this.executeRoll('2d20', 'advantage');
            },
            
            rollDisadvantage() {
                this.hideResult();
                this.currentDice = { d20: 2 };
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '2D20 (Nachteil)';
                this.updateUI();
                this.executeRoll('2d20', 'disadvantage');
            },
            
            repeatLast() {
                if (!this.lastRoll) return;
                this.hideResult();
                document.getElementById('notationInput').value = this.lastRoll.notation;
                this.parseDiceFromNotation(this.lastRoll.notation);
                this.executeRoll(this.lastRoll.notationClean, this.lastRoll.special);
            },
            
            hideResult() {
                const result = document.getElementById('diceResult');
                result.classList.remove('visible', 'critical', 'fumble', 'secret');
                this.clearDiceLabels();
                if (this.resultTimeout) {
                    clearTimeout(this.resultTimeout);
                    this.resultTimeout = null;
                }
            },
            
            executeRoll(notationStr, special = null, throwVector = null) {
                if (this.isRolling) return;
                this.isRolling = true;
                
                // Clear previous labels immediately
                this.clearDiceLabels();
                
                // Set dice color + gradient before roll
                if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(this.currentDiceColor, this.currentDiceGradient);
                }
                
                const arena = document.getElementById('diceArena');
                const result = document.getElementById('diceResult');
                const btn = document.getElementById('rollBtn');
                
                // UI Feedback
                arena.classList.remove('empty');
                arena.classList.add('throwing');
                result.classList.remove('visible', 'critical', 'fumble', 'secret');
                btn.classList.add('rolling');
                
                setTimeout(() => arena.classList.remove('throwing'), 300);
                
                // Save for repeat
                const displayNotation = document.getElementById('notationInput').value || notationStr;
                this.lastRoll = { notation: displayNotation, notationClean: notationStr, special };
                document.getElementById('repeatBtn').disabled = false;
                
                // Handle W100/D100 specially
                let libraryNotation = notationStr;
                const d100Count = this.currentDice.d100 || 0;
                if (d100Count > 0) {
                    libraryNotation = notationStr.replace(/(\d*)d100/gi, (match, count) => {
                        const c = parseInt(count) || 1;
                        return `${c}d100+${c}d10`;
                    });
                }
                
                this.currentLibraryNotation = libraryNotation;
                
                // ================================================
                // ECHTZEIT-SYNC: Berechne Ergebnisse VOR Animation
                // ================================================
                const precomputed = this.precomputeRoll(libraryNotation, d100Count);
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const playerName = userData.name || 'Spieler';
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                // Calculate final values
                let finalTotal = precomputed.total + mod;
                if (special === 'advantage') {
                    finalTotal = Math.max(...precomputed.displayRolls) + mod;
                } else if (special === 'disadvantage') {
                    finalTotal = Math.min(...precomputed.displayRolls) + mod;
                }
                
                const isCritical = this.checkCriticalPrecomputed(precomputed.displayRolls, special);
                
                // Build history notation
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) parts.push(`${count}${type.replace('d', 'W')}`);
                }
                let histNotation = parts.join('+');
                if (mod !== 0) histNotation += (mod > 0 ? '+' : '') + mod;
                if (special) histNotation += ` (${special === 'advantage' ? 'V' : 'N'})`;
                
                // ================================================
                // SYNC SOFORT - VOR Animation starten
                // ================================================
                const rollData = {
                    player: playerName,
                    playerId: userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || playerName,
                    color: userData.color || '#FF4655',
                    diceTheme: this.currentTheme || 'classic',
                    labelColor: this.currentLabelColor || 'auto',
                    total: finalTotal,
                    notation: histNotation,
                    results: precomputed.displayRolls,
                    rawResults: precomputed.rawResults,
                    modifier: mod,
                    critical: isCritical,
                    secret: this.secretRoll,
                    special: special,
                    timestamp: Date.now(),
                    diceConfig: {
                        notation: libraryNotation,
                        rawResults: precomputed.rawResults
                    }
                };
                
                // Push to Firebase IMMEDIATELY
                this.syncRoll(rollData);
                
                // Add to own history
                this.addToHistory({
                    player: playerName,
                    color: userData.color || '#FF4655',
                    total: finalTotal,
                    notation: histNotation,
                    rolls: precomputed.displayRolls,
                    critical: isCritical,
                    secret: this.secretRoll,
                    timestamp: Date.now()
                });
                
                // ================================================
                // Animation mit vorberechneten Ergebnissen
                // ================================================
                const animationStartTime = Date.now();
                const MIN_ANIMATION_TIME = 2500; // Mindestens 2.5 Sekunden Animation
                
                const showFinalResult = () => {
                    const elapsed = Date.now() - animationStartTime;
                    const remainingTime = Math.max(0, MIN_ANIMATION_TIME - elapsed);
                    
                    // Warte bis Mindestzeit erreicht
                    setTimeout(() => {
                        btn.classList.remove('rolling');
                        
                        // Show dice labels (Zahlen-Indikatoren) and pulse effects
                        this.showDiceLabels(precomputed.displayRolls, precomputed.rawResults);
                        
                        this.displayRollResult(precomputed.displayRolls, finalTotal, mod, isCritical, special, playerName, userData.color);
                        this.isRolling = false;
                    }, remainingTime);
                };
                
                if (this.box) {
                    this.box.setDice(libraryNotation);
                    
                    // before_roll gibt vorberechnete Ergebnisse zurück
                    const beforeRoll = (notation) => precomputed.rawResults;
                    
                    let done = false;
                    const afterRoll = () => {
                        if (done) return;
                        done = true;
                        showFinalResult();
                    };
                    
                    if (throwVector && throwVector.vector && throwVector.boost) {
                        this.box.throw_with_vector(throwVector.vector, throwVector.boost, beforeRoll, afterRoll);
                    } else {
                        this.box.start_throw(beforeRoll, afterRoll);
                    }
                    
                    // Fallback timeout
                    setTimeout(() => { if (!done) { done = true; showFinalResult(); } }, 8000);
                } else {
                    setTimeout(showFinalResult, 1500);
                }
            },
            
            // Berechne Würfelergebnisse VOR Animation
            precomputeRoll(libraryNotation, d100Count) {
                const rawResults = [];
                const displayRolls = [];
                let total = 0;
                
                // Parse dice notation
                const diceRegex = /(\d*)d(\d+)/gi;
                let match;
                while ((match = diceRegex.exec(libraryNotation)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    for (let i = 0; i < count; i++) {
                        // WICHTIG: Die Library erwartet für d100 Werte 1-10 (nicht 1-100!)
                        // d100 in der Library = Zehnerstelle (1-10 → 00,10,20...90)
                        // d10 in der Library = Einerstelle (1-10 → 0-9, wobei 10=0)
                        if (sides === 100) {
                            // Für d100: generiere 1-10 (wird zu 00-90)
                            rawResults.push(Math.floor(Math.random() * 10) + 1);
                        } else {
                            rawResults.push(Math.floor(Math.random() * sides) + 1);
                        }
                    }
                }
                
                // Handle D100 conversion für Display
                if (d100Count > 0) {
                    let idx = 0;
                    for (let i = 0; i < d100Count; i++) {
                        const tens = rawResults[idx] || 1;      // 1-10
                        const ones = rawResults[idx + 1] || 1;  // 1-10
                        
                        // Library: d100 1-10 → 00,10,20...90 | d10 1-10 → 1-9,0
                        const tensVal = (tens - 1) * 10;        // 0, 10, 20...90
                        const onesVal = ones === 10 ? 0 : ones; // 1-9, oder 0
                        
                        let value = tensVal + onesVal;
                        if (value === 0) value = 100; // 00+0 = 100
                        
                        console.log(`[DiceRoller] D100: tens=${tens}→${tensVal}, ones=${ones}→${onesVal}, result=${value}`);
                        
                        displayRolls.push(value);
                        total += value;
                        idx += 2;
                    }
                    // Remaining dice (non-d100)
                    while (idx < rawResults.length) {
                        displayRolls.push(rawResults[idx]);
                        total += rawResults[idx];
                        idx++;
                    }
                } else {
                    displayRolls.push(...rawResults);
                    total = rawResults.reduce((a, b) => a + b, 0);
                }
                
                return { rawResults, displayRolls, total };
            },
            
            // Check critical from precomputed rolls
            checkCriticalPrecomputed(rolls, special) {
                const diceTypes = Object.entries(this.currentDice).filter(([t, c]) => c > 0);
                const isD20 = diceTypes.length === 1 && diceTypes[0][0] === 'd20' && diceTypes[0][1] === 1;
                const isD100 = diceTypes.length === 1 && diceTypes[0][0] === 'd100' && diceTypes[0][1] === 1;
                
                if (isD20 || (special && diceTypes.some(([t]) => t === 'd20'))) {
                    if (rolls.includes(20)) return 'success';
                    if (rolls.includes(1)) return 'failure';
                }
                if (isD100) {
                    if (rolls.includes(1)) return 'success';
                    if (rolls.includes(100)) return 'failure';
                }
                return false;
            },
            
            // Zeige Ergebnis an
            displayRollResult(rolls, total, mod, isCritical, special, playerName, playerColor) {
                // Clear any existing timeout to prevent early hide
                if (this.resultTimeout) {
                    clearTimeout(this.resultTimeout);
                    this.resultTimeout = null;
                }
                
                const arena = document.getElementById('diceArena');
                const resultEl = document.getElementById('diceResult');
                const totalEl = document.getElementById('resultTotal');
                const breakdownEl = document.getElementById('resultBreakdown');
                const playerEl = document.getElementById('resultPlayer');
                
                arena.classList.remove('throwing');
                
                if (playerEl) {
                    playerEl.textContent = playerName;
                    playerEl.style.color = playerColor || '#FF4655';
                }
                
                totalEl.textContent = total;
                
                let modStr = '';
                if (mod !== 0) {
                    const cls = mod > 0 ? 'positive' : 'negative';
                    modStr = ` <span class="dice-result__mod dice-result__mod--${cls}">${mod > 0 ? '+' : ''}${mod}</span>`;
                }
                
                if (special === 'advantage') {
                    breakdownEl.innerHTML = `[${rolls.join(', ')}] → höchste: ${Math.max(...rolls)}${modStr}`;
                } else if (special === 'disadvantage') {
                    breakdownEl.innerHTML = `[${rolls.join(', ')}] → niedrigste: ${Math.min(...rolls)}${modStr}`;
                } else {
                    breakdownEl.innerHTML = `[${rolls.join(', ')}]${modStr} = ${total}`;
                }
                
                if (this.secretRoll) resultEl.classList.add('secret');
                
                if (isCritical === 'success') {
                    resultEl.classList.add('critical');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('success');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                } else if (isCritical === 'failure') {
                    resultEl.classList.add('fumble');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('failure');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                }
                
                resultEl.classList.add('visible');
                
                this.resultTimeout = setTimeout(() => {
                    resultEl.classList.remove('visible', 'critical', 'fumble', 'secret');
                    this.clearDiceLabels();
                }, 8000);
            },
            
            calculateD100Result(rawRolls, d100Count) {
                // Library returns:
                // - d100 (tens): 0, 10, 20, 30, 40, 50, 60, 70, 80, 90
                // - d10 (ones): 1-10 (where 10 means the "0" face was rolled)
                const rolls = [];
                let total = 0;
                let rollIndex = 0;
                
                for (let i = 0; i < d100Count; i++) {
                    const tens = rawRolls[rollIndex] || 0;           // 0, 10, 20, 30...90
                    const onesRaw = rawRolls[rollIndex + 1] || 1;    // 1-10
                    const ones = onesRaw === 10 ? 0 : onesRaw;       // Convert 10 back to 0
                    
                    let value = tens + ones;
                    // Special case: 00 + 0 = 100 (not 0)
                    if (value === 0) value = 100;
                    
                    console.log(`[DiceRoller] D100 #${i+1}: tens=${tens}, onesRaw=${onesRaw}, ones=${ones}, value=${value}`);
                    
                    rolls.push(value);
                    total += value;
                    rollIndex += 2;
                }
                
                // Add remaining rolls (non-d100 dice)
                while (rollIndex < rawRolls.length) {
                    rolls.push(rawRolls[rollIndex]);
                    total += rawRolls[rollIndex];
                    rollIndex++;
                }
                
                return { rolls, total };
            },
            
            simulateRoll(notation) {
                const rolls = [];
                let total = 0;
                
                // Normalize W to D
                const normalized = notation.toUpperCase().replace(/W/g, 'D');
                
                const diceRegex = /(\d*)D(\d+)/g;
                let match;
                while ((match = diceRegex.exec(normalized)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    
                    if (sides === 100) {
                        // D100: tens (00-90) + ones (0-9)
                        for (let i = 0; i < count; i++) {
                            const tens = Math.floor(Math.random() * 10) * 10; // 0, 10, 20...90
                            const ones = Math.floor(Math.random() * 10);       // 0-9
                            let value = tens + ones;
                            if (value === 0) value = 100; // 00 + 0 = 100
                            rolls.push(value);
                            total += value;
                        }
                    } else {
                        for (let i = 0; i < count; i++) {
                            const roll = Math.floor(Math.random() * sides) + 1;
                            rolls.push(roll);
                            total += roll;
                        }
                    }
                }
                
                const modMatch = normalized.match(/([+-]\d+)(?!D)(?:\s*$|\s*\()/);
                const mod = modMatch ? parseInt(modMatch[1]) : 0;
                total += mod;
                
                return { rolls, total, breakdown: `[${rolls.join(', ')}]${mod !== 0 ? (mod > 0 ? '+' : '') + mod : ''} = ${total}` };
            },
            
            handleResult(rolls, total, notation, special = null, rawRolls = null) {
                const arena = document.getElementById('diceArena');
                const resultEl = document.getElementById('diceResult');
                const totalEl = document.getElementById('resultTotal');
                const breakdownEl = document.getElementById('resultBreakdown');
                const playerEl = document.getElementById('resultPlayer');
                const skillLabelEl = document.getElementById('resultSkillLabel');
                const targetEl = document.getElementById('resultTarget');
                const outcomeEl = document.getElementById('resultOutcome');
                const backBtnEl = document.getElementById('resultBackBtn');
                
                // Reset skill check display classes
                resultEl.classList.remove('skill-success', 'skill-failure');
                skillLabelEl.classList.remove('visible');
                targetEl.classList.remove('visible');
                outcomeEl.classList.remove('visible', 'success', 'failure');
                backBtnEl.classList.remove('visible');
                
                // Get current modifier
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                // Handle advantage/disadvantage
                let finalTotal = total;
                let displayRolls = rolls;
                
                if (special === 'advantage' && rolls.length >= 2) {
                    finalTotal = Math.max(rolls[0], rolls[1]);
                    if (mod !== 0) finalTotal += mod;
                } else if (special === 'disadvantage' && rolls.length >= 2) {
                    finalTotal = Math.min(rolls[0], rolls[1]);
                    if (mod !== 0) finalTotal += mod;
                }
                
                // Check critical
                const isCritical = this.checkCritical(rolls, special);
                
                // Show dice labels above each die
                this.showDiceLabels(rolls, rawRolls);
                
                // Get user info
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const playerName = userData.name || 'Spieler';
                const playerColor = userData.color || '#FF4655';
                
                // Display
                playerEl.textContent = playerName;
                playerEl.style.color = playerColor;
                totalEl.textContent = finalTotal;
                
                // Skill Check Display (Worlds Apart D100)
                if (this.skillCheckMode && this.skillCheckTarget > 0) {
                    // Show skill label
                    skillLabelEl.textContent = this.skillCheckLabel;
                    skillLabelEl.classList.add('visible');
                    
                    // Determine success/failure (roll must be <= target)
                    const rollResult = rolls[0]; // D100 result
                    const isSuccess = rollResult <= this.skillCheckTarget;
                    
                    // Show target value
                    targetEl.textContent = `Zielwert: ${this.skillCheckTarget}`;
                    targetEl.classList.add('visible');
                    
                    // Show outcome
                    outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown: Gewürfelt vs Zielwert
                    breakdownEl.innerHTML = `Gewürfelt: ${rollResult} | Zielwert: ${this.skillCheckTarget}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    this.lastCheckResult = {
                        label: this.skillCheckLabel,
                        result: rollResult,
                        success: isSuccess,
                        outcome: isSuccess ? 'Erfolg' : 'Fehlschlag',
                        critical: false
                    };
                    
                    console.log('[DiceRoller] Skill Check Result:', { roll: rollResult, target: this.skillCheckTarget, success: isSuccess });
                }
                // Zweite Chance Display (Worlds Apart D20)
                else if (this.zweiteChanceMode) {
                    // Show label
                    skillLabelEl.textContent = 'Zweite Chance';
                    skillLabelEl.classList.add('visible');
                    
                    // Show threshold info
                    targetEl.textContent = '1–5 = Fehlschlag | 6–20 = Wiederholen';
                    targetEl.classList.add('visible');
                    
                    // Get natural roll
                    const rollValue = rolls[0];
                    const isSuccess = rollValue >= 6;
                    
                    // Show outcome
                    if (isSuccess) {
                        outcomeEl.textContent = 'WIEDERHOLEN ERLAUBT!';
                    } else {
                        outcomeEl.textContent = 'FEHLSCHLAG BLEIBT!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown
                    breakdownEl.innerHTML = `Gewürfelt: ${rollValue}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    this.lastCheckResult = {
                        label: 'Zweite Chance',
                        result: rollValue,
                        success: isSuccess,
                        outcome: isSuccess ? 'Wiederholen!' : 'Fehlschlag!',
                        critical: false,
                        zweiteChance: true,
                        diceIndex: this.zweiteChanceDiceIndex
                    };
                    
                    console.log('[DiceRoller] Zweite Chance Result:', { roll: rollValue, success: isSuccess, diceIndex: this.zweiteChanceDiceIndex });
                }
                // Fokus Check Display (Worlds Apart D20)
                else if (this.fokusCheckMode) {
                    // Show fokus label
                    skillLabelEl.textContent = 'Fokus-Fähigkeit';
                    skillLabelEl.classList.add('visible');
                    
                    // Show threshold info
                    targetEl.textContent = `≥11 Erfolg | ≤10 Fehlschlag`;
                    targetEl.classList.add('visible');
                    
                    // Get natural roll
                    const rollValue = rolls[0];
                    const isNat20 = rollValue === 20;
                    const isNat1 = rollValue === 1;
                    
                    // Determine success/failure (total must be >= 11, but nat 20 always success, nat 1 always fail)
                    const isSuccess = isNat20 || (!isNat1 && finalTotal >= 11);
                    const isCritical = isNat20 || isNat1;
                    
                    // Show outcome
                    if (isNat20) {
                        outcomeEl.textContent = 'KRITISCHER ERFOLG!';
                        resultEl.classList.add('critical');
                    } else if (isNat1) {
                        outcomeEl.textContent = 'PATZER!';
                        resultEl.classList.add('fumble');
                    } else {
                        outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown with roll + modifier = total
                    const modSign = mod >= 0 ? '+' : '';
                    breakdownEl.innerHTML = `${rollValue} ${modSign} ${mod} = ${finalTotal}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    let outcomeText = isSuccess ? 'Erfolg' : 'Fehlschlag';
                    if (isNat20) outcomeText = 'Kritisch!';
                    if (isNat1) outcomeText = 'Patzer!';
                    
                    this.lastCheckResult = {
                        label: 'Fokus-Fähigkeit',
                        result: finalTotal,
                        success: isSuccess,
                        outcome: outcomeText,
                        critical: isCritical
                    };
                    
                    console.log('[DiceRoller] Fokus Check Result:', { roll: rollValue, mod: mod, total: finalTotal, success: isSuccess, critical: isCritical });
                } else {
                    // Normal roll - show breakdown
                    breakdownEl.style.display = '';
                }
                
                // Format modifier string with color
                let modStr = '';
                if (mod !== 0) {
                    const modClass = mod > 0 ? 'positive' : 'negative';
                    const modSign = mod > 0 ? '+' : '';
                    modStr = ` <span class="dice-result__mod dice-result__mod--${modClass}">${modSign}${mod}</span>`;
                }
                
                if (special === 'advantage') {
                    const baseResult = Math.max(rolls[0], rolls[1]);
                    breakdownEl.innerHTML = `[${rolls[0]}, ${rolls[1]}] → höchste: ${baseResult}${modStr}`;
                } else if (special === 'disadvantage') {
                    const baseResult = Math.min(rolls[0], rolls[1]);
                    breakdownEl.innerHTML = `[${rolls[0]}, ${rolls[1]}] → niedrigste: ${baseResult}${modStr}`;
                } else {
                    // Calculate base total (without modifier)
                    const baseTotal = rolls.reduce((a, b) => a + b, 0);
                    breakdownEl.innerHTML = `[${rolls.join(', ')}]${modStr} = ${total}`;
                }
                
                // Secret roll styling
                if (this.secretRoll) {
                    resultEl.classList.add('secret');
                }
                
                // Scan-line effect through arena
                arena.classList.add('resolving');
                setTimeout(() => arena.classList.remove('resolving'), 1500);
                
                // Critical/Fumble styling and effects
                if (isCritical === 'success') {
                    resultEl.classList.add('critical');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('success');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                } else if (isCritical === 'failure') {
                    resultEl.classList.add('fumble');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('failure');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                }
                
                resultEl.classList.add('visible');
                
                // Auto-hide result after 8 seconds
                this.resultTimeout = setTimeout(() => {
                    resultEl.classList.remove('visible', 'critical', 'fumble', 'secret', 'skill-success', 'skill-failure');
                    skillLabelEl.classList.remove('visible');
                    targetEl.classList.remove('visible');
                    outcomeEl.classList.remove('visible', 'success', 'failure');
                    backBtnEl.classList.remove('visible');
                    breakdownEl.style.display = '';
                    this.clearDiceLabels();
                    
                    // Reset skill check mode
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    
                    // Reset fokus check mode
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                }, 8000);
                
                // Build notation string for history (German W notation)
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        const wType = type.replace('d', 'W');
                        parts.push(`${count}${wType}`);
                    }
                }
                let histNotation = parts.join('+');
                if (mod !== 0) histNotation += (mod > 0 ? '+' : '') + mod;
                if (special) histNotation += ` (${special === 'advantage' ? 'V' : 'N'})`;
                
                // Add to history
                this.addToHistory({
                    player: playerName,
                    color: userData.color || '#FF4655',
                    total: finalTotal,
                    notation: histNotation,
                    rolls: displayRolls,
                    critical: isCritical,
                    secret: this.secretRoll,
                    special,
                    timestamp: Date.now()
                });
                
                // Sync to multiplayer
                this.syncRoll({
                    player: playerName,
                    playerId: userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || playerName,
                    color: userData.color || '#FF4655',
                    diceTheme: this.currentTheme || 'classic',
                    labelColor: this.currentLabelColor || 'auto',
                    total: finalTotal,
                    notation: histNotation,
                    results: displayRolls,
                    modifier: mod,
                    critical: isCritical,
                    secret: this.secretRoll,
                    timestamp: Date.now(),
                    diceConfig: {
                        notation: this.currentLibraryNotation,
                        results: displayRolls
                    }
                });
                
                this.isRolling = false;
            },
            
            checkCritical(rolls, special) {
                // Get the dice type being rolled
                const diceTypes = Object.entries(this.currentDice).filter(([type, count]) => count > 0);
                const isOnlyD20 = diceTypes.length === 1 && diceTypes[0][0] === 'd20' && diceTypes[0][1] === 1;
                const isOnlyD100 = diceTypes.length === 1 && diceTypes[0][0] === 'd100' && diceTypes[0][1] === 1;
                
                // D&D 5e: D20 critical
                if (isOnlyD20 || (special && diceTypes.some(([type]) => type === 'd20'))) {
                    // Nat 20 = Critical Success
                    if (rolls.length === 1 && rolls[0] === 20) return 'success';
                    if (rolls.length === 2 && special && (rolls[0] === 20 || rolls[1] === 20)) return 'success';
                    // Nat 1 = Critical Failure
                    if (rolls.length === 1 && rolls[0] === 1) return 'failure';
                    if (rolls.length === 2 && special && (rolls[0] === 1 || rolls[1] === 1)) return 'failure';
                }
                
                // Worlds Apart: D100 critical
                if (isOnlyD100) {
                    // 1 on d100 = Critical Success
                    if (rolls.length === 1 && rolls[0] === 1) return 'success';
                    // 100 on d100 = Critical Failure
                    if (rolls.length === 1 && rolls[0] === 100) return 'failure';
                }
                
                return false;
            },
            
            showCritFlash(type) {
                const flash = document.createElement('div');
                flash.className = `crit-flash crit-flash--${type}`;
                document.body.appendChild(flash);
                
                // Remove after animation
                setTimeout(() => {
                    flash.remove();
                }, 600);
            },
            
            // ========================================
            // MULTIPLAYER
            // ========================================
            
            initMultiplayer() {
                const roomCode = localStorage.getItem('rift_current_room');
                if (!roomCode || typeof firebase === 'undefined') {
                    console.log('[DiceRoller] No room or Firebase, skipping multiplayer');
                    return;
                }
                
                // Store normalized room code for Firestore
                this.roomCode = roomCode.replace(/-/g, '').toUpperCase();
                
                // Get current user for filtering
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                this.currentPlayerName = userData.name || 'Spieler';
                this.currentPlayerId = userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || userData.name || 'unknown_' + Date.now();
                
                console.log('[DiceRoller] Current player:', this.currentPlayerName, 'ID:', this.currentPlayerId);
                
                try {
                    this.roomRef = firebase.database().ref(`rooms/${roomCode}`);
                    this.diceRef = this.roomRef.child('dice_rolls');
                    this.statsRef = this.roomRef.child('dice_stats');
                    
                    // Initialize stats structure if not exists
                    this.statsRef.once('value', (snapshot) => {
                        if (!snapshot.exists()) {
                            this.statsRef.set({
                                totalRolls: 0,
                                criticalSuccesses: 0,
                                criticalFailures: 0,
                                sumOfTotals: 0,
                                maxRoll: null,
                                minRoll: null
                            });
                        }
                    });
                    
                    // Subscribe to stats changes
                    this.statsRef.on('value', (snapshot) => {
                        const stats = snapshot.val();
                        if (stats) {
                            this.roomStats = stats;
                            this.updateStatsDisplay(stats);
                        }
                    });
                    
                    // Listen for new rolls from ALL players
                    this.diceRef.orderByChild('timestamp').limitToLast(20).on('child_added', (snapshot) => {
                        const roll = snapshot.val();
                        if (!roll) return;
                        
                        // Skip old rolls (more than 30 seconds)
                        const rollAge = Date.now() - roll.timestamp;
                        if (rollAge > 30000) return;
                        
                        // Check if this is from another player
                        const isOwnRoll = (roll.playerId && roll.playerId === this.currentPlayerId) || 
                                          (!roll.playerId && roll.player === this.currentPlayerName);
                        
                        console.log('[DiceRoller] Roll received:', roll.player, '| Own:', isOwnRoll);
                        
                        if (!isOwnRoll) {
                            console.log('[DiceRoller] 🎲 REMOTE ROLL from', roll.player, ':', roll.notation, '=', roll.total);
                            this.handleRemoteRoll(roll);
                        }
                    });
                    
                    console.log('[DiceRoller] ✅ Multiplayer connected - listening for live rolls');
                } catch (e) {
                    console.error('[DiceRoller] Multiplayer init failed:', e);
                }
            },
            
            // Handle incoming roll from another player
            handleRemoteRoll(roll) {
                console.log('[DiceRoller] handleRemoteRoll:', roll);
                
                // Add to history
                this.addToHistory({
                    player: roll.player || 'Spieler',
                    color: roll.color || '#8b5cf6',
                    total: roll.total,
                    notation: roll.notation,
                    rolls: roll.results || [],
                    critical: roll.critical,
                    secret: roll.secret,
                    timestamp: roll.timestamp || Date.now(),
                    isRemote: true
                });
                
                // Execute 3D animation and show result
                this.executeRemoteRoll(roll);
            },
            
            // Execute 3D animation for a remote roll
            executeRemoteRoll(roll) {
                console.log('[DiceRoller] 🎲 executeRemoteRoll:', roll.player, roll.notation);
                
                // Clear any existing result timeout
                if (this.resultTimeout) {
                    clearTimeout(this.resultTimeout);
                    this.resultTimeout = null;
                }
                
                const arena = document.getElementById('diceArena');
                const resultEl = document.getElementById('diceResult');
                
                if (!arena || !resultEl) return;
                
                // Clear previous labels from last roll
                this.clearDiceLabels();
                
                // Remove empty state (for remote rolls too)
                arena.classList.remove('empty');
                
                // Create/show indicator
                let indicator = document.getElementById('remotePlayerIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'remotePlayerIndicator';
                    indicator.className = 'dice-remote-indicator';
                    arena.appendChild(indicator);
                }
                indicator.innerHTML = `<span style="color: ${roll.color || '#8b5cf6'}">${roll.player}</span> würfelt...`;
                indicator.classList.add('visible');
                
                // Clear previous
                resultEl.classList.remove('visible', 'critical', 'fumble', 'secret');
                arena.classList.add('throwing');
                
                const animationStartTime = Date.now();
                const MIN_ANIMATION_TIME = 2500; // Mindestens 2.5 Sekunden
                
                // Speichere EIGENE Würfelfarben und Zahlenfarbe
                const myDiceColor = this.currentDiceColor;
                const myDiceGradient = this.currentDiceGradient;
                const myLabelColor = this.currentLabelColor;
                
                const showResult = () => {
                    const elapsed = Date.now() - animationStartTime;
                    const remainingTime = Math.max(0, MIN_ANIMATION_TIME - elapsed);
                    
                    setTimeout(() => {
                        arena.classList.remove('throwing');
                        indicator.classList.remove('visible');
                        
                        // Stelle EIGENE Würfelfarben und Zahlenfarbe wieder her (für Card Previews)
                        if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                            DICE.setDiceColor(myDiceColor, myDiceGradient);
                        }
                        if (typeof DICE !== 'undefined' && typeof DICE.setLabelColor === 'function') {
                            DICE.setLabelColor(myLabelColor === 'auto' ? null : myLabelColor);
                        }
                        
                        // Show dice labels (Zahlen-Indikatoren) and pulse effects
                        const rawResults = roll.diceConfig?.rawResults || roll.rawResults || null;
                        this.showDiceLabels(roll.results || [], rawResults);
                        
                        // Use displayRollResult with remote player's data
                        this.displayRollResult(
                            roll.results || [],
                            roll.total,
                            roll.modifier || 0,
                            roll.critical,
                            roll.special,
                            roll.player,
                            roll.color
                        );
                    }, remainingTime);
                };
                
                // Try 3D animation with the SAME results
                if (this.box && roll.diceConfig && roll.diceConfig.notation && roll.diceConfig.rawResults) {
                    try {
                        // Setze temporär die Würfelfarbe und Zahlenfarbe des ANDEREN Spielers (NUR für diesen Wurf)
                        if (roll.diceTheme && typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                            const remoteColors = this.themeColors[roll.diceTheme] || this.themeColors.classic;
                            DICE.setDiceColor(remoteColors.accent, remoteColors.gradient || null);
                        }
                        if (roll.labelColor && typeof DICE !== 'undefined' && typeof DICE.setLabelColor === 'function') {
                            DICE.setLabelColor(roll.labelColor === 'auto' ? null : roll.labelColor);
                        }
                        
                        this.box.setDice(roll.diceConfig.notation);
                        
                        // before_roll gibt EXAKT die gleichen Ergebnisse zurück
                        const beforeRoll = () => roll.diceConfig.rawResults;
                        
                        let done = false;
                        this.box.start_throw(beforeRoll, () => {
                            if (done) return;
                            done = true;
                            showResult();
                        });
                        
                        // Fallback
                        setTimeout(() => { if (!done) { done = true; showResult(); } }, 8000);
                        return;
                    } catch (e) {
                        console.error('[DiceRoller] Remote 3D failed:', e);
                        // Bei Fehler: Eigene Farben und Zahlenfarbe wiederherstellen
                        if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                            DICE.setDiceColor(myDiceColor, myDiceGradient);
                        }
                        if (typeof DICE !== 'undefined' && typeof DICE.setLabelColor === 'function') {
                            DICE.setLabelColor(myLabelColor === 'auto' ? null : myLabelColor);
                        }
                    }
                }
                
                // Fallback: show result after delay
                setTimeout(showResult, MIN_ANIMATION_TIME);
            },
            
            syncRoll(rollData) {
                if (!this.diceRef) return;
                
                // Don't sync if secret and not GM
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                if (rollData.secret && !userData.isGM) {
                    return;
                }
                
                try {
                    // 1. Push to Realtime Database (for live feed)
                    this.diceRef.push(rollData);
                    
                    // 2. Also write to Firestore (for GM logs)
                    this.logRollToFirestore(rollData);
                } catch (e) {
                    console.error('[DiceRoller] Sync failed:', e);
                }
            },
            
            async logRollToFirestore(rollData) {
                if (!this.roomCode) return;
                
                try {
                    // Ensure Firestore is available
                    if (typeof firebase === 'undefined' || !firebase.firestore) {
                        console.log('[DiceRoller] Firestore not available for logging');
                        return;
                    }
                    
                    const db = firebase.firestore();
                    const diceCollection = db.collection('rooms').doc(this.roomCode).collection('dice');
                    
                    // Build log entry
                    const logEntry = {
                        player: rollData.player || 'Unbekannt',
                        playerId: rollData.playerId || null,
                        color: rollData.color || '#8b5cf6',
                        notation: rollData.notation || '',
                        total: rollData.total || 0,
                        results: rollData.results || [],
                        diceTheme: rollData.diceTheme || 'classic',
                        secret: rollData.secret || false,
                        critical: rollData.critical || null,
                        label: rollData.label || null,
                        success: rollData.success || null,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        clientTimestamp: rollData.timestamp || Date.now()
                    };
                    
                    await diceCollection.add(logEntry);
                    console.log('[DiceRoller] Roll logged to Firestore');
                    
                    // Send toast notification (only for non-secret rolls)
                    if (!logEntry.secret && window.RIFTToast?.send) {
                        const isSuccess = logEntry.critical === 'success' ? true : logEntry.critical === 'failure' ? false : null;
                        RIFTToast.diceRoll(logEntry.player, logEntry.total, logEntry.notation, isSuccess);
                    }
                    
                } catch (e) {
                    console.warn('[DiceRoller] Firestore log failed:', e);
                    // Don't throw - Firestore logging is optional
                }
            },
            
            showFeedItem(roll) {
                const feed = document.getElementById('diceFeed');
                if (!feed) return;
                
                // Don't show own rolls in feed
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                if (roll.player === userData.name) return;
                
                const item = document.createElement('div');
                let itemClass = 'dice-feed__item';
                if (roll.secret) itemClass += ' secret';
                if (roll.critical === 'success') itemClass += ' critical';
                if (roll.critical === 'failure') itemClass += ' fumble';
                item.className = itemClass;
                
                // Get dice theme color
                const themeColors = {
                    // Basic
                    classic: '#ffffff', blood: '#ff4655', ice: '#00d4ff', nature: '#4caf50', royal: '#9c27b0', gold: '#ffd700',
                    // Elemental
                    fire: '#ff5722', ocean: '#00ffff', toxic: '#39ff14', lava: '#ff4500', frost: '#a8e6ff',
                    storm: '#ffd700', earth: '#d2691e', shadow: '#4a4a4a',
                    // Gems & Metals  
                    ruby: '#ff1744', sapphire: '#2979ff', emerald: '#00e676', amethyst: '#e040fb',
                    diamond: '#ffffff', opal: '#ff9ff3', silver: '#c0c0c0', bronze: '#cd7f32',
                    platinum: '#e5e4e2', copper: '#cd7f32', obsidian: '#2d2d44',
                    // Fantasy
                    dragon: '#ff4500', necro: '#00ff00', fey: '#98fb98', infernal: '#ff0000',
                    celestial: '#ffd700', eldritch: '#7b68ee',
                    // Cosmic & Nature
                    nebula: '#ff6bcb', void: '#8b5cf6', galaxy: '#dda0dd', aurora: '#00ff7f',
                    sunset: '#ff7e5f', bloodmoon: '#dc143c', forest: '#228b22', cherry: '#ffb7c5', autumn: '#ff8c00',
                    // Tech & Retro
                    cyber: '#00ffff', midnight: '#b8c6db', matrix: '#00ff00', hologram: '#00ffff',
                    plasma: '#ff00ff', neon: '#ff1493', synthwave: '#ff6ec7', steampunk: '#b87333', vaporwave: '#ff71ce',
                    // Fun & Special
                    rainbow: '#ff6b6b', candy: '#ff69b4', prism: '#ff0000', bubblegum: '#ff77aa',
                    coral: '#ff7f50', lavender: '#e6e6fa', mint: '#98ff98', peach: '#ffcba4',
                    // Textured
                    marbleWhite: '#f5f5f5', marbleBlack: '#424242', marbleGreen: '#4caf50', marbleRose: '#f48fb1',
                    woodOak: '#8d6e63', woodCherry: '#a1887f', woodEbony: '#2d2d2d',
                    stoneGranite: '#9e9e9e', stoneSandstone: '#d7ccc8',
                    // Glitter
                    glitterGold: '#ffd700', glitterSilver: '#cfd8dc', glitterRose: '#f8bbd9',
                    glitterBlue: '#64b5f6', glitterPurple: '#ce93d8',
                    // Patterns
                    stripesRed: '#ef5350', stripesBlue: '#64b5f6', stripesGreen: '#81c784',
                    polkaDots: '#f8bbd9', polkaBlack: '#424242',
                    checkerRed: '#f44336', checkerGreen: '#66bb6a',
                    camoForest: '#8bc34a', camoDesert: '#d7ccc8', camoArctic: '#eceff1',
                    waveOcean: '#4fc3f7', waveAqua: '#80deea',
                    hexTech: '#42a5f5', hexGold: '#ffc107',
                    dragonScales: '#4caf50', fishScales: '#4dd0e1',
                    // Special Effects
                    starryNight: '#3f51b5', galaxy2: '#9c27b0', thunderstorm: '#78909c', electricBlue: '#29b6f6',
                    // Metallic
                    chrome: '#e0e0e0', titanium: '#78909c', rosegold: '#e8b4a6', brushedSteel: '#bdbdbd',
                    rust: '#e64a19', patina: '#4db6ac',
                    // Food
                    chocolate: '#6d4c41', caramel: '#ffa726', strawberry: '#ef5350', blueberry: '#7986cb',
                    grape: '#ab47bc', lemon: '#ffee58', lime: '#aed581', orange2: '#ffa726',
                    // Seasonal
                    springBlossom: '#f48fb1', summerSun: '#ffc107', autumnLeaves: '#ff7043', winterFrost: '#e1f5fe',
                    christmas: '#2e7d32', halloween: '#ff9800', valentine: '#f48fb1',
                    // Gaming
                    critSuccess: '#ffc107', critFail: '#b71c1c', lucky: '#81c784',
                    cursed: '#7b1fa2', blessed: '#fff59d', ethereal: '#b2ebf2',
                    // Dark
                    charcoal: '#37474f', slate: '#78909c', graphite: '#616161', carbon: '#303030', onyx: '#1a1a1a',
                    // Pastel
                    pastelPink: '#f8bbd9', pastelBlue: '#b3e5fc', pastelGreen: '#c8e6c9',
                    pastelYellow: '#fff9c4', pastelPurple: '#e1bee7', pastelRainbow: '#ffcdd2',
                    // Nature Extended
                    deepSea: '#0277bd', coralReef: '#ff8a65', jungle: '#66bb6a', desert: '#deb887',
                    volcanic: '#ff5722', arctic: '#b3e5fc', tundra: '#b0bec5', swamp: '#7cb342'
                };
                const diceColor = themeColors[roll.diceTheme] || '#ffffff';
                
                const initial = roll.player.charAt(0).toUpperCase();
                const critIndicator = roll.critical === 'success' ? '!' : (roll.critical === 'failure' ? '💀' : '');
                
                item.innerHTML = `
                    <div class="dice-feed__avatar" style="background: ${roll.color}">${initial}</div>
                    <div class="dice-feed__info">
                        <div class="dice-feed__name" style="color: ${roll.color}">${roll.player}</div>
                        <div class="dice-feed__roll">${roll.notation} <span class="dice-feed__dice-color" style="background: ${diceColor}"></span></div>
                    </div>
                    <div class="dice-feed__result">${roll.secret ? '?' : roll.total}${critIndicator}</div>
                `;
                
                feed.insertBefore(item, feed.firstChild);
                
                // Trigger effects for critical rolls from other players
                if (roll.critical === 'success' || roll.critical === 'failure') {
                    const arena = document.getElementById('diceArena');
                    if (arena) {
                        arena.classList.add('shake');
                        this.spawnParticles(30);
                        this.showCritFlash(roll.critical);
                        setTimeout(() => arena.classList.remove('shake'), 500);
                    }
                }
                
                // Remove after 10s
                setTimeout(() => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateX(20px)';
                    setTimeout(() => item.remove(), 300);
                }, 10000);
                
                // Keep max 5 items
                while (feed.children.length > 5) {
                    feed.lastChild.remove();
                }
            },
            
            // ========================================
            // DICE VALUE LABELS
            // ========================================
            
            clearDiceLabels() {
                const container = document.getElementById('diceLabels');
                const pulseContainer = document.getElementById('dicePulses');
                if (container) container.innerHTML = '';
                if (pulseContainer) pulseContainer.innerHTML = '';
            },
            
            showDiceLabels(rolls, rawRolls = null) {
                this.clearDiceLabels();
                
                if (!this.box) return;
                
                const container = document.getElementById('diceLabels');
                const pulseContainer = document.getElementById('dicePulses');
                if (!container) return;
                
                // Clear pulse container
                if (pulseContainer) pulseContainer.innerHTML = '';
                
                // Get screen positions from the library
                const positions = this.box.getDiceScreenPositions();
                if (!positions || positions.length === 0) return;
                
                console.log('[DiceRoller] Dice positions:', positions);
                console.log('[DiceRoller] Rolls to display:', rolls, 'Raw:', rawRolls);
                
                // Use rawRolls if available (for d100 we need the individual dice values)
                const valuesToShow = rawRolls || rolls;
                
                // Create labels and pulses for each die
                for (let i = 0; i < Math.min(positions.length, valuesToShow.length); i++) {
                    const pos = positions[i];
                    const value = valuesToShow[i];
                    
                    if (pos.x < 0 || pos.y < 0) continue; // Skip if off-screen
                    
                    // Create pulse effect in separate container (UNDER dice)
                    // Multiple rings for better effect
                    if (pulseContainer) {
                        for (let r = 0; r < 4; r++) {
                            const pulse = document.createElement('div');
                            pulse.className = `dice-pulse dice-pulse--${pos.type}`;
                            pulse.style.left = `${pos.x}px`;
                            pulse.style.top = `${pos.y + 20}px`;
                            pulse.style.animationDelay = `${i * 0.08 + r * 0.1}s`;
                            pulseContainer.appendChild(pulse);
                        }
                    }
                    
                    // Create label
                    const label = document.createElement('div');
                    label.className = `dice-label dice-label--${pos.type}`;
                    
                    // Check for critical (nat 20 or nat 1 on d20)
                    if (pos.type === 'd20' && value === 20) {
                        label.classList.add('dice-label--crit-success');
                    } else if (pos.type === 'd20' && value === 1) {
                        label.classList.add('dice-label--crit-failure');
                    }
                    
                    // Format value for display
                    let displayValue = value;
                    if (pos.type === 'd100') {
                        // Tens die: 0, 10, 20... display as "00", "10", "20"...
                        displayValue = value === 0 ? '00' : value;
                    } else if (pos.type === 'd10') {
                        // Ones die: library returns 1-10, display 0-9 (10 becomes 0)
                        displayValue = value === 10 ? '0' : value;
                    }
                    
                    label.textContent = displayValue;
                    label.style.left = `${pos.x}px`;
                    label.style.top = `${pos.y}px`;
                    label.style.animationDelay = `${i * 0.1}s`;
                    
                    container.appendChild(label);
                }
            },
            
            // ========================================
            // PARTICLES
            // ========================================
            
            spawnParticles(count = 20) {
                const container = document.getElementById('particlesContainer');
                if (!container) return;
                
                const colors = ['#FF4655', '#FF6B6B', '#FFE66D', '#4ECDC4', '#45B7D1', '#DDA0DD'];
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'dice-particle';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 80 + Math.random() * 120;
                    
                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                    particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                    particle.style.width = particle.style.height = `${5 + Math.random() * 8}px`;
                    
                    container.appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }
            },
            
            // ========================================
            // UI
            // ========================================
            
            updateUI() {
                // Update button counts
                ['d4', 'd6', 'd8', 'd10', 'd12', 'd20', 'd100'].forEach(type => {
                    const countEl = document.getElementById(`count-${type}`);
                    const btn = document.querySelector(`.dice-btn[data-dice="${type}"]`);
                    const count = this.currentDice[type] || 0;
                    
                    if (countEl) countEl.textContent = count;
                    if (btn) {
                        const hadCount = btn.classList.contains('has-count');
                        btn.classList.toggle('has-count', count > 0);
                        
                        // Start/stop particles
                        if (count > 0 && !hadCount) {
                            this.startParticles(btn);
                        } else if (count === 0 && hadCount) {
                            this.stopParticles(btn);
                        }
                    }
                });
                
                // Update roll button
                const btn = document.getElementById('rollBtn');
                const hasInput = document.getElementById('notationInput').value.trim().length > 0;
                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                btn.disabled = !hasInput && !hasDice;
            },
            
            // Partikel-System
            particleIntervals: {},
            
            startParticles(btn) {
                const container = btn.querySelector('.dice-btn__particles');
                if (!container) return;
                
                const type = btn.dataset.dice;
                
                // Spawn particles mit variablem Timing
                const spawnLoop = () => {
                    if (!btn.classList.contains('has-count')) {
                        this.stopParticles(btn);
                        return;
                    }
                    this.spawnParticle(container);
                    
                    // Nächster Spawn in 250-500ms
                    const nextSpawn = 250 + Math.random() * 250;
                    this.particleIntervals[type] = setTimeout(spawnLoop, nextSpawn);
                };
                
                this.particleIntervals[type] = setTimeout(spawnLoop, 100);
                
                // Spawn first few immediately
                this.spawnParticle(container);
                setTimeout(() => this.spawnParticle(container), 80);
                setTimeout(() => this.spawnParticle(container), 180);
            },
            
            stopParticles(btn) {
                const type = btn.dataset.dice;
                if (this.particleIntervals[type]) {
                    clearTimeout(this.particleIntervals[type]);
                    delete this.particleIntervals[type];
                }
            },
            
            spawnParticle(container) {
                const particle = document.createElement('div');
                particle.className = 'dice-btn__particle';
                
                // Random position innerhalb des Containers (über dem Counter)
                const xPos = Math.random() * 35; // 0-35px von links im Container
                const size = 2 + Math.random() * 2.5; // 2-4.5px
                const duration = 1.8 + Math.random() * 1.2; // 1.8-3s
                const delay = Math.random() * 0.15;
                const drift = -10 + Math.random() * 20; // -10 bis +10px seitlich
                
                particle.style.cssText = `
                    left: ${xPos}px;
                    top: 0;
                    width: ${size}px;
                    height: ${size}px;
                    --drift: ${drift}px;
                    animation: particleFloat ${duration}s ease-out ${delay}s forwards;
                `;
                
                container.appendChild(particle);
                
                // Remove after animation
                setTimeout(() => particle.remove(), (duration + delay) * 1000 + 100);
            },
            
            // ========================================
            // HISTORY
            // ========================================
            
            addToHistory(roll) {
                this.history.unshift(roll);
                if (this.history.length > 50) this.history = this.history.slice(0, 50);
                this.saveHistory();
                this.renderHistory();
                
                // Update Firebase stats if connected (only for own rolls, not remote)
                if (this.statsRef && !roll.isRemote) {
                    this.updateFirebaseStats(roll);
                } else {
                    this.updateStats();
                }
            },
            
            // Update room-wide stats in Firebase
            updateFirebaseStats(roll) {
                if (!this.statsRef) return;
                
                this.statsRef.transaction((currentStats) => {
                    if (!currentStats) {
                        currentStats = {
                            totalRolls: 0,
                            criticalSuccesses: 0,
                            criticalFailures: 0,
                            sumOfTotals: 0,
                            maxRoll: null,
                            minRoll: null
                        };
                    }
                    
                    currentStats.totalRolls = (currentStats.totalRolls || 0) + 1;
                    currentStats.sumOfTotals = (currentStats.sumOfTotals || 0) + roll.total;
                    
                    if (roll.critical === 'success') {
                        currentStats.criticalSuccesses = (currentStats.criticalSuccesses || 0) + 1;
                    }
                    if (roll.critical === 'failure') {
                        currentStats.criticalFailures = (currentStats.criticalFailures || 0) + 1;
                    }
                    
                    if (currentStats.maxRoll === null || roll.total > currentStats.maxRoll) {
                        currentStats.maxRoll = roll.total;
                    }
                    if (currentStats.minRoll === null || roll.total < currentStats.minRoll) {
                        currentStats.minRoll = roll.total;
                    }
                    
                    return currentStats;
                });
            },
            
            // Update UI with room stats
            updateStatsDisplay(stats) {
                const totalEl = document.getElementById('statTotal');
                const avgEl = document.getElementById('statAvg');
                const critsEl = document.getElementById('statCrits');
                const fumblesEl = document.getElementById('statFumbles');
                const maxEl = document.getElementById('statMax');
                const minEl = document.getElementById('statMin');
                
                if (!totalEl) return;
                
                totalEl.textContent = stats.totalRolls || 0;
                
                if (stats.totalRolls === 0) {
                    avgEl.textContent = '-';
                    critsEl.textContent = '0';
                    fumblesEl.textContent = '0';
                    maxEl.textContent = '-';
                    minEl.textContent = '-';
                    return;
                }
                
                const avg = (stats.sumOfTotals / stats.totalRolls).toFixed(1);
                avgEl.textContent = avg;
                critsEl.textContent = stats.criticalSuccesses || 0;
                fumblesEl.textContent = stats.criticalFailures || 0;
                maxEl.textContent = stats.maxRoll !== null ? stats.maxRoll : '-';
                minEl.textContent = stats.minRoll !== null ? stats.minRoll : '-';
            },
            
            // Reset room stats
            resetStats() {
                if (this.statsRef) {
                    // Reset Firebase stats
                    this.statsRef.set({
                        totalRolls: 0,
                        criticalSuccesses: 0,
                        criticalFailures: 0,
                        sumOfTotals: 0,
                        maxRoll: null,
                        minRoll: null
                    });
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.show('Statistiken zurückgesetzt', 'success');
                    }
                } else {
                    // Reset local stats
                    this.history = [];
                    this.saveHistory();
                    this.renderHistory();
                    this.updateStats();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.show('Lokale Statistiken zurückgesetzt', 'success');
                    }
                }
            },
            
            renderHistory() {
                const list = document.getElementById('historyList');
                if (!list) return;
                
                if (this.history.length === 0) {
                    list.innerHTML = '<div class="dice-history__empty">Noch keine Würfe</div>';
                    return;
                }
                
                list.innerHTML = this.history.slice(0, 15).map(roll => {
                    const time = new Date(roll.timestamp);
                    const timeStr = time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    let critClass = '';
                    let critIndicator = '';
                    if (roll.critical === 'success') {
                        critClass = ' dice-history__item--crit';
                        critIndicator = '!';
                    } else if (roll.critical === 'failure') {
                        critClass = ' dice-history__item--fumble';
                        critIndicator = '💀';
                    } else if (roll.critical === true) {
                        // Legacy support
                        critClass = ' dice-history__item--crit';
                        critIndicator = '!';
                    }
                    const playerName = roll.player || 'Spieler';
                    const playerColor = roll.color || '#FF4655';
                    
                    return `
                        <div class="dice-history__item${critClass}" title="${playerName} • ${roll.notation} • ${timeStr}">
                            <div class="dice-history__player" style="color: ${playerColor}">${playerName}</div>
                            <div class="dice-history__value">${roll.total}${critIndicator}</div>
                            <div class="dice-history__notation">${roll.notation}</div>
                        </div>
                    `;
                }).join('');
            },
            
            // ========================================
            // PERSISTENCE
            // ========================================
            
            loadSettings() {
                // Sound
                this.soundEnabled = localStorage.getItem('rift_dice_sound') !== 'false';
                window.RIFT_DICE_SOUND = this.soundEnabled;
                document.getElementById('soundToggle')?.classList.toggle('active', this.soundEnabled);
                document.getElementById('soundToggle2')?.classList.toggle('active', this.soundEnabled);
            },
            
            saveHistory() {
                localStorage.setItem('rift_dice_history', JSON.stringify(this.history));
            },
            
            loadHistory() {
                try {
                    this.history = JSON.parse(localStorage.getItem('rift_dice_history') || '[]');
                } catch { this.history = []; }
                this.renderHistory();
                this.updateStats();
            },
            
            clearHistory() {
                this.history = [];
                this.saveHistory();
                this.renderHistory();
                this.updateStats();
                if (typeof showToast === 'function') showToast('Verlauf gelöscht', 'info');
            },
            
            statsPopupOpen: false,
            hotkeysPopupOpen: false,
            
            toggleStatsPopup() {
                this.statsPopupOpen = !this.statsPopupOpen;
                const popup = document.getElementById('statsPopup');
                const btn = document.getElementById('statsBtn');
                const overlay = document.getElementById('diceSettingsOverlay');
                
                // Close other popups
                if (this.statsPopupOpen) {
                    this.closeAllPopups('stats');
                }
                
                if (this.statsPopupOpen) {
                    popup?.classList.add('open');
                    btn?.classList.add('active');
                    overlay?.classList.add('open');
                    this.updateStats();
                } else {
                    popup?.classList.remove('open');
                    btn?.classList.remove('active');
                    overlay?.classList.remove('open');
                }
            },
            
            toggleHotkeysPopup() {
                this.hotkeysPopupOpen = !this.hotkeysPopupOpen;
                const popup = document.getElementById('hotkeysPopup');
                const btn = document.getElementById('hotkeysBtn');
                const overlay = document.getElementById('diceSettingsOverlay');
                
                // Close other popups
                if (this.hotkeysPopupOpen) {
                    this.closeAllPopups('hotkeys');
                }
                
                if (this.hotkeysPopupOpen) {
                    popup?.classList.add('open');
                    btn?.classList.add('active');
                    overlay?.classList.add('open');
                } else {
                    popup?.classList.remove('open');
                    btn?.classList.remove('active');
                    overlay?.classList.remove('open');
                }
            },
            
            closeAllPopups(except = null) {
                if (except !== 'stats') {
                    this.statsPopupOpen = false;
                    document.getElementById('statsPopup')?.classList.remove('open');
                    document.getElementById('statsBtn')?.classList.remove('active');
                }
                if (except !== 'hotkeys') {
                    this.hotkeysPopupOpen = false;
                    document.getElementById('hotkeysPopup')?.classList.remove('open');
                    document.getElementById('hotkeysBtn')?.classList.remove('active');
                }
                if (except !== 'settings') {
                    document.getElementById('settingsPopup')?.classList.remove('open');
                    document.getElementById('settingsBtn')?.classList.remove('active');
                }
                // Only close overlay if ALL popups are closed
                if (!except) {
                    document.getElementById('diceSettingsOverlay')?.classList.remove('open');
                }
            },
            
            updateStats() {
                // If we have room stats from Firebase, use those instead
                if (this.roomStats) {
                    this.updateStatsDisplay(this.roomStats);
                    return;
                }
                
                // Fallback to local history stats
                const totalEl = document.getElementById('statTotal');
                const avgEl = document.getElementById('statAvg');
                const critsEl = document.getElementById('statCrits');
                const fumblesEl = document.getElementById('statFumbles');
                const maxEl = document.getElementById('statMax');
                const minEl = document.getElementById('statMin');
                
                if (!totalEl) return;
                
                totalEl.textContent = this.history.length;
                
                if (this.history.length === 0) {
                    avgEl.textContent = '-';
                    critsEl.textContent = '0';
                    fumblesEl.textContent = '0';
                    maxEl.textContent = '-';
                    minEl.textContent = '-';
                    return;
                }
                
                const totals = this.history.map(r => r.total);
                const avg = (totals.reduce((a, b) => a + b, 0) / totals.length).toFixed(1);
                const crits = this.history.filter(r => r.critical === 'success').length;
                const fumbles = this.history.filter(r => r.critical === 'failure').length;
                const max = Math.max(...totals);
                const min = Math.min(...totals);
                
                avgEl.textContent = avg;
                critsEl.textContent = crits;
                fumblesEl.textContent = fumbles;
                maxEl.textContent = max;
                minEl.textContent = min;
            },
            
            exportHistory() {
                if (this.history.length === 0) {
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Keine Würfe zum Exportieren');
                    }
                    return;
                }
                
                // Build text format
                const lines = ['RIFT Würfel-Protokoll', '=' .repeat(40), ''];
                
                const now = new Date();
                lines.push(`Exportiert: ${now.toLocaleDateString('de-DE')} ${now.toLocaleTimeString('de-DE')}`);
                lines.push(`Anzahl Würfe: ${this.history.length}`);
                lines.push('');
                lines.push('-'.repeat(40));
                lines.push('');
                
                this.history.forEach((roll, i) => {
                    const time = new Date(roll.timestamp).toLocaleTimeString('de-DE');
                    const critMarker = roll.critical === 'success' ? ' ⭐ KRITISCH!' : 
                                       roll.critical === 'failure' ? ' 💀 PATZER!' : '';
                    lines.push(`[${time}] ${roll.player}: ${roll.notation} = ${roll.total}${critMarker}`);
                });
                
                lines.push('');
                lines.push('-'.repeat(40));
                
                // Calculate stats
                const totals = this.history.map(r => r.total);
                const avg = (totals.reduce((a, b) => a + b, 0) / totals.length).toFixed(1);
                const max = Math.max(...totals);
                const min = Math.min(...totals);
                const crits = this.history.filter(r => r.critical === 'success').length;
                const fumbles = this.history.filter(r => r.critical === 'failure').length;
                
                lines.push('');
                lines.push('STATISTIK');
                lines.push(`Durchschnitt: ${avg}`);
                lines.push(`Maximum: ${max}`);
                lines.push(`Minimum: ${min}`);
                lines.push(`Kritische Erfolge: ${crits}`);
                lines.push(`Kritische Fehlschläge: ${fumbles}`);
                
                // Create download
                const text = lines.join('\n');
                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rift-wuerfel-${now.toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success('Verlauf exportiert');
                }
            }
        };
        
        // Global function for back button
        function goBackToSheet() {
            if (DiceRoller.returnUrl) {
                // Build URL with result parameters if we have a check result
                let url = DiceRoller.returnUrl;
                
                if (DiceRoller.lastCheckResult) {
                    const r = DiceRoller.lastCheckResult;
                    const params = new URLSearchParams();
                    params.set('result', r.result);
                    params.set('label', r.label);
                    params.set('success', r.success);
                    params.set('outcome', r.outcome);
                    if (r.critical) params.set('critical', 'true');
                    if (r.zweiteChance) {
                        params.set('zweiteChance', 'true');
                        params.set('diceIndex', r.diceIndex);
                    }
                    
                    // Append to URL
                    const separator = url.includes('?') ? '&' : '?';
                    url += separator + params.toString();
                }
                
                window.location.href = url;
            }
        }
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        initUnifiedLayout();
        
        // Init after layout is ready
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                DiceRoller.init();
            });
        });
        
        // Update UI when notation input changes
        document.getElementById('notationInput')?.addEventListener('input', (e) => {
            // Parse as user types
            DiceRoller.parseDiceFromNotation(e.target.value);
        });
        
        // ========================================
        // DICE PREVIEW - 3D rotating dice in buttons
        // ========================================
        const DicePreview = {
            previews: [],
            animationId: null,
            
            init() {
                console.log('DicePreview init starting...');
                
                // Check if THREE is available
                if (typeof THREE === 'undefined') {
                    console.error('THREE.js not loaded!');
                    return;
                }
                
                const canvases = document.querySelectorAll('.dice-btn__canvas');
                console.log('Found canvases:', canvases.length);
                
                canvases.forEach((canvas, index) => {
                    const type = canvas.dataset.type;
                    console.log('Creating preview for:', type);
                    try {
                        this.createPreview(canvas, type);
                    } catch(e) {
                        console.error('Error creating preview for ' + type, e);
                    }
                });
                
                if (this.previews.length > 0) {
                    this.animate();
                    console.log('Animation started with', this.previews.length, 'previews');
                }
            },
            
            createPreview(canvas, type) {
                const size = 100;
                
                // Set canvas size
                canvas.width = size * 2;
                canvas.height = size * 2;
                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
                canvas.style.display = 'block';
                
                // Create renderer
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true, 
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                renderer.setSize(size * 2, size * 2);
                renderer.setPixelRatio(1);
                renderer.setClearColor(0x000000, 0);
                renderer.sortObjects = true;
                
                // Create scene
                const scene = new THREE.Scene();
                
                // Create camera - adjusted for DICE library scale
                const camera = new THREE.PerspectiveCamera(28, 1, 1, 1000);
                const cameraDistance = type === 'd100' ? 220 : 180;
                camera.position.set(0, 0, cameraDistance);
                camera.lookAt(0, 0, 0);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                directionalLight.position.set(50, 50, 80);
                scene.add(directionalLight);
                
                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-30, -30, -50);
                scene.add(backLight);
                
                let mesh;
                let isD100 = type === 'd100';
                
                // Use DICE library to create real dice with proper face textures
                if (typeof DICE !== 'undefined' && DICE.createPreviewDice) {
                    if (isD100) {
                        // D100: Two dice - tens (d100) and ones (d10)
                        mesh = new THREE.Group();
                        
                        const tensDice = DICE.createPreviewDice('d100', 0.7);
                        const onesDice = DICE.createPreviewDice('d10', 0.7);
                        
                        if (tensDice && onesDice) {
                            tensDice.position.x = -25;
                            onesDice.position.x = 25;
                            
                            // Random starting rotation
                            tensDice.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI);
                            onesDice.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI);
                            
                            mesh.add(tensDice);
                            mesh.add(onesDice);
                            mesh.userData.dice = [tensDice, onesDice];
                        }
                    } else {
                        mesh = DICE.createPreviewDice(type, 0.8);
                        if (mesh) {
                            // Random starting rotation
                            mesh.rotation.x = Math.random() * Math.PI * 2;
                            mesh.rotation.y = Math.random() * Math.PI * 2;
                            mesh.rotation.z = Math.random() * Math.PI;
                        }
                    }
                }
                
                // Fallback to simple geometry if DICE not available
                if (!mesh) {
                    console.warn('DICE.createPreviewDice not available, using fallback');
                    const geometry = this.createGeometry(type);
                    const material = this.createThemedMaterial(type);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI);
                }
                
                scene.add(mesh);
                
                // Store preview data
                this.previews.push({
                    renderer,
                    scene,
                    camera,
                    mesh,
                    type,
                    isD100,
                    rotationSpeed: {
                        x: 0.0005 + Math.random() * 0.0005,
                        y: 0.0008 + Math.random() * 0.0005,
                        z: 0.0003 + Math.random() * 0.0003
                    }
                });
                
                // Initial render
                renderer.render(scene, camera);
            },
            
            createGeometry(type) {
                switch(type) {
                    case 'd4':
                        return new THREE.TetrahedronGeometry(1.1);
                    case 'd6':
                        return new THREE.BoxGeometry(1.0, 1.0, 1.0);
                    case 'd8':
                        return new THREE.OctahedronGeometry(0.95);
                    case 'd10':
                        return this.createD10Geometry(0.85);
                    case 'd100':
                        return null; // Handled separately
                    case 'd12':
                        return new THREE.DodecahedronGeometry(0.95);
                    case 'd20':
                        return new THREE.IcosahedronGeometry(1.0);
                    default:
                        return new THREE.BoxGeometry(1.0, 1.0, 1.0);
                }
            },
            
            // Special handling for D100 (two D10s)
            createD100Group() {
                const group = new THREE.Group();
                
                // Left D10 (tens: 00) - mit "00" Textur
                const material1 = this.createThemedMaterial('d10_tens');
                const geom1 = this.createD10Geometry(0.7);
                const mesh1 = new THREE.Mesh(geom1, material1);
                mesh1.position.x = -0.6;
                mesh1.renderOrder = 0;
                
                // Add edges
                const edges1 = new THREE.EdgesGeometry(geom1, 1);
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.15,
                    depthTest: true
                });
                const lines1 = new THREE.LineSegments(edges1, lineMat);
                lines1.renderOrder = 1;
                mesh1.add(lines1);
                
                // Right D10 (ones: 0) - mit "0" Textur
                const material2 = this.createThemedMaterial('d10');
                const geom2 = this.createD10Geometry(0.7);
                const mesh2 = new THREE.Mesh(geom2, material2);
                mesh2.position.x = 0.6;
                mesh2.renderOrder = 0;
                
                // Add edges
                const edges2 = new THREE.EdgesGeometry(geom2, 1);
                const lines2 = new THREE.LineSegments(edges2, lineMat.clone());
                lines2.renderOrder = 1;
                mesh2.add(lines2);
                
                // Different starting rotations
                mesh1.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                mesh2.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                
                group.add(mesh1);
                group.add(mesh2);
                
                // Store references for individual rotation
                group.userData.dice = [mesh1, mesh2];
                
                return group;
            },
            
            // D10 - Pentagonal Bipyramid
            createD10Geometry(radius) {
                const geometry = new THREE.Geometry();
                const sides = 5;
                const h = radius * 1.3;
                
                // Top vertex (index 0)
                geometry.vertices.push(new THREE.Vector3(0, h, 0));
                
                // Middle ring (indices 1-5)
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    geometry.vertices.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }
                
                // Bottom vertex (index 6)
                geometry.vertices.push(new THREE.Vector3(0, -h, 0));
                
                // Top faces (counter-clockwise when viewed from outside)
                for (let i = 0; i < sides; i++) {
                    const next = (i + 1) % sides;
                    geometry.faces.push(new THREE.Face3(0, 1 + next, 1 + i));
                }
                
                // Bottom faces (counter-clockwise when viewed from outside)
                for (let i = 0; i < sides; i++) {
                    const next = (i + 1) % sides;
                    geometry.faces.push(new THREE.Face3(6, 1 + i, 1 + next));
                }
                
                geometry.computeFaceNormals();
                geometry.computeVertexNormals();
                
                return geometry;
            },
            
            // Get current theme color for preview dice
            getThemeColor() {
                // Try to get color from DiceRoller's current theme
                if (typeof DiceRoller !== 'undefined' && DiceRoller.currentDiceColor) {
                    // Convert hex string to number
                    const hex = DiceRoller.currentDiceColor.replace('#', '');
                    return parseInt(hex, 16);
                }
                // Default: nice purple/violet color
                return 0x8B5CF6;
            },
            
            // Get full theme data including gradient
            getThemeData() {
                if (typeof DiceRoller !== 'undefined' && DiceRoller.currentTheme && DiceRoller.themeColors) {
                    return DiceRoller.themeColors[DiceRoller.currentTheme] || null;
                }
                return null;
            },
            
            // Get typical number for each dice type
            getDiceNumber(type) {
                const numbers = {
                    'd4': '4',
                    'd6': '6', 
                    'd8': '8',
                    'd10': '0',
                    'd10_tens': '00',
                    'd12': '12',
                    'd20': '20',
                    'd100': '' // D100 hat zwei Würfel
                };
                return numbers[type] || '';
            },
            
            // Determine if text should be dark based on background brightness
            getTextColor(colors) {
                if (!colors || !colors[0]) return '#ffffff';
                const hex = colors[0].replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                return brightness > 160 ? '#1a1a1a' : '#ffffff';
            },
            
            // Apply texture overlay (stripes, dots, marble, etc.)
            applyTexture(ctx, width, height, texture, colors) {
                ctx.save();
                
                switch(texture) {
                    case 'stripes':
                        ctx.globalCompositeOperation = 'overlay';
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = width / 15;
                        for (let i = -height; i < width + height; i += width / 8) {
                            ctx.beginPath();
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i + height, height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'dots':
                        ctx.globalCompositeOperation = 'overlay';
                        const dotSize = width / 25;
                        const spacing = width / 10;
                        for (let x = spacing/2; x < width; x += spacing) {
                            for (let y = spacing/2; y < height; y += spacing) {
                                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                                ctx.beginPath();
                                ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    case 'noise':
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const data = imageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                            const noise = (Math.random() - 0.5) * 45;
                            data[i] = Math.min(255, Math.max(0, data[i] + noise));
                            data[i+1] = Math.min(255, Math.max(0, data[i+1] + noise));
                            data[i+2] = Math.min(255, Math.max(0, data[i+2] + noise));
                        }
                        ctx.putImageData(imageData, 0, 0);
                        break;
                        
                    case 'marble':
                        for (let v = 0; v < 12; v++) {
                            ctx.globalCompositeOperation = 'overlay';
                            ctx.strokeStyle = v % 2 === 0 ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.15)';
                            ctx.lineWidth = 1 + Math.random() * 3;
                            ctx.beginPath();
                            let startX = Math.random() * width;
                            let startY = Math.random() * height;
                            ctx.moveTo(startX, startY);
                            for (let j = 0; j < 6; j++) {
                                const cpX = startX + (Math.random() - 0.5) * width * 0.5;
                                const cpY = startY + (Math.random() - 0.5) * height * 0.5;
                                const endX = startX + (Math.random() - 0.5) * width * 0.7;
                                const endY = startY + (Math.random() - 0.5) * height * 0.7;
                                ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                                startX = endX; startY = endY;
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'sparkle':
                        ctx.globalCompositeOperation = 'screen';
                        for (let i = 0; i < 45; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = Math.random() * 4 + 1.5;
                            const alpha = Math.random() * 0.7 + 0.2;
                            ctx.fillStyle = 'rgba(255,255,255,' + alpha + ')';
                            ctx.beginPath();
                            ctx.moveTo(x, y - size);
                            ctx.lineTo(x + size * 0.25, y - size * 0.25);
                            ctx.lineTo(x + size, y);
                            ctx.lineTo(x + size * 0.25, y + size * 0.25);
                            ctx.lineTo(x, y + size);
                            ctx.lineTo(x - size * 0.25, y + size * 0.25);
                            ctx.lineTo(x - size, y);
                            ctx.lineTo(x - size * 0.25, y - size * 0.25);
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                        
                    case 'cracks':
                        ctx.globalCompositeOperation = 'overlay';
                        for (let c = 0; c < 8; c++) {
                            ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            let cx = Math.random() * width;
                            let cy = Math.random() * height;
                            ctx.moveTo(cx, cy);
                            for (let s = 0; s < 5; s++) {
                                cx += (Math.random() - 0.5) * width * 0.25;
                                cy += (Math.random() - 0.5) * height * 0.25;
                                ctx.lineTo(cx, cy);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'wood':
                        ctx.globalCompositeOperation = 'overlay';
                        for (let r = 0; r < 15; r++) {
                            ctx.strokeStyle = r % 2 === 0 ? 'rgba(139,90,43,0.15)' : 'rgba(0,0,0,0.08)';
                            ctx.lineWidth = 2 + Math.random() * 4;
                            ctx.beginPath();
                            const yPos = (r / 15) * height + (Math.random() - 0.5) * 10;
                            ctx.moveTo(0, yPos);
                            for (let x = 0; x < width; x += 20) {
                                ctx.lineTo(x, yPos + Math.sin(x * 0.05) * 5);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'hexagons':
                        ctx.globalCompositeOperation = 'overlay';
                        const hexSize = width / 8;
                        for (let row = 0; row < height / hexSize + 2; row++) {
                            for (let col = 0; col < width / hexSize + 2; col++) {
                                const cx = col * hexSize * 1.5 + (row % 2) * hexSize * 0.75;
                                const cy = row * hexSize * 0.866;
                                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (i / 6) * Math.PI * 2;
                                    const hx = cx + Math.cos(angle) * hexSize * 0.45;
                                    const hy = cy + Math.sin(angle) * hexSize * 0.45;
                                    if (i === 0) ctx.moveTo(hx, hy);
                                    else ctx.lineTo(hx, hy);
                                }
                                ctx.closePath();
                                ctx.stroke();
                            }
                        }
                        break;
                        
                    case 'scales':
                        ctx.globalCompositeOperation = 'overlay';
                        const scaleSize = width / 10;
                        for (let row = 0; row < height / scaleSize + 2; row++) {
                            for (let col = -1; col < width / scaleSize + 2; col++) {
                                const scx = col * scaleSize + (row % 2) * scaleSize / 2;
                                const scy = row * scaleSize * 0.65;
                                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                                ctx.beginPath();
                                ctx.arc(scx, scy, scaleSize * 0.55, 0, Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                        break;
                }
                
                ctx.restore();
            },
            
            // Create a gradient texture for the dice with optional number
            createGradientTexture(themeData, diceType) {
                const size = 256;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                if (!themeData || !themeData.gradient) {
                    // Fallback: solid color
                    const color = themeData?.accent || '#8B5CF6';
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, size, size);
                } else {
                    const gradient = themeData.gradient;
                    let grd;
                    
                    if (gradient.type === 'radial') {
                        grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    } else {
                        // Linear gradient diagonal
                        grd = ctx.createLinearGradient(0, 0, size, size);
                    }
                    
                    const colors = gradient.colors || ['#ffffff', '#888888'];
                    const stops = gradient.stops || colors.map((_, i, arr) => i / (arr.length - 1));
                    colors.forEach((color, i) => {
                        grd.addColorStop(stops[i] || i / (colors.length - 1), color);
                    });
                    
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, size, size);
                    
                    // Apply texture if present
                    if (gradient.texture) {
                        this.applyTexture(ctx, size, size, gradient.texture, colors);
                    }
                    
                    // Add subtle noise for depth
                    ctx.globalAlpha = 0.02;
                    for (let i = 0; i < 500; i++) {
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#000000';
                        ctx.fillRect(x, y, 1, 1);
                    }
                    ctx.globalAlpha = 1;
                    
                    // Add number if diceType provided
                    if (diceType) {
                        const number = this.getDiceNumber(diceType);
                        if (number) {
                            const textColor = this.getTextColor(colors);
                            ctx.font = 'bold ' + (size * 0.5) + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // Text shadow for depth
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.fillText(number, size/2 + 2, size/2 + 2);
                            
                            // Main text
                            ctx.fillStyle = textColor;
                            ctx.fillText(number, size/2, size/2);
                            
                            // Underline for 6 and 9
                            if (number === '6' || number === '9') {
                                ctx.fillText('.', size/2 + size*0.2, size/2);
                            }
                        }
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            },
            
            // Create material with gradient texture
            createThemedMaterial(diceType) {
                const themeData = this.getThemeData();
                const texture = this.createGradientTexture(themeData, diceType);
                
                return new THREE.MeshPhongMaterial({
                    map: texture,
                    color: 0xffffff,
                    shininess: 80,
                    specular: 0x333333,
                    shading: THREE.FlatShading,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });
            },
            
            // Update all preview dice when theme changes - recreate meshes with new materials
            updateColors() {
                if (typeof DICE === 'undefined' || !DICE.createPreviewDice) {
                    console.warn('DICE.createPreviewDice not available for updateColors');
                    return;
                }
                
                // Tell DICE library to refresh materials (clears cache)
                if (DICE.refreshPreviewMaterials) {
                    DICE.refreshPreviewMaterials();
                }
                
                this.previews.forEach(preview => {
                    // Remove old mesh from scene
                    preview.scene.remove(preview.mesh);
                    
                    // Create new mesh with updated colors
                    let newMesh;
                    
                    if (preview.isD100) {
                        newMesh = new THREE.Group();
                        const tensDice = DICE.createPreviewDice('d100', 0.7);
                        const onesDice = DICE.createPreviewDice('d10', 0.7);
                        
                        if (tensDice && onesDice) {
                            tensDice.position.x = -25;
                            onesDice.position.x = 25;
                            
                            // Keep same rotation
                            if (preview.mesh.userData.dice) {
                                tensDice.rotation.copy(preview.mesh.userData.dice[0].rotation);
                                onesDice.rotation.copy(preview.mesh.userData.dice[1].rotation);
                            }
                            
                            newMesh.add(tensDice);
                            newMesh.add(onesDice);
                            newMesh.userData.dice = [tensDice, onesDice];
                        }
                    } else {
                        newMesh = DICE.createPreviewDice(preview.type, 0.8);
                        if (newMesh && preview.mesh) {
                            // Keep same rotation
                            newMesh.rotation.copy(preview.mesh.rotation);
                        }
                    }
                    
                    if (newMesh) {
                        preview.scene.add(newMesh);
                        preview.mesh = newMesh;
                    }
                });
            },
            
            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                this.previews.forEach(preview => {
                    if (preview.isD100 && preview.mesh.userData.dice) {
                        // D100: Rotate each die independently
                        preview.mesh.userData.dice.forEach((die, i) => {
                            const speed = i === 0 ? 1 : 1.3; // Slightly different speeds
                            die.rotation.x += preview.rotationSpeed.x * speed;
                            die.rotation.y += preview.rotationSpeed.y * speed;
                            die.rotation.z += preview.rotationSpeed.z * speed;
                        });
                    } else {
                        // Normal dice
                        preview.mesh.rotation.x += preview.rotationSpeed.x;
                        preview.mesh.rotation.y += preview.rotationSpeed.y;
                        preview.mesh.rotation.z += preview.rotationSpeed.z;
                    }
                    preview.renderer.render(preview.scene, preview.camera);
                });
            },
            
            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        };
        
        // Initialize after everything is loaded
        if (document.readyState === 'complete') {
            setTimeout(() => DicePreview.init(), 200);
        } else {
            window.addEventListener('load', () => {
                setTimeout(() => DicePreview.init(), 200);
            });
        }
    </script>
    <script>
        // Mobile Settings Theme Grid Population
        document.addEventListener('DOMContentLoaded', function() {
            const mobileGrid = document.getElementById('mobileThemeGrid');
            const desktopGrid = document.querySelector('.dice-theme-grid');
            
            if (mobileGrid && desktopGrid) {
                // Kopiere alle Theme Cards
                const cards = desktopGrid.querySelectorAll('.dice-theme-card');
                cards.forEach(card => {
                    const clone = card.cloneNode(true);
                    clone.addEventListener('click', function() {
                        // Remove active from all
                        mobileGrid.querySelectorAll('.dice-theme-card').forEach(c => c.classList.remove('active'));
                        desktopGrid.querySelectorAll('.dice-theme-card').forEach(c => c.classList.remove('active'));
                        // Add active to clicked and desktop equivalent
                        this.classList.add('active');
                        const theme = this.dataset.theme;
                        const desktopCard = desktopGrid.querySelector(`[data-theme="${theme}"]`);
                        if (desktopCard) desktopCard.classList.add('active');
                        // Apply theme
                        if (window.DiceRoller && DiceRoller.setTheme) {
                            DiceRoller.setTheme(theme);
                        }
                    });
                    mobileGrid.appendChild(clone);
                });
            }
        });
    </script>
    <script src="assets/js/broadcast.js"></script>
    
    <!-- MOBILE SETTINGS POPUP - DIREKT IM BODY -->
    <div class="mobile-settings-overlay" id="mobileSettingsOverlay" onclick="document.getElementById('mobileSettingsPopup').classList.remove('open'); this.classList.remove('open');"></div>
    <div class="mobile-settings-popup" id="mobileSettingsPopup">
        <div class="mobile-settings-popup__header">
            <span>Einstellungen</span>
            <button class="mobile-settings-popup__close" onclick="document.getElementById('mobileSettingsPopup').classList.remove('open'); document.getElementById('mobileSettingsOverlay').classList.remove('open');">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <div class="mobile-settings-popup__content">
            <span class="mobile-settings-popup__label">Würfelfarbe</span>
            <div class="mobile-theme-grid" id="mobileThemeGrid"></div>
        </div>
    </div>

    <!-- Settings Overlay - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-overlay" id="diceSettingsOverlay" onclick="DiceRoller.closeAllPopups()"></div>
    
    <!-- Stats Popup - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-popup dice-stats-popup" id="statsPopup">
        <div class="dice-settings-popup__header">
            <span>Statistiken</span>
            <button class="dice-settings-popup__close" onclick="DiceRoller.toggleStatsPopup()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <p class="dice-stats-hint">Statistiken für alle Spieler im Raum</p>
        <div class="dice-stats-grid">
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statTotal">0</span>
                <span class="dice-stats-card__label">Würfe</span>
            </div>
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statAvg">-</span>
                <span class="dice-stats-card__label">Durchschnitt</span>
            </div>
            <div class="dice-stats-card dice-stats-card--success">
                <span class="dice-stats-card__value" id="statCrits">0</span>
                <span class="dice-stats-card__label">Kritische Erfolge</span>
            </div>
            <div class="dice-stats-card dice-stats-card--failure">
                <span class="dice-stats-card__value" id="statFumbles">0</span>
                <span class="dice-stats-card__label">Patzer</span>
            </div>
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statMax">-</span>
                <span class="dice-stats-card__label">Maximum</span>
            </div>
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statMin">-</span>
                <span class="dice-stats-card__label">Minimum</span>
            </div>
        </div>
        <button class="dice-stats-reset" onclick="DiceRoller.resetStats()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
            </svg>
            Statistiken zurücksetzen
        </button>
    </div>
    
    <!-- Hotkeys Popup - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-popup dice-hotkeys-popup" id="hotkeysPopup">
        <div class="dice-settings-popup__header">
            <span>Tastenkürzel</span>
            <button class="dice-settings-popup__close" onclick="DiceRoller.toggleHotkeysPopup()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <div class="dice-hotkeys-list">
            <div class="dice-hotkey"><kbd>Enter</kbd><span>Würfeln</span></div>
            <div class="dice-hotkey"><kbd>Space</kbd><span>Würfeln</span></div>
            <div class="dice-hotkey"><kbd>1-7</kbd><span>Würfel hinzufügen</span></div>
            <div class="dice-hotkey"><kbd>Shift+1-7</kbd><span>Würfel entfernen</span></div>
            <div class="dice-hotkey"><kbd>+/-</kbd><span>Modifier ±1</span></div>
            <div class="dice-hotkey"><kbd>Shift +/-</kbd><span>Modifier ±5</span></div>
            <div class="dice-hotkey"><kbd>A</kbd><span>Vorteil</span></div>
            <div class="dice-hotkey"><kbd>D</kbd><span>Nachteil</span></div>
            <div class="dice-hotkey"><kbd>R</kbd><span>Wiederholen</span></div>
            <div class="dice-hotkey"><kbd>Esc</kbd><span>Reset</span></div>
        </div>
    </div>
    
    <!-- Settings Popup - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-popup" id="settingsPopup">
        <div class="dice-settings-popup__header">
            <span>Einstellungen</span>
            <button class="dice-settings-popup__close" id="settingsClose" onclick="DiceRoller.closeAllPopups()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        
        <!-- TABS -->
        <div class="dice-settings-tabs">
            <button class="dice-settings-tab active" data-tab="diceColor" onclick="DiceRoller.switchSettingsTab('diceColor')">
                🎲 Würfel
            </button>
            <button class="dice-settings-tab" data-tab="labelColor" onclick="DiceRoller.switchSettingsTab('labelColor')">
                🔢 Zahlen
            </button>
            <button class="dice-settings-tab" data-tab="arenaTheme" onclick="DiceRoller.switchSettingsTab('arenaTheme')">
                🏟️ Arena
            </button>
        </div>
        
        <!-- TAB CONTENT: Würfelfarbe -->
        <div class="dice-settings-tab-content active" id="tabDiceColor">
    
    <div class="dice-settings-popup__section dice-settings-popup__section--themes">
        <span class="dice-settings-popup__label">Würfelfarbe <span id="themeCount">(137)</span></span>
        <input type="text" class="dice-theme-search" id="themeSearch" placeholder="Theme suchen..." oninput="DiceRoller.filterThemes(this.value)">
        <div class="dice-theme-grid">
            <!-- BASIC -->
            <button class="dice-theme-card active" data-theme="classic">
                <div class="dice-theme-card__preview dice-theme-card__preview--classic"></div>
                <span>Klassisch</span>
            </button>
            <button class="dice-theme-card" data-theme="blood">
                <div class="dice-theme-card__preview dice-theme-card__preview--blood"></div>
                <span>Blut</span>
            </button>
            <button class="dice-theme-card" data-theme="ice">
                <div class="dice-theme-card__preview dice-theme-card__preview--ice"></div>
                <span>Eis</span>
            </button>
            <button class="dice-theme-card" data-theme="nature">
                <div class="dice-theme-card__preview dice-theme-card__preview--nature"></div>
                <span>Natur</span>
            </button>
            <button class="dice-theme-card" data-theme="royal">
                <div class="dice-theme-card__preview dice-theme-card__preview--royal"></div>
                <span>Royal</span>
            </button>
            <button class="dice-theme-card" data-theme="gold">
                <div class="dice-theme-card__preview dice-theme-card__preview--gold"></div>
                <span>Gold</span>
            </button>
            
            <!-- ELEMENTAL -->
            <button class="dice-theme-card" data-theme="fire">
                <div class="dice-theme-card__preview dice-theme-card__preview--fire"></div>
                <span>Feuer</span>
            </button>
            <button class="dice-theme-card" data-theme="ocean">
                <div class="dice-theme-card__preview dice-theme-card__preview--ocean"></div>
                <span>Ozean</span>
            </button>
            <button class="dice-theme-card" data-theme="toxic">
                <div class="dice-theme-card__preview dice-theme-card__preview--toxic"></div>
                <span>Toxisch</span>
            </button>
            <button class="dice-theme-card" data-theme="lava">
                <div class="dice-theme-card__preview dice-theme-card__preview--lava"></div>
                <span>Lava</span>
            </button>
            <button class="dice-theme-card" data-theme="frost">
                <div class="dice-theme-card__preview dice-theme-card__preview--frost"></div>
                <span>Frost</span>
            </button>
            <button class="dice-theme-card" data-theme="storm">
                <div class="dice-theme-card__preview dice-theme-card__preview--storm"></div>
                <span>Sturm</span>
            </button>
            <button class="dice-theme-card" data-theme="earth">
                <div class="dice-theme-card__preview dice-theme-card__preview--earth"></div>
                <span>Erde</span>
            </button>
            <button class="dice-theme-card" data-theme="shadow">
                <div class="dice-theme-card__preview dice-theme-card__preview--shadow"></div>
                <span>Schatten</span>
            </button>
            
            <!-- GEMS & METALS -->
            <button class="dice-theme-card" data-theme="ruby">
                <div class="dice-theme-card__preview dice-theme-card__preview--ruby"></div>
                <span>Rubin</span>
            </button>
            <button class="dice-theme-card" data-theme="sapphire">
                <div class="dice-theme-card__preview dice-theme-card__preview--sapphire"></div>
                <span>Saphir</span>
            </button>
            <button class="dice-theme-card" data-theme="emerald">
                <div class="dice-theme-card__preview dice-theme-card__preview--emerald"></div>
                <span>Smaragd</span>
            </button>
            <button class="dice-theme-card" data-theme="amethyst">
                <div class="dice-theme-card__preview dice-theme-card__preview--amethyst"></div>
                <span>Amethyst</span>
            </button>
            <button class="dice-theme-card" data-theme="diamond">
                <div class="dice-theme-card__preview dice-theme-card__preview--diamond"></div>
                <span>Diamant</span>
            </button>
            <button class="dice-theme-card" data-theme="opal">
                <div class="dice-theme-card__preview dice-theme-card__preview--opal"></div>
                <span>Opal</span>
            </button>
            <button class="dice-theme-card" data-theme="silver">
                <div class="dice-theme-card__preview dice-theme-card__preview--silver"></div>
                <span>Silber</span>
            </button>
            <button class="dice-theme-card" data-theme="bronze">
                <div class="dice-theme-card__preview dice-theme-card__preview--bronze"></div>
                <span>Bronze</span>
            </button>
            <button class="dice-theme-card" data-theme="platinum">
                <div class="dice-theme-card__preview dice-theme-card__preview--platinum"></div>
                <span>Platin</span>
            </button>
            <button class="dice-theme-card" data-theme="copper">
                <div class="dice-theme-card__preview dice-theme-card__preview--copper"></div>
                <span>Kupfer</span>
            </button>
            <button class="dice-theme-card" data-theme="obsidian">
                <div class="dice-theme-card__preview dice-theme-card__preview--obsidian"></div>
                <span>Obsidian</span>
            </button>
            
            <!-- FANTASY -->
            <button class="dice-theme-card" data-theme="dragon">
                <div class="dice-theme-card__preview dice-theme-card__preview--dragon"></div>
                <span>Drache</span>
            </button>
            <button class="dice-theme-card" data-theme="necro">
                <div class="dice-theme-card__preview dice-theme-card__preview--necro"></div>
                <span>Nekro</span>
            </button>
            <button class="dice-theme-card" data-theme="fey">
                <div class="dice-theme-card__preview dice-theme-card__preview--fey"></div>
                <span>Fey</span>
            </button>
            <button class="dice-theme-card" data-theme="infernal">
                <div class="dice-theme-card__preview dice-theme-card__preview--infernal"></div>
                <span>Höllisch</span>
            </button>
            <button class="dice-theme-card" data-theme="celestial">
                <div class="dice-theme-card__preview dice-theme-card__preview--celestial"></div>
                <span>Himmlisch</span>
            </button>
            <button class="dice-theme-card" data-theme="eldritch">
                <div class="dice-theme-card__preview dice-theme-card__preview--eldritch"></div>
                <span>Eldritch</span>
            </button>
            
            <!-- COSMIC & NATURE -->
            <button class="dice-theme-card" data-theme="nebula">
                <div class="dice-theme-card__preview dice-theme-card__preview--nebula"></div>
                <span>Nebula</span>
            </button>
            <button class="dice-theme-card" data-theme="void">
                <div class="dice-theme-card__preview dice-theme-card__preview--void"></div>
                <span>Void</span>
            </button>
            <button class="dice-theme-card" data-theme="galaxy">
                <div class="dice-theme-card__preview dice-theme-card__preview--galaxy"></div>
                <span>Galaxy</span>
            </button>
            <button class="dice-theme-card" data-theme="aurora">
                <div class="dice-theme-card__preview dice-theme-card__preview--aurora"></div>
                <span>Aurora</span>
            </button>
            <button class="dice-theme-card" data-theme="sunset">
                <div class="dice-theme-card__preview dice-theme-card__preview--sunset"></div>
                <span>Sunset</span>
            </button>
            <button class="dice-theme-card" data-theme="bloodmoon">
                <div class="dice-theme-card__preview dice-theme-card__preview--bloodmoon"></div>
                <span>Blutmond</span>
            </button>
            <button class="dice-theme-card" data-theme="forest">
                <div class="dice-theme-card__preview dice-theme-card__preview--forest"></div>
                <span>Wald</span>
            </button>
            <button class="dice-theme-card" data-theme="cherry">
                <div class="dice-theme-card__preview dice-theme-card__preview--cherry"></div>
                <span>Kirsche</span>
            </button>
            <button class="dice-theme-card" data-theme="autumn">
                <div class="dice-theme-card__preview dice-theme-card__preview--autumn"></div>
                <span>Herbst</span>
            </button>
            
            <!-- TECH & RETRO -->
            <button class="dice-theme-card" data-theme="cyber">
                <div class="dice-theme-card__preview dice-theme-card__preview--cyber"></div>
                <span>Cyber</span>
            </button>
            <button class="dice-theme-card" data-theme="midnight">
                <div class="dice-theme-card__preview dice-theme-card__preview--midnight"></div>
                <span>Mitternacht</span>
            </button>
            <button class="dice-theme-card" data-theme="matrix">
                <div class="dice-theme-card__preview dice-theme-card__preview--matrix"></div>
                <span>Matrix</span>
            </button>
            <button class="dice-theme-card" data-theme="hologram">
                <div class="dice-theme-card__preview dice-theme-card__preview--hologram"></div>
                <span>Hologramm</span>
            </button>
            <button class="dice-theme-card" data-theme="plasma">
                <div class="dice-theme-card__preview dice-theme-card__preview--plasma"></div>
                <span>Plasma</span>
            </button>
            <button class="dice-theme-card" data-theme="neon">
                <div class="dice-theme-card__preview dice-theme-card__preview--neon"></div>
                <span>Neon</span>
            </button>
            <button class="dice-theme-card" data-theme="synthwave">
                <div class="dice-theme-card__preview dice-theme-card__preview--synthwave"></div>
                <span>Synthwave</span>
            </button>
            <button class="dice-theme-card" data-theme="steampunk">
                <div class="dice-theme-card__preview dice-theme-card__preview--steampunk"></div>
                <span>Steampunk</span>
            </button>
            <button class="dice-theme-card" data-theme="vaporwave">
                <div class="dice-theme-card__preview dice-theme-card__preview--vaporwave"></div>
                <span>Vaporwave</span>
            </button>
            
            <!-- FUN & SPECIAL -->
            <button class="dice-theme-card" data-theme="rainbow">
                <div class="dice-theme-card__preview dice-theme-card__preview--rainbow"></div>
                <span>Rainbow</span>
            </button>
            <button class="dice-theme-card" data-theme="candy">
                <div class="dice-theme-card__preview dice-theme-card__preview--candy"></div>
                <span>Candy</span>
            </button>
            <button class="dice-theme-card" data-theme="prism">
                <div class="dice-theme-card__preview dice-theme-card__preview--prism"></div>
                <span>Prisma</span>
            </button>
            <button class="dice-theme-card" data-theme="bubblegum">
                <div class="dice-theme-card__preview dice-theme-card__preview--bubblegum"></div>
                <span>Bubblegum</span>
            </button>
            <button class="dice-theme-card" data-theme="coral">
                <div class="dice-theme-card__preview dice-theme-card__preview--coral"></div>
                <span>Koralle</span>
            </button>
            <button class="dice-theme-card" data-theme="lavender">
                <div class="dice-theme-card__preview dice-theme-card__preview--lavender"></div>
                <span>Lavendel</span>
            </button>
            <button class="dice-theme-card" data-theme="mint">
                <div class="dice-theme-card__preview dice-theme-card__preview--mint"></div>
                <span>Minze</span>
            </button>
            <button class="dice-theme-card" data-theme="peach">
                <div class="dice-theme-card__preview dice-theme-card__preview--peach"></div>
                <span>Pfirsich</span>
            </button>
            
            <!-- TEXTURED -->
            <button class="dice-theme-card" data-theme="marbleWhite">
                <div class="dice-theme-card__preview dice-theme-card__preview--marbleWhite"></div>
                <span>Marmor Weiß</span>
            </button>
            <button class="dice-theme-card" data-theme="marbleBlack">
                <div class="dice-theme-card__preview dice-theme-card__preview--marbleBlack"></div>
                <span>Marmor Schwarz</span>
            </button>
            <button class="dice-theme-card" data-theme="marbleGreen">
                <div class="dice-theme-card__preview dice-theme-card__preview--marbleGreen"></div>
                <span>Marmor Grün</span>
            </button>
            <button class="dice-theme-card" data-theme="marbleRose">
                <div class="dice-theme-card__preview dice-theme-card__preview--marbleRose"></div>
                <span>Marmor Rosé</span>
            </button>
            <button class="dice-theme-card" data-theme="woodOak">
                <div class="dice-theme-card__preview dice-theme-card__preview--woodOak"></div>
                <span>Holz Eiche</span>
            </button>
            <button class="dice-theme-card" data-theme="woodCherry">
                <div class="dice-theme-card__preview dice-theme-card__preview--woodCherry"></div>
                <span>Holz Kirsche</span>
            </button>
            <button class="dice-theme-card" data-theme="woodEbony">
                <div class="dice-theme-card__preview dice-theme-card__preview--woodEbony"></div>
                <span>Holz Ebenholz</span>
            </button>
            <button class="dice-theme-card" data-theme="stoneGranite">
                <div class="dice-theme-card__preview dice-theme-card__preview--stoneGranite"></div>
                <span>Granit</span>
            </button>
            <button class="dice-theme-card" data-theme="stoneSandstone">
                <div class="dice-theme-card__preview dice-theme-card__preview--stoneSandstone"></div>
                <span>Sandstein</span>
            </button>
            
            <!-- GLITTER -->
            <button class="dice-theme-card" data-theme="glitterGold">
                <div class="dice-theme-card__preview dice-theme-card__preview--glitterGold"></div>
                <span>Glitzer Gold</span>
            </button>
            <button class="dice-theme-card" data-theme="glitterSilver">
                <div class="dice-theme-card__preview dice-theme-card__preview--glitterSilver"></div>
                <span>Glitzer Silber</span>
            </button>
            <button class="dice-theme-card" data-theme="glitterRose">
                <div class="dice-theme-card__preview dice-theme-card__preview--glitterRose"></div>
                <span>Glitzer Rosé</span>
            </button>
            <button class="dice-theme-card" data-theme="glitterBlue">
                <div class="dice-theme-card__preview dice-theme-card__preview--glitterBlue"></div>
                <span>Glitzer Blau</span>
            </button>
            <button class="dice-theme-card" data-theme="glitterPurple">
                <div class="dice-theme-card__preview dice-theme-card__preview--glitterPurple"></div>
                <span>Glitzer Lila</span>
            </button>
            
            <!-- PATTERNS -->
            <button class="dice-theme-card" data-theme="stripesRed">
                <div class="dice-theme-card__preview dice-theme-card__preview--stripesRed"></div>
                <span>Streifen Rot</span>
            </button>
            <button class="dice-theme-card" data-theme="stripesBlue">
                <div class="dice-theme-card__preview dice-theme-card__preview--stripesBlue"></div>
                <span>Streifen Blau</span>
            </button>
            <button class="dice-theme-card" data-theme="stripesGreen">
                <div class="dice-theme-card__preview dice-theme-card__preview--stripesGreen"></div>
                <span>Streifen Grün</span>
            </button>
            <button class="dice-theme-card" data-theme="polkaDots">
                <div class="dice-theme-card__preview dice-theme-card__preview--polkaDots"></div>
                <span>Punkte Pink</span>
            </button>
            <button class="dice-theme-card" data-theme="polkaBlack">
                <div class="dice-theme-card__preview dice-theme-card__preview--polkaBlack"></div>
                <span>Punkte Schwarz</span>
            </button>
            <button class="dice-theme-card" data-theme="checkerRed">
                <div class="dice-theme-card__preview dice-theme-card__preview--checkerRed"></div>
                <span>Karo Rot</span>
            </button>
            <button class="dice-theme-card" data-theme="checkerGreen">
                <div class="dice-theme-card__preview dice-theme-card__preview--checkerGreen"></div>
                <span>Karo Grün</span>
            </button>
            <button class="dice-theme-card" data-theme="camoForest">
                <div class="dice-theme-card__preview dice-theme-card__preview--camoForest"></div>
                <span>Camo Wald</span>
            </button>
            <button class="dice-theme-card" data-theme="camoDesert">
                <div class="dice-theme-card__preview dice-theme-card__preview--camoDesert"></div>
                <span>Camo Wüste</span>
            </button>
            <button class="dice-theme-card" data-theme="camoArctic">
                <div class="dice-theme-card__preview dice-theme-card__preview--camoArctic"></div>
                <span>Camo Arktis</span>
            </button>
            <button class="dice-theme-card" data-theme="waveOcean">
                <div class="dice-theme-card__preview dice-theme-card__preview--waveOcean"></div>
                <span>Wellen Ozean</span>
            </button>
            <button class="dice-theme-card" data-theme="waveAqua">
                <div class="dice-theme-card__preview dice-theme-card__preview--waveAqua"></div>
                <span>Wellen Aqua</span>
            </button>
            <button class="dice-theme-card" data-theme="hexTech">
                <div class="dice-theme-card__preview dice-theme-card__preview--hexTech"></div>
                <span>Hex Tech</span>
            </button>
            <button class="dice-theme-card" data-theme="hexGold">
                <div class="dice-theme-card__preview dice-theme-card__preview--hexGold"></div>
                <span>Hex Gold</span>
            </button>
            <button class="dice-theme-card" data-theme="dragonScales">
                <div class="dice-theme-card__preview dice-theme-card__preview--dragonScales"></div>
                <span>Drachenschuppen</span>
            </button>
            <button class="dice-theme-card" data-theme="fishScales">
                <div class="dice-theme-card__preview dice-theme-card__preview--fishScales"></div>
                <span>Fischschuppen</span>
            </button>
            
            <!-- SPECIAL EFFECTS -->
            <button class="dice-theme-card" data-theme="starryNight">
                <div class="dice-theme-card__preview dice-theme-card__preview--starryNight"></div>
                <span>Sternennacht</span>
            </button>
            <button class="dice-theme-card" data-theme="galaxy2">
                <div class="dice-theme-card__preview dice-theme-card__preview--galaxy2"></div>
                <span>Galaxie II</span>
            </button>
            <button class="dice-theme-card" data-theme="thunderstorm">
                <div class="dice-theme-card__preview dice-theme-card__preview--thunderstorm"></div>
                <span>Gewitter</span>
            </button>
            <button class="dice-theme-card" data-theme="electricBlue">
                <div class="dice-theme-card__preview dice-theme-card__preview--electricBlue"></div>
                <span>Elektrisch</span>
            </button>
            
            <!-- METALLIC -->
            <button class="dice-theme-card" data-theme="chrome">
                <div class="dice-theme-card__preview dice-theme-card__preview--chrome"></div>
                <span>Chrom</span>
            </button>
            <button class="dice-theme-card" data-theme="titanium">
                <div class="dice-theme-card__preview dice-theme-card__preview--titanium"></div>
                <span>Titan</span>
            </button>
            <button class="dice-theme-card" data-theme="rosegold">
                <div class="dice-theme-card__preview dice-theme-card__preview--rosegold"></div>
                <span>Roségold</span>
            </button>
            <button class="dice-theme-card" data-theme="brushedSteel">
                <div class="dice-theme-card__preview dice-theme-card__preview--brushedSteel"></div>
                <span>Gebürsteter Stahl</span>
            </button>
            <button class="dice-theme-card" data-theme="rust">
                <div class="dice-theme-card__preview dice-theme-card__preview--rust"></div>
                <span>Rost</span>
            </button>
            <button class="dice-theme-card" data-theme="patina">
                <div class="dice-theme-card__preview dice-theme-card__preview--patina"></div>
                <span>Patina</span>
            </button>
            
            <!-- FOOD -->
            <button class="dice-theme-card" data-theme="chocolate">
                <div class="dice-theme-card__preview dice-theme-card__preview--chocolate"></div>
                <span>Schokolade</span>
            </button>
            <button class="dice-theme-card" data-theme="caramel">
                <div class="dice-theme-card__preview dice-theme-card__preview--caramel"></div>
                <span>Karamell</span>
            </button>
            <button class="dice-theme-card" data-theme="strawberry">
                <div class="dice-theme-card__preview dice-theme-card__preview--strawberry"></div>
                <span>Erdbeere</span>
            </button>
            <button class="dice-theme-card" data-theme="blueberry">
                <div class="dice-theme-card__preview dice-theme-card__preview--blueberry"></div>
                <span>Blaubeere</span>
            </button>
            <button class="dice-theme-card" data-theme="grape">
                <div class="dice-theme-card__preview dice-theme-card__preview--grape"></div>
                <span>Traube</span>
            </button>
            <button class="dice-theme-card" data-theme="lemon">
                <div class="dice-theme-card__preview dice-theme-card__preview--lemon"></div>
                <span>Zitrone</span>
            </button>
            <button class="dice-theme-card" data-theme="lime">
                <div class="dice-theme-card__preview dice-theme-card__preview--lime"></div>
                <span>Limette</span>
            </button>
            <button class="dice-theme-card" data-theme="orange2">
                <div class="dice-theme-card__preview dice-theme-card__preview--orange2"></div>
                <span>Orange</span>
            </button>
            
            <!-- SEASONAL -->
            <button class="dice-theme-card" data-theme="springBlossom">
                <div class="dice-theme-card__preview dice-theme-card__preview--springBlossom"></div>
                <span>Frühling</span>
            </button>
            <button class="dice-theme-card" data-theme="summerSun">
                <div class="dice-theme-card__preview dice-theme-card__preview--summerSun"></div>
                <span>Sommer</span>
            </button>
            <button class="dice-theme-card" data-theme="autumnLeaves">
                <div class="dice-theme-card__preview dice-theme-card__preview--autumnLeaves"></div>
                <span>Herbstlaub</span>
            </button>
            <button class="dice-theme-card" data-theme="winterFrost">
                <div class="dice-theme-card__preview dice-theme-card__preview--winterFrost"></div>
                <span>Winterfrost</span>
            </button>
            <button class="dice-theme-card" data-theme="christmas">
                <div class="dice-theme-card__preview dice-theme-card__preview--christmas"></div>
                <span>Weihnachten</span>
            </button>
            <button class="dice-theme-card" data-theme="halloween">
                <div class="dice-theme-card__preview dice-theme-card__preview--halloween"></div>
                <span>Halloween</span>
            </button>
            <button class="dice-theme-card" data-theme="valentine">
                <div class="dice-theme-card__preview dice-theme-card__preview--valentine"></div>
                <span>Valentinstag</span>
            </button>
            
            <!-- GAMING -->
            <button class="dice-theme-card" data-theme="critSuccess">
                <div class="dice-theme-card__preview dice-theme-card__preview--critSuccess"></div>
                <span>Krit. Erfolg</span>
            </button>
            <button class="dice-theme-card" data-theme="critFail">
                <div class="dice-theme-card__preview dice-theme-card__preview--critFail"></div>
                <span>Krit. Patzer</span>
            </button>
            <button class="dice-theme-card" data-theme="lucky">
                <div class="dice-theme-card__preview dice-theme-card__preview--lucky"></div>
                <span>Glückswürfel</span>
            </button>
            <button class="dice-theme-card" data-theme="cursed">
                <div class="dice-theme-card__preview dice-theme-card__preview--cursed"></div>
                <span>Verflucht</span>
            </button>
            <button class="dice-theme-card" data-theme="blessed">
                <div class="dice-theme-card__preview dice-theme-card__preview--blessed"></div>
                <span>Gesegnet</span>
            </button>
            <button class="dice-theme-card" data-theme="ethereal">
                <div class="dice-theme-card__preview dice-theme-card__preview--ethereal"></div>
                <span>Ätherisch</span>
            </button>
            
            <!-- DARK -->
            <button class="dice-theme-card" data-theme="charcoal">
                <div class="dice-theme-card__preview dice-theme-card__preview--charcoal"></div>
                <span>Kohle</span>
            </button>
            <button class="dice-theme-card" data-theme="slate">
                <div class="dice-theme-card__preview dice-theme-card__preview--slate"></div>
                <span>Schiefer</span>
            </button>
            <button class="dice-theme-card" data-theme="graphite">
                <div class="dice-theme-card__preview dice-theme-card__preview--graphite"></div>
                <span>Graphit</span>
            </button>
            <button class="dice-theme-card" data-theme="carbon">
                <div class="dice-theme-card__preview dice-theme-card__preview--carbon"></div>
                <span>Carbon</span>
            </button>
            <button class="dice-theme-card" data-theme="onyx">
                <div class="dice-theme-card__preview dice-theme-card__preview--onyx"></div>
                <span>Onyx</span>
            </button>
            
            <!-- PASTEL -->
            <button class="dice-theme-card" data-theme="pastelPink">
                <div class="dice-theme-card__preview dice-theme-card__preview--pastelPink"></div>
                <span>Pastell Rosa</span>
            </button>
            <button class="dice-theme-card" data-theme="pastelBlue">
                <div class="dice-theme-card__preview dice-theme-card__preview--pastelBlue"></div>
                <span>Pastell Blau</span>
            </button>
            <button class="dice-theme-card" data-theme="pastelGreen">
                <div class="dice-theme-card__preview dice-theme-card__preview--pastelGreen"></div>
                <span>Pastell Grün</span>
            </button>
            <button class="dice-theme-card" data-theme="pastelYellow">
                <div class="dice-theme-card__preview dice-theme-card__preview--pastelYellow"></div>
                <span>Pastell Gelb</span>
            </button>
            <button class="dice-theme-card" data-theme="pastelPurple">
                <div class="dice-theme-card__preview dice-theme-card__preview--pastelPurple"></div>
                <span>Pastell Lila</span>
            </button>
            <button class="dice-theme-card" data-theme="pastelRainbow">
                <div class="dice-theme-card__preview dice-theme-card__preview--pastelRainbow"></div>
                <span>Pastell Regenbogen</span>
            </button>
            
            <!-- NATURE EXTENDED -->
            <button class="dice-theme-card" data-theme="deepSea">
                <div class="dice-theme-card__preview dice-theme-card__preview--deepSea"></div>
                <span>Tiefsee</span>
            </button>
            <button class="dice-theme-card" data-theme="coralReef">
                <div class="dice-theme-card__preview dice-theme-card__preview--coralReef"></div>
                <span>Korallenriff</span>
            </button>
            <button class="dice-theme-card" data-theme="jungle">
                <div class="dice-theme-card__preview dice-theme-card__preview--jungle"></div>
                <span>Dschungel</span>
            </button>
            <button class="dice-theme-card" data-theme="desert">
                <div class="dice-theme-card__preview dice-theme-card__preview--desert"></div>
                <span>Wüste</span>
            </button>
            <button class="dice-theme-card" data-theme="volcanic">
                <div class="dice-theme-card__preview dice-theme-card__preview--volcanic"></div>
                <span>Vulkanisch</span>
            </button>
            <button class="dice-theme-card" data-theme="arctic">
                <div class="dice-theme-card__preview dice-theme-card__preview--arctic"></div>
                <span>Arktis</span>
            </button>
            <button class="dice-theme-card" data-theme="tundra">
                <div class="dice-theme-card__preview dice-theme-card__preview--tundra"></div>
                <span>Tundra</span>
            </button>
            <button class="dice-theme-card" data-theme="swamp">
                <div class="dice-theme-card__preview dice-theme-card__preview--swamp"></div>
                <span>Sumpf</span>
            </button>
        </div>
    </div>
    </div><!-- Ende Tab Würfelfarbe -->
    
    <!-- TAB CONTENT: Zahlenfarbe -->
    <div class="dice-settings-tab-content" id="tabLabelColor">
        <div class="dice-settings-popup__section">
            <span class="dice-settings-popup__label">Zahlenfarbe</span>
            <p class="dice-settings-popup__hint">Wähle die Farbe der Zahlen auf deinen Würfeln. "Auto" passt sich automatisch an die Würfelfarbe an.</p>
            <div class="dice-label-color-grid">
                <button class="dice-label-color-btn active" data-color="auto" onclick="DiceRoller.setLabelColor('auto')">
                    <div class="dice-label-color-preview dice-label-color-preview--auto"></div>
                    <span>Auto</span>
                </button>
                <button class="dice-label-color-btn" data-color="#ffffff" onclick="DiceRoller.setLabelColor('#ffffff')">
                    <div class="dice-label-color-preview" style="background: #ffffff;"></div>
                    <span>Weiß</span>
                </button>
                <button class="dice-label-color-btn" data-color="#1a1a1a" onclick="DiceRoller.setLabelColor('#1a1a1a')">
                    <div class="dice-label-color-preview" style="background: #1a1a1a;"></div>
                    <span>Schwarz</span>
                </button>
                <button class="dice-label-color-btn" data-color="#ff4444" onclick="DiceRoller.setLabelColor('#ff4444')">
                    <div class="dice-label-color-preview" style="background: #ff4444;"></div>
                    <span>Rot</span>
                </button>
                <button class="dice-label-color-btn" data-color="#ff9800" onclick="DiceRoller.setLabelColor('#ff9800')">
                    <div class="dice-label-color-preview" style="background: #ff9800;"></div>
                    <span>Orange</span>
                </button>
                <button class="dice-label-color-btn" data-color="#ffeb3b" onclick="DiceRoller.setLabelColor('#ffeb3b')">
                    <div class="dice-label-color-preview" style="background: #ffeb3b;"></div>
                    <span>Gelb</span>
                </button>
                <button class="dice-label-color-btn" data-color="#4caf50" onclick="DiceRoller.setLabelColor('#4caf50')">
                    <div class="dice-label-color-preview" style="background: #4caf50;"></div>
                    <span>Grün</span>
                </button>
                <button class="dice-label-color-btn" data-color="#00bcd4" onclick="DiceRoller.setLabelColor('#00bcd4')">
                    <div class="dice-label-color-preview" style="background: #00bcd4;"></div>
                    <span>Cyan</span>
                </button>
                <button class="dice-label-color-btn" data-color="#2196f3" onclick="DiceRoller.setLabelColor('#2196f3')">
                    <div class="dice-label-color-preview" style="background: #2196f3;"></div>
                    <span>Blau</span>
                </button>
                <button class="dice-label-color-btn" data-color="#9c27b0" onclick="DiceRoller.setLabelColor('#9c27b0')">
                    <div class="dice-label-color-preview" style="background: #9c27b0;"></div>
                    <span>Lila</span>
                </button>
                <button class="dice-label-color-btn" data-color="#e91e63" onclick="DiceRoller.setLabelColor('#e91e63')">
                    <div class="dice-label-color-preview" style="background: #e91e63;"></div>
                    <span>Pink</span>
                </button>
                <button class="dice-label-color-btn" data-color="#ffd700" onclick="DiceRoller.setLabelColor('#ffd700')">
                    <div class="dice-label-color-preview" style="background: #ffd700;"></div>
                    <span>Gold</span>
                </button>
            </div>
        </div>
    </div><!-- Ende Tab Zahlenfarbe -->
    
    <!-- TAB CONTENT: Arena-Theme -->
    <div class="dice-settings-tab-content" id="tabArenaTheme">
        <div class="dice-settings-popup__section">
            <span class="dice-settings-popup__label">Würfelareal</span>
            <p class="dice-settings-popup__hint">Wähle das Aussehen der Würfelfläche.</p>
            <div class="dice-arena-theme-grid">
                <button class="dice-arena-theme-card active" data-arena-theme="default" onclick="DiceRoller.setArenaTheme('default')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--default"></div>
                    <span>Standard</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="tavern" onclick="DiceRoller.setArenaTheme('tavern')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--tavern"></div>
                    <span>Taverne</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="casino" onclick="DiceRoller.setArenaTheme('casino')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--casino"></div>
                    <span>Casino</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="dungeon" onclick="DiceRoller.setArenaTheme('dungeon')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--dungeon"></div>
                    <span>Kerker</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="arcane" onclick="DiceRoller.setArenaTheme('arcane')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--arcane"></div>
                    <span>Arkane Magie</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="cyber" onclick="DiceRoller.setArenaTheme('cyber')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--cyber"></div>
                    <span>Cyber-Grid</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="nebula" onclick="DiceRoller.setArenaTheme('nebula')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--nebula"></div>
                    <span>Nebula</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="lava" onclick="DiceRoller.setArenaTheme('lava')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--lava"></div>
                    <span>Lavahöhle</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="frost" onclick="DiceRoller.setArenaTheme('frost')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--frost"></div>
                    <span>Frostreich</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="parchment" onclick="DiceRoller.setArenaTheme('parchment')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--parchment"></div>
                    <span>Pergament</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="ocean" onclick="DiceRoller.setArenaTheme('ocean')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--ocean"></div>
                    <span>Ozean</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="forest" onclick="DiceRoller.setArenaTheme('forest')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--forest"></div>
                    <span>Wald</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="bloodmoon" onclick="DiceRoller.setArenaTheme('bloodmoon')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--bloodmoon"></div>
                    <span>Blutmond</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="desert" onclick="DiceRoller.setArenaTheme('desert')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--desert"></div>
                    <span>Wüste</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="void" onclick="DiceRoller.setArenaTheme('void')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--void"></div>
                    <span>Leere</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="marble" onclick="DiceRoller.setArenaTheme('marble')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--marble"></div>
                    <span>Marmor</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="gothic" onclick="DiceRoller.setArenaTheme('gothic')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--gothic"></div>
                    <span>Gotik</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="steampunk" onclick="DiceRoller.setArenaTheme('steampunk')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--steampunk"></div>
                    <span>Steampunk</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="neonpink" onclick="DiceRoller.setArenaTheme('neonpink')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--neonpink"></div>
                    <span>Neon Pink</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="matrix" onclick="DiceRoller.setArenaTheme('matrix')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--matrix"></div>
                    <span>Matrix</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="starfield" onclick="DiceRoller.setArenaTheme('starfield')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--starfield"></div>
                    <span>Sternenhimmel</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="sakura" onclick="DiceRoller.setArenaTheme('sakura')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--sakura"></div>
                    <span>Sakura</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="inferno" onclick="DiceRoller.setArenaTheme('inferno')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--inferno"></div>
                    <span>Inferno</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="twilight" onclick="DiceRoller.setArenaTheme('twilight')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--twilight"></div>
                    <span>Dämmerung</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="crystal" onclick="DiceRoller.setArenaTheme('crystal')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--crystal"></div>
                    <span>Kristall</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="mossy" onclick="DiceRoller.setArenaTheme('mossy')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--mossy"></div>
                    <span>Moosstein</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="royal" onclick="DiceRoller.setArenaTheme('royal')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--royal"></div>
                    <span>Königlich</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="eclipse" onclick="DiceRoller.setArenaTheme('eclipse')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--eclipse"></div>
                    <span>Finsternis</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="aurora" onclick="DiceRoller.setArenaTheme('aurora')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--aurora"></div>
                    <span>Nordlicht</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="storm" onclick="DiceRoller.setArenaTheme('storm')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--storm"></div>
                    <span>Gewitter</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="toxic" onclick="DiceRoller.setArenaTheme('toxic')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--toxic"></div>
                    <span>Toxisch</span>
                </button>
                <button class="dice-arena-theme-card" data-arena-theme="copper" onclick="DiceRoller.setArenaTheme('copper')">
                    <div class="dice-arena-theme-preview dice-arena-theme-preview--copper"></div>
                    <span>Kupfer</span>
                </button>
            </div>
        </div>
    </div><!-- Ende Tab Arena-Theme -->
    
    <div class="dice-settings-popup__section">
        <span class="dice-settings-popup__label">Optionen</span>
        <div class="dice-settings-popup__toggles">
            <button class="dice-settings-toggle active" id="soundToggle2" onclick="DiceRoller.toggleSound()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                </svg>
                <span>Sound</span>
            </button>
            <button class="dice-settings-toggle" id="secretToggle2" onclick="DiceRoller.toggleSecret()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
                <span>Geheim</span>
            </button>
        </div>
    </div>
</body>
</html>
