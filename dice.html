<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/icon_rift_r.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="view-transition" content="same-origin">
    <title>RIFT – Würfel</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/dock.css">
    <link rel="stylesheet" href="assets/css/hub.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    <link rel="stylesheet" href="assets/css/dice.css?v=11">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">
<style>
        /* Back to Sheet Button */
        .back-to-sheet-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            margin-left: auto;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .back-to-sheet-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            color: var(--accent);
        }
        .back-to-sheet-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* Fix pointer-events for dice-result when visible */
        .dice-result.visible {
            pointer-events: auto !important;
        }
        
        /* Skill Check Display Styles */
        .dice-result__skill-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
            display: none;
        }
        .dice-result__skill-label.visible {
            display: block;
        }
        .dice-result__target {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 4px;
            display: none;
        }
        .dice-result__target.visible {
            display: block;
        }
        .dice-result__outcome {
            font-family: 'Dharma Gothic', 'Inter', sans-serif;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 8px;
            padding: 6px 16px;
            border-radius: 4px;
            display: none;
        }
        .dice-result__outcome.visible {
            display: inline-block;
        }
        .dice-result__outcome.success {
            color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            text-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        .dice-result__outcome.failure {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        /* Color the total based on outcome */
        .dice-result.skill-success #resultTotal {
            color: #22c55e !important;
            text-shadow: 0 0 30px rgba(34, 197, 94, 0.6);
        }
        .dice-result.skill-failure #resultTotal {
            color: #ef4444 !important;
            text-shadow: 0 0 30px rgba(239, 68, 68, 0.6);
        }
        .dice-result__back-btn {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer !important;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999 !important;
            pointer-events: auto !important;
        }
        .dice-result__back-btn.visible {
            display: inline-flex;
        }
        .dice-result__back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-primary, #FF4655);
            color: #fff;
        }
        .dice-result__back-btn svg {
            width: 18px;
            height: 18px;
        }
    </style>

    <!-- Auth Guard: Hide until authenticated -->
    <style>
        body:not(.auth-ready) .app { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) .sheet-container { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) main { opacity: 0; pointer-events: none; }
        body.auth-ready .app { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready .sheet-container { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready main { opacity: 1; transition: opacity 0.15s ease; }
    </style>
    
    <!-- Theme Preview Styles (inline fallback) -->
    <style>
        .dice-theme-card__preview--fire {
            background: linear-gradient(135deg, #ff5722 0%, #ff9800 50%, #4a1c00 100%) !important;
        }
        .dice-theme-card__preview--ocean {
            background: linear-gradient(135deg, #00ffff 0%, #0099cc 50%, #001a33 100%) !important;
        }
        .dice-theme-card__preview--toxic {
            background: linear-gradient(135deg, #39ff14 0%, #00ff00 50%, #0a2a0a 100%) !important;
            box-shadow: inset 0 0 10px rgba(57, 255, 20, 0.5);
        }
        .dice-theme-card__preview--nebula {
            background: linear-gradient(135deg, #ff6bcb 0%, #c56cf0 50%, #1a0a2e 100%) !important;
            box-shadow: inset 0 0 10px rgba(197, 108, 240, 0.5);
        }
        .dice-theme-card__preview--sunset {
            background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 50%, #2a0a1a 100%) !important;
        }
        .dice-theme-card__preview--cyber {
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%) !important;
            animation: cyber-pulse 2s ease-in-out infinite alternate;
        }
        .dice-theme-card__preview--midnight {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%) !important;
        }
        .dice-theme-card__preview--copper {
            background: linear-gradient(135deg, #cd7f32 0%, #b87333 50%, #2a1a0a 100%) !important;
        }
        .dice-theme-card__preview--void {
            background: radial-gradient(circle at 30% 30%, #6d28d9 0%, #4c1d95 30%, #000000 100%) !important;
        }
        .dice-theme-card__preview--rainbow {
            background: linear-gradient(135deg, #ff6b6b 0%, #feca57 20%, #48dbfb 40%, #ff9ff3 60%, #54a0ff 80%, #5f27cd 100%) !important;
            animation: rainbow-shift 3s ease infinite;
            background-size: 200% 200%;
        }
        @keyframes cyber-pulse {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.3); }
        }
        @keyframes rainbow-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* ═══════════════════════════════════════
           TIER SYSTEM STYLES
           ═══════════════════════════════════════ */
        .tier-section {
            margin-bottom: 24px;
        }
        .tier-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 14px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .tier-badge {
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .tier-badge--free {
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .tier-badge--silver {
            background: linear-gradient(135deg, rgba(192,192,192,0.2), rgba(128,128,128,0.15));
            color: #e0e0e0;
            border: 1px solid rgba(192,192,192,0.3);
            box-shadow: 0 0 10px rgba(192,192,192,0.15);
        }
        .tier-badge--gold {
            background: linear-gradient(135deg, rgba(255,215,0,0.25), rgba(218,165,32,0.2));
            color: #ffd700;
            border: 1px solid rgba(255,215,0,0.4);
            box-shadow: 0 0 12px rgba(255,215,0,0.2);
        }
        .tier-count {
            font-size: 12px;
            color: rgba(255,255,255,0.35);
        }
        
        /* Settings Tab Styling - Unified Design */
        .dice-settings-tabs {
            display: flex;
            gap: 4px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .dice-settings-tab {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 8px;
        }
        .dice-settings-tab:hover {
            color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.05);
        }
        .dice-settings-tab.active {
            color: #fff;
            background: rgba(255,255,255,0.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .dice-settings-tab svg {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }
        
        /* Arena Theme with Image - THE RIFT Original */
        .dice-arena-theme-preview--rift {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770181215/rift-assets/cf0ew69drn3yd5max2jr.png') center/cover;
        }
        /* RIFT Arena Themes */
        .dice-arena-theme-preview--rift-negative {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217425/rift-assets/ppyadxq8t37oj5nfytvb.png') center/cover;
        }
        .dice-arena-theme-preview--rift-tag {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217429/rift-assets/cqrjsukgmwlpwyezcbdl.png') center/cover;
        }
        .dice-arena-theme-preview--rift-tag-negative {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217434/rift-assets/ee5vhoakgzxfsez5d5w9.png') center/cover;
        }
        .dice-arena-theme-preview--rift-rest-easy {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217435/rift-assets/mjim6aws4nagnnxrxlae.png') center/cover;
        }
        .dice-arena-theme-preview--rift-rest-easy-negative {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217436/rift-assets/d3nh07m2gyxer7wdtvzv.png') center/cover;
        }
        .dice-arena-theme-preview--rift-punk {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217439/rift-assets/ttxtvwpvcicohknluxi5.png') center/cover;
        }
        .dice-arena-theme-preview--rift-punk-alt {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217441/rift-assets/tgt9azhgs7sqkxbrdh0d.png') center/cover;
        }
        .dice-arena-theme-preview--rift-leather {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217443/rift-assets/mmt55vukt4tbbpek8hlw.png') center/cover;
        }
        .dice-arena-theme-preview--rift-leather-negative {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217445/rift-assets/dlx8hdckjzuw6ijrtrjt.png') center/cover;
        }
        .dice-arena-theme-preview--rift-the-dice {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217446/rift-assets/z3nrydaaqqwgbbkcuqa3.png') center/cover;
        }
        .dice-arena-theme-preview--rift-the-dice-alt {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770217447/rift-assets/tpd35lyqdlliyvqcrq4h.png') center/cover;
        }
        .dice-arena-theme-preview--dragonclaw-red {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770235663/rift-assets/mq1vanad7kzp4tg6vwfn.png') center/cover;
        }
        .dice-arena-theme-preview--dragonclaw-green {
            background: url('https://res.cloudinary.com/dza4jgreq/image/upload/v1770235665/rift-assets/rflk7srpbglks52z43s0.png') center/cover;
        }
        
        /* Effects Grid & Buttons */
        .dice-effects-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        /* RIFT: Dauerhafter Glow-Effekt unter dem Würfel */
        .dice-glow-effect {
            position: absolute;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
            background: radial-gradient(circle, var(--glow-color, rgba(255,255,255,0.6)) 0%, transparent 70%);
            filter: blur(8px);
        }
        
        /* RIFT: Dauerhafter Pulse-Effekt (endlose Ringe) */
        .dice-pulse-effect {
            position: absolute;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
        }
        .dice-pulse-effect::before,
        .dice-pulse-effect::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border-radius: 50%;
            border: 2px solid var(--glow-color, rgba(255,255,255,0.6));
            animation: pulseRingLoop 2.5s ease-out infinite;
        }
        .dice-pulse-effect::after {
            animation-delay: 1.25s;
        }
        @keyframes pulseRingLoop {
            0% {
                width: 20px;
                height: 20px;
                margin-left: -10px;
                margin-top: -10px;
                opacity: 0.8;
            }
            100% {
                width: 200px;
                height: 200px;
                margin-left: -100px;
                margin-top: -100px;
                opacity: 0;
            }
        }
        
        /* RIFT: Body scroll lock when popup is open */
        body.popup-open {
            overflow: hidden !important;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* RIFT: Settings Preview - neben dem Popup */
        .dice-settings-preview {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px;
            background: #1b1b1b;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100000;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        }
        /* Links vom Popup auf Desktop */
        @media (min-width: 900px) {
            .dice-settings-preview {
                right: calc(50% + 320px);
            }
        }
        /* Unter dem Popup auf Mobile */
        @media (max-width: 899px) {
            .dice-settings-preview {
                display: none !important;
            }
        }
        .dice-settings-preview.open {
            display: flex;
        }
        .dice-settings-preview__canvas-wrapper {
            position: relative;
            width: 100px;
            height: 100px;
        }
        .dice-settings-preview__canvas {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            position: relative;
            z-index: 2;
        }
        .dice-settings-preview__effects {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 1;
        }
        /* Preview Glow */
        .dice-settings-preview__effects .preview-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--glow-color, #ffffff) 0%, transparent 70%);
            filter: blur(10px);
            opacity: 0.8;
        }
        /* Preview Pulse */
        .dice-settings-preview__effects .preview-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        .dice-settings-preview__effects .preview-pulse::before,
        .dice-settings-preview__effects .preview-pulse::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--glow-color, #ffffff);
            animation: previewPulseRing 2.5s ease-out infinite;
        }
        .dice-settings-preview__effects .preview-pulse::after {
            animation-delay: 1.25s;
        }
        @keyframes previewPulseRing {
            0% {
                width: 20px;
                height: 20px;
                opacity: 0.8;
            }
            100% {
                width: 90px;
                height: 90px;
                opacity: 0;
            }
        }
        .dice-settings-preview__label {
            font-size: 11px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .dice-effect-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 20px 16px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        .dice-effect-btn:hover:not(:disabled) {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.15);
        }
        .dice-effect-btn.active {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.25);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        .dice-effect-btn.active .dice-effect-btn__icon {
            color: #fff;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.5));
        }
        .dice-effect-btn--locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .dice-effect-btn__icon {
            width: 32px;
            height: 32px;
            color: rgba(255,255,255,0.6);
            transition: all 0.2s;
        }
        .dice-effect-btn__icon svg {
            width: 100%;
            height: 100%;
        }
        .dice-effect-btn__label {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
        }
        .dice-effect-btn__desc {
            font-size: 11px;
            color: rgba(255,255,255,0.4);
            text-align: center;
        }
        .dice-effect-btn__badge {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 2px 8px;
            background: linear-gradient(135deg, rgba(255,215,0,0.25), rgba(218,165,32,0.2));
            color: #ffd700;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 4px;
            border: 1px solid rgba(255,215,0,0.3);
        }
    </style>
</head>
<body class="page-dice">
    <!-- Unified Layout Placeholders -->
    <div id="topnav-placeholder"></div>
    <div id="meganav-placeholder"></div>
    
    <div class="app">
        <main class="main main--hub">
            <div class="main__content">
                
                <!-- Announcement Banner -->
                <div id="announcementBanner" style="display: none;"></div>
                
                <div class="dice-page">
                    
                    <!-- 3D Arena -->
                    <div class="dice-arena empty" id="diceArena">
                        <!-- Pulse Effects Container (UNDER dice) -->
                        <div class="dice-pulses" id="dicePulses"></div>
                        
                        <!-- Empty State -->
                        <div class="dice-arena__empty">
                            <svg class="dice-arena__empty-icon" width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                                <circle cx="12" cy="12" r="2"/>
                            </svg>
                            <p>Wähle Würfel und ziehe zum Werfen</p>
                        </div>
                        
                        <!-- Swipe Hint -->
                        <div class="dice-arena__swipe-hint">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                            Wischen zum Würfeln
                        </div>
                        
                        <!-- Dice Value Labels (overlay) -->
                        <div class="dice-labels" id="diceLabels"></div>
                        
                        <!-- Result Display -->
                        <div class="dice-result" id="diceResult">
                            <div class="dice-result__player" id="resultPlayer"></div>
                            <div class="dice-result__skill-label" id="resultSkillLabel"></div>
                            <div class="dice-result__total" id="resultTotal">0</div>
                            <div class="dice-result__target" id="resultTarget"></div>
                            <div class="dice-result__outcome" id="resultOutcome"></div>
                            <div class="dice-result__breakdown" id="resultBreakdown"></div>
                            <button class="dice-result__back-btn" id="resultBackBtn" onclick="goBackToSheet()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                    <polyline points="14 2 14 8 20 8"/>
                                    <line x1="16" y1="13" x2="8" y2="13"/>
                                    <line x1="16" y1="17" x2="8" y2="17"/>
                                    <polyline points="10 9 9 9 8 9"/>
                                </svg>
                                Zurück zum Charakterbogen
                            </button>
                        </div>
                        
                        <!-- Multiplayer Feed -->
                        <div class="dice-feed" id="diceFeed"></div>
                        
                        <!-- Particles -->
                        <div class="dice-particles" id="particlesContainer"></div>
                    </div>
                    
                    <!-- Controls -->
                    <div class="dice-controls">
                        
                        <!-- Toolbar -->
                        <div class="dice-toolbar">
                            <div class="dice-toolbar__left">
                                <!-- Presets -->
                                <div class="dice-presets-wrapper">
                                    <button class="dice-toggle" id="presetsBtn" onclick="DiceRoller.togglePresets()">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                                        </svg>
                                        Presets
                                    </button>
                                    
                                    <!-- Presets Popup -->
                                    <div class="dice-presets-popup" id="presetsPopup">
                                        <div class="dice-presets-popup__header">
                                            <span>Würfel-Presets</span>
                                            <button class="dice-presets-popup__close" onclick="DiceRoller.togglePresets()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                            </button>
                                        </div>
                                        <div class="dice-presets-popup__list" id="presetsList">
                                            <div class="dice-presets-popup__empty">Keine Presets gespeichert</div>
                                        </div>
                                        <div class="dice-presets-popup__hint">
                                            Tipp: Würfel auswählen, dann "Speichern"
                                        </div>
                                    </div>
                                </div>
                                
                                <button class="dice-toggle" id="savePresetBtn" onclick="DiceRoller.savePreset()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                        <polyline points="17 21 17 13 7 13 7 21"/>
                                        <polyline points="7 3 7 8 15 8"/>
                                    </svg>
                                    Speichern
                                </button>
                            </div>
                            <div class="dice-toolbar__right">
                                <!-- Sound Toggle -->
                                <button class="dice-toggle active" id="soundToggle" onclick="DiceRoller.toggleSound()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                    </svg>
                                    Sound
                                </button>
                                <!-- Secret Roll Toggle -->
                                <button class="dice-toggle" id="secretToggle" onclick="DiceRoller.toggleSecret()">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                    </svg>
                                    Geheim
                                </button>
                            </div>
                        </div>
                        
                        <!-- Dice Orbit - Linksklick: hinzufügen, Rechtsklick: entfernen -->
                        <div class="dice-orbit">
                            <!-- Dice Buttons - Hero Cards -->
                            <div class="dice-orbit__dice">
                                <!-- Reset Button -->
                                <button class="dice-orbit__action dice-orbit__reset" onclick="DiceRoller.clearDice()" title="Zurücksetzen">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                        <path d="M3 3v5h5"/>
                                    </svg>
                                    <span class="dice-orbit__reset-label">Reset</span>
                                </button>
                                
                                <!-- D4 -->
                                <button class="dice-btn" data-dice="d4" onclick="DiceRoller.addDice('d4')" title="D4 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d4"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D4</span>
                                    <div class="dice-btn__badge"><span id="count-d4">0</span></div>
                                </button>
                                
                                <!-- D6 -->
                                <button class="dice-btn" data-dice="d6" onclick="DiceRoller.addDice('d6')" title="D6 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d6"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D6</span>
                                    <div class="dice-btn__badge"><span id="count-d6">0</span></div>
                                </button>
                                
                                <!-- D8 -->
                                <button class="dice-btn" data-dice="d8" onclick="DiceRoller.addDice('d8')" title="D8 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d8"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D8</span>
                                    <div class="dice-btn__badge"><span id="count-d8">0</span></div>
                                </button>
                                
                                <!-- D10 -->
                                <button class="dice-btn" data-dice="d10" onclick="DiceRoller.addDice('d10')" title="D10 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d10"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D10</span>
                                    <div class="dice-btn__badge"><span id="count-d10">0</span></div>
                                </button>
                                
                                <!-- D12 -->
                                <button class="dice-btn" data-dice="d12" onclick="DiceRoller.addDice('d12')" title="D12 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d12"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D12</span>
                                    <div class="dice-btn__badge"><span id="count-d12">0</span></div>
                                </button>
                                
                                <!-- D20 -->
                                <button class="dice-btn" data-dice="d20" onclick="DiceRoller.addDice('d20')" title="D20 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d20"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D20</span>
                                    <div class="dice-btn__badge"><span id="count-d20">0</span></div>
                                </button>
                                
                                <!-- D100 -->
                                <button class="dice-btn" data-dice="d100" onclick="DiceRoller.addDice('d100')" title="D100 - Linksklick: +1 / Rechtsklick: -1">
                                    <div class="dice-btn__icon">
                                        <canvas class="dice-btn__canvas" data-type="d100"></canvas>
                                    </div>
                                    <span class="dice-btn__label">D100</span>
                                    <div class="dice-btn__badge"><span id="count-d100">0</span></div>
                                </button>
                                
                                <!-- Divider -->
                                <div class="dice-orbit__divider"></div>
                                
                                <!-- Settings Group: 2 rows -->
                                <div class="dice-orbit__settings-group">
                                    <!-- Row 1: Settings (full width) -->
                                    <div class="dice-settings-wrapper dice-settings-wrapper--full">
                                        <button class="dice-orbit__action dice-orbit__settings" id="settingsBtn" title="Einstellungen">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
                                                <circle cx="12" cy="12" r="3"/>
                                            </svg>
                                        </button>
                                    </div>
                                    
                                    <!-- Row 2: Stats + Hotkeys -->
                                    <div class="dice-orbit__settings-row">
                                        <!-- Stats Button -->
                                        <div class="dice-settings-wrapper">
                                            <button class="dice-orbit__action dice-orbit__stats" id="statsBtn" title="Statistiken">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <path d="M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.997.398-.997.95v8a1 1 0 0 0 1 1z"/>
                                                    <path d="M21.21 15.89A10 10 0 1 1 8 2.83"/>
                                                </svg>
                                            </button>
                                        </div>
                                        
                                        <!-- Hotkeys Button -->
                                        <div class="dice-settings-wrapper">
                                            <button class="dice-orbit__action dice-orbit__hotkeys" id="hotkeysBtn" title="Tastenkürzel">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <rect x="2" y="4" width="20" height="16" rx="2"/>
                                                    <path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M6 16h12"/>
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div class="dice-quick-row">
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w20')">1W20</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('2w6')">2W6</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w20+5')">1W20+5</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('4w6')">4W6</button>
                            <button class="dice-preset" onclick="DiceRoller.quickRoll('1w100')">1W100</button>
                            
                            <button class="dice-adv-btn" onclick="DiceRoller.rollAdvantage()" title="2W20, höchsten nehmen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
                                Vorteil
                            </button>
                            <button class="dice-adv-btn dice-adv-btn--dis" onclick="DiceRoller.rollDisadvantage()" title="2W20, niedrigsten nehmen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                                Nachteil
                            </button>
                            
                            <button class="dice-repeat-btn" id="repeatBtn" onclick="DiceRoller.repeatLast()" disabled title="Letzten Wurf wiederholen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Nochmal
                            </button>
                        </div>
                        
                        <!-- Roll Zone -->
                        <div class="dice-roll-zone">
                            <!-- Custom Notation Input (hidden by default) -->
                            <div class="dice-notation">
                                <input type="text" 
                                       class="dice-notation__input" 
                                       id="notationInput" 
                                       placeholder="z.B. 2W6+3, 1W20+1W4..."
                                       onkeydown="if(event.key==='Enter') DiceRoller.rollFromNotation()">
                                <button class="dice-notation__clear" onclick="document.getElementById('notationInput').value=''; DiceRoller.clearDice();">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                </button>
                            </div>
                            
                            <!-- Modifier -->
                            <div class="dice-modifier">
                                <button class="dice-modifier__btn dice-modifier__btn--lg" onclick="DiceRoller.adjustModifier(-20)">−20</button>
                                <button class="dice-modifier__btn dice-modifier__btn--md" onclick="DiceRoller.adjustModifier(-10)">−10</button>
                                <button class="dice-modifier__btn" onclick="DiceRoller.adjustModifier(-5)">−5</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-4)">−4</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-3)">−3</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-2)">−2</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(-1)">−1</button>
                                <div class="dice-modifier__display" id="modifierDisplay">+0</div>
                                <input type="number" class="dice-modifier__value" id="modifierInput" value="0" min="-99" max="99">
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(1)">+1</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(2)">+2</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(3)">+3</button>
                                <button class="dice-modifier__btn dice-modifier__btn--sm" onclick="DiceRoller.adjustModifier(4)">+4</button>
                                <button class="dice-modifier__btn" onclick="DiceRoller.adjustModifier(5)">+5</button>
                                <button class="dice-modifier__btn dice-modifier__btn--md" onclick="DiceRoller.adjustModifier(10)">+10</button>
                                <button class="dice-modifier__btn dice-modifier__btn--lg" onclick="DiceRoller.adjustModifier(20)">+20</button>
                            </div>
                            
                            <!-- Roll Button -->
                            <button class="dice-roll-btn" id="rollBtn" onclick="DiceRoller.roll()" disabled>
                                Würfeln!
                            </button>
                            
                            <!-- Quick Actions -->
                            <div class="dice-action-group">
                                <button class="dice-action-btn dice-action-btn--adv" onclick="DiceRoller.rollAdvantage()" title="Vorteil (2W20↑)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="18 15 12 9 6 15"/></svg>
                                </button>
                                <button class="dice-action-btn dice-action-btn--dis" onclick="DiceRoller.rollDisadvantage()" title="Nachteil (2W20↓)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="6 9 12 15 18 9"/></svg>
                                </button>
                            </div>
                            
                            <!-- Reset Button -->
                            <button class="dice-mobile-reset" onclick="DiceRoller.clearDice();">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                    <path d="M3 3v5h5"/>
                                </svg>
                            </button>
                            
                            <!-- Mobile Settings Button -->
                            <button class="dice-mobile-settings" onclick="document.getElementById('mobileSettingsPopup').classList.add('open'); document.getElementById('mobileSettingsOverlay').classList.add('open');">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                                </svg>
                                Einstellungen
                            </button>
                        </div>
                        
                        <!-- History -->
                        <div class="dice-history">
                            <div class="dice-history__header">
                                <span class="dice-history__title">Verlauf</span>
                                <div class="dice-history__actions">
                                    <button class="dice-history__export" onclick="DiceRoller.exportHistory()" title="Exportieren">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                            <polyline points="7 10 12 15 17 10"/>
                                            <line x1="12" y1="15" x2="12" y2="3"/>
                                        </svg>
                                    </button>
                                    <button class="dice-history__clear" onclick="DiceRoller.clearHistory()">Löschen</button>
                                </div>
                            </div>
                            
                            <div class="dice-history__list" id="historyList">
                                <div class="dice-history__empty">Noch keine Würfe</div>
                            </div>
                        </div>
                        
                    </div>
                    
                </div>
                
                <!-- Footer Placeholder -->
                <div id="footer-placeholder"></div>
                
            </div>
        </main>
        
        <!-- Probability Tooltip -->
        <div class="dice-probability-tooltip" id="probTooltip">
            <div class="dice-probability-tooltip__title"></div>
            <div class="dice-probability-tooltip__content"></div>
        </div>
    </div>
    
    <!-- Dock Placeholder -->
    <div id="dock-placeholder"></div>
    
    <!-- 3D Dice Libraries -->
    <script src="assets/libs/dice/teal.js"></script>
    <script src="assets/libs/dice/three.min.js"></script>
    <script src="assets/libs/dice/cannon.min.js"></script>
    <script src="assets/libs/dice/dice-new.js?v=15"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- RIFT Services -->
    <script src="assets/js/firebase-config.js"></script>
    <script>
        // Auth Guard - redirect to login if not authenticated
        (function() {
            function waitForAuth() {
                // Wait for Firebase SDK
                if (typeof firebase === 'undefined' || !firebase.auth) {
                    return setTimeout(waitForAuth, 50);
                }
                // Wait for Firebase app initialization
                try {
                    var auth = firebase.auth();
                    auth.onAuthStateChanged(function(user) {
                        if (!user) {
                            window.location.href = '/login';
                        } else {
                            document.body.classList.add('auth-ready');
                        }
                    });
                } catch(e) {
                    // Firebase not initialized yet, retry
                    setTimeout(waitForAuth, 50);
                }
            }
            waitForAuth();
        })();
    </script>

    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    
    <!-- Core Scripts -->
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/layout-unified.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    
    <script>
        // ========================================
        // RIFT DICE ROLLER - FULL FEATURED
        // ========================================
        
        // Global sound toggle for library
        window.RIFT_DICE_SOUND = true;
        
        const DiceRoller = {
            // State
            box: null,
            currentDice: {},
            history: [],
            lastRoll: null,
            isRolling: false,
            resultTimeout: null,
            
            // Skill Check State (Worlds Apart)
            skillCheckMode: false,
            skillCheckTarget: 0,
            skillCheckLabel: '',
            
            // Fokus Check State (Worlds Apart D20)
            fokusCheckMode: false,
            fokusCheckLabel: '',
            fokusCheckMod: 0,
            
            // Zweite Chance State (Worlds Apart D20)
            zweiteChanceMode: false,
            zweiteChanceDiceIndex: -1,
            
            // Last check result (for passing back to sheet)
            lastCheckResult: null,
            
            // Return URL (back to character sheet)
            returnUrl: null,
            
            // Settings
            soundEnabled: true,
            secretRoll: false,
            currentTheme: null,
            currentDiceColor: '#2a2a2a',
            currentLabelColor: 'auto', // 'auto' oder Hex-Farbe
            
            // Theme colors for 3D dice
            themeColors: {
                // ═══════════════════════════════════════
                // SCHWARZ & GRAU
                // ═══════════════════════════════════════
                black: { primary: '#0a0a0a', secondary: '#333333', accent: '#1a1a1a' },
                onyx: { primary: '#0d0d0d', secondary: '#2d2d2d', accent: '#1f1f1f' },
                charcoal: { primary: '#1a1a1a', secondary: '#404040', accent: '#2d2d2d' },
                graphite: { primary: '#1c1c1c', secondary: '#4a4a4a', accent: '#363636' },
                slate: { primary: '#1e2a30', secondary: '#546e7a', accent: '#455a64' },
                storm: { primary: '#1a1a2e', secondary: '#5c6a7e', accent: '#4a5568' },
                ash: { primary: '#2a2a2a', secondary: '#6b6b6b', accent: '#505050' },
                smoke: { primary: '#2d2d2d', secondary: '#808080', accent: '#696969' },
                silver: { primary: '#1a1a1a', secondary: '#c0c0c0', accent: '#a8a8a8' },
                pearl: { primary: '#1a1a1a', secondary: '#e8e8e8', accent: '#d4d4d4' },
                white: { primary: '#1a1a1a', secondary: '#ffffff', accent: '#f5f5f5' },
                
                // ═══════════════════════════════════════
                // ROT
                // ═══════════════════════════════════════
                maroon: { primary: '#1a0a0a', secondary: '#800000', accent: '#4a0000' },
                darkRed: { primary: '#1a0505', secondary: '#8b0000', accent: '#660000' },
                crimson: { primary: '#1a0a0a', secondary: '#dc143c', accent: '#b21030' },
                red: { primary: '#1a0a0a', secondary: '#ff0000', accent: '#cc0000' },
                scarlet: { primary: '#1a0808', secondary: '#ff2400', accent: '#d41f00' },
                cherry: { primary: '#1a0a0a', secondary: '#de3163', accent: '#b8264f' },
                ruby: { primary: '#1a0a10', secondary: '#e0115f', accent: '#b80e4d' },
                rose: { primary: '#1a1015', secondary: '#ff007f', accent: '#d10069' },
                coral: { primary: '#1a1210', secondary: '#ff7f50', accent: '#e56b3e' },
                salmon: { primary: '#1a1412', secondary: '#fa8072', accent: '#e8705f' },
                
                // ═══════════════════════════════════════
                // ORANGE
                // ═══════════════════════════════════════
                rust: { primary: '#1a0f05', secondary: '#b7410e', accent: '#8b3208' },
                copper: { primary: '#1a100a', secondary: '#b87333', accent: '#96602a' },
                bronze: { primary: '#1a1008', secondary: '#cd7f32', accent: '#a86828' },
                burnt: { primary: '#1a0f08', secondary: '#cc5500', accent: '#a84600' },
                orange: { primary: '#1a1005', secondary: '#ff8c00', accent: '#e07800' },
                tangerine: { primary: '#1a1008', secondary: '#ff9966', accent: '#e88555' },
                peach: { primary: '#1a1510', secondary: '#ffcba4', accent: '#e8b893' },
                apricot: { primary: '#1a1410', secondary: '#fbceb1', accent: '#e8bc9f' },
                
                // ═══════════════════════════════════════
                // GELB & GOLD
                // ═══════════════════════════════════════
                gold: { primary: '#1a1505', secondary: '#ffd700', accent: '#d4b000' },
                amber: { primary: '#1a1408', secondary: '#ffbf00', accent: '#d4a000' },
                honey: { primary: '#1a1308', secondary: '#eb9605', accent: '#c88005' },
                mustard: { primary: '#1a1508', secondary: '#ffdb58', accent: '#e0c34d' },
                yellow: { primary: '#1a1a05', secondary: '#ffff00', accent: '#e6e600' },
                lemon: { primary: '#1a1a08', secondary: '#fff44f', accent: '#e6dc47' },
                cream: { primary: '#1a1a10', secondary: '#fffdd0', accent: '#e8e6be' },
                ivory: { primary: '#1a1a12', secondary: '#fffff0', accent: '#e8e8d8' },
                
                // ═══════════════════════════════════════
                // GRÜN
                // ═══════════════════════════════════════
                darkGreen: { primary: '#050f05', secondary: '#013220', accent: '#012818' },
                forest: { primary: '#081a08', secondary: '#228b22', accent: '#1a6b1a' },
                hunter: { primary: '#0a1a0a', secondary: '#355e3b', accent: '#2a4a30' },
                emerald: { primary: '#081a10', secondary: '#50c878', accent: '#40a060' },
                green: { primary: '#0a1a0a', secondary: '#00ff00', accent: '#00d400' },
                lime: { primary: '#101a08', secondary: '#32cd32', accent: '#28a828' },
                grass: { primary: '#101a08', secondary: '#7cfc00', accent: '#68d800' },
                mint: { primary: '#0a1a14', secondary: '#98fb98', accent: '#7de87d' },
                sage: { primary: '#101a10', secondary: '#9dc183', accent: '#84a86e' },
                olive: { primary: '#12140a', secondary: '#808000', accent: '#666600' },
                jade: { primary: '#0a1a12', secondary: '#00a86b', accent: '#008856' },
                teal: { primary: '#0a1a1a', secondary: '#008080', accent: '#006666' },
                
                // ═══════════════════════════════════════
                // CYAN & TÜRKIS
                // ═══════════════════════════════════════
                cyan: { primary: '#051a1a', secondary: '#00ffff', accent: '#00d4d4' },
                aqua: { primary: '#081a1a', secondary: '#00ced1', accent: '#00a8ab' },
                turquoise: { primary: '#0a1a18', secondary: '#40e0d0', accent: '#35b8aa' },
                seafoam: { primary: '#0a1a16', secondary: '#71eeb8', accent: '#5dd4a0' },
                
                // ═══════════════════════════════════════
                // BLAU
                // ═══════════════════════════════════════
                navy: { primary: '#05050f', secondary: '#000080', accent: '#000066' },
                midnight: { primary: '#08081a', secondary: '#191970', accent: '#14145a' },
                darkBlue: { primary: '#05081a', secondary: '#00008b', accent: '#000070' },
                royal: { primary: '#080a1a', secondary: '#4169e1', accent: '#3555c0' },
                blue: { primary: '#05051a', secondary: '#0000ff', accent: '#0000d4' },
                cobalt: { primary: '#080a1a', secondary: '#0047ab', accent: '#003a8c' },
                azure: { primary: '#081018', secondary: '#007fff', accent: '#0068d4' },
                sky: { primary: '#0a1218', secondary: '#87ceeb', accent: '#6eb8d8' },
                powder: { primary: '#0a1416', secondary: '#b0e0e6', accent: '#96c8ce' },
                ice: { primary: '#0a1418', secondary: '#a5f2f3', accent: '#8ad8d9' },
                
                // ═══════════════════════════════════════
                // LILA & VIOLETT
                // ═══════════════════════════════════════
                indigo: { primary: '#0a0a14', secondary: '#4b0082', accent: '#3c0068' },
                purple: { primary: '#0f0a18', secondary: '#800080', accent: '#660066' },
                violet: { primary: '#10081a', secondary: '#8f00ff', accent: '#7400d4' },
                amethyst: { primary: '#120a1a', secondary: '#9966cc', accent: '#7d54ab' },
                lavender: { primary: '#12101a', secondary: '#b57edc', accent: '#9668ba' },
                lilac: { primary: '#14101a', secondary: '#c8a2c8', accent: '#ab88ab' },
                plum: { primary: '#140a14', secondary: '#8e4585', accent: '#74396d' },
                grape: { primary: '#10081a', secondary: '#6f2da8', accent: '#5a258a' },
                
                // ═══════════════════════════════════════
                // PINK & MAGENTA
                // ═══════════════════════════════════════
                magenta: { primary: '#1a081a', secondary: '#ff00ff', accent: '#d400d4' },
                fuchsia: { primary: '#1a0a18', secondary: '#ff77ff', accent: '#e066e0' },
                hotPink: { primary: '#1a0815', secondary: '#ff69b4', accent: '#e05a9c' },
                pink: { primary: '#1a0a12', secondary: '#ffc0cb', accent: '#e8aeb8' },
                blush: { primary: '#1a1012', secondary: '#de5d83', accent: '#ba4e6e' },
                raspberry: { primary: '#1a0810', secondary: '#e30b5c', accent: '#be094d' },
                
                // ═══════════════════════════════════════
                // BRAUN & ERDTÖNE
                // ═══════════════════════════════════════
                brown: { primary: '#100a05', secondary: '#8b4513', accent: '#724010' },
                chocolate: { primary: '#0f0805', secondary: '#7b3f00', accent: '#653400' },
                coffee: { primary: '#0d0805', secondary: '#6f4e37', accent: '#5c412e' },
                mocha: { primary: '#100a08', secondary: '#967969', accent: '#7d6458' },
                tan: { primary: '#14100a', secondary: '#d2b48c', accent: '#b89c78' },
                beige: { primary: '#14120e', secondary: '#f5f5dc', accent: '#dcdcc6' },
                sand: { primary: '#14120a', secondary: '#c2b280', accent: '#a8996d' },
                khaki: { primary: '#12100a', secondary: '#c3b091', accent: '#a8967c' },
                
                // ═══════════════════════════════════════
                // METALLIC
                // ═══════════════════════════════════════
                steel: { primary: '#101214', secondary: '#71797e', accent: '#5d6468' },
                chrome: { primary: '#121416', secondary: '#dbe4eb', accent: '#c2ccd4' },
                titanium: { primary: '#101214', secondary: '#878681', accent: '#706f6a' },
                gunmetal: { primary: '#0d0e10', secondary: '#2a3439', accent: '#232a2e' },
                platinum: { primary: '#121416', secondary: '#e5e4e2', accent: '#cccbc9' },
                rosegold: { primary: '#1a1210', secondary: '#b76e79', accent: '#9c5d66' },
                
                // ═══════════════════════════════════════
                // TEXTURED (Test)
                // ═══════════════════════════════════════
                marbleWhite: { 
                    primary: '#1a1a1a', secondary: '#f5f5f5', accent: '#e8e8e8',
                    texture: { type: 'marble', baseColor: '#f0f0f0', veinColor: '#888888' }
                },
                marbleBlack: { 
                    primary: '#0a0a0a', secondary: '#2d2d2d', accent: '#1a1a1a',
                    texture: { type: 'marble', baseColor: '#1a1a1a', veinColor: '#444444' }
                },
                marbleGreen: { 
                    primary: '#0a1a0a', secondary: '#2d4a2d', accent: '#1a3a1a',
                    texture: { type: 'marble', baseColor: '#1a3a1a', veinColor: '#4a8a4a' }
                },
                woodOak: { 
                    primary: '#1a1008', secondary: '#8d6e63', accent: '#6d4c41',
                    texture: { type: 'wood', baseColor: '#8d6e63', grainColor: '#5d4037' }
                },
                woodEbony: { 
                    primary: '#0a0805', secondary: '#2d2520', accent: '#1a1510',
                    texture: { type: 'wood', baseColor: '#1a1510', grainColor: '#0a0805' }
                },
                stoneGranite: { 
                    primary: '#1a1a1a', secondary: '#9e9e9e', accent: '#757575',
                    texture: { type: 'stone', baseColor: '#757575', speckleColor: '#424242' }
                },
                
                // ═══════════════════════════════════════
                // PREMIUM - Gems & Special
                // ═══════════════════════════════════════
                sapphire: { primary: '#051030', secondary: '#0047ab', accent: '#1a5cff' },
                bloodmoon: { primary: '#1a0000', secondary: '#8b0000', accent: '#cc0000' },
                aurora: { primary: '#0a1a1a', secondary: '#00ff87', accent: '#60efff' },
                lava: { primary: '#1a0800', secondary: '#ff4500', accent: '#ff6b00' },
                ice: { primary: '#0a1418', secondary: '#a5f2f3', accent: '#80deea' },
                
                // ═══════════════════════════════════════
                // FARBVERLÄUFE (Gradients)
                // ═══════════════════════════════════════
                gradSunset: { 
                    primary: '#1a0a05', secondary: '#ff7e5f', accent: '#feb47b',
                    gradient: { type: 'linear', colors: ['#ff7e5f', '#feb47b', '#ff6b6b'] }
                },
                gradOcean: { 
                    primary: '#051a1a', secondary: '#00b4db', accent: '#0083b0',
                    gradient: { type: 'linear', colors: ['#00b4db', '#0083b0', '#005f7f'] }
                },
                gradToxic: { 
                    primary: '#0a1a05', secondary: '#39ff14', accent: '#32cd32',
                    gradient: { type: 'linear', colors: ['#39ff14', '#32cd32', '#228b22'] }
                },
                gradNebula: { 
                    primary: '#1a0a1e', secondary: '#ff6bcb', accent: '#c56cf0',
                    gradient: { type: 'radial', colors: ['#ff6bcb', '#c56cf0', '#6c5ce7'] }
                },
                gradFire: { 
                    primary: '#1a0500', secondary: '#ff5722', accent: '#ff9800',
                    gradient: { type: 'linear', colors: ['#ff5722', '#ff9800', '#ffeb3b'] }
                },
                // 5 dunkle Gradients
                gradAbyssal: { 
                    primary: '#050510', secondary: '#1a1a3e', accent: '#2d1b69',
                    gradient: { type: 'radial', colors: ['#2d1b69', '#151530', '#050510'] }
                },
                gradVoid: { 
                    primary: '#0a0010', secondary: '#1a0030', accent: '#3d0066',
                    gradient: { type: 'radial', colors: ['#3d0066', '#1a0030', '#080015'] }
                },
                gradShadow: { 
                    primary: '#0a0a0a', secondary: '#2d2d3d', accent: '#1a1a2e',
                    gradient: { type: 'linear', colors: ['#2d2d3d', '#1a1a2e', '#0a0a14'] }
                },
                gradBloodMist: { 
                    primary: '#100005', secondary: '#3d0015', accent: '#660022',
                    gradient: { type: 'radial', colors: ['#660022', '#3d0015', '#100005'] }
                },
                gradDeepSea: { 
                    primary: '#020810', secondary: '#0a2035', accent: '#0d3050',
                    gradient: { type: 'linear', colors: ['#0d3050', '#0a2035', '#030a15'] }
                },
                
                // ═══════════════════════════════════════
                // TEXTUREN (Expanded)
                // ═══════════════════════════════════════
                obsidian: { 
                    primary: '#050508', secondary: '#1a1a24', accent: '#0f0f18',
                    gradient: { type: 'radial', colors: ['#1e1e2a', '#0f0f18', '#080810'] },
                    texture: { type: 'obsidian' }
                },
                jadeGreen: { 
                    primary: '#051a0a', secondary: '#2e8b57', accent: '#1e6b3a',
                    gradient: { type: 'radial', colors: ['#3da06a', '#2e8b57', '#1a5a35'] },
                    texture: { type: 'jade' }
                },
                lapisBlue: { 
                    primary: '#05082a', secondary: '#1a3c8a', accent: '#0e2860',
                    gradient: { type: 'radial', colors: ['#2850a0', '#1a3c8a', '#0e2860'] },
                    texture: { type: 'lapis' }
                },
                meteoriteIron: { 
                    primary: '#101214', secondary: '#5a5a5a', accent: '#3d3d3d',
                    gradient: { type: 'linear', colors: ['#6a6a6a', '#4a4a4a', '#2d2d2d'] },
                    texture: { type: 'meteorite' }
                },
                fossilStone: { 
                    primary: '#141210', secondary: '#b8a88a', accent: '#8a7a5a',
                    gradient: { type: 'linear', colors: ['#c4b090', '#a0906a', '#7a6a4a'] },
                    texture: { type: 'fossil' }
                },
                carbonFiber: { 
                    primary: '#080808', secondary: '#2a2a2a', accent: '#1a1a1a',
                    gradient: { type: 'linear', colors: ['#2d2d2d', '#1a1a1a', '#101010'] },
                    texture: { type: 'carbon' }
                },
                snakeSkin: { 
                    primary: '#0a0f0a', secondary: '#3a5a3a', accent: '#2a4a2a',
                    gradient: { type: 'linear', colors: ['#4a6a4a', '#3a5a3a', '#1a3a1a'] },
                    texture: { type: 'snakeskin' }
                },
                chainmailSilver: { 
                    primary: '#101214', secondary: '#8a8a90', accent: '#6a6a70',
                    gradient: { type: 'linear', colors: ['#a0a0a8', '#7a7a82', '#5a5a62'] },
                    texture: { type: 'chainmail' }
                },
                damascusSteel: { 
                    primary: '#0a0c10', secondary: '#5a6070', accent: '#3a4050',
                    gradient: { type: 'linear', colors: ['#6a7080', '#4a5060', '#2a3040'] },
                    texture: { type: 'damascus' }
                },
                runicStone: { 
                    primary: '#0a0a14', secondary: '#3a3a5a', accent: '#2a2a44',
                    gradient: { type: 'radial', colors: ['#4a4a6a', '#2a2a44', '#1a1a2e'] },
                    texture: { type: 'runes' }
                },
                nebulaGlow: { 
                    primary: '#0a0518', secondary: '#2e1a5a', accent: '#1a0e3a',
                    gradient: { type: 'radial', colors: ['#3a2070', '#2e1a5a', '#0a0518'] },
                    texture: { type: 'nebula' }
                },
                veinsGold: { 
                    primary: '#1a1005', secondary: '#3a2a10', accent: '#2a1a08',
                    gradient: { type: 'linear', colors: ['#4a3a1a', '#2a1a08', '#1a1005'] },
                    texture: { type: 'veins' }
                },
                circuitBoard: { 
                    primary: '#001a0a', secondary: '#005520', accent: '#003a14',
                    gradient: { type: 'linear', colors: ['#007030', '#005520', '#003010'] },
                    texture: { type: 'circuit' }
                },
                boneWhite: { 
                    primary: '#14120e', secondary: '#e8dcc8', accent: '#d0c4a8',
                    gradient: { type: 'linear', colors: ['#f0e4d0', '#dcd0b8', '#c4b898'] },
                    texture: { type: 'bone' }
                },
                parchmentOld: { 
                    primary: '#141008', secondary: '#d4c4a0', accent: '#b0a070',
                    gradient: { type: 'linear', colors: ['#e0d0b0', '#c4b490', '#a89870'] },
                    texture: { type: 'parchment' }
                },
                crystalAmethyst: { 
                    primary: '#10051a', secondary: '#7a3ab0', accent: '#5a2890',
                    gradient: { type: 'radial', colors: ['#9050d0', '#6a30a0', '#4a1880'] },
                    texture: { type: 'crystal' }
                }
            },
            
            // Firebase
            roomRef: null,
            diceRef: null,
            
            // ========================================
            // INITIALIZATION
            // ========================================
            
            init() {
                console.log('[DiceRoller] Initializing...');
                
                const container = document.getElementById('diceArena');
                if (!container) {
                    console.error('[DiceRoller] Container not found');
                    return;
                }
                
                // Wait for container to have dimensions
                if (container.clientWidth === 0 || container.clientHeight === 0) {
                    setTimeout(() => this.init(), 200);
                    return;
                }
                
                // Initialize 3D Dice
                if (typeof DICE !== 'undefined') {
                    try {
                        this.box = new DICE.dice_box(container);
                        this.initSwipe(container);
                        console.log('[DiceRoller] 3D Dice initialized');
                    } catch (e) {
                        console.error('[DiceRoller] 3D init failed:', e);
                    }
                }
                
                // Load settings
                this.loadSettings();
                this.loadHistory();
                this.initThemes();
                this.initSettings();
                this.initRightClick();
                this.initMultiplayer();
                this.initDragDrop();
                this.initKeyboard();
                this.initShakeToRoll();
                this.initProbabilityTooltips();
                this.updateUI();
                this.updateModifierDisplay(0);
                
                // Check for URL parameters (Auto-Roll from Charakterbogen)
                this.handleUrlParams();
            },
            
            // ========================================
            // URL PARAMETER HANDLING (Auto-Roll)
            // ========================================
            
            handleUrlParams() {
                const params = new URLSearchParams(window.location.search);
                
                // Check for return URL (back to character sheet)
                const returnUrl = params.get('return');
                if (returnUrl) {
                    this.returnUrl = decodeURIComponent(returnUrl);
                    const backBtn = document.getElementById('backToSheetBtn');
                    const resultBackBtn = document.getElementById('resultBackBtn');
                    if (backBtn) {
                        backBtn.style.display = 'inline-flex';
                    }
                    if (resultBackBtn) {
                        resultBackBtn.style.display = 'inline-flex';
                    }
                }
                
                // Check for auto-roll parameters
                const diceType = params.get('dice'); // e.g., "d20" or "d100"
                const modifier = parseInt(params.get('mod')) || 0;
                const diceCount = parseInt(params.get('count')) || 1; // For multi-dice rolls (e.g., 2d6)
                const label = params.get('label') ? decodeURIComponent(params.get('label')) : '';
                const autoRoll = params.get('roll') === '1';
                const checkType = params.get('check'); // 'fokus' for D20 fokus checks, 'zweitechance' for second chance
                const diceIndex = params.get('diceIndex'); // For Zweite Chance
                const isQuickDice = params.get('quickdice') === 'true'; // From dock quick dice
                
                // Valid dice types
                const validDice = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20', 'd100'];
                
                if (diceType && autoRoll && validDice.includes(diceType)) {
                    console.log('[DiceRoller] Auto-roll from URL:', { diceType, diceCount, modifier, label, checkType, isQuickDice });
                    
                    // Reset all check modes
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                    this.zweiteChanceMode = false;
                    this.zweiteChanceDiceIndex = -1;
                    
                    // Check if this is a Zweite Chance check (D20 with check=zweitechance)
                    if (diceType === 'd20' && checkType === 'zweitechance') {
                        this.zweiteChanceMode = true;
                        this.zweiteChanceDiceIndex = parseInt(diceIndex) || 0;
                        console.log('[DiceRoller] Zweite Chance Mode:', { diceIndex: this.zweiteChanceDiceIndex });
                    }
                    // Check if this is a Fokus check (D20 with check=fokus)
                    else if (diceType === 'd20' && checkType === 'fokus' && label) {
                        this.fokusCheckMode = true;
                        this.fokusCheckLabel = label;
                        this.fokusCheckMod = modifier;
                        console.log('[DiceRoller] Fokus Check Mode:', { label, mod: modifier });
                    }
                    // Check if this is a Worlds Apart skill check (d100 with label)
                    else if (diceType === 'd100' && label) {
                        this.skillCheckMode = true;
                        this.skillCheckTarget = modifier; // For skill checks, mod is the target number
                        this.skillCheckLabel = label;
                        console.log('[DiceRoller] Skill Check Mode:', { target: modifier, label });
                    }
                    
                    // Clear current dice and set the requested one
                    this.currentDice = {};
                    this.currentDice[diceType] = diceCount;
                    
                    // Set modifier
                    if (this.skillCheckMode) {
                        // For D100 skill checks, mod is the target, not added to roll
                        document.getElementById('modifierInput').value = 0;
                        this.updateModifierDisplay(0);
                    } else {
                        // For fokus checks and normal rolls, use modifier
                        document.getElementById('modifierInput').value = modifier;
                        this.updateModifierDisplay(modifier);
                    }
                    
                    // Update UI
                    this.updateUI();
                    
                    // Show label as toast
                    if (window.RIFT?.ui?.Toast) {
                        if (this.skillCheckMode && label) {
                            RIFT.ui.Toast.info(`${label} – Zielwert: ${modifier}`);
                        } else if (this.fokusCheckMode && label) {
                            RIFT.ui.Toast.info(`${label} – W20${modifier >= 0 ? '+' : ''}${modifier}`);
                        } else if (label) {
                            const modStr = modifier !== 0 ? (modifier >= 0 ? `+${modifier}` : modifier) : '';
                            RIFT.ui.Toast.info(`${label}: ${diceCount > 1 ? diceCount : ''}W${diceType.replace('d', '')}${modStr}`);
                        } else if (isQuickDice) {
                            // Quick dice without label - show dice formula
                            const modStr = modifier !== 0 ? (modifier >= 0 ? `+${modifier}` : modifier) : '';
                            RIFT.ui.Toast.info(`${diceCount > 1 ? diceCount : ''}W${diceType.replace('d', '')}${modStr}`);
                        }
                    }
                    
                    // Auto-roll after delay (wait for 3D box to be ready)
                    setTimeout(() => {
                        console.log('[DiceRoller] Auto-rolling now, box ready:', !!this.box);
                        this.roll();
                    }, 800);
                    
                    // Clean URL (remove params without reload)
                    const cleanUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
            },
            
            // ========================================
            // KEYBOARD SHORTCUTS
            // ========================================
            
            initKeyboard() {
                document.addEventListener('keydown', (e) => {
                    // Ignoriere wenn in Input-Feld
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    const key = e.key.toLowerCase();
                    
                    // Enter = Würfeln
                    if (e.key === 'Enter' && !this.isRolling) {
                        e.preventDefault();
                        this.roll();
                        return;
                    }
                    
                    // Space = Würfeln (alternativ)
                    if (e.key === ' ' && !this.isRolling) {
                        e.preventDefault();
                        this.roll();
                        return;
                    }
                    
                    // 1-7 = Würfel hinzufügen
                    const diceMap = {
                        '1': 'd4',
                        '2': 'd6',
                        '3': 'd8',
                        '4': 'd10',
                        '5': 'd12',
                        '6': 'd20',
                        '7': 'd100'
                    };
                    
                    if (diceMap[key]) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.removeDice(diceMap[key]);
                        } else {
                            this.addDice(diceMap[key]);
                        }
                        return;
                    }
                    
                    // R = Repeat
                    if (key === 'r' && this.lastRoll) {
                        e.preventDefault();
                        this.repeatLast();
                        return;
                    }
                    
                    // Backspace/Delete/Escape = Reset
                    if (e.key === 'Backspace' || e.key === 'Delete' || e.key === 'Escape') {
                        e.preventDefault();
                        this.clearDice();
                        return;
                    }
                    
                    // +/= = Modifier erhöhen
                    if (key === '+' || key === '=') {
                        e.preventDefault();
                        this.adjustModifier(e.shiftKey ? 5 : 1);
                        return;
                    }
                    
                    // - = Modifier verringern
                    if (key === '-') {
                        e.preventDefault();
                        this.adjustModifier(e.shiftKey ? -5 : -1);
                        return;
                    }
                    
                    // A = Advantage
                    if (key === 'a' && !e.ctrlKey) {
                        e.preventDefault();
                        this.rollAdvantage();
                        return;
                    }
                    
                    // D = Disadvantage
                    if (key === 'd' && !e.ctrlKey) {
                        e.preventDefault();
                        this.rollDisadvantage();
                        return;
                    }
                });
            },
            
            // ========================================
            // SHAKE TO ROLL (Mobile)
            // ========================================
            
            shakeThreshold: 15,
            lastShakeTime: 0,
            
            initShakeToRoll() {
                // Check if DeviceMotion is available
                if (!('DeviceMotionEvent' in window)) {
                    console.log('[DiceRoller] DeviceMotion not available');
                    return;
                }
                
                // Request permission on iOS 13+
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    // Will be triggered on first touch
                    document.body.addEventListener('touchstart', () => {
                        DeviceMotionEvent.requestPermission()
                            .then(response => {
                                if (response === 'granted') {
                                    this.bindShakeListener();
                                }
                            })
                            .catch(console.error);
                    }, { once: true });
                } else {
                    this.bindShakeListener();
                }
            },
            
            bindShakeListener() {
                let lastX = null, lastY = null, lastZ = null;
                
                window.addEventListener('devicemotion', (e) => {
                    const acc = e.accelerationIncludingGravity;
                    if (!acc) return;
                    
                    if (lastX !== null) {
                        const deltaX = Math.abs(acc.x - lastX);
                        const deltaY = Math.abs(acc.y - lastY);
                        const deltaZ = Math.abs(acc.z - lastZ);
                        
                        const totalDelta = deltaX + deltaY + deltaZ;
                        
                        if (totalDelta > this.shakeThreshold) {
                            const now = Date.now();
                            // Debounce: mindestens 1 Sekunde zwischen Shakes
                            if (now - this.lastShakeTime > 1000 && !this.isRolling) {
                                this.lastShakeTime = now;
                                
                                // Check if dice are selected
                                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                                if (hasDice) {
                                    console.log('[DiceRoller] Shake detected!');
                                    this.roll();
                                }
                            }
                        }
                    }
                    
                    lastX = acc.x;
                    lastY = acc.y;
                    lastZ = acc.z;
                });
                
                console.log('[DiceRoller] Shake-to-Roll enabled');
            },
            
            // ========================================
            // PROBABILITY TOOLTIPS
            // ========================================
            
            initProbabilityTooltips() {
                const buttons = document.querySelectorAll('.dice-btn');
                const tooltip = document.getElementById('probTooltip');
                
                if (!tooltip) return;
                
                // Add info button to each dice card
                buttons.forEach(btn => {
                    // Create info button
                    const infoBtn = document.createElement('button');
                    infoBtn.className = 'dice-btn__info';
                    infoBtn.innerHTML = '?';
                    infoBtn.type = 'button';
                    
                    // Prevent click from propagating to dice button
                    infoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                    });
                    
                    // Show tooltip on hover
                    infoBtn.addEventListener('mouseenter', (e) => {
                        e.stopPropagation();
                        const diceType = btn.dataset.dice;
                        if (diceType) {
                            this.showProbabilityTooltip(diceType, infoBtn);
                        }
                    });
                    
                    infoBtn.addEventListener('mouseleave', (e) => {
                        e.stopPropagation();
                        this.hideProbabilityTooltip();
                    });
                    
                    btn.appendChild(infoBtn);
                });
            },
            
            showProbabilityTooltip(diceType, element) {
                const tooltip = document.getElementById('probTooltip');
                if (!tooltip) return;
                
                const titleEl = tooltip.querySelector('.dice-probability-tooltip__title');
                const contentEl = tooltip.querySelector('.dice-probability-tooltip__content');
                
                const sides = parseInt(diceType.replace('d', ''));
                const avg = ((sides + 1) / 2).toFixed(1);
                const probEach = (100 / sides).toFixed(1);
                
                titleEl.textContent = diceType.toUpperCase();
                
                let html = `<div class="prob-row"><span>Durchschnitt:</span><span>${avg}</span></div>`;
                html += `<div class="prob-row"><span>Pro Seite:</span><span>${probEach}%</span></div>`;
                
                // Special probabilities - D&D 5e optimiert
                if (diceType === 'd20') {
                    html += `<div class="prob-section">Kritisch</div>`;
                    html += `<div class="prob-row prob-row--crit"><span>Nat 20:</span><span>5%</span></div>`;
                    html += `<div class="prob-row prob-row--fumble"><span>Nat 1:</span><span>5%</span></div>`;
                    html += `<div class="prob-section">DC Erfolg</div>`;
                    html += `<div class="prob-row"><span>DC 5:</span><span>80%</span></div>`;
                    html += `<div class="prob-row"><span>DC 10:</span><span>55%</span></div>`;
                    html += `<div class="prob-row"><span>DC 15:</span><span>30%</span></div>`;
                    html += `<div class="prob-row"><span>DC 20:</span><span>5%</span></div>`;
                    html += `<div class="prob-section">Mit Vorteil</div>`;
                    html += `<div class="prob-row prob-row--adv"><span>Nat 20:</span><span>9.75%</span></div>`;
                    html += `<div class="prob-row prob-row--adv"><span>DC 10:</span><span>~80%</span></div>`;
                    html += `<div class="prob-row prob-row--adv"><span>DC 15:</span><span>~51%</span></div>`;
                } else if (diceType === 'd100') {
                    html += `<div class="prob-section">Schwellen</div>`;
                    html += `<div class="prob-row"><span>≤25:</span><span>25%</span></div>`;
                    html += `<div class="prob-row"><span>≤50:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>≤75:</span><span>75%</span></div>`;
                    html += `<div class="prob-row"><span>≤95:</span><span>95%</span></div>`;
                    html += `<div class="prob-hint">Wild Magic, Zufallstabellen</div>`;
                } else if (diceType === 'd12') {
                    html += `<div class="prob-row"><span>≥7:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (12):</span><span>8.3%</span></div>`;
                    html += `<div class="prob-hint">Greataxe, Barbarian</div>`;
                } else if (diceType === 'd10') {
                    html += `<div class="prob-row"><span>≥6:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (10):</span><span>10%</span></div>`;
                    html += `<div class="prob-hint">Glaive, Halberd, Firebolt</div>`;
                } else if (diceType === 'd8') {
                    html += `<div class="prob-row"><span>≥5:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (8):</span><span>12.5%</span></div>`;
                    html += `<div class="prob-hint">Longsword, Rapier, Cure Wounds</div>`;
                } else if (diceType === 'd6') {
                    html += `<div class="prob-row"><span>≥4:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (6):</span><span>16.7%</span></div>`;
                    html += `<div class="prob-hint">Shortsword, Fireball, Sneak Attack</div>`;
                } else if (diceType === 'd4') {
                    html += `<div class="prob-row"><span>≥3:</span><span>50%</span></div>`;
                    html += `<div class="prob-row"><span>Max (4):</span><span>25%</span></div>`;
                    html += `<div class="prob-hint">Dagger, Magic Missile, Guidance</div>`;
                }
                
                contentEl.innerHTML = html;
                
                // Position tooltip
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left + rect.width / 2}px`;
                tooltip.style.top = `${rect.top - 10}px`;
                tooltip.classList.add('visible');
            },
            
            hideProbabilityTooltip() {
                const tooltip = document.getElementById('probTooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            },
            
            // ========================================
            // DRAG & DROP
            // ========================================
            
            initDragDrop() {
                const arena = document.getElementById('diceArena');
                const canvases = document.querySelectorAll('.dice-btn__canvas');
                
                // Track drag start position
                let dragStartPos = null;
                let dragStartTime = null;
                
                // Make canvases draggable
                canvases.forEach(canvas => {
                    canvas.setAttribute('draggable', 'true');
                    canvas.style.cursor = 'grab';
                    
                    canvas.addEventListener('dragstart', (e) => {
                        const diceType = canvas.dataset.type;
                        e.dataTransfer.setData('text/plain', diceType);
                        e.dataTransfer.effectAllowed = 'copy';
                        canvas.style.opacity = '0.5';
                        
                        // Track start position
                        dragStartPos = { x: e.clientX, y: e.clientY };
                        dragStartTime = Date.now();
                    });
                    
                    canvas.addEventListener('dragend', (e) => {
                        canvas.style.opacity = '1';
                    });
                });
                
                // Arena as drop target
                arena.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    arena.classList.add('drag-over');
                });
                
                arena.addEventListener('dragleave', (e) => {
                    arena.classList.remove('drag-over');
                });
                
                arena.addEventListener('drop', (e) => {
                    e.preventDefault();
                    arena.classList.remove('drag-over');
                    
                    const diceType = e.dataTransfer.getData('text/plain');
                    if (diceType && !this.isRolling) {
                        // Calculate throw vector from start to drop position
                        let throwVector = null;
                        
                        if (dragStartPos) {
                            const dropPos = { x: e.clientX, y: e.clientY };
                            const dx = dropPos.x - dragStartPos.x;
                            const dy = dropPos.y - dragStartPos.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const elapsed = Math.max(Date.now() - dragStartTime, 100);
                            
                            if (dist > 30) {
                                // Calculate boost based on drag speed
                                const timeInt = Math.min(elapsed, 2000);
                                const boost = Math.sqrt((2500 - timeInt) / 2500) * dist * 1.5;
                                
                                throwVector = {
                                    vector: { x: dx, y: -dy },
                                    boost: Math.max(boost, 200)
                                };
                            }
                        }
                        
                        // Check if the DROPPED dice is part of current selection
                        const droppedIsSelected = (this.currentDice[diceType] || 0) > 0;
                        const hasSelection = Object.values(this.currentDice).some(c => c > 0);
                        
                        if (hasSelection && droppedIsSelected) {
                            // Dropped die is in selection → roll ALL selected dice
                            const totalDice = Object.values(this.currentDice).reduce((a, b) => a + b, 0);
                            
                            if (totalDice > 1 && window.RIFT?.ui?.Toast) {
                                const parts = Object.entries(this.currentDice)
                                    .filter(([_, count]) => count > 0)
                                    .map(([type, count]) => `${count}${type.toUpperCase()}`)
                                    .join(' + ');
                                RIFT.ui.Toast.info(`Werfe ${parts}`);
                            }
                            
                            this.pendingThrowVector = throwVector;
                            this.roll();
                        } else {
                            // Dropped die is NOT in selection → roll only the dropped die
                            this.quickRollWithVector(diceType, throwVector);
                        }
                    }
                    
                    // Reset tracking
                    dragStartPos = null;
                    dragStartTime = null;
                });
            },
            
            quickRollWithVector(diceType, throwVector) {
                // Save modifier BEFORE clearDice (which resets it to 0)
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                // Roll a single die immediately with vector
                this.clearDice();
                this.currentDice[diceType] = 1;
                
                // Restore modifier
                document.getElementById('modifierInput').value = mod;
                this.updateModifierDisplay(mod);
                
                this.updateUI();
                
                // Build notation with modifier
                let notation = `1${diceType}`;
                if (mod !== 0) notation += (mod > 0 ? '+' : '') + mod;
                
                this.executeRoll(notation, null, throwVector);
            },
            
            // ========================================
            // SWIPE HANDLING
            // ========================================
            
            initSwipe(container) {
                let startPos = null;
                let startTime = null;
                
                const onStart = (e) => {
                    if (this.isRolling) return;
                    startPos = this.getEventPos(e);
                    startTime = Date.now();
                };
                
                const onEnd = (e) => {
                    if (!startPos || this.isRolling) return;
                    
                    const endPos = this.getEventPos(e);
                    const dx = endPos.x - startPos.x;
                    const dy = endPos.y - startPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const elapsed = Date.now() - startTime;
                    
                    const savedStartPos = { ...startPos };
                    startPos = null;
                    
                    // Minimum swipe distance
                    if (dist < 50) return;
                    
                    // Check if we have dice to roll
                    const hasDice = Object.values(this.currentDice).some(c => c > 0);
                    const hasNotation = document.getElementById('notationInput').value.trim().length > 0;
                    
                    if (!hasDice && !hasNotation) {
                        // Default to 1d20 if nothing selected
                        this.currentDice = { d20: 1 };
                        this.updateNotationFromDice();
                        this.updateUI();
                    }
                    
                    // Calculate boost based on speed
                    const timeInt = Math.min(elapsed, 2000);
                    const boost = Math.sqrt((2500 - timeInt) / 2500) * dist * 2;
                    
                    // Vector for throw direction (inverted y for 3D space)
                    const vector = { x: dx, y: -dy };
                    
                    console.log('[DiceRoller] Swipe detected, vector:', vector, 'boost:', boost);
                    
                    // Store throw vector for executeRoll
                    this.pendingThrowVector = { vector, boost };
                    this.roll();
                };
                
                container.addEventListener('mousedown', onStart);
                container.addEventListener('mouseup', onEnd);
                container.addEventListener('touchstart', (e) => { e.preventDefault(); onStart(e); });
                container.addEventListener('touchend', (e) => { e.preventDefault(); onEnd(e); });
            },
            
            getEventPos(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            },
            
            // ========================================
            // RIGHT CLICK TO REMOVE DICE
            // ========================================
            
            initRightClick() {
                document.querySelectorAll('.dice-btn').forEach(btn => {
                    btn.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const type = btn.dataset.dice;
                        if (type) this.removeDice(type);
                    });
                });
            },
            
            // ========================================
            // THEMES
            // ========================================
            
            initThemes() {
                // Theme buttons (alte + neue)
                document.querySelectorAll('.dice-theme-btn, .dice-theme-card').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const theme = btn.dataset.theme;
                        this.setTheme(theme, true); // true = show toast
                    });
                });
                
                // Load saved theme (no toast on initial load)
                const saved = localStorage.getItem('rift_dice_theme') || 'onyx';
                this.setTheme(saved, false);
                
                // Load saved label color
                this.loadLabelColor();
                
                // Load arena themes from Firebase (async, will apply saved theme after load)
                this.loadArenaThemesFromDB();
                
                // Load saved effects
                this.loadEffects();
            },
            
            setTheme(theme, showNotification = false) {
                // Skip if already this theme
                if (this.currentTheme === theme && !showNotification) return;
                
                this.currentTheme = theme;
                
                // Set data attribute for CSS
                document.body.dataset.diceTheme = theme;
                
                // Update theme buttons (alte)
                document.querySelectorAll('.dice-theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === theme);
                });
                
                // Update theme cards (neue)
                document.querySelectorAll('.dice-theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.theme === theme);
                });
                
                // Update arena background gradient based on theme
                const arena = document.getElementById('diceArena');
                const colors = this.themeColors[theme] || this.themeColors.onyx;
                
                if (arena) {
                    arena.style.setProperty('--theme-primary', colors.primary);
                    arena.style.setProperty('--theme-secondary', colors.secondary);
                }
                
                // Update 3D dice color + gradient + texture - store for next roll
                this.currentDiceColor = colors.accent;
                this.currentDiceGradient = colors.gradient || null;
                this.currentDiceTexture = colors.texture || null;
                
                // Set color, gradient AND texture on DICE module
                if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(colors.accent, colors.gradient, colors.texture);
                }
                
                // Update preview dice with new colors
                if (typeof DicePreview !== 'undefined' && DicePreview.updateColors) {
                    DicePreview.updateColors();
                }
                
                localStorage.setItem('rift_dice_theme', theme);
                
                // Only show toast when explicitly changing theme
                if (showNotification && window.RIFT?.ui?.Toast) {
                    const names = { 
                        // Schwarz & Grau
                        black: 'Schwarz', onyx: 'Onyx', charcoal: 'Kohle', graphite: 'Graphit',
                        slate: 'Schiefer', storm: 'Sturm', ash: 'Asche', smoke: 'Rauch',
                        silver: 'Silber', pearl: 'Perle', white: 'Weiß',
                        // Rot
                        maroon: 'Kastanie', darkRed: 'Dunkelrot', crimson: 'Karmesin', red: 'Rot',
                        scarlet: 'Scharlach', cherry: 'Kirsche', ruby: 'Rubin', rose: 'Rose',
                        coral: 'Koralle', salmon: 'Lachs',
                        // Orange
                        rust: 'Rost', copper: 'Kupfer', bronze: 'Bronze', burnt: 'Verbrannt',
                        orange: 'Orange', tangerine: 'Mandarine', peach: 'Pfirsich', apricot: 'Aprikose',
                        // Gelb & Gold
                        gold: 'Gold', amber: 'Bernstein', honey: 'Honig', mustard: 'Senf',
                        yellow: 'Gelb', lemon: 'Zitrone', cream: 'Creme', ivory: 'Elfenbein',
                        // Grün
                        darkGreen: 'Dunkelgrün', forest: 'Wald', hunter: 'Jäger', emerald: 'Smaragd',
                        green: 'Grün', lime: 'Limette', grass: 'Gras', mint: 'Minze',
                        sage: 'Salbei', olive: 'Oliv', jade: 'Jade', teal: 'Petrol',
                        // Cyan & Türkis
                        cyan: 'Cyan', aqua: 'Aqua', turquoise: 'Türkis', seafoam: 'Meeresschaum',
                        // Blau
                        navy: 'Marine', midnight: 'Mitternacht', darkBlue: 'Dunkelblau', royal: 'Royal',
                        blue: 'Blau', cobalt: 'Kobalt', azure: 'Azur', sky: 'Himmel',
                        powder: 'Puder', ice: 'Eis',
                        // Lila & Violett
                        indigo: 'Indigo', purple: 'Lila', violet: 'Violett', amethyst: 'Amethyst',
                        lavender: 'Lavendel', lilac: 'Flieder', plum: 'Pflaume', grape: 'Traube',
                        // Pink & Magenta
                        magenta: 'Magenta', fuchsia: 'Fuchsia', hotPink: 'Pink', pink: 'Rosa',
                        blush: 'Rosé', raspberry: 'Himbeere',
                        // Braun & Erdtöne
                        brown: 'Braun', chocolate: 'Schokolade', coffee: 'Kaffee', mocha: 'Mokka',
                        tan: 'Hellbraun', beige: 'Beige', sand: 'Sand', khaki: 'Khaki',
                        // Metallic
                        steel: 'Stahl', chrome: 'Chrom', titanium: 'Titan', gunmetal: 'Anthrazit',
                        platinum: 'Platin', rosegold: 'Roségold',
                        // Textured
                        marbleWhite: 'Marmor Weiß', marbleBlack: 'Marmor Schwarz', marbleGreen: 'Marmor Grün',
                        woodOak: 'Holz Eiche', woodEbony: 'Holz Ebenholz', stoneGranite: 'Granit',
                        // Gradients
                        gradSunset: 'Sonnenuntergang', gradOcean: 'Ozean', gradToxic: 'Toxisch',
                        gradNebula: 'Nebula', gradFire: 'Feuer',
                        gradAbyssal: 'Abyssal', gradVoid: 'Leere', gradShadow: 'Schatten',
                        gradBloodMist: 'Blutnebel', gradDeepSea: 'Tiefsee',
                        // New Textures
                        obsidian: 'Obsidian', jadeGreen: 'Jade', lapisBlue: 'Lapislazuli',
                        meteoriteIron: 'Meteorit', fossilStone: 'Fossil', carbonFiber: 'Carbon',
                        snakeSkin: 'Schlangenhaut', chainmailSilver: 'Kettenhemd',
                        damascusSteel: 'Damast', runicStone: 'Runenstein',
                        nebulaGlow: 'Nebula-Glow', veinsGold: 'Goldadern',
                        circuitBoard: 'Leiterplatte', boneWhite: 'Knochen',
                        parchmentOld: 'Pergament', crystalAmethyst: 'Kristall'
                    };
                    // Toast removed - preview is sufficient
                }
                
                // Update preview dice colors
                if (typeof DicePreview !== 'undefined' && DicePreview.updateColors) {
                    DicePreview.updateColors();
                }
                
                // Update Preview-Effekte (Glow/Pulse Farbe)
                this.updatePreviewEffects();
            },
            
            // ========================================
            // SETTINGS POPUP
            // ========================================
            
            initSettings() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsPopup = document.getElementById('settingsPopup');
                const settingsClose = document.getElementById('settingsClose');
                
                const statsBtn = document.getElementById('statsBtn');
                const statsPopup = document.getElementById('statsPopup');
                
                const hotkeysBtn = document.getElementById('hotkeysBtn');
                const hotkeysPopup = document.getElementById('hotkeysPopup');
                
                // Settings Button
                if (settingsBtn && settingsPopup) {
                    settingsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = settingsPopup.classList.contains('open');
                        this.closeAllPopups();
                        if (!isOpen) {
                            settingsPopup.classList.add('open');
                            settingsBtn.classList.add('active');
                            // Scroll to top when opening
                            settingsPopup.scrollTop = 0;
                            // Reset to first tab
                            this.switchSettingsTab('diceColor');
                            // Open overlay behind popup
                            const overlay = document.getElementById('diceSettingsOverlay');
                            if (overlay) overlay.classList.add('open');
                            // RIFT: Body scroll lock mit Position-Speicherung
                            this.savedScrollY = window.scrollY;
                            document.body.style.top = `-${this.savedScrollY}px`;
                            document.body.classList.add('popup-open');
                            // RIFT: Preview öffnen
                            const preview = document.getElementById('settingsPreviewContainer');
                            if (preview) preview.classList.add('open');
                        }
                    });
                    
                    settingsClose?.addEventListener('click', () => {
                        settingsPopup.classList.remove('open');
                        settingsBtn.classList.remove('active');
                        // Close overlay
                        const overlay = document.getElementById('diceSettingsOverlay');
                        if (overlay) overlay.classList.remove('open');
                    });
                }
                
                // Stats Button
                if (statsBtn && statsPopup) {
                    statsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleStatsPopup();
                    });
                }
                
                // Hotkeys Button
                if (hotkeysBtn && hotkeysPopup) {
                    hotkeysBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleHotkeysPopup();
                    });
                }
                
                // Click outside schließt alle Popups
                document.addEventListener('click', (e) => {
                    const allPopups = [settingsPopup, statsPopup, hotkeysPopup];
                    const allBtns = [settingsBtn, statsBtn, hotkeysBtn];
                    
                    let clickedInside = false;
                    allPopups.forEach(popup => {
                        if (popup?.contains(e.target)) clickedInside = true;
                    });
                    allBtns.forEach(btn => {
                        if (btn?.contains(e.target)) clickedInside = true;
                    });
                    
                    if (!clickedInside) {
                        this.closeAllPopups();
                    }
                });
                
                // Clicks in Popups nicht durchlassen
                [settingsPopup, statsPopup, hotkeysPopup].forEach(popup => {
                    popup?.addEventListener('click', (e) => e.stopPropagation());
                });
            },
            
            // ========================================
            // SOUND
            // ========================================
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                window.RIFT_DICE_SOUND = this.soundEnabled;
                
                // Update both toggle buttons
                document.getElementById('soundToggle')?.classList.toggle('active', this.soundEnabled);
                document.getElementById('soundToggle2')?.classList.toggle('active', this.soundEnabled);
                localStorage.setItem('rift_dice_sound', this.soundEnabled);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(this.soundEnabled ? 'Sound an' : 'Sound aus');
                }
            },
            
            // ========================================
            // SECRET ROLL
            // ========================================
            
            toggleSecret() {
                this.secretRoll = !this.secretRoll;
                
                // Update both toggle buttons
                document.getElementById('secretToggle')?.classList.toggle('active', this.secretRoll);
                document.getElementById('secretToggle2')?.classList.toggle('active', this.secretRoll);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(this.secretRoll ? 'Geheimer Wurf aktiviert' : 'Normaler Wurf');
                }
            },
            
            // ========================================
            // THEME FILTER
            // ========================================
            
            filterThemes(query) {
                const cards = document.querySelectorAll('.dice-theme-card');
                const searchTerm = query.toLowerCase().trim();
                let visibleCount = 0;
                
                cards.forEach(card => {
                    const themeName = card.querySelector('span')?.textContent?.toLowerCase() || '';
                    const themeKey = card.dataset.theme?.toLowerCase() || '';
                    const matches = themeName.includes(searchTerm) || themeKey.includes(searchTerm);
                    
                    card.style.display = matches ? '' : 'none';
                    if (matches) visibleCount++;
                });
                
                // Update count
                const countEl = document.getElementById('themeCount');
                if (countEl) {
                    countEl.textContent = `(${visibleCount})`;
                }
            },
            
            // ========================================
            // SETTINGS TABS
            // ========================================
            
            switchSettingsTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.dice-settings-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Update tab content
                document.querySelectorAll('.dice-settings-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const tabMap = {
                    'diceColor': 'tabDiceColor',
                    'labelColor': 'tabLabelColor',
                    'effects': 'tabEffects',
                    'arenaTheme': 'tabArenaTheme'
                };
                
                const targetContent = document.getElementById(tabMap[tabName]);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            },
            
            // ========================================
            // LABEL COLOR (Zahlenfarbe)
            // ========================================
            
            setLabelColor(color, showNotification = true) {
                this.currentLabelColor = color;
                
                // Update DICE library
                if (typeof DICE !== 'undefined' && DICE.setLabelColor) {
                    DICE.setLabelColor(color === 'auto' ? null : color);
                }
                
                // Update preview dice
                if (typeof DicePreview !== 'undefined' && DicePreview.updateColors) {
                    DicePreview.updateColors();
                }
                
                // Update UI buttons
                document.querySelectorAll('.dice-label-color-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.color === color);
                });
                
                // Save to localStorage
                localStorage.setItem('rift_dice_label_color', color);
                
                // Show toast
                if (showNotification && window.RIFT?.ui?.Toast) {
                    const colorNames = {
                        'auto': 'Automatisch',
                        '#ffffff': 'Weiß',
                        '#1a1a1a': 'Schwarz',
                        '#ff4444': 'Rot',
                        '#ff9800': 'Orange',
                        '#ffeb3b': 'Gelb',
                        '#4caf50': 'Grün',
                        '#00bcd4': 'Cyan',
                        '#2196f3': 'Blau',
                        '#9c27b0': 'Lila',
                        '#e91e63': 'Pink',
                        '#ffd700': 'Gold'
                    };
                    // Toast removed - preview is sufficient
                }
            },
            
            loadLabelColor() {
                const saved = localStorage.getItem('rift_dice_label_color');
                if (saved) {
                    this.setLabelColor(saved, false);
                }
            },
            
            // ========================================
            // DICE EFFECTS (GLOW & PULSE)
            // ========================================
            
            currentGlow: false,
            currentPulse: false,
            
            setGlow(enabled, showNotification = true) {
                this.currentGlow = enabled;
                
                // Update DICE library
                if (typeof DICE !== 'undefined' && DICE.setGlow) {
                    DICE.setGlow(enabled);
                }
                
                // Update Settings Preview Effekte
                this.updatePreviewEffects();
                
                // Update Settings Preview
                if (typeof DicePreview !== 'undefined' && DicePreview.updateSettingsPreview) {
                    DicePreview.updateSettingsPreview();
                }
                
                // Update UI
                document.querySelectorAll('.dice-effect-btn[data-effect="glow"]').forEach(btn => {
                    btn.classList.toggle('active', enabled);
                });
                
                // Save preference
                localStorage.setItem('rift_dice_glow', enabled ? 'true' : 'false');
                
                // Toast removed - preview is sufficient
            },
            
            setPulse(enabled, showNotification = true) {
                this.currentPulse = enabled;
                
                // Update DICE library
                if (typeof DICE !== 'undefined' && DICE.setPulse) {
                    DICE.setPulse(enabled);
                }
                
                // Update Settings Preview Effekte
                this.updatePreviewEffects();
                
                // Update Settings Preview
                if (typeof DicePreview !== 'undefined' && DicePreview.updateSettingsPreview) {
                    DicePreview.updateSettingsPreview();
                }
                
                // Update UI
                document.querySelectorAll('.dice-effect-btn[data-effect="pulse"]').forEach(btn => {
                    btn.classList.toggle('active', enabled);
                });
                
                // Save preference
                localStorage.setItem('rift_dice_pulse', enabled ? 'true' : 'false');
                
                // Toast removed - preview is sufficient
            },
            
            updatePreviewEffects() {
                const container = document.getElementById('previewEffectsContainer');
                if (!container) return;
                
                // Clear existing effects
                container.innerHTML = '';
                
                // Theme-Farbe holen
                const glowColor = this.themeColors[this.currentTheme] || '#ffffff';
                
                if (this.currentGlow && !this.currentPulse) {
                    // Nur Glow: statischer Schein
                    const glow = document.createElement('div');
                    glow.className = 'preview-glow';
                    glow.style.setProperty('--glow-color', glowColor);
                    container.appendChild(glow);
                }
                
                if (this.currentPulse) {
                    // Pulse: expandierende Ringe
                    const pulse = document.createElement('div');
                    pulse.className = 'preview-pulse';
                    pulse.style.setProperty('--glow-color', glowColor);
                    container.appendChild(pulse);
                }
            },
            
            loadEffects() {
                const glow = localStorage.getItem('rift_dice_glow') === 'true';
                const pulse = localStorage.getItem('rift_dice_pulse') === 'true';
                
                if (glow) this.setGlow(true, false);
                if (pulse) this.setPulse(true, false);
            },
            
            // ========================================
            // ARENA THEME
            // ========================================
            
            currentArenaTheme: 'default',
            
            setArenaTheme(theme, showNotification = true) {
                this.currentArenaTheme = theme;
                
                // Apply to arena
                const arena = document.getElementById('diceArena');
                if (arena) {
                    arena.dataset.arenaTheme = theme;
                }
                
                // Update UI
                document.querySelectorAll('.dice-arena-theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.arenaTheme === theme);
                });
                
                // Save preference
                localStorage.setItem('rift_dice_arena_theme', theme);
                
                // Toast removed - preview is sufficient
            },
            
            loadArenaTheme() {
                const saved = localStorage.getItem('rift_dice_arena_theme');
                if (saved) {
                    this.setArenaTheme(saved, false);
                }
            },
            
            // ========================================
            // DYNAMIC ARENA THEMES (from Firebase)
            // ========================================
            
            arenaThemes: [],
            arenaThemesLoaded: false,
            
            async loadArenaThemesFromDB() {
                if (this.arenaThemesLoaded) return;
                
                try {
                    // Check if Firebase is available
                    if (typeof db === 'undefined') {
                        console.warn('[DiceRoller] Firebase not available, using fallback');
                        this.renderArenaThemesFallback();
                        return;
                    }
                    
                    const snapshot = await db.collection('arenaThemes').orderBy('order', 'asc').get();
                    
                    if (snapshot.empty) {
                        console.warn('[DiceRoller] No arena themes in DB, using fallback');
                        this.renderArenaThemesFallback();
                        return;
                    }
                    
                    this.arenaThemes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log('[DiceRoller] Loaded', this.arenaThemes.length, 'arena themes from DB');
                    
                    // Inject dynamic CSS
                    this.injectArenaThemeCSS();
                    
                    // Render the themes UI
                    this.renderArenaThemesUI();
                    
                    this.arenaThemesLoaded = true;
                    
                    // Re-apply saved theme after themes are loaded
                    this.loadArenaTheme();
                    
                } catch (error) {
                    console.error('[DiceRoller] Error loading arena themes:', error);
                    this.renderArenaThemesFallback();
                }
            },
            
            injectArenaThemeCSS() {
                // Remove old dynamic styles if exist
                const oldStyle = document.getElementById('rift-dynamic-arena-styles');
                if (oldStyle) oldStyle.remove();
                
                // Generate CSS for all themes
                let css = '/* RIFT Dynamic Arena Themes */\n';
                
                this.arenaThemes.forEach(t => {
                    if (!t.imageUrl || !t.themeId) return;
                    
                    css += `
.dice-arena[data-arena-theme="${t.themeId}"] {
    background: url('${t.imageUrl}') center/cover !important;
}
.dice-arena[data-arena-theme="${t.themeId}"]::after {
    background: none !important;
}
.dice-arena-theme-preview--${t.themeId} {
    background: url('${t.imageUrl}') center/cover !important;
}
`;
                });
                
                const style = document.createElement('style');
                style.id = 'rift-dynamic-arena-styles';
                style.textContent = css;
                document.head.appendChild(style);
                
                console.log('[DiceRoller] Injected CSS for', this.arenaThemes.length, 'arena themes');
            },
            
            renderArenaThemesUI() {
                const container = document.getElementById('arenaThemesContent');
                if (!container) return;
                
                // Group by tier
                const tiers = {
                    free: { label: 'RIFT Free', badge: 'tier-badge--free', themes: [] },
                    silver: { label: 'RIFT Silver', badge: 'tier-badge--silver', themes: [] },
                    gold: { label: 'RIFT Gold', badge: 'tier-badge--gold', themes: [] }
                };
                
                this.arenaThemes.forEach(t => {
                    const tier = t.tier || 'free';
                    if (tiers[tier]) {
                        tiers[tier].themes.push(t);
                    }
                });
                
                // Get current theme for active state
                const currentTheme = this.currentArenaTheme || 'rift';
                
                // Build HTML
                let html = '';
                
                ['free', 'silver', 'gold'].forEach(tierKey => {
                    const tier = tiers[tierKey];
                    if (tier.themes.length === 0) return;
                    
                    html += `
                        <div class="tier-section">
                            <div class="tier-header">
                                <span class="tier-badge ${tier.badge}">${tier.label}</span>
                                <span class="tier-count">${tier.themes.length} Theme${tier.themes.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="dice-arena-theme-grid">
                    `;
                    
                    tier.themes.forEach(t => {
                        const isActive = t.themeId === currentTheme ? ' active' : '';
                        html += `
                            <button class="dice-arena-theme-card${isActive}" data-arena-theme="${t.themeId}" onclick="DiceRoller.setArenaTheme('${t.themeId}')">
                                <div class="dice-arena-theme-preview dice-arena-theme-preview--${t.themeId}"></div>
                                <span>${t.name || t.themeId}</span>
                            </button>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            },
            
            renderArenaThemesFallback() {
                // Fallback with basic themes if DB fails
                const container = document.getElementById('arenaThemesContent');
                if (!container) return;
                
                container.innerHTML = `
                    <div style="text-align:center;padding:30px;color:rgba(255,255,255,0.5);">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:40px;height:40px;margin-bottom:12px;opacity:0.5;">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                        <p>Arena Themes konnten nicht geladen werden.</p>
                        <p style="font-size:12px;margin-top:8px;">Bitte versuche es später erneut.</p>
                    </div>
                `;
            },
            
            // ========================================
            // PRESETS
            // ========================================
            
            presets: [],
            presetsOpen: false,
            
            togglePresets() {
                this.presetsOpen = !this.presetsOpen;
                const popup = document.getElementById('presetsPopup');
                const btn = document.getElementById('presetsBtn');
                
                if (this.presetsOpen) {
                    this.loadPresets();
                    this.renderPresets();
                    popup.classList.add('visible');
                    btn.classList.add('active');
                } else {
                    popup.classList.remove('visible');
                    btn.classList.remove('active');
                }
            },
            
            loadPresets() {
                try {
                    this.presets = JSON.parse(localStorage.getItem('rift_dice_presets') || '[]');
                } catch (e) {
                    this.presets = [];
                }
            },
            
            savePresets() {
                localStorage.setItem('rift_dice_presets', JSON.stringify(this.presets));
            },
            
            savePreset() {
                // Check if there are dice selected
                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                if (!hasDice) {
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Keine Würfel ausgewählt');
                    }
                    return;
                }
                
                // Prompt for name
                const defaultName = this.buildNotationString();
                const name = prompt('Preset-Name:', defaultName);
                if (!name) return;
                
                // Build preset
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                const preset = {
                    name: name,
                    dice: { ...this.currentDice },
                    modifier: mod,
                    notation: this.buildNotationString()
                };
                
                this.loadPresets();
                this.presets.push(preset);
                this.savePresets();
                this.renderPresets();
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success(`Preset "${name}" gespeichert`);
                }
            },
            
            buildNotationString() {
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        const wType = type.replace('d', 'W').toUpperCase();
                        parts.push(`${count}${wType}`);
                    }
                }
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                let notation = parts.join('+');
                if (mod !== 0) notation += (mod > 0 ? '+' : '') + mod;
                return notation;
            },
            
            loadPreset(index) {
                const preset = this.presets[index];
                if (!preset) return;
                
                this.currentDice = { ...preset.dice };
                document.getElementById('modifierInput').value = preset.modifier || 0;
                this.updateModifierDisplay(preset.modifier || 0);
                this.updateNotationFromDice();
                this.updateUI();
                
                // Close popup
                this.togglePresets();
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info(`"${preset.name}" geladen`);
                }
            },
            
            deletePreset(index, e) {
                e.stopPropagation();
                const preset = this.presets[index];
                if (!preset) return;
                
                if (confirm(`Preset "${preset.name}" löschen?`)) {
                    this.presets.splice(index, 1);
                    this.savePresets();
                    this.renderPresets();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.info('Preset gelöscht');
                    }
                }
            },
            
            renderPresets() {
                const list = document.getElementById('presetsList');
                if (!list) return;
                
                if (this.presets.length === 0) {
                    list.innerHTML = '<div class="dice-presets-popup__empty">Keine Presets gespeichert</div>';
                    return;
                }
                
                list.innerHTML = this.presets.map((preset, i) => `
                    <div class="dice-presets-popup__item" onclick="DiceRoller.loadPreset(${i})">
                        <div class="dice-presets-popup__item-info">
                            <span class="dice-presets-popup__item-name">${preset.name}</span>
                            <span class="dice-presets-popup__item-notation">${preset.notation}</span>
                        </div>
                        <button class="dice-presets-popup__item-delete" onclick="DiceRoller.deletePreset(${i}, event)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                `).join('');
            },
            
            // ========================================
            // DICE SELECTION
            // ========================================
            
            addDice(type) {
                if (!this.currentDice[type]) this.currentDice[type] = 0;
                this.currentDice[type]++;
                this.updateNotationFromDice();
                this.updateUI();
            },
            
            removeDice(type) {
                if (this.currentDice[type]) {
                    this.currentDice[type]--;
                    if (this.currentDice[type] <= 0) delete this.currentDice[type];
                }
                this.updateNotationFromDice();
                this.updateUI();
            },
            
            clearDice() {
                this.currentDice = {};
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '';
                this.updateUI();
            },
            
            updateNotationFromDice() {
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        // Use German W notation
                        const wType = type.replace('d', 'W');
                        parts.push(`${count}${wType}`);
                    }
                }
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                let notation = parts.join('+');
                if (mod > 0) notation += `+${mod}`;
                else if (mod < 0) notation += `${mod}`;
                
                document.getElementById('notationInput').value = notation;
            },
            
            // Parse notation - supports both D and W (German)
            parseDiceFromNotation(notation) {
                this.currentDice = {};
                let modifier = 0;
                
                // Normalize: replace W with D (case insensitive)
                const normalized = notation.toUpperCase().replace(/W/g, 'D');
                
                // Match dice patterns (now only D since we normalized)
                const diceRegex = /(\d*)D(\d+)/g;
                let match;
                while ((match = diceRegex.exec(normalized)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    const type = `d${sides}`;
                    this.currentDice[type] = (this.currentDice[type] || 0) + count;
                }
                
                // Match modifier at end (after all dice)
                const modMatch = normalized.match(/([+-]\d+)(?!D)(?:\s*$|\s*\()/);
                if (modMatch) {
                    modifier = parseInt(modMatch[1]);
                }
                
                document.getElementById('modifierInput').value = modifier;
                this.updateUI();
            },
            
            adjustModifier(delta) {
                const input = document.getElementById('modifierInput');
                let val = parseInt(input.value) || 0;
                val = Math.max(-99, Math.min(99, val + delta));
                input.value = val;
                this.updateModifierDisplay(val);
                this.updateNotationFromDice();
            },
            
            updateModifierDisplay(val) {
                const display = document.getElementById('modifierDisplay');
                if (!display) return;
                
                if (val === 0) {
                    display.textContent = '+0';
                    display.className = 'dice-modifier__display';
                } else if (val > 0) {
                    display.textContent = '+' + val;
                    display.className = 'dice-modifier__display dice-modifier__display--positive';
                } else {
                    display.textContent = val.toString();
                    display.className = 'dice-modifier__display dice-modifier__display--negative';
                }
            },
            
            // ========================================
            // ROLLING
            // ========================================
            
            roll() {
                if (this.isRolling) return;
                
                // Hide previous result
                this.hideResult();
                
                // Get notation from input or build from dice
                let notationStr = document.getElementById('notationInput').value.trim();
                
                if (notationStr) {
                    this.parseDiceFromNotation(notationStr);
                }
                
                // Build from selected dice
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) parts.push(`${count}${type}`);
                }
                if (parts.length === 0) return;
                
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                notationStr = parts.join('+');
                if (mod !== 0) notationStr += (mod > 0 ? '+' : '') + mod;
                
                // Use pending throw vector if available
                const throwVector = this.pendingThrowVector || null;
                this.pendingThrowVector = null;
                
                this.executeRoll(notationStr, null, throwVector);
            },
            
            rollFromNotation() {
                const notation = document.getElementById('notationInput').value.trim();
                if (!notation) return;
                this.parseDiceFromNotation(notation);
                this.roll();
            },
            
            quickRoll(notation) {
                this.hideResult();
                this.parseDiceFromNotation(notation);
                document.getElementById('notationInput').value = notation;
                setTimeout(() => this.roll(), 50);
            },
            
            rollAdvantage() {
                this.hideResult();
                this.currentDice = { d20: 2 };
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '2D20 (Vorteil)';
                this.updateUI();
                this.executeRoll('2d20', 'advantage');
            },
            
            rollDisadvantage() {
                this.hideResult();
                this.currentDice = { d20: 2 };
                document.getElementById('modifierInput').value = 0;
                this.updateModifierDisplay(0);
                document.getElementById('notationInput').value = '2D20 (Nachteil)';
                this.updateUI();
                this.executeRoll('2d20', 'disadvantage');
            },
            
            repeatLast() {
                if (!this.lastRoll) return;
                this.hideResult();
                document.getElementById('notationInput').value = this.lastRoll.notation;
                this.parseDiceFromNotation(this.lastRoll.notation);
                this.executeRoll(this.lastRoll.notationClean, this.lastRoll.special);
            },
            
            hideResult() {
                const result = document.getElementById('diceResult');
                result.classList.remove('visible', 'critical', 'fumble', 'secret');
                this.clearDiceLabels();
                if (this.resultTimeout) {
                    clearTimeout(this.resultTimeout);
                    this.resultTimeout = null;
                }
            },
            
            executeRoll(notationStr, special = null, throwVector = null) {
                if (this.isRolling) return;
                this.isRolling = true;
                
                this.clearDiceLabels();
                
                if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(this.currentDiceColor, this.currentDiceGradient, this.currentDiceTexture);
                }
                
                const arena = document.getElementById('diceArena');
                const result = document.getElementById('diceResult');
                const btn = document.getElementById('rollBtn');
                
                arena.classList.remove('empty');
                arena.classList.add('throwing');
                result.classList.remove('visible', 'critical', 'fumble', 'secret');
                btn.classList.add('rolling');
                
                setTimeout(() => arena.classList.remove('throwing'), 300);
                
                const displayNotation = document.getElementById('notationInput').value || notationStr;
                this.lastRoll = { notation: displayNotation, notationClean: notationStr, special };
                document.getElementById('repeatBtn').disabled = false;
                
                let libraryNotation = notationStr;
                const d100Count = this.currentDice.d100 || 0;
                if (d100Count > 0) {
                    libraryNotation = notationStr.replace(/(\d*)d100/gi, (match, count) => {
                        const c = parseInt(count) || 1;
                        return `${c}d100+${c}d10`;
                    });
                }
                
                this.currentLibraryNotation = libraryNotation;
                
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const playerName = userData.name || 'Spieler';
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) parts.push(`${count}${type.replace('d', 'W')}`);
                }
                let histNotation = parts.join('+');
                if (mod !== 0) histNotation += (mod > 0 ? '+' : '') + mod;
                if (special) histNotation += ` (${special === 'advantage' ? 'V' : 'N'})`;
                
                const animationStartTime = Date.now();
                const MIN_ANIMATION_TIME = 2500;
                
                // Build roll label for other players
                let rollLabel = null;
                let rollTarget = null;
                let rollType = null;
                let rollElement = null;
                if (this.skillCheckMode) {
                    rollLabel = `Fähigkeit: ${this.skillCheckLabel}`;
                    rollTarget = this.skillCheckTarget;
                    rollType = 'skill';
                } else if (this.fokusCheckMode) {
                    rollLabel = `Fokus: ${this.fokusCheckLabel}`;
                    rollTarget = `≥11`;
                    rollType = 'fokus';
                    rollElement = this.fokusCheckLabel; // Element name (e.g. "Schall", "Gift")
                } else if (this.zweiteChanceMode) {
                    rollLabel = 'Zweite Chance';
                    rollTarget = '6-20';
                    rollType = 'zweitechance';
                }
                
                // SOFORT SYNC starten - andere Spieler sehen "würfelt..."
                this.syncRollStart({
                    player: playerName,
                    playerId: userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || playerName,
                    color: userData.color || '#FF4655',
                    diceTheme: this.currentTheme || 'onyx',
                    labelColor: this.currentLabelColor || 'auto',
                    notation: histNotation,
                    secret: this.secretRoll,
                    special: special,
                    timestamp: Date.now(),
                    // Add skill/fokus info for other players
                    rollLabel: rollLabel,
                    rollTarget: rollTarget,
                    rollType: rollType,
                    rollElement: rollElement,
                    diceConfig: {
                        notation: libraryNotation,
                        d100Count: d100Count
                    }
                });
                
                const handleResults = (libraryResults) => {
                    console.log('[DiceRoller] Library returned:', libraryResults);
                    
                    let displayRolls = [];
                    let labelValues = [];
                    let total = 0;
                    
                    if (d100Count > 0) {
                        let idx = 0;
                        for (let i = 0; i < d100Count; i++) {
                            const tensValue = libraryResults[idx];     // 0,10,20...90
                            const onesValue = libraryResults[idx + 1]; // 0-9
                            
                            let d100Result = tensValue + onesValue;
                            if (d100Result === 0) d100Result = 100;
                            
                            labelValues.push(tensValue);
                            labelValues.push(onesValue);
                            displayRolls.push(d100Result);
                            total += d100Result;
                            idx += 2;
                        }
                        while (idx < libraryResults.length) {
                            const val = libraryResults[idx];
                            labelValues.push(val);
                            displayRolls.push(val);
                            total += val;
                            idx++;
                        }
                    } else {
                        for (const val of libraryResults) {
                            const onlyD10 = Object.keys(this.currentDice).filter(t => this.currentDice[t] > 0);
                            if (onlyD10.length === 1 && onlyD10[0] === 'd10') {
                                const calcVal = val === 0 ? 10 : val;
                                labelValues.push(val);
                                displayRolls.push(calcVal);
                                total += calcVal;
                            } else {
                                labelValues.push(val);
                                displayRolls.push(val);
                                total += val;
                            }
                        }
                    }
                    
                    let finalTotal = total + mod;
                    if (special === 'advantage') finalTotal = Math.max(...displayRolls) + mod;
                    if (special === 'disadvantage') finalTotal = Math.min(...displayRolls) + mod;
                    
                    const isCritical = this.checkCriticalFromResults(displayRolls, special);
                    
                    // Sync mit ECHTEN Library-Ergebnissen
                    this.syncRollComplete({
                        player: playerName,
                        playerId: userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || playerName,
                        color: userData.color || '#FF4655',
                        diceTheme: this.currentTheme || 'onyx',
                        labelColor: this.currentLabelColor || 'auto',
                        total: finalTotal,
                        notation: histNotation,
                        results: displayRolls,
                        labelValues: labelValues,
                        modifier: mod,
                        critical: isCritical,
                        secret: this.secretRoll,
                        special: special,
                        timestamp: Date.now(),
                        // Check-Infos für Remote-Spieler
                        checkInfo: {
                            skillCheckMode: this.skillCheckMode,
                            skillCheckLabel: this.skillCheckLabel,
                            skillCheckTarget: this.skillCheckTarget,
                            fokusCheckMode: this.fokusCheckMode,
                            fokusCheckLabel: this.fokusCheckLabel,
                            zweiteChanceMode: this.zweiteChanceMode
                        },
                        diceConfig: {
                            notation: libraryNotation,
                            beforeRollValues: libraryResults, // ECHTE Werte für Remote
                            labelValues: labelValues,
                            d100Count: d100Count
                        }
                    });
                    
                    const elapsed = Date.now() - animationStartTime;
                    const remainingTime = Math.max(0, MIN_ANIMATION_TIME - elapsed);
                    
                    setTimeout(() => {
                        btn.classList.remove('rolling');
                        this.showDiceLabels(labelValues, d100Count);
                        this.displayRollResult(displayRolls, finalTotal, mod, isCritical, special, playerName, userData.color, d100Count, labelValues);
                        this.addToHistory({
                            player: playerName,
                            color: userData.color || '#FF4655',
                            total: finalTotal,
                            notation: histNotation,
                            rolls: displayRolls,
                            critical: isCritical,
                            secret: this.secretRoll,
                            timestamp: Date.now()
                        });
                        this.isRolling = false;
                    }, remainingTime);
                };
                
                if (this.box) {
                    this.box.setDice(libraryNotation);
                    
                    let done = false;
                    const afterRoll = (notation) => {
                        if (done) return;
                        done = true;
                        handleResults(notation.result);
                    };
                    
                    // Library würfelt FREI - keine beforeRoll!
                    if (throwVector && throwVector.vector && throwVector.boost) {
                        this.box.throw_with_vector(throwVector.vector, throwVector.boost, null, afterRoll);
                    } else {
                        this.box.start_throw(null, afterRoll);
                    }
                    
                    setTimeout(() => {
                        if (!done) {
                            done = true;
                            handleResults(this.generateFallbackResults(libraryNotation, d100Count));
                        }
                    }, 8000);
                } else {
                    setTimeout(() => {
                        handleResults(this.generateFallbackResults(libraryNotation, d100Count));
                    }, 1500);
                }
            },
            
            generateFallbackResults(notation, d100Count) {
                const results = [];
                if (d100Count > 0) {
                    for (let i = 0; i < d100Count; i++) {
                        results.push(Math.floor(Math.random() * 10) * 10);
                        results.push(Math.floor(Math.random() * 10));
                    }
                }
                const remaining = notation.replace(/\d*d100\+\d*d10/gi, '');
                const diceRegex = /(\d*)d(\d+)/gi;
                let match;
                while ((match = diceRegex.exec(remaining)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    for (let j = 0; j < count; j++) {
                        if (sides === 10) {
                            results.push(Math.floor(Math.random() * 10));
                        } else {
                            results.push(Math.floor(Math.random() * sides) + 1);
                        }
                    }
                }
                return results;
            },
            
            checkCriticalFromResults(rolls, special) {
                const diceTypes = Object.entries(this.currentDice).filter(([t, c]) => c > 0);
                const isD20 = diceTypes.length === 1 && diceTypes[0][0] === 'd20' && diceTypes[0][1] === 1;
                const isD100 = diceTypes.length === 1 && diceTypes[0][0] === 'd100' && diceTypes[0][1] === 1;
                
                if (isD20 || (special && diceTypes.some(([t]) => t === 'd20'))) {
                    if (rolls.includes(20)) return 'success';
                    if (rolls.includes(1)) return 'failure';
                }
                if (isD100) {
                    if (rolls.includes(1)) return 'success';
                    if (rolls.includes(100)) return 'failure';
                }
                return false;
            },
            
            // Sync: Start - andere Spieler starten Animation
            syncRollStart(data) {
                if (!this.diceRef || !this.multiplayerEnabled) return;
                console.log('[DiceRoller] syncRollStart');
                this.diceRef.push({ ...data, phase: 'start' });
                
                // Send toast notification for roll start (visible on all pages)
                if (!data.secret && window.RIFTToast?.diceRolling) {
                    RIFTToast.diceRolling(data.player, data.rollLabel || '', data.rollType, data.rollElement);
                }
            },
            
            // Sync: Complete - echte Ergebnisse
            syncRollComplete(data) {
                if (!this.diceRef || !this.multiplayerEnabled) return;
                console.log('[DiceRoller] syncRollComplete');
                this.diceRef.push({ ...data, phase: 'complete' });
                
                // Send toast notification for roll result (visible on all other pages)
                if (!data.secret && window.RIFTToast?.diceRoll) {
                    let rollInfo = data.notation;
                    let rollType = null;
                    let rollElement = null;
                    
                    if (data.checkInfo?.skillCheckMode) {
                        rollInfo = `Fähigkeit: ${data.checkInfo.skillCheckLabel}`;
                        rollType = 'skill';
                    } else if (data.checkInfo?.fokusCheckMode) {
                        rollInfo = `Fokus: ${data.checkInfo.fokusCheckLabel}`;
                        rollType = 'fokus';
                        rollElement = data.checkInfo.fokusCheckLabel;
                    } else if (data.checkInfo?.zweiteChanceMode) {
                        rollInfo = 'Zweite Chance';
                        rollType = 'zweitechance';
                    }
                    
                    // Determine success
                    let isSuccess = null;
                    if (data.checkInfo?.skillCheckMode && data.results?.[0] !== undefined) {
                        isSuccess = data.results[0] <= data.checkInfo.skillCheckTarget;
                    } else if (data.checkInfo?.fokusCheckMode) {
                        const rollValue = data.results?.[0];
                        isSuccess = rollValue === 20 || (rollValue !== 1 && data.total >= 11);
                    } else if (data.checkInfo?.zweiteChanceMode) {
                        isSuccess = data.results?.[0] >= 6;
                    } else if (data.critical === 'success') {
                        isSuccess = true;
                    } else if (data.critical === 'failure') {
                        isSuccess = false;
                    }
                    
                    RIFTToast.diceRoll(data.player, data.total, rollInfo, isSuccess, rollType, rollElement);
                }
                
                // Also log to Firestore
                this.logRollToFirestore(data);
            },
            
            // Zeige Ergebnis an
            displayRollResult(rolls, total, mod, isCritical, special, playerName, playerColor, d100Count = 0, labelValues = null) {
                // Clear any existing timeout to prevent early hide
                if (this.resultTimeout) {
                    clearTimeout(this.resultTimeout);
                    this.resultTimeout = null;
                }
                
                const arena = document.getElementById('diceArena');
                const resultEl = document.getElementById('diceResult');
                const totalEl = document.getElementById('resultTotal');
                const breakdownEl = document.getElementById('resultBreakdown');
                const playerEl = document.getElementById('resultPlayer');
                const skillLabelEl = document.getElementById('resultSkillLabel');
                const targetEl = document.getElementById('resultTarget');
                const outcomeEl = document.getElementById('resultOutcome');
                const backBtnEl = document.getElementById('resultBackBtn');
                
                arena.classList.remove('throwing');
                
                // Reset skill check display classes
                resultEl.classList.remove('skill-success', 'skill-failure');
                skillLabelEl.classList.remove('visible');
                targetEl.classList.remove('visible');
                outcomeEl.classList.remove('visible', 'success', 'failure');
                backBtnEl.classList.remove('visible');
                
                if (playerEl) {
                    playerEl.textContent = playerName;
                    playerEl.style.color = playerColor || '#FF4655';
                }
                
                totalEl.textContent = total;
                
                let modStr = '';
                if (mod !== 0) {
                    const cls = mod > 0 ? 'positive' : 'negative';
                    modStr = ` <span class="dice-result__mod dice-result__mod--${cls}">${mod > 0 ? '+' : ''}${mod}</span>`;
                }
                
                // Build breakdown string
                let breakdownParts = [];
                
                if (d100Count > 0 && labelValues && labelValues.length >= d100Count * 2) {
                    // D100: Zeige "40 + 9 = 49" Format
                    let idx = 0;
                    for (let i = 0; i < d100Count; i++) {
                        const tens = labelValues[idx];
                        const ones = labelValues[idx + 1];
                        const tensStr = tens === 0 ? '00' : tens.toString();
                        breakdownParts.push(`${tensStr} + ${ones}`);
                        idx += 2;
                    }
                    // Add remaining dice (non-D100)
                    while (idx < labelValues.length) {
                        breakdownParts.push(labelValues[idx].toString());
                        idx++;
                    }
                } else {
                    // Normal dice: just show the results
                    breakdownParts = rolls.map(r => r.toString());
                }
                
                // ========================================
                // SKILL CHECK DISPLAY (Fähigkeiten D100)
                // ========================================
                if (this.skillCheckMode && this.skillCheckTarget > 0) {
                    skillLabelEl.textContent = `Fähigkeit: ${this.skillCheckLabel}`;
                    skillLabelEl.classList.add('visible');
                    
                    const rollResult = rolls[0];
                    const isSuccess = rollResult <= this.skillCheckTarget;
                    
                    targetEl.textContent = `Zielwert: ${this.skillCheckTarget}`;
                    targetEl.classList.add('visible');
                    
                    outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    breakdownEl.innerHTML = `Gewürfelt: ${rollResult} | Zielwert: ${this.skillCheckTarget}`;
                    
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    this.lastCheckResult = {
                        label: `Fähigkeit: ${this.skillCheckLabel}`,
                        result: rollResult,
                        success: isSuccess,
                        outcome: isSuccess ? 'Erfolg' : 'Fehlschlag',
                        critical: false
                    };
                }
                // ========================================
                // ZWEITE CHANCE DISPLAY (D20)
                // ========================================
                else if (this.zweiteChanceMode) {
                    skillLabelEl.textContent = 'Zweite Chance';
                    skillLabelEl.classList.add('visible');
                    
                    targetEl.textContent = '1–5 = Fehlschlag | 6–20 = Wiederholen';
                    targetEl.classList.add('visible');
                    
                    const rollValue = rolls[0];
                    const isSuccess = rollValue >= 6;
                    
                    outcomeEl.textContent = isSuccess ? 'WIEDERHOLEN ERLAUBT!' : 'FEHLSCHLAG BLEIBT!';
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    breakdownEl.innerHTML = `Gewürfelt: ${rollValue}`;
                    
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    this.lastCheckResult = {
                        label: 'Zweite Chance',
                        result: rollValue,
                        success: isSuccess,
                        outcome: isSuccess ? 'Wiederholen!' : 'Fehlschlag!',
                        critical: false,
                        zweiteChance: true,
                        diceIndex: this.zweiteChanceDiceIndex
                    };
                }
                // ========================================
                // FOKUS CHECK DISPLAY (D20)
                // ========================================
                else if (this.fokusCheckMode) {
                    skillLabelEl.textContent = `Fokus: ${this.fokusCheckLabel}`;
                    skillLabelEl.classList.add('visible');
                    
                    targetEl.textContent = `≥11 Erfolg | ≤10 Fehlschlag`;
                    targetEl.classList.add('visible');
                    
                    const rollValue = rolls[0];
                    const isNat20 = rollValue === 20;
                    const isNat1 = rollValue === 1;
                    const isSuccess = isNat20 || (!isNat1 && total >= 11);
                    const isCrit = isNat20 || isNat1;
                    
                    if (isNat20) {
                        outcomeEl.textContent = 'KRITISCHER ERFOLG!';
                        resultEl.classList.add('critical');
                    } else if (isNat1) {
                        outcomeEl.textContent = 'PATZER!';
                        resultEl.classList.add('fumble');
                    } else {
                        outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    const modSign = mod >= 0 ? '+' : '';
                    breakdownEl.innerHTML = `${rollValue} ${modSign} ${mod} = ${total}`;
                    
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    let outcomeText = isSuccess ? 'Erfolg' : 'Fehlschlag';
                    if (isNat20) outcomeText = 'Kritisch!';
                    if (isNat1) outcomeText = 'Patzer!';
                    
                    this.lastCheckResult = {
                        label: `Fokus: ${this.fokusCheckLabel}`,
                        result: total,
                        success: isSuccess,
                        outcome: outcomeText,
                        critical: isCrit
                    };
                }
                // ========================================
                // NORMAL ROLL DISPLAY
                // ========================================
                else {
                    if (special === 'advantage') {
                        breakdownEl.innerHTML = `[${breakdownParts.join(', ')}] → höchste: ${Math.max(...rolls)}${modStr}`;
                    } else if (special === 'disadvantage') {
                        breakdownEl.innerHTML = `[${breakdownParts.join(', ')}] → niedrigste: ${Math.min(...rolls)}${modStr}`;
                    } else {
                        breakdownEl.innerHTML = `[${breakdownParts.join(', ')}]${modStr} = ${total}`;
                    }
                }
                
                if (this.secretRoll) resultEl.classList.add('secret');
                
                if (isCritical === 'success' && !this.fokusCheckMode) {
                    resultEl.classList.add('critical');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('success');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                } else if (isCritical === 'failure' && !this.fokusCheckMode) {
                    resultEl.classList.add('fumble');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('failure');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                }
                
                resultEl.classList.add('visible');
                
                this.resultTimeout = setTimeout(() => {
                    resultEl.classList.remove('visible', 'critical', 'fumble', 'secret', 'skill-success', 'skill-failure');
                    skillLabelEl.classList.remove('visible');
                    targetEl.classList.remove('visible');
                    outcomeEl.classList.remove('visible', 'success', 'failure');
                    backBtnEl.classList.remove('visible');
                    this.clearDiceLabels();
                    
                    // Reset check modes
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                    this.zweiteChanceMode = false;
                    this.zweiteChanceDiceIndex = -1;
                }, 8000);
            },
            
            calculateD100Result(rawRolls, d100Count) {
                // Library returns:
                // - d100 (tens): 0, 10, 20, 30, 40, 50, 60, 70, 80, 90
                // - d10 (ones): 1-10 (where 10 means the "0" face was rolled)
                const rolls = [];
                let total = 0;
                let rollIndex = 0;
                
                for (let i = 0; i < d100Count; i++) {
                    const tens = rawRolls[rollIndex] || 0;           // 0, 10, 20, 30...90
                    const onesRaw = rawRolls[rollIndex + 1] || 1;    // 1-10
                    const ones = onesRaw === 10 ? 0 : onesRaw;       // Convert 10 back to 0
                    
                    let value = tens + ones;
                    // Special case: 00 + 0 = 100 (not 0)
                    if (value === 0) value = 100;
                    
                    console.log(`[DiceRoller] D100 #${i+1}: tens=${tens}, onesRaw=${onesRaw}, ones=${ones}, value=${value}`);
                    
                    rolls.push(value);
                    total += value;
                    rollIndex += 2;
                }
                
                // Add remaining rolls (non-d100 dice)
                while (rollIndex < rawRolls.length) {
                    rolls.push(rawRolls[rollIndex]);
                    total += rawRolls[rollIndex];
                    rollIndex++;
                }
                
                return { rolls, total };
            },
            
            simulateRoll(notation) {
                const rolls = [];
                let total = 0;
                
                // Normalize W to D
                const normalized = notation.toUpperCase().replace(/W/g, 'D');
                
                const diceRegex = /(\d*)D(\d+)/g;
                let match;
                while ((match = diceRegex.exec(normalized)) !== null) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    
                    if (sides === 100) {
                        // D100: tens (00-90) + ones (0-9)
                        for (let i = 0; i < count; i++) {
                            const tens = Math.floor(Math.random() * 10) * 10; // 0, 10, 20...90
                            const ones = Math.floor(Math.random() * 10);       // 0-9
                            let value = tens + ones;
                            if (value === 0) value = 100; // 00 + 0 = 100
                            rolls.push(value);
                            total += value;
                        }
                    } else {
                        for (let i = 0; i < count; i++) {
                            const roll = Math.floor(Math.random() * sides) + 1;
                            rolls.push(roll);
                            total += roll;
                        }
                    }
                }
                
                const modMatch = normalized.match(/([+-]\d+)(?!D)(?:\s*$|\s*\()/);
                const mod = modMatch ? parseInt(modMatch[1]) : 0;
                total += mod;
                
                return { rolls, total, breakdown: `[${rolls.join(', ')}]${mod !== 0 ? (mod > 0 ? '+' : '') + mod : ''} = ${total}` };
            },
            
            handleResult(rolls, total, notation, special = null, rawRolls = null) {
                const arena = document.getElementById('diceArena');
                const resultEl = document.getElementById('diceResult');
                const totalEl = document.getElementById('resultTotal');
                const breakdownEl = document.getElementById('resultBreakdown');
                const playerEl = document.getElementById('resultPlayer');
                const skillLabelEl = document.getElementById('resultSkillLabel');
                const targetEl = document.getElementById('resultTarget');
                const outcomeEl = document.getElementById('resultOutcome');
                const backBtnEl = document.getElementById('resultBackBtn');
                
                // Reset skill check display classes
                resultEl.classList.remove('skill-success', 'skill-failure');
                skillLabelEl.classList.remove('visible');
                targetEl.classList.remove('visible');
                outcomeEl.classList.remove('visible', 'success', 'failure');
                backBtnEl.classList.remove('visible');
                
                // Get current modifier
                const mod = parseInt(document.getElementById('modifierInput').value) || 0;
                
                // Handle advantage/disadvantage
                let finalTotal = total;
                let displayRolls = rolls;
                
                if (special === 'advantage' && rolls.length >= 2) {
                    finalTotal = Math.max(rolls[0], rolls[1]);
                    if (mod !== 0) finalTotal += mod;
                } else if (special === 'disadvantage' && rolls.length >= 2) {
                    finalTotal = Math.min(rolls[0], rolls[1]);
                    if (mod !== 0) finalTotal += mod;
                }
                
                // Check critical
                const isCritical = this.checkCritical(rolls, special);
                
                // Show dice labels above each die (use rolls as labelValues for legacy, no d100)
                this.showDiceLabels(rolls, 0);
                
                // Get user info
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const playerName = userData.name || 'Spieler';
                const playerColor = userData.color || '#FF4655';
                
                // Display
                playerEl.textContent = playerName;
                playerEl.style.color = playerColor;
                totalEl.textContent = finalTotal;
                
                // Skill Check Display (Worlds Apart D100)
                if (this.skillCheckMode && this.skillCheckTarget > 0) {
                    // Show skill label
                    skillLabelEl.textContent = `Fähigkeit: ${this.skillCheckLabel}`;
                    skillLabelEl.classList.add('visible');
                    
                    // Determine success/failure (roll must be <= target)
                    const rollResult = rolls[0]; // D100 result
                    const isSuccess = rollResult <= this.skillCheckTarget;
                    
                    // Show target value
                    targetEl.textContent = `Zielwert: ${this.skillCheckTarget}`;
                    targetEl.classList.add('visible');
                    
                    // Show outcome
                    outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown: Gewürfelt vs Zielwert
                    breakdownEl.innerHTML = `Gewürfelt: ${rollResult} | Zielwert: ${this.skillCheckTarget}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    this.lastCheckResult = {
                        label: `Fähigkeit: ${this.skillCheckLabel}`,
                        result: rollResult,
                        success: isSuccess,
                        outcome: isSuccess ? 'Erfolg' : 'Fehlschlag',
                        critical: false
                    };
                    
                    console.log('[DiceRoller] Skill Check Result:', { roll: rollResult, target: this.skillCheckTarget, success: isSuccess });
                }
                // Zweite Chance Display (Worlds Apart D20)
                else if (this.zweiteChanceMode) {
                    // Show label
                    skillLabelEl.textContent = 'Zweite Chance';
                    skillLabelEl.classList.add('visible');
                    
                    // Show threshold info
                    targetEl.textContent = '1–5 = Fehlschlag | 6–20 = Wiederholen';
                    targetEl.classList.add('visible');
                    
                    // Get natural roll
                    const rollValue = rolls[0];
                    const isSuccess = rollValue >= 6;
                    
                    // Show outcome
                    if (isSuccess) {
                        outcomeEl.textContent = 'WIEDERHOLEN ERLAUBT!';
                    } else {
                        outcomeEl.textContent = 'FEHLSCHLAG BLEIBT!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown
                    breakdownEl.innerHTML = `Gewürfelt: ${rollValue}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    this.lastCheckResult = {
                        label: 'Zweite Chance',
                        result: rollValue,
                        success: isSuccess,
                        outcome: isSuccess ? 'Wiederholen!' : 'Fehlschlag!',
                        critical: false,
                        zweiteChance: true,
                        diceIndex: this.zweiteChanceDiceIndex
                    };
                    
                    console.log('[DiceRoller] Zweite Chance Result:', { roll: rollValue, success: isSuccess, diceIndex: this.zweiteChanceDiceIndex });
                }
                // Fokus Check Display (Worlds Apart D20)
                else if (this.fokusCheckMode) {
                    // Show fokus label with actual fokus name
                    skillLabelEl.textContent = `Fokus: ${this.fokusCheckLabel}`;
                    skillLabelEl.classList.add('visible');
                    
                    // Show threshold info
                    targetEl.textContent = `≥11 Erfolg | ≤10 Fehlschlag`;
                    targetEl.classList.add('visible');
                    
                    // Get natural roll
                    const rollValue = rolls[0];
                    const isNat20 = rollValue === 20;
                    const isNat1 = rollValue === 1;
                    
                    // Determine success/failure (total must be >= 11, but nat 20 always success, nat 1 always fail)
                    const isSuccess = isNat20 || (!isNat1 && finalTotal >= 11);
                    const isCritical = isNat20 || isNat1;
                    
                    // Show outcome
                    if (isNat20) {
                        outcomeEl.textContent = 'KRITISCHER ERFOLG!';
                        resultEl.classList.add('critical');
                    } else if (isNat1) {
                        outcomeEl.textContent = 'PATZER!';
                        resultEl.classList.add('fumble');
                    } else {
                        outcomeEl.textContent = isSuccess ? 'ERFOLG!' : 'FEHLSCHLAG!';
                    }
                    outcomeEl.classList.add('visible', isSuccess ? 'success' : 'failure');
                    resultEl.classList.add(isSuccess ? 'skill-success' : 'skill-failure');
                    
                    // Show breakdown with roll + modifier = total
                    const modSign = mod >= 0 ? '+' : '';
                    breakdownEl.innerHTML = `${rollValue} ${modSign} ${mod} = ${finalTotal}`;
                    breakdownEl.style.display = '';
                    
                    // Show back button if return URL exists
                    if (this.returnUrl) {
                        backBtnEl.classList.add('visible');
                    }
                    
                    // Save result for passing back to sheet
                    let outcomeText = isSuccess ? 'Erfolg' : 'Fehlschlag';
                    if (isNat20) outcomeText = 'Kritisch!';
                    if (isNat1) outcomeText = 'Patzer!';
                    
                    this.lastCheckResult = {
                        label: `Fokus: ${this.fokusCheckLabel}`,
                        result: finalTotal,
                        success: isSuccess,
                        outcome: outcomeText,
                        critical: isCritical
                    };
                    
                    console.log('[DiceRoller] Fokus Check Result:', { roll: rollValue, mod: mod, total: finalTotal, success: isSuccess, critical: isCritical });
                } else {
                    // Normal roll - show breakdown
                    breakdownEl.style.display = '';
                }
                
                // Format modifier string with color
                let modStr = '';
                if (mod !== 0) {
                    const modClass = mod > 0 ? 'positive' : 'negative';
                    const modSign = mod > 0 ? '+' : '';
                    modStr = ` <span class="dice-result__mod dice-result__mod--${modClass}">${modSign}${mod}</span>`;
                }
                
                if (special === 'advantage') {
                    const baseResult = Math.max(rolls[0], rolls[1]);
                    breakdownEl.innerHTML = `[${rolls[0]}, ${rolls[1]}] → höchste: ${baseResult}${modStr}`;
                } else if (special === 'disadvantage') {
                    const baseResult = Math.min(rolls[0], rolls[1]);
                    breakdownEl.innerHTML = `[${rolls[0]}, ${rolls[1]}] → niedrigste: ${baseResult}${modStr}`;
                } else {
                    // Calculate base total (without modifier)
                    const baseTotal = rolls.reduce((a, b) => a + b, 0);
                    breakdownEl.innerHTML = `[${rolls.join(', ')}]${modStr} = ${total}`;
                }
                
                // Secret roll styling
                if (this.secretRoll) {
                    resultEl.classList.add('secret');
                }
                
                // Scan-line effect through arena
                arena.classList.add('resolving');
                setTimeout(() => arena.classList.remove('resolving'), 1500);
                
                // Critical/Fumble styling and effects
                if (isCritical === 'success') {
                    resultEl.classList.add('critical');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('success');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                } else if (isCritical === 'failure') {
                    resultEl.classList.add('fumble');
                    arena.classList.add('shake');
                    this.spawnParticles(30);
                    this.showCritFlash('failure');
                    setTimeout(() => arena.classList.remove('shake'), 500);
                }
                
                resultEl.classList.add('visible');
                
                // Auto-hide result after 8 seconds
                this.resultTimeout = setTimeout(() => {
                    resultEl.classList.remove('visible', 'critical', 'fumble', 'secret', 'skill-success', 'skill-failure');
                    skillLabelEl.classList.remove('visible');
                    targetEl.classList.remove('visible');
                    outcomeEl.classList.remove('visible', 'success', 'failure');
                    backBtnEl.classList.remove('visible');
                    breakdownEl.style.display = '';
                    this.clearDiceLabels();
                    
                    // Reset skill check mode
                    this.skillCheckMode = false;
                    this.skillCheckTarget = 0;
                    this.skillCheckLabel = '';
                    
                    // Reset fokus check mode
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.fokusCheckMod = 0;
                }, 8000);
                
                // Build notation string for history (German W notation)
                const parts = [];
                for (const [type, count] of Object.entries(this.currentDice)) {
                    if (count > 0) {
                        const wType = type.replace('d', 'W');
                        parts.push(`${count}${wType}`);
                    }
                }
                let histNotation = parts.join('+');
                if (mod !== 0) histNotation += (mod > 0 ? '+' : '') + mod;
                if (special) histNotation += ` (${special === 'advantage' ? 'V' : 'N'})`;
                
                // Add to history
                this.addToHistory({
                    player: playerName,
                    color: userData.color || '#FF4655',
                    total: finalTotal,
                    notation: histNotation,
                    rolls: displayRolls,
                    critical: isCritical,
                    secret: this.secretRoll,
                    special,
                    timestamp: Date.now()
                });
                
                // Sync to multiplayer
                // Calculate success for skill checks
                let rollSuccess = null;
                let rollLabel = null;
                if (this.skillCheckMode && this.skillCheckTarget > 0) {
                    rollLabel = `Fähigkeit: ${this.skillCheckLabel}`;
                    rollSuccess = displayRolls[0] <= this.skillCheckTarget;
                } else if (this.fokusCheckMode) {
                    rollLabel = `Fokus: ${this.fokusCheckLabel}`;
                    const rollValue = displayRolls[0];
                    const isNat20 = rollValue === 20;
                    const isNat1 = rollValue === 1;
                    rollSuccess = isNat20 || (!isNat1 && finalTotal >= 11);
                } else if (this.zweiteChanceMode) {
                    rollLabel = 'Zweite Chance';
                    rollSuccess = displayRolls[0] >= 6;
                }
                
                this.syncRoll({
                    player: playerName,
                    playerId: userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || playerName,
                    color: userData.color || '#FF4655',
                    diceTheme: this.currentTheme || 'onyx',
                    labelColor: this.currentLabelColor || 'auto',
                    total: finalTotal,
                    notation: histNotation,
                    results: displayRolls,
                    modifier: mod,
                    critical: isCritical,
                    secret: this.secretRoll,
                    timestamp: Date.now(),
                    // Add label for skill/fokus/zweite chance rolls
                    label: rollLabel,
                    checkType: this.skillCheckMode ? 'skill' : (this.fokusCheckMode ? 'fokus' : (this.zweiteChanceMode ? 'zweitechance' : null)),
                    success: rollSuccess,
                    diceConfig: {
                        notation: this.currentLibraryNotation,
                        results: displayRolls
                    }
                });
                
                this.isRolling = false;
            },
            
            checkCritical(rolls, special) {
                // Get the dice type being rolled
                const diceTypes = Object.entries(this.currentDice).filter(([type, count]) => count > 0);
                const isOnlyD20 = diceTypes.length === 1 && diceTypes[0][0] === 'd20' && diceTypes[0][1] === 1;
                const isOnlyD100 = diceTypes.length === 1 && diceTypes[0][0] === 'd100' && diceTypes[0][1] === 1;
                
                // D&D 5e: D20 critical
                if (isOnlyD20 || (special && diceTypes.some(([type]) => type === 'd20'))) {
                    // Nat 20 = Critical Success
                    if (rolls.length === 1 && rolls[0] === 20) return 'success';
                    if (rolls.length === 2 && special && (rolls[0] === 20 || rolls[1] === 20)) return 'success';
                    // Nat 1 = Critical Failure
                    if (rolls.length === 1 && rolls[0] === 1) return 'failure';
                    if (rolls.length === 2 && special && (rolls[0] === 1 || rolls[1] === 1)) return 'failure';
                }
                
                // Worlds Apart: D100 critical
                if (isOnlyD100) {
                    // 1 on d100 = Critical Success
                    if (rolls.length === 1 && rolls[0] === 1) return 'success';
                    // 100 on d100 = Critical Failure
                    if (rolls.length === 1 && rolls[0] === 100) return 'failure';
                }
                
                return false;
            },
            
            showCritFlash(type) {
                const flash = document.createElement('div');
                flash.className = `crit-flash crit-flash--${type}`;
                document.body.appendChild(flash);
                
                // Remove after animation
                setTimeout(() => {
                    flash.remove();
                }, 600);
            },
            
            // ========================================
            // MULTIPLAYER
            // ========================================
            
            initMultiplayer() {
                const roomCode = localStorage.getItem('rift_current_room');
                console.log('[DiceRoller] initMultiplayer called, roomCode:', roomCode, 'firebase:', typeof firebase !== 'undefined');
                
                // Check if Firebase SDK is loaded AND initialized
                if (!roomCode || typeof firebase === 'undefined' || !firebase.apps || firebase.apps.length === 0) {
                    console.log('[DiceRoller] No room or Firebase not initialized, skipping multiplayer');
                    return;
                }
                
                // Store normalized room code for Firestore
                this.roomCode = roomCode.replace(/-/g, '').toUpperCase();
                
                // Get current user for filtering
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                this.currentPlayerName = userData.name || 'Spieler';
                this.currentPlayerId = userData.odaiId || userData.odaid || localStorage.getItem('rift_player_id') || userData.name || 'unknown_' + Date.now();
                
                console.log('[DiceRoller] Current player:', this.currentPlayerName, 'ID:', this.currentPlayerId);
                
                try {
                    this.roomRef = firebase.database().ref(`rooms/${roomCode}`);
                    this.diceRef = this.roomRef.child('dice_rolls');
                    this.statsRef = this.roomRef.child('dice_stats');
                    
                    console.log('[DiceRoller] Firebase refs created, diceRef:', !!this.diceRef);
                    
                    // Initialize stats structure if not exists
                    this.statsRef.once('value', (snapshot) => {
                        if (!snapshot.exists()) {
                            this.statsRef.set({
                                totalRolls: 0,
                                criticalSuccesses: 0,
                                criticalFailures: 0,
                                sumOfTotals: 0,
                                maxRoll: null,
                                minRoll: null
                            });
                        }
                    });
                    
                    // Subscribe to stats changes
                    this.statsRef.on('value', (snapshot) => {
                        const stats = snapshot.val();
                        if (stats) {
                            this.roomStats = stats;
                            this.updateStatsDisplay(stats);
                        }
                    });
                    
                    // Listen for new rolls from ALL players
                    this.diceRef.orderByChild('timestamp').limitToLast(20).on('child_added', (snapshot) => {
                        const roll = snapshot.val();
                        console.log('[DiceRoller] child_added event, roll:', roll?.player, roll?.phase || 'no-phase');
                        if (!roll) return;
                        
                        // Skip old rolls (more than 30 seconds)
                        const rollAge = Date.now() - roll.timestamp;
                        if (rollAge > 30000) {
                            console.log('[DiceRoller] Skipping old roll, age:', rollAge);
                            return;
                        }
                        
                        // Check if this is from another player
                        const isOwnRoll = (roll.playerId && roll.playerId === this.currentPlayerId) || 
                                          (!roll.playerId && roll.player === this.currentPlayerName);
                        
                        console.log('[DiceRoller] Roll received:', roll.player, '| Own:', isOwnRoll, '| PlayerId:', roll.playerId, 'vs', this.currentPlayerId);
                        
                        if (!isOwnRoll) {
                            console.log('[DiceRoller] 🎲 REMOTE ROLL from', roll.player, ':', roll.notation, '=', roll.total);
                            this.handleRemoteRoll(roll);
                        }
                    });
                    
                    console.log('[DiceRoller] ✅ Multiplayer connected - listening for live rolls');
                    this.multiplayerEnabled = true;
                } catch (e) {
                    console.error('[DiceRoller] Multiplayer init failed:', e);
                }
            },
            
            // Handle incoming roll from another player
            handleRemoteRoll(roll) {
                console.log('[DiceRoller] handleRemoteRoll:', roll.player, roll.phase);
                
                const arena = document.getElementById('diceArena');
                
                if (roll.phase === 'start') {
                    // Phase 1: Zeige rotierende 3D-Würfel in der Mitte
                    arena.classList.remove('empty');
                    this.clearDiceLabels();
                    
                    // Altes Ergebnis ausblenden
                    const resultEl = document.getElementById('diceResult');
                    if (resultEl) {
                        resultEl.classList.remove('visible', 'critical', 'fumble', 'secret');
                    }
                    
                    // Indicator
                    let indicator = document.getElementById('remotePlayerIndicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'remotePlayerIndicator';
                        indicator.className = 'dice-remote-indicator';
                        arena.appendChild(indicator);
                    }
                    
                    // Build indicator text with optional label and target
                    let indicatorText = `<span style="color: ${roll.color || '#8b5cf6'}">${roll.player}</span> würfelt`;
                    if (roll.rollLabel) {
                        indicatorText += ` auf <strong>${roll.rollLabel}</strong>`;
                        if (roll.rollTarget) {
                            indicatorText += ` <span style="opacity: 0.7">(Ziel: ${roll.rollTarget})</span>`;
                        }
                    }
                    indicatorText += '...';
                    indicator.innerHTML = indicatorText;
                    indicator.classList.add('visible');
                    
                    // Starte rotierende 3D-Würfel
                    this.startSpinningDice(roll);
                    
                    // Speichere für phase 2
                    this.pendingRemoteRolls = this.pendingRemoteRolls || {};
                    this.pendingRemoteRolls[roll.playerId] = { ...roll, startTime: Date.now() };
                    return;
                }
                
                if (roll.phase === 'complete') {
                    // Phase 2: Stoppe Rotation, zeige Ergebnis
                    this.stopSpinningDice(roll);
                    return;
                }
                
                // Legacy ohne phase
                if (!roll.results && roll.total === undefined) {
                    console.log('[DiceRoller] Skipping roll without results');
                    return;
                }
                this.showRemoteResult(roll);
            },
            
            // Starte 3D-Würfel die in der Mitte rotieren
            startSpinningDice(roll) {
                if (!this.box) return;
                
                const notation = roll.diceConfig?.notation || '1d20';
                
                // Setze Würfelfarbe
                if (roll.diceTheme && typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    const remoteColors = this.themeColors[roll.diceTheme] || this.themeColors.onyx;
                    DICE.setDiceColor(remoteColors.accent, remoteColors.gradient || null, remoteColors.texture || null);
                }
                if (roll.labelColor && typeof DICE !== 'undefined' && typeof DICE.setLabelColor === 'function') {
                    DICE.setLabelColor(roll.labelColor === 'auto' ? null : roll.labelColor);
                }
                
                // Lösche alte Würfel
                this.box.clear();
                
                // Parse Notation um Würfeltypen zu bekommen
                const diceTypes = [];
                const matches = notation.matchAll(/(\d*)d(\d+)/gi);
                for (const match of matches) {
                    const count = parseInt(match[1]) || 1;
                    const sides = parseInt(match[2]);
                    const type = sides === 100 ? 'd100' : `d${sides}`;
                    for (let i = 0; i < count; i++) {
                        diceTypes.push(type);
                    }
                }
                
                // Erstelle Würfel in der Mitte mit Rotation
                const spacing = 80;
                const total = diceTypes.length;
                const startX = -((total - 1) * spacing) / 2;
                
                diceTypes.forEach((type, i) => {
                    const pos = { x: startX + i * spacing, y: 50, z: 0 };
                    const velocity = { x: 0, y: 0, z: 0 };
                    const angle = { x: 12, y: 18, z: 8 };
                    const axis = { x: 0.5, y: 0.5, z: 0.5, a: 0.5 };
                    
                    this.box.create_dice(type, pos, velocity, angle, axis);
                });
                
                // Aktiviere Glow-Effekt auf Arena
                const arena = document.getElementById('diceArena');
                arena.classList.add('dice-spinning-effect');
                
                // Starte manuellen Rotations-Loop
                this.spinningRemote = true;
                this.spinStartTime = Date.now();
                this.spinRemoteDice();
            },
            
            // Manueller Rotations-Loop für schwebende Würfel
            spinRemoteDice() {
                if (!this.spinningRemote || !this.box || !this.box.dices) return;
                
                const elapsed = (Date.now() - this.spinStartTime) / 1000;
                
                this.box.dices.forEach((dice, index) => {
                    if (dice.body) {
                        // Schwebende Bewegung (Sinus-Welle)
                        const baseY = 50;
                        const floatAmplitude = 8;
                        const floatSpeed = 2 + index * 0.3;
                        dice.body.position.y = baseY + Math.sin(elapsed * floatSpeed) * floatAmplitude;
                        
                        // Leichte horizontale Bewegung
                        const baseX = dice.body.position.x;
                        dice.body.position.x += Math.sin(elapsed * 1.5 + index) * 0.3;
                        
                        // Verhindere Drift
                        dice.body.velocity.set(0, 0, 0);
                        
                        // Rotation um ALLE Achsen
                        const q = dice.body.quaternion;
                        const speedX = 0.06 + index * 0.01;
                        const speedY = 0.09 + index * 0.015;
                        const speedZ = 0.04 + index * 0.008;
                        
                        // Rotation um X
                        this.applyQuaternionRotation(q, 1, 0, 0, speedX);
                        // Rotation um Y
                        this.applyQuaternionRotation(q, 0, 1, 0, speedY);
                        // Rotation um Z
                        this.applyQuaternionRotation(q, 0, 0, 1, speedZ);
                        
                        q.normalize();
                        
                        // Sync mesh mit body
                        dice.position.copy(dice.body.position);
                        dice.quaternion.copy(dice.body.quaternion);
                    }
                });
                
                // Render
                if (this.box.renderer && this.box.scene && this.box.camera) {
                    this.box.renderer.render(this.box.scene, this.box.camera);
                }
                
                requestAnimationFrame(() => this.spinRemoteDice());
            },
            
            // Hilfs-Funktion für Quaternion-Rotation
            applyQuaternionRotation(q, axisX, axisY, axisZ, angle) {
                const halfAngle = angle / 2;
                const s = Math.sin(halfAngle);
                const c = Math.cos(halfAngle);
                
                // Rotation quaternion
                const rw = c;
                const rx = axisX * s;
                const ry = axisY * s;
                const rz = axisZ * s;
                
                // Multiply: q = q * r
                const qw = q.w * rw - q.x * rx - q.y * ry - q.z * rz;
                const qx = q.w * rx + q.x * rw + q.y * rz - q.z * ry;
                const qy = q.w * ry - q.x * rz + q.y * rw + q.z * rx;
                const qz = q.w * rz + q.x * ry - q.y * rx + q.z * rw;
                
                q.w = qw;
                q.x = qx;
                q.y = qy;
                q.z = qz;
            },
            
            // Stoppe Rotation und zeige Ergebnis - KEIN WURF!
            stopSpinningDice(roll) {
                this.spinningRemote = false;
                
                // Entferne Glow-Effekt
                const arena = document.getElementById('diceArena');
                arena.classList.remove('dice-spinning-effect');
                
                let indicator = document.getElementById('remotePlayerIndicator');
                
                const myDiceColor = this.currentDiceColor;
                const myDiceGradient = this.currentDiceGradient;
                const myDiceTexture = this.currentDiceTexture;
                const myLabelColor = this.currentLabelColor;
                
                const labelValues = roll.diceConfig?.labelValues || roll.labelValues || [];
                const remoteD100Count = roll.diceConfig?.d100Count || 0;
                const beforeRollValues = roll.diceConfig?.beforeRollValues || [];
                
                // Stoppe Würfel-Rotation und setze KORREKTE FACE
                if (this.box && this.box.dices && beforeRollValues.length > 0) {
                    this.box.dices.forEach((dice, i) => {
                        if (dice.body) {
                            // Stoppe Bewegung
                            dice.body.angularVelocity.set(0, 0, 0);
                            dice.body.velocity.set(0, 0, 0);
                        }
                        
                        // Setze korrekte Face mit shift_dice_faces
                        if (beforeRollValues[i] !== undefined && typeof DICE !== 'undefined' && typeof DICE.get_dice_value === 'function') {
                            const currentValue = DICE.get_dice_value(dice);
                            const targetValue = beforeRollValues[i];
                            console.log(`[DiceRoller] Shifting dice ${i}: current=${currentValue}, target=${targetValue}`);
                            DICE.shift_dice_faces(dice, targetValue, currentValue);
                        }
                        
                        // Sync mesh
                        if (dice.body) {
                            dice.position.copy(dice.body.position);
                            dice.quaternion.copy(dice.body.quaternion);
                        }
                    });
                    
                    // Ein letztes Render um die neuen Faces zu zeigen
                    if (this.box.renderer && this.box.scene && this.box.camera) {
                        this.box.renderer.render(this.box.scene, this.box.camera);
                    }
                }
                
                // Kurze Pause, dann Ergebnis zeigen
                setTimeout(() => {
                    if (indicator) indicator.classList.remove('visible');
                    
                    // Eigene Farben wiederherstellen
                    if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                        DICE.setDiceColor(myDiceColor, myDiceGradient, myDiceTexture);
                    }
                    if (typeof DICE !== 'undefined' && typeof DICE.setLabelColor === 'function') {
                        DICE.setLabelColor(myLabelColor === 'auto' ? null : myLabelColor);
                    }
                    
                    // Zeige Labels über den Würfeln
                    this.showDiceLabels(labelValues, remoteD100Count);
                    
                    // Save current local check modes (in case player was setting up their own roll)
                    const savedModes = {
                        skillCheckMode: this.skillCheckMode,
                        skillCheckLabel: this.skillCheckLabel,
                        skillCheckTarget: this.skillCheckTarget,
                        fokusCheckMode: this.fokusCheckMode,
                        fokusCheckLabel: this.fokusCheckLabel,
                        zweiteChanceMode: this.zweiteChanceMode
                    };
                    
                    // Temporarily set Check-Modi for Remote-Roll display
                    if (roll.checkInfo) {
                        this.skillCheckMode = roll.checkInfo.skillCheckMode || false;
                        this.skillCheckLabel = roll.checkInfo.skillCheckLabel || '';
                        this.skillCheckTarget = roll.checkInfo.skillCheckTarget || 0;
                        this.fokusCheckMode = roll.checkInfo.fokusCheckMode || false;
                        this.fokusCheckLabel = roll.checkInfo.fokusCheckLabel || '';
                        this.zweiteChanceMode = roll.checkInfo.zweiteChanceMode || false;
                    }
                    
                    // Zeige Ergebnis-Card
                    this.displayRollResult(
                        roll.results || [],
                        roll.total,
                        roll.modifier || 0,
                        roll.critical,
                        roll.special,
                        roll.player,
                        roll.color,
                        remoteD100Count,
                        labelValues
                    );
                    
                    // IMMEDIATELY reset check modes after display (don't inherit remote player's roll type)
                    this.skillCheckMode = false;
                    this.skillCheckLabel = '';
                    this.skillCheckTarget = 0;
                    this.fokusCheckMode = false;
                    this.fokusCheckLabel = '';
                    this.zweiteChanceMode = false;
                    this.zweiteChanceDiceIndex = -1;
                    
                    this.addToHistory({
                        player: roll.player || 'Spieler',
                        color: roll.color || '#8b5cf6',
                        total: roll.total,
                        notation: roll.notation,
                        rolls: roll.results || [],
                        critical: roll.critical,
                        secret: roll.secret,
                        timestamp: roll.timestamp || Date.now(),
                        isRemote: true
                    });
                }, 300);
            },
            
            // Zeige Remote Ergebnis ohne Animation
            showRemoteResult(roll) {
                const labelValues = roll.diceConfig?.labelValues || roll.labelValues || [];
                const remoteD100Count = roll.diceConfig?.d100Count || 0;
                
                let indicator = document.getElementById('remotePlayerIndicator');
                if (indicator) indicator.classList.remove('visible');
                
                // Eigene Farben wiederherstellen
                if (typeof DICE !== 'undefined' && typeof DICE.setDiceColor === 'function') {
                    DICE.setDiceColor(this.currentDiceColor, this.currentDiceGradient, this.currentDiceTexture);
                }
                if (typeof DICE !== 'undefined' && typeof DICE.setLabelColor === 'function') {
                    DICE.setLabelColor(this.currentLabelColor === 'auto' ? null : this.currentLabelColor);
                }
                
                this.showDiceLabels(labelValues, remoteD100Count);
                this.displayRollResult(
                    roll.results || [],
                    roll.total,
                    roll.modifier || 0,
                    roll.critical,
                    roll.special,
                    roll.player,
                    roll.color,
                    remoteD100Count,
                    labelValues
                );
                
                this.addToHistory({
                    player: roll.player || 'Spieler',
                    color: roll.color || '#8b5cf6',
                    total: roll.total,
                    notation: roll.notation,
                    rolls: roll.results || [],
                    critical: roll.critical,
                    secret: roll.secret,
                    timestamp: roll.timestamp || Date.now(),
                    isRemote: true
                });
            },
            
            syncRoll(rollData) {
                console.log('[DiceRoller] syncRoll called, diceRef:', !!this.diceRef);
                if (!this.diceRef) {
                    console.warn('[DiceRoller] No diceRef - multiplayer not initialized!');
                    return;
                }
                
                // Don't sync if secret and not GM
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                if (rollData.secret && !userData.isGM) {
                    return;
                }
                
                try {
                    // 1. Push to Realtime Database (for live feed)
                    console.log('[DiceRoller] Pushing roll to Firebase:', rollData.player, rollData.total);
                    this.diceRef.push(rollData);
                    
                    // 2. Also write to Firestore (for GM logs)
                    this.logRollToFirestore(rollData);
                    
                    // 3. Send toast notification
                    if (!rollData.secret && window.RIFTToast?.diceRoll) {
                        const rollInfo = rollData.label || rollData.notation;
                        let rollType = null;
                        let rollElement = null;
                        if (rollData.checkType === 'skill') {
                            rollType = 'skill';
                        } else if (rollData.checkType === 'fokus') {
                            rollType = 'fokus';
                            // Extract element from label "Fokus: Element"
                            if (rollData.label?.startsWith('Fokus: ')) {
                                rollElement = rollData.label.replace('Fokus: ', '');
                            }
                        } else if (rollData.checkType === 'zweitechance') {
                            rollType = 'zweitechance';
                        }
                        RIFTToast.diceRoll(rollData.player, rollData.total, rollInfo, rollData.success, rollType, rollElement);
                    }
                } catch (e) {
                    console.error('[DiceRoller] Sync failed:', e);
                }
            },
            
            async logRollToFirestore(rollData) {
                if (!this.roomCode) return;
                
                try {
                    // Ensure Firestore is available AND initialized
                    if (typeof firebase === 'undefined' || !firebase.firestore || !firebase.apps || firebase.apps.length === 0) {
                        console.log('[DiceRoller] Firestore not available for logging');
                        return;
                    }
                    
                    const db = firebase.firestore();
                    const diceCollection = db.collection('rooms').doc(this.roomCode).collection('dice');
                    
                    // Build log entry
                    const logEntry = {
                        player: rollData.player || 'Unbekannt',
                        playerId: rollData.playerId || null,
                        color: rollData.color || '#8b5cf6',
                        notation: rollData.notation || '',
                        total: rollData.total || 0,
                        results: rollData.results || [],
                        diceTheme: rollData.diceTheme || 'onyx',
                        secret: rollData.secret || false,
                        critical: rollData.critical || null,
                        label: rollData.label || null,
                        success: rollData.success || null,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        clientTimestamp: rollData.timestamp || Date.now()
                    };
                    
                    await diceCollection.add(logEntry);
                    console.log('[DiceRoller] Roll logged to Firestore');
                    
                } catch (e) {
                    console.warn('[DiceRoller] Firestore log failed:', e);
                    // Don't throw - Firestore logging is optional
                }
            },
            
            showFeedItem(roll) {
                const feed = document.getElementById('diceFeed');
                if (!feed) return;
                
                // Don't show own rolls in feed
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                if (roll.player === userData.name) return;
                
                const item = document.createElement('div');
                let itemClass = 'dice-feed__item';
                if (roll.secret) itemClass += ' secret';
                if (roll.critical === 'success') itemClass += ' critical';
                if (roll.critical === 'failure') itemClass += ' fumble';
                item.className = itemClass;
                
                // Get dice theme color
                const themeColors = {
                    // Basic
                    classic: '#ffffff', blood: '#ff4655', ice: '#00d4ff', nature: '#4caf50', royal: '#9c27b0', gold: '#ffd700',
                    // Elemental
                    fire: '#ff5722', ocean: '#00ffff', toxic: '#39ff14', lava: '#ff4500', frost: '#a8e6ff',
                    storm: '#ffd700', earth: '#d2691e', shadow: '#4a4a4a',
                    // Gems & Metals  
                    ruby: '#ff1744', sapphire: '#2979ff', emerald: '#00e676', amethyst: '#e040fb',
                    diamond: '#ffffff', opal: '#ff9ff3', silver: '#c0c0c0', bronze: '#cd7f32',
                    platinum: '#e5e4e2', copper: '#cd7f32', obsidian: '#2d2d44',
                    // Fantasy
                    dragon: '#ff4500', necro: '#00ff00', fey: '#98fb98', infernal: '#ff0000',
                    celestial: '#ffd700', eldritch: '#7b68ee',
                    // Cosmic & Nature
                    nebula: '#ff6bcb', void: '#8b5cf6', galaxy: '#dda0dd', aurora: '#00ff7f',
                    sunset: '#ff7e5f', bloodmoon: '#dc143c', forest: '#228b22', cherry: '#ffb7c5', autumn: '#ff8c00',
                    // Tech & Retro
                    cyber: '#00ffff', midnight: '#b8c6db', matrix: '#00ff00', hologram: '#00ffff',
                    plasma: '#ff00ff', neon: '#ff1493', synthwave: '#ff6ec7', steampunk: '#b87333', vaporwave: '#ff71ce',
                    // Fun & Special
                    rainbow: '#ff6b6b', candy: '#ff69b4', prism: '#ff0000', bubblegum: '#ff77aa',
                    coral: '#ff7f50', lavender: '#e6e6fa', mint: '#98ff98', peach: '#ffcba4',
                    // Textured
                    marbleWhite: '#f5f5f5', marbleBlack: '#424242', marbleGreen: '#4caf50', marbleRose: '#f48fb1',
                    woodOak: '#8d6e63', woodCherry: '#a1887f', woodEbony: '#2d2d2d',
                    stoneGranite: '#9e9e9e', stoneSandstone: '#d7ccc8',
                    // Glitter
                    glitterGold: '#ffd700', glitterSilver: '#cfd8dc', glitterRose: '#f8bbd9',
                    glitterBlue: '#64b5f6', glitterPurple: '#ce93d8',
                    // Patterns
                    stripesRed: '#ef5350', stripesBlue: '#64b5f6', stripesGreen: '#81c784',
                    polkaDots: '#f8bbd9', polkaBlack: '#424242',
                    checkerRed: '#f44336', checkerGreen: '#66bb6a',
                    camoForest: '#8bc34a', camoDesert: '#d7ccc8', camoArctic: '#eceff1',
                    waveOcean: '#4fc3f7', waveAqua: '#80deea',
                    hexTech: '#42a5f5', hexGold: '#ffc107',
                    dragonScales: '#4caf50', fishScales: '#4dd0e1',
                    // Special Effects
                    starryNight: '#3f51b5', galaxy2: '#9c27b0', thunderstorm: '#78909c', electricBlue: '#29b6f6',
                    // Metallic
                    chrome: '#e0e0e0', titanium: '#78909c', rosegold: '#e8b4a6', brushedSteel: '#bdbdbd',
                    rust: '#e64a19', patina: '#4db6ac',
                    // Food
                    chocolate: '#6d4c41', caramel: '#ffa726', strawberry: '#ef5350', blueberry: '#7986cb',
                    grape: '#ab47bc', lemon: '#ffee58', lime: '#aed581', orange2: '#ffa726',
                    // Seasonal
                    springBlossom: '#f48fb1', summerSun: '#ffc107', autumnLeaves: '#ff7043', winterFrost: '#e1f5fe',
                    christmas: '#2e7d32', halloween: '#ff9800', valentine: '#f48fb1',
                    // Gaming
                    critSuccess: '#ffc107', critFail: '#b71c1c', lucky: '#81c784',
                    cursed: '#7b1fa2', blessed: '#fff59d', ethereal: '#b2ebf2',
                    // Dark
                    charcoal: '#37474f', slate: '#78909c', graphite: '#616161', carbon: '#303030', onyx: '#1a1a1a',
                    // Pastel
                    pastelPink: '#f8bbd9', pastelBlue: '#b3e5fc', pastelGreen: '#c8e6c9',
                    pastelYellow: '#fff9c4', pastelPurple: '#e1bee7', pastelRainbow: '#ffcdd2',
                    // Nature Extended
                    deepSea: '#0277bd', coralReef: '#ff8a65', jungle: '#66bb6a', desert: '#deb887',
                    volcanic: '#ff5722', arctic: '#b3e5fc', tundra: '#b0bec5', swamp: '#7cb342',
                    // Gradients
                    gradSunset: '#ff7e5f', gradOcean: '#00b4db', gradToxic: '#39ff14',
                    gradNebula: '#ff6bcb', gradFire: '#ff5722',
                    gradAbyssal: '#2d1b69', gradVoid: '#3d0066', gradShadow: '#2d2d3d',
                    gradBloodMist: '#660022', gradDeepSea: '#0d3050',
                    // New Textures
                    obsidian: '#2a2a3a', jadeGreen: '#2e8b57', lapisBlue: '#2850a0',
                    meteoriteIron: '#6a6a6a', fossilStone: '#b8a88a', carbonFiber: '#2d2d2d',
                    snakeSkin: '#4a6a4a', chainmailSilver: '#a0a0a8',
                    damascusSteel: '#6a7080', runicStone: '#4a4a6a',
                    nebulaGlow: '#3a2070', veinsGold: '#4a3a1a',
                    circuitBoard: '#007030', boneWhite: '#e8dcc8',
                    parchmentOld: '#d4c4a0', crystalAmethyst: '#9050d0'
                };
                const diceColor = themeColors[roll.diceTheme] || '#ffffff';
                
                const initial = roll.player.charAt(0).toUpperCase();
                const critIndicator = roll.critical === 'success' ? '!' : (roll.critical === 'failure' ? '💀' : '');
                
                // Build roll info line - include label if present
                let rollInfo = roll.notation;
                if (roll.label) {
                    rollInfo = `<span class="dice-feed__label">${roll.label}</span>`;
                }
                
                // Success/failure indicator for skill checks
                let successIndicator = '';
                if (roll.checkType && roll.success !== null && roll.success !== undefined) {
                    successIndicator = roll.success 
                        ? '<span class="dice-feed__success">✓</span>' 
                        : '<span class="dice-feed__failure">✗</span>';
                }
                
                item.innerHTML = `
                    <div class="dice-feed__avatar" style="background: ${roll.color}">${initial}</div>
                    <div class="dice-feed__info">
                        <div class="dice-feed__name" style="color: ${roll.color}">${roll.player}</div>
                        <div class="dice-feed__roll">${rollInfo} <span class="dice-feed__dice-color" style="background: ${diceColor}"></span></div>
                    </div>
                    <div class="dice-feed__result">${roll.secret ? '?' : roll.total}${successIndicator}${critIndicator}</div>
                `;
                
                feed.insertBefore(item, feed.firstChild);
                
                // Trigger effects for critical rolls from other players
                if (roll.critical === 'success' || roll.critical === 'failure') {
                    const arena = document.getElementById('diceArena');
                    if (arena) {
                        arena.classList.add('shake');
                        this.spawnParticles(30);
                        this.showCritFlash(roll.critical);
                        setTimeout(() => arena.classList.remove('shake'), 500);
                    }
                }
                
                // Remove after 10s
                setTimeout(() => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateX(20px)';
                    setTimeout(() => item.remove(), 300);
                }, 10000);
                
                // Keep max 5 items
                while (feed.children.length > 5) {
                    feed.lastChild.remove();
                }
            },
            
            // ========================================
            // DICE VALUE LABELS
            // ========================================
            
            clearDiceLabels() {
                const container = document.getElementById('diceLabels');
                const pulseContainer = document.getElementById('dicePulses');
                if (container) container.innerHTML = '';
                if (pulseContainer) pulseContainer.innerHTML = '';
            },
            
            showDiceLabels(labelValues, d100Count = 0) {
                this.clearDiceLabels();
                
                if (!this.box) return;
                
                const container = document.getElementById('diceLabels');
                const pulseContainer = document.getElementById('dicePulses');
                if (!container) return;
                
                // Clear pulse container
                if (pulseContainer) pulseContainer.innerHTML = '';
                
                // Get screen positions from the library
                const positions = this.box.getDiceScreenPositions();
                if (!positions || positions.length === 0) return;
                
                console.log('[DiceRoller] Dice positions:', positions);
                console.log('[DiceRoller] Label values to display:', labelValues);
                console.log('[DiceRoller] D100 count:', d100Count);
                
                // For D100: We need to match labels to dice by TYPE, not by index
                // because the library may return positions in different order
                // Our labelValues for D100: [tensDisplay, onesDisplay, ...]
                // positions may be: [{type:'d10',...}, {type:'d100',...}] in any order
                
                let tensLabelIdx = 0;  // Index in labelValues for tens values
                let onesLabelIdx = 1;  // Index in labelValues for ones values
                let otherLabelIdx = d100Count * 2;  // Index for non-d100 dice
                
                // Track which label indices we've used
                const usedLabels = new Set();
                
                for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    let value;
                    
                    if (pos.x < 0 || pos.y < 0) continue; // Skip if off-screen
                    
                    // Determine which label value to use based on dice type
                    if (d100Count > 0 && pos.type === 'd100') {
                        // This is the TENS die (00, 10, 20... 90)
                        value = labelValues[tensLabelIdx];
                        usedLabels.add(tensLabelIdx);
                        tensLabelIdx += 2; // Next d100 pair
                    } else if (d100Count > 0 && pos.type === 'd10') {
                        // This is the ONES die (0-9)
                        value = labelValues[onesLabelIdx];
                        usedLabels.add(onesLabelIdx);
                        onesLabelIdx += 2; // Next d100 pair
                    } else {
                        // Regular die
                        while (usedLabels.has(otherLabelIdx) && otherLabelIdx < labelValues.length) {
                            otherLabelIdx++;
                        }
                        value = labelValues[otherLabelIdx];
                        usedLabels.add(otherLabelIdx);
                        otherLabelIdx++;
                    }
                    
                    if (value === undefined) continue;
                    
                    // RIFT: Dauerhafter Glow/Pulse-Effekt wenn aktiviert
                    if (pulseContainer && (this.currentGlow || this.currentPulse)) {
                        // Theme-Farbe direkt nutzen (ist ein Hex-String)
                        const glowColor = this.themeColors[this.currentTheme] || '#ffffff';
                        
                        if (this.currentGlow && !this.currentPulse) {
                            // Nur Glow: statischer Schein
                            const glow = document.createElement('div');
                            glow.className = 'dice-glow-effect';
                            glow.style.left = `${pos.x}px`;
                            glow.style.top = `${pos.y + 20}px`;
                            glow.style.setProperty('--glow-color', glowColor);
                            pulseContainer.appendChild(glow);
                        }
                        
                        if (this.currentPulse) {
                            // Pulse: expandierende Ringe in Endlosschleife
                            const pulseEffect = document.createElement('div');
                            pulseEffect.className = 'dice-pulse-effect';
                            pulseEffect.style.left = `${pos.x}px`;
                            pulseEffect.style.top = `${pos.y + 20}px`;
                            pulseEffect.style.setProperty('--glow-color', glowColor);
                            pulseContainer.appendChild(pulseEffect);
                        }
                    }
                    
                    // Create pulse effect in separate container (UNDER dice) - einmaliger Landing-Effekt
                    if (pulseContainer && !this.currentPulse) {
                        for (let r = 0; r < 4; r++) {
                            const pulse = document.createElement('div');
                            pulse.className = `dice-pulse dice-pulse--${pos.type}`;
                            pulse.style.left = `${pos.x}px`;
                            pulse.style.top = `${pos.y + 20}px`;
                            pulse.style.animationDelay = `${i * 0.08 + r * 0.1}s`;
                            pulseContainer.appendChild(pulse);
                        }
                    }
                    
                    // Create label
                    const label = document.createElement('div');
                    label.className = `dice-label dice-label--${pos.type}`;
                    
                    // Check for critical (nat 20 or nat 1 on d20)
                    if (pos.type === 'd20' && value === 20) {
                        label.classList.add('dice-label--crit-success');
                    } else if (pos.type === 'd20' && value === 1) {
                        label.classList.add('dice-label--crit-failure');
                    }
                    
                    // Format value for display
                    let displayValue = value;
                    if (pos.type === 'd100' && value === 0) {
                        // D100 Tens die: 0 becomes "00"
                        displayValue = '00';
                    }
                    
                    label.textContent = displayValue;
                    label.style.left = `${pos.x}px`;
                    label.style.top = `${pos.y}px`;
                    label.style.animationDelay = `${i * 0.1}s`;
                    
                    container.appendChild(label);
                }
            },
            
            // ========================================
            // PARTICLES
            // ========================================
            
            spawnParticles(count = 20) {
                const container = document.getElementById('particlesContainer');
                if (!container) return;
                
                const colors = ['#FF4655', '#FF6B6B', '#FFE66D', '#4ECDC4', '#45B7D1', '#DDA0DD'];
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'dice-particle';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 80 + Math.random() * 120;
                    
                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                    particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                    particle.style.width = particle.style.height = `${5 + Math.random() * 8}px`;
                    
                    container.appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }
            },
            
            // ========================================
            // UI
            // ========================================
            
            updateUI() {
                // Update button counts
                ['d4', 'd6', 'd8', 'd10', 'd12', 'd20', 'd100'].forEach(type => {
                    const countEl = document.getElementById(`count-${type}`);
                    const btn = document.querySelector(`.dice-btn[data-dice="${type}"]`);
                    const count = this.currentDice[type] || 0;
                    
                    if (countEl) countEl.textContent = count;
                    if (btn) {
                        const hadCount = btn.classList.contains('has-count');
                        btn.classList.toggle('has-count', count > 0);
                        
                        // Start/stop particles
                        if (count > 0 && !hadCount) {
                            this.startParticles(btn);
                        } else if (count === 0 && hadCount) {
                            this.stopParticles(btn);
                        }
                    }
                });
                
                // Update roll button
                const btn = document.getElementById('rollBtn');
                const hasInput = document.getElementById('notationInput').value.trim().length > 0;
                const hasDice = Object.values(this.currentDice).some(c => c > 0);
                btn.disabled = !hasInput && !hasDice;
            },
            
            // Partikel-System
            particleIntervals: {},
            
            startParticles(btn) {
                const container = btn.querySelector('.dice-btn__particles');
                if (!container) return;
                
                const type = btn.dataset.dice;
                
                // Spawn particles mit variablem Timing
                const spawnLoop = () => {
                    if (!btn.classList.contains('has-count')) {
                        this.stopParticles(btn);
                        return;
                    }
                    this.spawnParticle(container);
                    
                    // Nächster Spawn in 250-500ms
                    const nextSpawn = 250 + Math.random() * 250;
                    this.particleIntervals[type] = setTimeout(spawnLoop, nextSpawn);
                };
                
                this.particleIntervals[type] = setTimeout(spawnLoop, 100);
                
                // Spawn first few immediately
                this.spawnParticle(container);
                setTimeout(() => this.spawnParticle(container), 80);
                setTimeout(() => this.spawnParticle(container), 180);
            },
            
            stopParticles(btn) {
                const type = btn.dataset.dice;
                if (this.particleIntervals[type]) {
                    clearTimeout(this.particleIntervals[type]);
                    delete this.particleIntervals[type];
                }
            },
            
            spawnParticle(container) {
                const particle = document.createElement('div');
                particle.className = 'dice-btn__particle';
                
                // Random position innerhalb des Containers (über dem Counter)
                const xPos = Math.random() * 35; // 0-35px von links im Container
                const size = 2 + Math.random() * 2.5; // 2-4.5px
                const duration = 1.8 + Math.random() * 1.2; // 1.8-3s
                const delay = Math.random() * 0.15;
                const drift = -10 + Math.random() * 20; // -10 bis +10px seitlich
                
                particle.style.cssText = `
                    left: ${xPos}px;
                    top: 0;
                    width: ${size}px;
                    height: ${size}px;
                    --drift: ${drift}px;
                    animation: particleFloat ${duration}s ease-out ${delay}s forwards;
                `;
                
                container.appendChild(particle);
                
                // Remove after animation
                setTimeout(() => particle.remove(), (duration + delay) * 1000 + 100);
            },
            
            // ========================================
            // HISTORY
            // ========================================
            
            addToHistory(roll) {
                this.history.unshift(roll);
                if (this.history.length > 50) this.history = this.history.slice(0, 50);
                this.saveHistory();
                this.renderHistory();
                
                // Update Firebase stats if connected (only for own rolls, not remote)
                if (this.statsRef && !roll.isRemote) {
                    this.updateFirebaseStats(roll);
                } else {
                    this.updateStats();
                }
            },
            
            // Update room-wide stats in Firebase
            updateFirebaseStats(roll) {
                if (!this.statsRef) return;
                
                this.statsRef.transaction((currentStats) => {
                    if (!currentStats) {
                        currentStats = {
                            totalRolls: 0,
                            criticalSuccesses: 0,
                            criticalFailures: 0,
                            sumOfTotals: 0,
                            maxRoll: null,
                            minRoll: null
                        };
                    }
                    
                    currentStats.totalRolls = (currentStats.totalRolls || 0) + 1;
                    currentStats.sumOfTotals = (currentStats.sumOfTotals || 0) + roll.total;
                    
                    if (roll.critical === 'success') {
                        currentStats.criticalSuccesses = (currentStats.criticalSuccesses || 0) + 1;
                    }
                    if (roll.critical === 'failure') {
                        currentStats.criticalFailures = (currentStats.criticalFailures || 0) + 1;
                    }
                    
                    if (currentStats.maxRoll === null || roll.total > currentStats.maxRoll) {
                        currentStats.maxRoll = roll.total;
                    }
                    if (currentStats.minRoll === null || roll.total < currentStats.minRoll) {
                        currentStats.minRoll = roll.total;
                    }
                    
                    return currentStats;
                });
            },
            
            // Update UI with room stats
            updateStatsDisplay(stats) {
                const totalEl = document.getElementById('statTotal');
                const avgEl = document.getElementById('statAvg');
                const critsEl = document.getElementById('statCrits');
                const fumblesEl = document.getElementById('statFumbles');
                const maxEl = document.getElementById('statMax');
                const minEl = document.getElementById('statMin');
                
                if (!totalEl) return;
                
                totalEl.textContent = stats.totalRolls || 0;
                
                if (stats.totalRolls === 0) {
                    avgEl.textContent = '-';
                    critsEl.textContent = '0';
                    fumblesEl.textContent = '0';
                    maxEl.textContent = '-';
                    minEl.textContent = '-';
                    return;
                }
                
                const avg = (stats.sumOfTotals / stats.totalRolls).toFixed(1);
                avgEl.textContent = avg;
                critsEl.textContent = stats.criticalSuccesses || 0;
                fumblesEl.textContent = stats.criticalFailures || 0;
                maxEl.textContent = stats.maxRoll !== null ? stats.maxRoll : '-';
                minEl.textContent = stats.minRoll !== null ? stats.minRoll : '-';
            },
            
            // Reset room stats
            resetStats() {
                if (this.statsRef) {
                    // Reset Firebase stats
                    this.statsRef.set({
                        totalRolls: 0,
                        criticalSuccesses: 0,
                        criticalFailures: 0,
                        sumOfTotals: 0,
                        maxRoll: null,
                        minRoll: null
                    });
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.show('Statistiken zurückgesetzt', 'success');
                    }
                } else {
                    // Reset local stats
                    this.history = [];
                    this.saveHistory();
                    this.renderHistory();
                    this.updateStats();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.show('Lokale Statistiken zurückgesetzt', 'success');
                    }
                }
            },
            
            renderHistory() {
                const list = document.getElementById('historyList');
                if (!list) return;
                
                if (this.history.length === 0) {
                    list.innerHTML = '<div class="dice-history__empty">Noch keine Würfe</div>';
                    return;
                }
                
                list.innerHTML = this.history.slice(0, 15).map(roll => {
                    const time = new Date(roll.timestamp);
                    const timeStr = time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    let critClass = '';
                    let critIndicator = '';
                    if (roll.critical === 'success') {
                        critClass = ' dice-history__item--crit';
                        critIndicator = '!';
                    } else if (roll.critical === 'failure') {
                        critClass = ' dice-history__item--fumble';
                        critIndicator = '💀';
                    } else if (roll.critical === true) {
                        // Legacy support
                        critClass = ' dice-history__item--crit';
                        critIndicator = '!';
                    }
                    const playerName = roll.player || 'Spieler';
                    const playerColor = roll.color || '#FF4655';
                    
                    return `
                        <div class="dice-history__item${critClass}" title="${playerName} • ${roll.notation} • ${timeStr}">
                            <div class="dice-history__player" style="color: ${playerColor}">${playerName}</div>
                            <div class="dice-history__value">${roll.total}${critIndicator}</div>
                            <div class="dice-history__notation">${roll.notation}</div>
                        </div>
                    `;
                }).join('');
            },
            
            // ========================================
            // PERSISTENCE
            // ========================================
            
            loadSettings() {
                // Sound
                this.soundEnabled = localStorage.getItem('rift_dice_sound') !== 'false';
                window.RIFT_DICE_SOUND = this.soundEnabled;
                document.getElementById('soundToggle')?.classList.toggle('active', this.soundEnabled);
                document.getElementById('soundToggle2')?.classList.toggle('active', this.soundEnabled);
            },
            
            saveHistory() {
                localStorage.setItem('rift_dice_history', JSON.stringify(this.history));
            },
            
            loadHistory() {
                try {
                    this.history = JSON.parse(localStorage.getItem('rift_dice_history') || '[]');
                } catch { this.history = []; }
                this.renderHistory();
                this.updateStats();
            },
            
            clearHistory() {
                this.history = [];
                this.saveHistory();
                this.renderHistory();
                this.updateStats();
                if (typeof showToast === 'function') showToast('Verlauf gelöscht', 'info');
            },
            
            statsPopupOpen: false,
            hotkeysPopupOpen: false,
            
            toggleStatsPopup() {
                this.statsPopupOpen = !this.statsPopupOpen;
                const popup = document.getElementById('statsPopup');
                const btn = document.getElementById('statsBtn');
                const overlay = document.getElementById('diceSettingsOverlay');
                
                // Close other popups
                if (this.statsPopupOpen) {
                    this.closeAllPopups('stats');
                }
                
                if (this.statsPopupOpen) {
                    popup?.classList.add('open');
                    btn?.classList.add('active');
                    overlay?.classList.add('open');
                    this.updateStats();
                } else {
                    popup?.classList.remove('open');
                    btn?.classList.remove('active');
                    overlay?.classList.remove('open');
                }
            },
            
            toggleHotkeysPopup() {
                this.hotkeysPopupOpen = !this.hotkeysPopupOpen;
                const popup = document.getElementById('hotkeysPopup');
                const btn = document.getElementById('hotkeysBtn');
                const overlay = document.getElementById('diceSettingsOverlay');
                
                // Close other popups
                if (this.hotkeysPopupOpen) {
                    this.closeAllPopups('hotkeys');
                }
                
                if (this.hotkeysPopupOpen) {
                    popup?.classList.add('open');
                    btn?.classList.add('active');
                    overlay?.classList.add('open');
                } else {
                    popup?.classList.remove('open');
                    btn?.classList.remove('active');
                    overlay?.classList.remove('open');
                }
            },
            
            closeAllPopups(except = null) {
                if (except !== 'stats') {
                    this.statsPopupOpen = false;
                    document.getElementById('statsPopup')?.classList.remove('open');
                    document.getElementById('statsBtn')?.classList.remove('active');
                }
                if (except !== 'hotkeys') {
                    this.hotkeysPopupOpen = false;
                    document.getElementById('hotkeysPopup')?.classList.remove('open');
                    document.getElementById('hotkeysBtn')?.classList.remove('active');
                }
                if (except !== 'settings') {
                    document.getElementById('settingsPopup')?.classList.remove('open');
                    document.getElementById('settingsBtn')?.classList.remove('active');
                    // RIFT: Preview schließen
                    document.getElementById('settingsPreviewContainer')?.classList.remove('open');
                }
                // Only close overlay if ALL popups are closed
                if (!except) {
                    document.getElementById('diceSettingsOverlay')?.classList.remove('open');
                    // RIFT: Body scroll lock entfernen und Position wiederherstellen
                    document.body.classList.remove('popup-open');
                    document.body.style.top = '';
                    if (this.savedScrollY !== undefined) {
                        window.scrollTo(0, this.savedScrollY);
                    }
                }
            },
            
            updateStats() {
                // If we have room stats from Firebase, use those instead
                if (this.roomStats) {
                    this.updateStatsDisplay(this.roomStats);
                    return;
                }
                
                // Fallback to local history stats
                const totalEl = document.getElementById('statTotal');
                const avgEl = document.getElementById('statAvg');
                const critsEl = document.getElementById('statCrits');
                const fumblesEl = document.getElementById('statFumbles');
                const maxEl = document.getElementById('statMax');
                const minEl = document.getElementById('statMin');
                
                if (!totalEl) return;
                
                totalEl.textContent = this.history.length;
                
                if (this.history.length === 0) {
                    avgEl.textContent = '-';
                    critsEl.textContent = '0';
                    fumblesEl.textContent = '0';
                    maxEl.textContent = '-';
                    minEl.textContent = '-';
                    return;
                }
                
                const totals = this.history.map(r => r.total);
                const avg = (totals.reduce((a, b) => a + b, 0) / totals.length).toFixed(1);
                const crits = this.history.filter(r => r.critical === 'success').length;
                const fumbles = this.history.filter(r => r.critical === 'failure').length;
                const max = Math.max(...totals);
                const min = Math.min(...totals);
                
                avgEl.textContent = avg;
                critsEl.textContent = crits;
                fumblesEl.textContent = fumbles;
                maxEl.textContent = max;
                minEl.textContent = min;
            },
            
            exportHistory() {
                if (this.history.length === 0) {
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Keine Würfe zum Exportieren');
                    }
                    return;
                }
                
                // Build text format
                const lines = ['RIFT Würfel-Protokoll', '=' .repeat(40), ''];
                
                const now = new Date();
                lines.push(`Exportiert: ${now.toLocaleDateString('de-DE')} ${now.toLocaleTimeString('de-DE')}`);
                lines.push(`Anzahl Würfe: ${this.history.length}`);
                lines.push('');
                lines.push('-'.repeat(40));
                lines.push('');
                
                this.history.forEach((roll, i) => {
                    const time = new Date(roll.timestamp).toLocaleTimeString('de-DE');
                    const critMarker = roll.critical === 'success' ? ' ⭐ KRITISCH!' : 
                                       roll.critical === 'failure' ? ' 💀 PATZER!' : '';
                    lines.push(`[${time}] ${roll.player}: ${roll.notation} = ${roll.total}${critMarker}`);
                });
                
                lines.push('');
                lines.push('-'.repeat(40));
                
                // Calculate stats
                const totals = this.history.map(r => r.total);
                const avg = (totals.reduce((a, b) => a + b, 0) / totals.length).toFixed(1);
                const max = Math.max(...totals);
                const min = Math.min(...totals);
                const crits = this.history.filter(r => r.critical === 'success').length;
                const fumbles = this.history.filter(r => r.critical === 'failure').length;
                
                lines.push('');
                lines.push('STATISTIK');
                lines.push(`Durchschnitt: ${avg}`);
                lines.push(`Maximum: ${max}`);
                lines.push(`Minimum: ${min}`);
                lines.push(`Kritische Erfolge: ${crits}`);
                lines.push(`Kritische Fehlschläge: ${fumbles}`);
                
                // Create download
                const text = lines.join('\n');
                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rift-wuerfel-${now.toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success('Verlauf exportiert');
                }
            }
        };
        
        // Global function for back button
        function goBackToSheet() {
            if (DiceRoller.returnUrl) {
                let url = DiceRoller.returnUrl;
                
                // Only add essential params for Zweite Chance (to mark dice as used)
                if (DiceRoller.lastCheckResult?.zweiteChance) {
                    const r = DiceRoller.lastCheckResult;
                    const params = new URLSearchParams();
                    params.set('zweiteChance', 'true');
                    params.set('diceIndex', r.diceIndex);
                    params.set('success', r.success);
                    
                    const separator = url.includes('?') ? '&' : '?';
                    url += separator + params.toString();
                }
                
                window.location.href = url;
            }
        }
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        initUnifiedLayout();
        
        // Init after layout is ready
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                DiceRoller.init();
            });
        });
        
        // Update UI when notation input changes
        document.getElementById('notationInput')?.addEventListener('input', (e) => {
            // Parse as user types
            DiceRoller.parseDiceFromNotation(e.target.value);
        });
        
        // ========================================
        // DICE PREVIEW - 3D rotating dice in buttons
        // ========================================
        const DicePreview = {
            previews: [],
            animationId: null,
            
            init() {
                console.log('DicePreview init starting...');
                
                // Check if THREE is available
                if (typeof THREE === 'undefined') {
                    console.error('THREE.js not loaded!');
                    return;
                }
                
                const canvases = document.querySelectorAll('.dice-btn__canvas');
                console.log('Found canvases:', canvases.length);
                
                canvases.forEach((canvas, index) => {
                    const type = canvas.dataset.type;
                    console.log('Creating preview for:', type);
                    try {
                        this.createPreview(canvas, type);
                    } catch(e) {
                        console.error('Error creating preview for ' + type, e);
                    }
                });
                
                if (this.previews.length > 0) {
                    this.animate();
                    console.log('Animation started with', this.previews.length, 'previews');
                }
            },
            
            createPreview(canvas, type) {
                const size = 100;
                
                // Set canvas size
                canvas.width = size * 2;
                canvas.height = size * 2;
                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
                canvas.style.display = 'block';
                
                // Create renderer
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true, 
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                renderer.setSize(size * 2, size * 2);
                renderer.setPixelRatio(1);
                renderer.setClearColor(0x000000, 0);
                renderer.sortObjects = true;
                
                // Create scene
                const scene = new THREE.Scene();
                
                // Create camera - adjusted for DICE library scale
                const camera = new THREE.PerspectiveCamera(28, 1, 1, 1000);
                const cameraDistance = type === 'd100' ? 220 : 180;
                camera.position.set(0, 0, cameraDistance);
                camera.lookAt(0, 0, 0);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                directionalLight.position.set(50, 50, 80);
                scene.add(directionalLight);
                
                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-30, -30, -50);
                scene.add(backLight);
                
                let mesh;
                let isD100 = type === 'd100';
                
                // Use DICE library to create real dice with proper face textures
                if (typeof DICE !== 'undefined' && DICE.createPreviewDice) {
                    if (isD100) {
                        // D100: Two dice - tens (d100) and ones (d10)
                        mesh = new THREE.Group();
                        
                        const tensDice = DICE.createPreviewDice('d100', 0.7);
                        const onesDice = DICE.createPreviewDice('d10', 0.7);
                        
                        if (tensDice && onesDice) {
                            tensDice.position.x = -25;
                            onesDice.position.x = 25;
                            
                            // Random starting rotation
                            tensDice.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI);
                            onesDice.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI);
                            
                            mesh.add(tensDice);
                            mesh.add(onesDice);
                            mesh.userData.dice = [tensDice, onesDice];
                        }
                    } else {
                        mesh = DICE.createPreviewDice(type, 0.8);
                        if (mesh) {
                            // Random starting rotation
                            mesh.rotation.x = Math.random() * Math.PI * 2;
                            mesh.rotation.y = Math.random() * Math.PI * 2;
                            mesh.rotation.z = Math.random() * Math.PI;
                        }
                    }
                }
                
                // Fallback to simple geometry if DICE not available
                if (!mesh) {
                    console.warn('DICE.createPreviewDice not available, using fallback');
                    const geometry = this.createGeometry(type);
                    const material = this.createThemedMaterial(type);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI);
                }
                
                scene.add(mesh);
                
                // Store preview data
                this.previews.push({
                    renderer,
                    scene,
                    camera,
                    mesh,
                    type,
                    isD100,
                    rotationSpeed: {
                        x: 0.0005 + Math.random() * 0.0005,
                        y: 0.0008 + Math.random() * 0.0005,
                        z: 0.0003 + Math.random() * 0.0003
                    }
                });
                
                // Initial render
                renderer.render(scene, camera);
            },
            
            createGeometry(type) {
                switch(type) {
                    case 'd4':
                        return new THREE.TetrahedronGeometry(1.1);
                    case 'd6':
                        return new THREE.BoxGeometry(1.0, 1.0, 1.0);
                    case 'd8':
                        return new THREE.OctahedronGeometry(0.95);
                    case 'd10':
                        return this.createD10Geometry(0.85);
                    case 'd100':
                        return null; // Handled separately
                    case 'd12':
                        return new THREE.DodecahedronGeometry(0.95);
                    case 'd20':
                        return new THREE.IcosahedronGeometry(1.0);
                    default:
                        return new THREE.BoxGeometry(1.0, 1.0, 1.0);
                }
            },
            
            // Special handling for D100 (two D10s)
            createD100Group() {
                const group = new THREE.Group();
                
                // Left D10 (tens: 00) - mit "00" Textur
                const material1 = this.createThemedMaterial('d10_tens');
                const geom1 = this.createD10Geometry(0.7);
                const mesh1 = new THREE.Mesh(geom1, material1);
                mesh1.position.x = -0.6;
                mesh1.renderOrder = 0;
                
                // Add edges
                const edges1 = new THREE.EdgesGeometry(geom1, 1);
                const lineMat = new THREE.LineBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.15,
                    depthTest: true
                });
                const lines1 = new THREE.LineSegments(edges1, lineMat);
                lines1.renderOrder = 1;
                mesh1.add(lines1);
                
                // Right D10 (ones: 0) - mit "0" Textur
                const material2 = this.createThemedMaterial('d10');
                const geom2 = this.createD10Geometry(0.7);
                const mesh2 = new THREE.Mesh(geom2, material2);
                mesh2.position.x = 0.6;
                mesh2.renderOrder = 0;
                
                // Add edges
                const edges2 = new THREE.EdgesGeometry(geom2, 1);
                const lines2 = new THREE.LineSegments(edges2, lineMat.clone());
                lines2.renderOrder = 1;
                mesh2.add(lines2);
                
                // Different starting rotations
                mesh1.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                mesh2.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                
                group.add(mesh1);
                group.add(mesh2);
                
                // Store references for individual rotation
                group.userData.dice = [mesh1, mesh2];
                
                return group;
            },
            
            // D10 - Pentagonal Bipyramid
            createD10Geometry(radius) {
                const geometry = new THREE.Geometry();
                const sides = 5;
                const h = radius * 1.3;
                
                // Top vertex (index 0)
                geometry.vertices.push(new THREE.Vector3(0, h, 0));
                
                // Middle ring (indices 1-5)
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    geometry.vertices.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }
                
                // Bottom vertex (index 6)
                geometry.vertices.push(new THREE.Vector3(0, -h, 0));
                
                // Top faces (counter-clockwise when viewed from outside)
                for (let i = 0; i < sides; i++) {
                    const next = (i + 1) % sides;
                    geometry.faces.push(new THREE.Face3(0, 1 + next, 1 + i));
                }
                
                // Bottom faces (counter-clockwise when viewed from outside)
                for (let i = 0; i < sides; i++) {
                    const next = (i + 1) % sides;
                    geometry.faces.push(new THREE.Face3(6, 1 + i, 1 + next));
                }
                
                geometry.computeFaceNormals();
                geometry.computeVertexNormals();
                
                return geometry;
            },
            
            // Get current theme color for preview dice
            getThemeColor() {
                // Try to get color from DiceRoller's current theme
                if (typeof DiceRoller !== 'undefined' && DiceRoller.currentDiceColor) {
                    // Convert hex string to number
                    const hex = DiceRoller.currentDiceColor.replace('#', '');
                    return parseInt(hex, 16);
                }
                // Default: nice purple/violet color
                return 0x8B5CF6;
            },
            
            // Get full theme data including gradient
            getThemeData() {
                if (typeof DiceRoller !== 'undefined' && DiceRoller.currentTheme && DiceRoller.themeColors) {
                    return DiceRoller.themeColors[DiceRoller.currentTheme] || null;
                }
                return null;
            },
            
            // Get typical number for each dice type
            getDiceNumber(type) {
                const numbers = {
                    'd4': '4',
                    'd6': '6', 
                    'd8': '8',
                    'd10': '0',
                    'd10_tens': '00',
                    'd12': '12',
                    'd20': '20',
                    'd100': '' // D100 hat zwei Würfel
                };
                return numbers[type] || '';
            },
            
            // Determine if text should be dark based on background brightness
            getTextColor(colors) {
                if (!colors || !colors[0]) return '#ffffff';
                const hex = colors[0].replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                return brightness > 160 ? '#1a1a1a' : '#ffffff';
            },
            
            // Apply texture overlay (stripes, dots, marble, etc.)
            applyTexture(ctx, width, height, texture, colors) {
                ctx.save();
                
                switch(texture) {
                    case 'stripes':
                        ctx.globalCompositeOperation = 'overlay';
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = width / 15;
                        for (let i = -height; i < width + height; i += width / 8) {
                            ctx.beginPath();
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i + height, height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'dots':
                        ctx.globalCompositeOperation = 'overlay';
                        const dotSize = width / 25;
                        const spacing = width / 10;
                        for (let x = spacing/2; x < width; x += spacing) {
                            for (let y = spacing/2; y < height; y += spacing) {
                                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                                ctx.beginPath();
                                ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    case 'noise':
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const data = imageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                            const noise = (Math.random() - 0.5) * 45;
                            data[i] = Math.min(255, Math.max(0, data[i] + noise));
                            data[i+1] = Math.min(255, Math.max(0, data[i+1] + noise));
                            data[i+2] = Math.min(255, Math.max(0, data[i+2] + noise));
                        }
                        ctx.putImageData(imageData, 0, 0);
                        break;
                        
                    case 'marble':
                        for (let v = 0; v < 12; v++) {
                            ctx.globalCompositeOperation = 'overlay';
                            ctx.strokeStyle = v % 2 === 0 ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.15)';
                            ctx.lineWidth = 1 + Math.random() * 3;
                            ctx.beginPath();
                            let startX = Math.random() * width;
                            let startY = Math.random() * height;
                            ctx.moveTo(startX, startY);
                            for (let j = 0; j < 6; j++) {
                                const cpX = startX + (Math.random() - 0.5) * width * 0.5;
                                const cpY = startY + (Math.random() - 0.5) * height * 0.5;
                                const endX = startX + (Math.random() - 0.5) * width * 0.7;
                                const endY = startY + (Math.random() - 0.5) * height * 0.7;
                                ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                                startX = endX; startY = endY;
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'sparkle':
                        ctx.globalCompositeOperation = 'screen';
                        for (let i = 0; i < 45; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const size = Math.random() * 4 + 1.5;
                            const alpha = Math.random() * 0.7 + 0.2;
                            ctx.fillStyle = 'rgba(255,255,255,' + alpha + ')';
                            ctx.beginPath();
                            ctx.moveTo(x, y - size);
                            ctx.lineTo(x + size * 0.25, y - size * 0.25);
                            ctx.lineTo(x + size, y);
                            ctx.lineTo(x + size * 0.25, y + size * 0.25);
                            ctx.lineTo(x, y + size);
                            ctx.lineTo(x - size * 0.25, y + size * 0.25);
                            ctx.lineTo(x - size, y);
                            ctx.lineTo(x - size * 0.25, y - size * 0.25);
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                        
                    case 'cracks':
                        ctx.globalCompositeOperation = 'overlay';
                        for (let c = 0; c < 8; c++) {
                            ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            let cx = Math.random() * width;
                            let cy = Math.random() * height;
                            ctx.moveTo(cx, cy);
                            for (let s = 0; s < 5; s++) {
                                cx += (Math.random() - 0.5) * width * 0.25;
                                cy += (Math.random() - 0.5) * height * 0.25;
                                ctx.lineTo(cx, cy);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'wood':
                        ctx.globalCompositeOperation = 'overlay';
                        for (let r = 0; r < 15; r++) {
                            ctx.strokeStyle = r % 2 === 0 ? 'rgba(139,90,43,0.15)' : 'rgba(0,0,0,0.08)';
                            ctx.lineWidth = 2 + Math.random() * 4;
                            ctx.beginPath();
                            const yPos = (r / 15) * height + (Math.random() - 0.5) * 10;
                            ctx.moveTo(0, yPos);
                            for (let x = 0; x < width; x += 20) {
                                ctx.lineTo(x, yPos + Math.sin(x * 0.05) * 5);
                            }
                            ctx.stroke();
                        }
                        break;
                        
                    case 'hexagons':
                        ctx.globalCompositeOperation = 'overlay';
                        const hexSize = width / 8;
                        for (let row = 0; row < height / hexSize + 2; row++) {
                            for (let col = 0; col < width / hexSize + 2; col++) {
                                const cx = col * hexSize * 1.5 + (row % 2) * hexSize * 0.75;
                                const cy = row * hexSize * 0.866;
                                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (i / 6) * Math.PI * 2;
                                    const hx = cx + Math.cos(angle) * hexSize * 0.45;
                                    const hy = cy + Math.sin(angle) * hexSize * 0.45;
                                    if (i === 0) ctx.moveTo(hx, hy);
                                    else ctx.lineTo(hx, hy);
                                }
                                ctx.closePath();
                                ctx.stroke();
                            }
                        }
                        break;
                        
                    case 'scales':
                        ctx.globalCompositeOperation = 'overlay';
                        const scaleSize = width / 10;
                        for (let row = 0; row < height / scaleSize + 2; row++) {
                            for (let col = -1; col < width / scaleSize + 2; col++) {
                                const scx = col * scaleSize + (row % 2) * scaleSize / 2;
                                const scy = row * scaleSize * 0.65;
                                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                                ctx.beginPath();
                                ctx.arc(scx, scy, scaleSize * 0.55, 0, Math.PI);
                                ctx.fill();
                                ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                            }
                        }
                        break;
                }
                
                ctx.restore();
            },
            
            // Create a gradient texture for the dice with optional number
            createGradientTexture(themeData, diceType) {
                const size = 256;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                if (!themeData || !themeData.gradient) {
                    // Fallback: solid color
                    const color = themeData?.accent || '#8B5CF6';
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, size, size);
                } else {
                    const gradient = themeData.gradient;
                    let grd;
                    
                    if (gradient.type === 'radial') {
                        grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    } else {
                        // Linear gradient diagonal
                        grd = ctx.createLinearGradient(0, 0, size, size);
                    }
                    
                    const colors = gradient.colors || ['#ffffff', '#888888'];
                    const stops = gradient.stops || colors.map((_, i, arr) => i / (arr.length - 1));
                    colors.forEach((color, i) => {
                        grd.addColorStop(stops[i] || i / (colors.length - 1), color);
                    });
                    
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, size, size);
                    
                    // Apply texture if present
                    if (gradient.texture) {
                        this.applyTexture(ctx, size, size, gradient.texture, colors);
                    }
                    
                    // Add subtle noise for depth
                    ctx.globalAlpha = 0.02;
                    for (let i = 0; i < 500; i++) {
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#000000';
                        ctx.fillRect(x, y, 1, 1);
                    }
                    ctx.globalAlpha = 1;
                    
                    // Add number if diceType provided
                    if (diceType) {
                        const number = this.getDiceNumber(diceType);
                        if (number) {
                            const textColor = this.getTextColor(colors);
                            ctx.font = 'bold ' + (size * 0.5) + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // Text shadow for depth
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.fillText(number, size/2 + 2, size/2 + 2);
                            
                            // Main text
                            ctx.fillStyle = textColor;
                            ctx.fillText(number, size/2, size/2);
                            
                            // Underline for 6 and 9
                            if (number === '6' || number === '9') {
                                ctx.fillText('.', size/2 + size*0.2, size/2);
                            }
                        }
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            },
            
            // Create material with gradient texture
            createThemedMaterial(diceType) {
                const themeData = this.getThemeData();
                const texture = this.createGradientTexture(themeData, diceType);
                
                return new THREE.MeshPhongMaterial({
                    map: texture,
                    color: 0xffffff,
                    shininess: 80,
                    specular: 0x333333,
                    shading: THREE.FlatShading,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });
            },
            
            // Update all preview dice when theme changes - recreate meshes with new materials
            updateColors() {
                if (typeof DICE === 'undefined' || !DICE.createPreviewDice) {
                    console.warn('DICE.createPreviewDice not available for updateColors');
                    return;
                }
                
                // Tell DICE library to refresh materials (clears cache)
                if (DICE.refreshPreviewMaterials) {
                    DICE.refreshPreviewMaterials();
                }
                
                this.previews.forEach(preview => {
                    // Remove old mesh from scene
                    preview.scene.remove(preview.mesh);
                    
                    // Create new mesh with updated colors
                    let newMesh;
                    
                    if (preview.isD100) {
                        newMesh = new THREE.Group();
                        const tensDice = DICE.createPreviewDice('d100', 0.7);
                        const onesDice = DICE.createPreviewDice('d10', 0.7);
                        
                        if (tensDice && onesDice) {
                            tensDice.position.x = -25;
                            onesDice.position.x = 25;
                            
                            // Keep same rotation
                            if (preview.mesh.userData.dice) {
                                tensDice.rotation.copy(preview.mesh.userData.dice[0].rotation);
                                onesDice.rotation.copy(preview.mesh.userData.dice[1].rotation);
                            }
                            
                            newMesh.add(tensDice);
                            newMesh.add(onesDice);
                            newMesh.userData.dice = [tensDice, onesDice];
                        }
                    } else {
                        newMesh = DICE.createPreviewDice(preview.type, 0.8);
                        if (newMesh && preview.mesh) {
                            // Keep same rotation
                            newMesh.rotation.copy(preview.mesh.rotation);
                        }
                    }
                    
                    if (newMesh) {
                        preview.scene.add(newMesh);
                        preview.mesh = newMesh;
                    }
                });
                
                // RIFT: Update Settings Preview too
                this.updateSettingsPreview();
            },
            
            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                this.previews.forEach(preview => {
                    if (preview.isD100 && preview.mesh.userData.dice) {
                        // D100: Rotate each die independently
                        preview.mesh.userData.dice.forEach((die, i) => {
                            const speed = i === 0 ? 1 : 1.3; // Slightly different speeds
                            die.rotation.x += preview.rotationSpeed.x * speed;
                            die.rotation.y += preview.rotationSpeed.y * speed;
                            die.rotation.z += preview.rotationSpeed.z * speed;
                        });
                    } else {
                        // Normal dice
                        preview.mesh.rotation.x += preview.rotationSpeed.x;
                        preview.mesh.rotation.y += preview.rotationSpeed.y;
                        preview.mesh.rotation.z += preview.rotationSpeed.z;
                    }
                    preview.renderer.render(preview.scene, preview.camera);
                });
                
                // RIFT: Settings Preview Animation
                if (this.settingsPreview) {
                    const sp = this.settingsPreview;
                    sp.mesh.rotation.x += sp.rotationSpeed.x;
                    sp.mesh.rotation.y += sp.rotationSpeed.y;
                    sp.mesh.rotation.z += sp.rotationSpeed.z;
                    
                    // Pulse animation for glow
                    if (sp.mesh.glowLight && typeof DICE !== 'undefined') {
                        const effects = DICE.getEffects ? DICE.getEffects() : {};
                        if (effects.pulse) {
                            const time = Date.now() * 0.001 * (effects.pulseSpeed || 2) * Math.PI * 2;
                            const pulseValue = (Math.sin(time) + 1) / 2;
                            const min = effects.pulseMin || 0.5;
                            const max = effects.pulseMax || 2.5;
                            sp.mesh.glowLight.intensity = min + pulseValue * (max - min);
                        }
                    }
                    
                    sp.renderer.render(sp.scene, sp.camera);
                }
            },
            
            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            },
            
            // RIFT: Settings Preview D20
            settingsPreview: null,
            
            initSettingsPreview() {
                const canvas = document.getElementById('settingsPreviewCanvas');
                if (!canvas || typeof THREE === 'undefined') return;
                
                const size = 100;
                canvas.width = size * 2;
                canvas.height = size * 2;
                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
                
                const renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(size * 2, size * 2);
                renderer.setClearColor(0x000000, 0);
                
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(30, 1, 1, 1000);
                camera.position.set(0, 0, 350);
                camera.lookAt(0, 0, 0);
                
                // Lighting
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambient);
                const directional = new THREE.DirectionalLight(0xffffff, 0.8);
                directional.position.set(50, 50, 80);
                scene.add(directional);
                
                // D20 Mesh - using DICE library if available
                let mesh;
                if (typeof DICE !== 'undefined' && DICE.createPreviewDice) {
                    mesh = DICE.createPreviewDice('d20', 1.0);
                }
                
                if (!mesh) {
                    // Fallback: Simple icosahedron
                    const geometry = new THREE.IcosahedronGeometry(56);
                    const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
                    mesh = new THREE.Mesh(geometry, material);
                }
                
                // Position: 50px left (-x), 50px up (+y) in screen space
                mesh.position.set(-45, 45, 0);
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                scene.add(mesh);
                
                // Glow light for preview
                const glowLight = new THREE.PointLight(0x888888, 0, 300);
                mesh.add(glowLight);
                
                this.settingsPreview = {
                    renderer,
                    scene,
                    camera,
                    mesh,
                    glowLight,
                    rotationSpeed: { x: 0.0008, y: 0.001, z: 0.0004 }
                };
                
                console.log('[DicePreview] Settings preview initialized');
            },
            
            updateSettingsPreview() {
                if (!this.settingsPreview) return;
                
                // Recreate mesh with current theme
                const { scene, mesh } = this.settingsPreview;
                scene.remove(mesh);
                
                let newMesh;
                if (typeof DICE !== 'undefined' && DICE.createPreviewDice) {
                    newMesh = DICE.createPreviewDice('d20', 1.0);
                }
                
                if (!newMesh) {
                    // Fallback
                    const geometry = new THREE.IcosahedronGeometry(56);
                    const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
                    newMesh = new THREE.Mesh(geometry, material);
                }
                
                // FIXE Position und Rotation
                newMesh.position.set(-45, 45, 0);
                newMesh.rotation.copy(mesh.rotation);
                
                scene.add(newMesh);
                this.settingsPreview.mesh = newMesh;
            }
        };
        
        // Initialize after everything is loaded
        if (document.readyState === 'complete') {
            setTimeout(() => {
                DicePreview.init();
                DicePreview.initSettingsPreview();
            }, 200);
        } else {
            window.addEventListener('load', () => {
                setTimeout(() => {
                    DicePreview.init();
                    DicePreview.initSettingsPreview();
                }, 200);
            });
        }
    </script>
    <script>
        // Mobile Settings Theme Grid Population
        document.addEventListener('DOMContentLoaded', function() {
            const mobileGrid = document.getElementById('mobileThemeGrid');
            const desktopGrid = document.querySelector('.dice-theme-grid');
            
            if (mobileGrid && desktopGrid) {
                // Kopiere alle Theme Cards
                const cards = desktopGrid.querySelectorAll('.dice-theme-card');
                cards.forEach(card => {
                    const clone = card.cloneNode(true);
                    clone.addEventListener('click', function() {
                        // Remove active from all
                        mobileGrid.querySelectorAll('.dice-theme-card').forEach(c => c.classList.remove('active'));
                        desktopGrid.querySelectorAll('.dice-theme-card').forEach(c => c.classList.remove('active'));
                        // Add active to clicked and desktop equivalent
                        this.classList.add('active');
                        const theme = this.dataset.theme;
                        const desktopCard = desktopGrid.querySelector(`[data-theme="${theme}"]`);
                        if (desktopCard) desktopCard.classList.add('active');
                        // Apply theme
                        if (window.DiceRoller && DiceRoller.setTheme) {
                            DiceRoller.setTheme(theme);
                        }
                    });
                    mobileGrid.appendChild(clone);
                });
            }
        });
    </script>
    <script src="assets/js/broadcast.js"></script>
    
    <!-- MOBILE SETTINGS POPUP - DIREKT IM BODY -->
    <div class="mobile-settings-overlay" id="mobileSettingsOverlay" onclick="document.getElementById('mobileSettingsPopup').classList.remove('open'); this.classList.remove('open');"></div>
    <div class="mobile-settings-popup" id="mobileSettingsPopup">
        <div class="mobile-settings-popup__header">
            <span>Einstellungen</span>
            <button class="mobile-settings-popup__close" onclick="document.getElementById('mobileSettingsPopup').classList.remove('open'); document.getElementById('mobileSettingsOverlay').classList.remove('open');">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <div class="mobile-settings-popup__content">
            <span class="mobile-settings-popup__label">Würfelfarbe</span>
            <div class="mobile-theme-grid" id="mobileThemeGrid"></div>
        </div>
    </div>

    <!-- Settings Overlay - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-overlay" id="diceSettingsOverlay" onclick="DiceRoller.closeAllPopups()"></div>
    
    <!-- RIFT: D20 Preview - neben dem Popup -->
    <div class="dice-settings-preview" id="settingsPreviewContainer">
        <div class="dice-settings-preview__canvas-wrapper">
            <div class="dice-settings-preview__effects" id="previewEffectsContainer"></div>
            <canvas class="dice-settings-preview__canvas" id="settingsPreviewCanvas" data-type="d20"></canvas>
        </div>
        <span class="dice-settings-preview__label">Vorschau</span>
    </div>
    
    <!-- Stats Popup - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-popup dice-stats-popup" id="statsPopup">
        <div class="dice-settings-popup__header">
            <span>Statistiken</span>
            <button class="dice-settings-popup__close" onclick="DiceRoller.toggleStatsPopup()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <p class="dice-stats-hint">Statistiken für alle Spieler im Raum</p>
        <div class="dice-stats-grid">
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statTotal">0</span>
                <span class="dice-stats-card__label">Würfe</span>
            </div>
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statAvg">-</span>
                <span class="dice-stats-card__label">Durchschnitt</span>
            </div>
            <div class="dice-stats-card dice-stats-card--success">
                <span class="dice-stats-card__value" id="statCrits">0</span>
                <span class="dice-stats-card__label">Kritische Erfolge</span>
            </div>
            <div class="dice-stats-card dice-stats-card--failure">
                <span class="dice-stats-card__value" id="statFumbles">0</span>
                <span class="dice-stats-card__label">Patzer</span>
            </div>
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statMax">-</span>
                <span class="dice-stats-card__label">Maximum</span>
            </div>
            <div class="dice-stats-card">
                <span class="dice-stats-card__value" id="statMin">-</span>
                <span class="dice-stats-card__label">Minimum</span>
            </div>
        </div>
        <button class="dice-stats-reset" onclick="DiceRoller.resetStats()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
            </svg>
            Statistiken zurücksetzen
        </button>
    </div>
    
    <!-- Hotkeys Popup - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-popup dice-hotkeys-popup" id="hotkeysPopup">
        <div class="dice-settings-popup__header">
            <span>Tastenkürzel</span>
            <button class="dice-settings-popup__close" onclick="DiceRoller.toggleHotkeysPopup()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <div class="dice-hotkeys-list">
            <div class="dice-hotkey"><kbd>Enter</kbd><span>Würfeln</span></div>
            <div class="dice-hotkey"><kbd>Space</kbd><span>Würfeln</span></div>
            <div class="dice-hotkey"><kbd>1-7</kbd><span>Würfel hinzufügen</span></div>
            <div class="dice-hotkey"><kbd>Shift+1-7</kbd><span>Würfel entfernen</span></div>
            <div class="dice-hotkey"><kbd>+/-</kbd><span>Modifier ±1</span></div>
            <div class="dice-hotkey"><kbd>Shift +/-</kbd><span>Modifier ±5</span></div>
            <div class="dice-hotkey"><kbd>A</kbd><span>Vorteil</span></div>
            <div class="dice-hotkey"><kbd>D</kbd><span>Nachteil</span></div>
            <div class="dice-hotkey"><kbd>R</kbd><span>Wiederholen</span></div>
            <div class="dice-hotkey"><kbd>Esc</kbd><span>Reset</span></div>
        </div>
    </div>
    
    <!-- Settings Popup - auf Body-Level für korrekten z-index -->
    <div class="dice-settings-popup" id="settingsPopup">
        <div class="dice-settings-popup__header">
            <span>Einstellungen</span>
            <button class="dice-settings-popup__close" id="settingsClose" onclick="DiceRoller.closeAllPopups()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        
        <!-- TABS -->
        <div class="dice-settings-tabs">
            <button class="dice-settings-tab active" data-tab="diceColor" onclick="DiceRoller.switchSettingsTab('diceColor')">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2c-.5 0-1 .19-1.41.59l-8 8c-.79.78-.79 2.05 0 2.82l8 8c.78.79 2.05.79 2.82 0l8-8c.79-.78.79-2.05 0-2.82l-8-8C13 2.19 12.5 2 12 2m0 2l8 8l-8 8l-8-8m4.5 4a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5a1.5 1.5 0 0 0-1.5-1.5m3 0a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5a1.5 1.5 0 0 0-1.5-1.5M12 5.5a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5a1.5 1.5 0 0 0-1.5-1.5m-3 9a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5a1.5 1.5 0 0 0-1.5-1.5m6 0a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5a1.5 1.5 0 0 0-1.5-1.5"/></svg>
                Würfel
            </button>
            <button class="dice-settings-tab" data-tab="labelColor" onclick="DiceRoller.switchSettingsTab('labelColor')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10l2 -2v8"/><path d="M9 8h3a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 0 -1 1v2a1 1 0 0 0 1 1h3"/><path d="M17 8h2.5a1.5 1.5 0 0 1 1.5 1.5v1a1.5 1.5 0 0 1 -1.5 1.5h-1.5h1.5a1.5 1.5 0 0 1 1.5 1.5v1a1.5 1.5 0 0 1 -1.5 1.5h-2.5"/></svg>
                Zahlen
            </button>
            <button class="dice-settings-tab" data-tab="effects" onclick="DiceRoller.switchSettingsTab('effects')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3l1.912 5.813a2 2 0 0 0 1.275 1.275l5.813 1.912l-5.813 1.912a2 2 0 0 0 -1.275 1.275l-1.912 5.813l-1.912 -5.813a2 2 0 0 0 -1.275 -1.275l-5.813 -1.912l5.813 -1.912a2 2 0 0 0 1.275 -1.275z"/><path d="M5 3v2"/><path d="M19 17v2"/><path d="M3 5h2"/><path d="M17 19h2"/></svg>
                Effekte
            </button>
            <button class="dice-settings-tab" data-tab="arenaTheme" onclick="DiceRoller.switchSettingsTab('arenaTheme')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3l-3 3"/><path d="M21 18l-3 3"/><path d="M11 3l-8 8"/><path d="M16 3l-13 13"/><path d="M21 3l-18 18"/><path d="M21 8l-13 13"/><path d="M21 13l-8 8"/></svg>
                Arena
            </button>
        </div>
        
        <!-- TAB CONTENT: Würfelfarbe -->
        <div class="dice-settings-tab-content active" id="tabDiceColor">
    
    <div class="dice-settings-popup__section dice-settings-popup__section--themes">
        <span class="dice-settings-popup__label">Würfelfarbe</span>
        <input type="text" class="dice-theme-search" id="themeSearch" placeholder="Theme suchen..." oninput="DiceRoller.filterThemes(this.value)">
        
        <!-- RIFT Free -->
        <div class="tier-section">
            <div class="tier-header">
                <span class="tier-badge tier-badge--free">RIFT Free</span>
                <span class="tier-count">10 Farben</span>
            </div>
            <div class="dice-theme-grid">
                <button class="dice-theme-card" data-theme="black">
                    <div class="dice-theme-card__preview" style="background: #1a1a1a;"></div>
                    <span>Schwarz</span>
                </button>
                <button class="dice-theme-card" data-theme="white">
                    <div class="dice-theme-card__preview" style="background: #f5f5f5;"></div>
                    <span>Weiß</span>
                </button>
                <button class="dice-theme-card" data-theme="red">
                    <div class="dice-theme-card__preview" style="background: #cc0000;"></div>
                    <span>Rot</span>
                </button>
                <button class="dice-theme-card" data-theme="blue">
                    <div class="dice-theme-card__preview" style="background: #0000d4;"></div>
                    <span>Blau</span>
                </button>
                <button class="dice-theme-card" data-theme="green">
                    <div class="dice-theme-card__preview" style="background: #00d400;"></div>
                    <span>Grün</span>
                </button>
                <button class="dice-theme-card" data-theme="yellow">
                    <div class="dice-theme-card__preview" style="background: #e6e600;"></div>
                    <span>Gelb</span>
                </button>
                <button class="dice-theme-card" data-theme="orange">
                    <div class="dice-theme-card__preview" style="background: #e07800;"></div>
                    <span>Orange</span>
                </button>
                <button class="dice-theme-card" data-theme="purple">
                    <div class="dice-theme-card__preview" style="background: #660066;"></div>
                    <span>Lila</span>
                </button>
                <button class="dice-theme-card" data-theme="pink">
                    <div class="dice-theme-card__preview" style="background: #e8aeb8;"></div>
                    <span>Pink</span>
                </button>
                <button class="dice-theme-card" data-theme="silver">
                    <div class="dice-theme-card__preview" style="background: #a8a8a8;"></div>
                    <span>Silber</span>
                </button>
            </div>
        </div>
        
        <!-- RIFT Silver -->
        <div class="tier-section">
            <div class="tier-header">
                <span class="tier-badge tier-badge--silver">RIFT Silver</span>
                <span class="tier-count">30 Farben</span>
            </div>
            <div class="dice-theme-grid">
                <button class="dice-theme-card" data-theme="onyx">
                    <div class="dice-theme-card__preview" style="background: #1f1f1f;"></div>
                    <span>Onyx</span>
                </button>
                <button class="dice-theme-card" data-theme="charcoal">
                    <div class="dice-theme-card__preview" style="background: #2d2d2d;"></div>
                    <span>Kohle</span>
                </button>
                <button class="dice-theme-card" data-theme="graphite">
                    <div class="dice-theme-card__preview" style="background: #363636;"></div>
                    <span>Graphit</span>
                </button>
                <button class="dice-theme-card" data-theme="slate">
                    <div class="dice-theme-card__preview" style="background: #455a64;"></div>
                    <span>Schiefer</span>
                </button>
                <button class="dice-theme-card" data-theme="pearl">
                    <div class="dice-theme-card__preview" style="background: #d4d4d4;"></div>
                    <span>Perle</span>
                </button>
                <button class="dice-theme-card" data-theme="crimson">
                    <div class="dice-theme-card__preview" style="background: #b21030;"></div>
                    <span>Karmesin</span>
                </button>
                <button class="dice-theme-card" data-theme="scarlet">
                    <div class="dice-theme-card__preview" style="background: #d41f00;"></div>
                    <span>Scharlach</span>
                </button>
                <button class="dice-theme-card" data-theme="cherry">
                    <div class="dice-theme-card__preview" style="background: #b8264f;"></div>
                    <span>Kirsche</span>
                </button>
                <button class="dice-theme-card" data-theme="coral">
                    <div class="dice-theme-card__preview" style="background: #e56b3e;"></div>
                    <span>Koralle</span>
                </button>
                <button class="dice-theme-card" data-theme="gold">
                    <div class="dice-theme-card__preview" style="background: #d4b000;"></div>
                    <span>Gold</span>
                </button>
                <button class="dice-theme-card" data-theme="amber">
                    <div class="dice-theme-card__preview" style="background: #d4a000;"></div>
                    <span>Bernstein</span>
                </button>
                <button class="dice-theme-card" data-theme="honey">
                    <div class="dice-theme-card__preview" style="background: #c88005;"></div>
                    <span>Honig</span>
                </button>
                <button class="dice-theme-card" data-theme="forest">
                    <div class="dice-theme-card__preview" style="background: #1a6b1a;"></div>
                    <span>Wald</span>
                </button>
                <button class="dice-theme-card" data-theme="emerald">
                    <div class="dice-theme-card__preview" style="background: #40a060;"></div>
                    <span>Smaragd</span>
                </button>
                <button class="dice-theme-card" data-theme="lime">
                    <div class="dice-theme-card__preview" style="background: #28a828;"></div>
                    <span>Limette</span>
                </button>
                <button class="dice-theme-card" data-theme="mint">
                    <div class="dice-theme-card__preview" style="background: #7de87d;"></div>
                    <span>Minze</span>
                </button>
                <button class="dice-theme-card" data-theme="teal">
                    <div class="dice-theme-card__preview" style="background: #006666;"></div>
                    <span>Petrol</span>
                </button>
                <button class="dice-theme-card" data-theme="cyan">
                    <div class="dice-theme-card__preview" style="background: #00d4d4;"></div>
                    <span>Cyan</span>
                </button>
                <button class="dice-theme-card" data-theme="turquoise">
                    <div class="dice-theme-card__preview" style="background: #35b8aa;"></div>
                    <span>Türkis</span>
                </button>
                <button class="dice-theme-card" data-theme="navy">
                    <div class="dice-theme-card__preview" style="background: #000066;"></div>
                    <span>Marine</span>
                </button>
                <button class="dice-theme-card" data-theme="royal">
                    <div class="dice-theme-card__preview" style="background: #3555c0;"></div>
                    <span>Königsblau</span>
                </button>
                <button class="dice-theme-card" data-theme="sky">
                    <div class="dice-theme-card__preview" style="background: #6eb8d8;"></div>
                    <span>Himmel</span>
                </button>
                <button class="dice-theme-card" data-theme="indigo">
                    <div class="dice-theme-card__preview" style="background: #3c0068;"></div>
                    <span>Indigo</span>
                </button>
                <button class="dice-theme-card" data-theme="violet">
                    <div class="dice-theme-card__preview" style="background: #7400d4;"></div>
                    <span>Violett</span>
                </button>
                <button class="dice-theme-card" data-theme="amethyst">
                    <div class="dice-theme-card__preview" style="background: #7d54ab;"></div>
                    <span>Amethyst</span>
                </button>
                <button class="dice-theme-card" data-theme="lavender">
                    <div class="dice-theme-card__preview" style="background: #9668ba;"></div>
                    <span>Lavendel</span>
                </button>
                <button class="dice-theme-card" data-theme="magenta">
                    <div class="dice-theme-card__preview" style="background: #d400d4;"></div>
                    <span>Magenta</span>
                </button>
                <button class="dice-theme-card" data-theme="hotPink">
                    <div class="dice-theme-card__preview" style="background: #e05a9c;"></div>
                    <span>Hot Pink</span>
                </button>
                <button class="dice-theme-card" data-theme="brown">
                    <div class="dice-theme-card__preview" style="background: #724010;"></div>
                    <span>Braun</span>
                </button>
                <button class="dice-theme-card" data-theme="chocolate">
                    <div class="dice-theme-card__preview" style="background: #653400;"></div>
                    <span>Schokolade</span>
                </button>
            </div>
        </div>
        
        <!-- RIFT Gold -->
        <div class="tier-section">
            <div class="tier-header">
                <span class="tier-badge tier-badge--gold">RIFT Gold</span>
                <span class="tier-count">20 Premium</span>
            </div>
            <div class="dice-theme-grid">
                <button class="dice-theme-card" data-theme="ruby">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 30% 30%, #ff1a5c, #b80e4d 50%, #8a0a3a);"></div>
                    <span>Rubin</span>
                </button>
                <button class="dice-theme-card" data-theme="sapphire">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 30% 30%, #1a5cff, #0047ab 50%, #002d6e);"></div>
                    <span>Saphir</span>
                </button>
                <button class="dice-theme-card" data-theme="rose">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #e8b4b8, #b76e79, #e8b4b8);"></div>
                    <span>Roségold</span>
                </button>
                <button class="dice-theme-card" data-theme="platinum">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #e8e8e8, #a0a0a0, #e8e8e8);"></div>
                    <span>Platin</span>
                </button>
                <button class="dice-theme-card" data-theme="chrome">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #f0f0f0, #888, #f0f0f0, #666);"></div>
                    <span>Chrom</span>
                </button>
                <button class="dice-theme-card" data-theme="copper">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #da8a67, #96602a, #da8a67);"></div>
                    <span>Kupfer</span>
                </button>
                <button class="dice-theme-card" data-theme="bronze">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #d4a574, #a86828, #d4a574);"></div>
                    <span>Bronze</span>
                </button>
                <button class="dice-theme-card" data-theme="gunmetal">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #4a5568, #232a2e, #4a5568);"></div>
                    <span>Anthrazit</span>
                </button>
                <button class="dice-theme-card" data-theme="bloodmoon">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 40% 40%, #8b0000, #4a0000 60%, #1a0000);"></div>
                    <span>Blutmond</span>
                </button>
                <button class="dice-theme-card" data-theme="nebula">
                    <div class="dice-theme-card__preview dice-theme-card__preview--nebula"></div>
                    <span>Nebula</span>
                </button>
                <button class="dice-theme-card" data-theme="aurora">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #00ff87, #60efff, #b967ff);"></div>
                    <span>Nordlicht</span>
                </button>
                <button class="dice-theme-card" data-theme="void">
                    <div class="dice-theme-card__preview dice-theme-card__preview--void"></div>
                    <span>Leere</span>
                </button>
                <button class="dice-theme-card" data-theme="marbleWhite">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #f0f0f0 0%, #e8e8e8 25%, #f5f5f5 50%, #ddd 75%, #f0f0f0 100%);"></div>
                    <span>Weißmarmor</span>
                </button>
                <button class="dice-theme-card" data-theme="marbleBlack">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #1a1a1a 0%, #333 25%, #1a1a1a 50%, #444 75%, #1a1a1a 100%);"></div>
                    <span>Schwarzmarmor</span>
                </button>
                <button class="dice-theme-card" data-theme="marbleGreen">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #1a3a1a 0%, #2d4a2d 25%, #1a3a1a 50%, #4a8a4a 75%, #1a3a1a 100%);"></div>
                    <span>Grünmarmor</span>
                </button>
                <button class="dice-theme-card" data-theme="woodOak">
                    <div class="dice-theme-card__preview" style="background: repeating-linear-gradient(90deg, #8d6e63, #8d6e63 3px, #6d5045 3px, #6d5045 6px);"></div>
                    <span>Eiche</span>
                </button>
                <button class="dice-theme-card" data-theme="woodEbony">
                    <div class="dice-theme-card__preview" style="background: repeating-linear-gradient(90deg, #1a1510, #1a1510 3px, #0d0a08 3px, #0d0a08 6px);"></div>
                    <span>Ebenholz</span>
                </button>
                <button class="dice-theme-card" data-theme="stoneGranite">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #757575 0%, #616161 25%, #757575 50%, #616161 75%, #757575 100%);"></div>
                    <span>Granit</span>
                </button>
                <button class="dice-theme-card" data-theme="ice">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #e0f7fa, #80deea, #e0f7fa);"></div>
                    <span>Eis</span>
                </button>
                <button class="dice-theme-card" data-theme="lava">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #ff6b00, #cc0000, #ff6b00);"></div>
                    <span>Lava</span>
                </button>
            </div>
        </div>
        
        <!-- Farbverläufe (Gradients) -->
        <div class="tier-section">
            <div class="tier-header">
                <span class="tier-badge tier-badge--gold">RIFT Gold</span>
                <span class="tier-count">Farbverläufe</span>
            </div>
            <div class="dice-theme-grid">
                <button class="dice-theme-card" data-theme="gradSunset">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #ff7e5f, #feb47b, #ff6b6b);"></div>
                    <span>Sonnenuntergang</span>
                </button>
                <button class="dice-theme-card" data-theme="gradOcean">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #00b4db, #0083b0, #005f7f);"></div>
                    <span>Ozean</span>
                </button>
                <button class="dice-theme-card" data-theme="gradToxic">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #39ff14, #32cd32, #228b22);"></div>
                    <span>Toxisch</span>
                </button>
                <button class="dice-theme-card" data-theme="gradNebula">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #ff6bcb, #c56cf0, #6c5ce7);"></div>
                    <span>Nebula</span>
                </button>
                <button class="dice-theme-card" data-theme="gradFire">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #ff5722, #ff9800, #ffeb3b);"></div>
                    <span>Feuer</span>
                </button>
                <button class="dice-theme-card" data-theme="gradAbyssal">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #2d1b69, #151530, #050510);"></div>
                    <span>Abyssal</span>
                </button>
                <button class="dice-theme-card" data-theme="gradVoid">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #3d0066, #1a0030, #080015);"></div>
                    <span>Leere</span>
                </button>
                <button class="dice-theme-card" data-theme="gradShadow">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #2d2d3d, #1a1a2e, #0a0a14);"></div>
                    <span>Schatten</span>
                </button>
                <button class="dice-theme-card" data-theme="gradBloodMist">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #660022, #3d0015, #100005);"></div>
                    <span>Blutnebel</span>
                </button>
                <button class="dice-theme-card" data-theme="gradDeepSea">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #0d3050, #0a2035, #030a15);"></div>
                    <span>Tiefsee</span>
                </button>
            </div>
        </div>
        
        <!-- Texturen (Expanded) -->
        <div class="tier-section">
            <div class="tier-header">
                <span class="tier-badge tier-badge--gold">RIFT Gold</span>
                <span class="tier-count">Texturen</span>
            </div>
            <div class="dice-theme-grid">
                <button class="dice-theme-card" data-theme="obsidian">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 30% 30%, #2a2a3a, #0f0f18);"></div>
                    <span>Obsidian</span>
                </button>
                <button class="dice-theme-card" data-theme="jadeGreen">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 40% 40%, #3da06a, #1a5a35);"></div>
                    <span>Jade</span>
                </button>
                <button class="dice-theme-card" data-theme="lapisBlue">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 40% 40%, #2850a0, #0e2860);"></div>
                    <span>Lapislazuli</span>
                </button>
                <button class="dice-theme-card" data-theme="meteoriteIron">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #6a6a6a 0%, #3d3d3d 50%, #5a5a5a 100%);"></div>
                    <span>Meteorit</span>
                </button>
                <button class="dice-theme-card" data-theme="fossilStone">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #c4b090, #8a7a5a, #a0906a);"></div>
                    <span>Fossil</span>
                </button>
                <button class="dice-theme-card" data-theme="carbonFiber">
                    <div class="dice-theme-card__preview" style="background: repeating-conic-gradient(#222 0% 25%, #1a1a1a 0% 50%) 0 0 / 8px 8px;"></div>
                    <span>Carbon</span>
                </button>
                <button class="dice-theme-card" data-theme="snakeSkin">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #4a6a4a, #2a4a2a, #1a3a1a);"></div>
                    <span>Schlangenhaut</span>
                </button>
                <button class="dice-theme-card" data-theme="chainmailSilver">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #a0a0a8 1px, transparent 1px), radial-gradient(circle, #8a8a90 1px, transparent 1px); background-size: 8px 8px; background-position: 0 0, 4px 4px; background-color: #6a6a70;"></div>
                    <span>Kettenhemd</span>
                </button>
                <button class="dice-theme-card" data-theme="damascusSteel">
                    <div class="dice-theme-card__preview" style="background: repeating-linear-gradient(45deg, #4a5060, #4a5060 2px, #5a6070 2px, #5a6070 4px);"></div>
                    <span>Damast</span>
                </button>
                <button class="dice-theme-card" data-theme="runicStone">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #4a4a6a, #1a1a2e);"></div>
                    <span>Runenstein</span>
                </button>
                <button class="dice-theme-card" data-theme="nebulaGlow">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle, #3a2070, #2e1a5a, #0a0518);"></div>
                    <span>Nebula-Glow</span>
                </button>
                <button class="dice-theme-card" data-theme="veinsGold">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #4a3a1a, #2a1a08, #1a1005);"></div>
                    <span>Goldadern</span>
                </button>
                <button class="dice-theme-card" data-theme="circuitBoard">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #007030, #003010);"></div>
                    <span>Leiterplatte</span>
                </button>
                <button class="dice-theme-card" data-theme="boneWhite">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #f0e4d0, #d0c4a8, #c4b898);"></div>
                    <span>Knochen</span>
                </button>
                <button class="dice-theme-card" data-theme="parchmentOld">
                    <div class="dice-theme-card__preview" style="background: linear-gradient(135deg, #e0d0b0, #b0a070, #a89870);"></div>
                    <span>Pergament</span>
                </button>
                <button class="dice-theme-card" data-theme="crystalAmethyst">
                    <div class="dice-theme-card__preview" style="background: radial-gradient(circle at 30% 30%, #9050d0, #5a2890, #4a1880);"></div>
                    <span>Kristall</span>
                </button>
            </div>
        </div>
    </div>
    </div><!-- Ende Tab Würfelfarbe -->
    
    <!-- TAB CONTENT: Zahlenfarbe -->
    <div class="dice-settings-tab-content" id="tabLabelColor">
        <div class="dice-settings-popup__section">
            <span class="dice-settings-popup__label">Zahlenfarbe</span>
            <p class="dice-settings-popup__hint">Wähle die Farbe der Zahlen auf deinen Würfeln.</p>
            
            <!-- RIFT Free -->
            <div class="tier-section">
                <div class="tier-header">
                    <span class="tier-badge tier-badge--free">RIFT Free</span>
                    <span class="tier-count">7 Farben</span>
                </div>
                <div class="dice-label-color-grid">
                    <button class="dice-label-color-btn active" data-color="auto" onclick="DiceRoller.setLabelColor('auto')">
                        <div class="dice-label-color-preview dice-label-color-preview--auto"></div>
                        <span>Auto</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#ffffff" onclick="DiceRoller.setLabelColor('#ffffff')">
                        <div class="dice-label-color-preview" style="background: #ffffff;"></div>
                        <span>Weiß</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#1a1a1a" onclick="DiceRoller.setLabelColor('#1a1a1a')">
                        <div class="dice-label-color-preview" style="background: #1a1a1a;"></div>
                        <span>Schwarz</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#ff4444" onclick="DiceRoller.setLabelColor('#ff4444')">
                        <div class="dice-label-color-preview" style="background: #ff4444;"></div>
                        <span>Rot</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#ffeb3b" onclick="DiceRoller.setLabelColor('#ffeb3b')">
                        <div class="dice-label-color-preview" style="background: #ffeb3b;"></div>
                        <span>Gelb</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#4caf50" onclick="DiceRoller.setLabelColor('#4caf50')">
                        <div class="dice-label-color-preview" style="background: #4caf50;"></div>
                        <span>Grün</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#2196f3" onclick="DiceRoller.setLabelColor('#2196f3')">
                        <div class="dice-label-color-preview" style="background: #2196f3;"></div>
                        <span>Blau</span>
                    </button>
                </div>
            </div>
            
            <!-- RIFT Silver -->
            <div class="tier-section">
                <div class="tier-header">
                    <span class="tier-badge tier-badge--silver">RIFT Silver</span>
                    <span class="tier-count">10 Farben</span>
                </div>
                <div class="dice-label-color-grid">
                    <button class="dice-label-color-btn" data-color="#ff9800" onclick="DiceRoller.setLabelColor('#ff9800')">
                        <div class="dice-label-color-preview" style="background: #ff9800;"></div>
                        <span>Orange</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#00bcd4" onclick="DiceRoller.setLabelColor('#00bcd4')">
                        <div class="dice-label-color-preview" style="background: #00bcd4;"></div>
                        <span>Cyan</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#9c27b0" onclick="DiceRoller.setLabelColor('#9c27b0')">
                        <div class="dice-label-color-preview" style="background: #9c27b0;"></div>
                        <span>Lila</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#e91e63" onclick="DiceRoller.setLabelColor('#e91e63')">
                        <div class="dice-label-color-preview" style="background: #e91e63;"></div>
                        <span>Pink</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#795548" onclick="DiceRoller.setLabelColor('#795548')">
                        <div class="dice-label-color-preview" style="background: #795548;"></div>
                        <span>Braun</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#607d8b" onclick="DiceRoller.setLabelColor('#607d8b')">
                        <div class="dice-label-color-preview" style="background: #607d8b;"></div>
                        <span>Grau</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#8bc34a" onclick="DiceRoller.setLabelColor('#8bc34a')">
                        <div class="dice-label-color-preview" style="background: #8bc34a;"></div>
                        <span>Limette</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#3f51b5" onclick="DiceRoller.setLabelColor('#3f51b5')">
                        <div class="dice-label-color-preview" style="background: #3f51b5;"></div>
                        <span>Indigo</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#009688" onclick="DiceRoller.setLabelColor('#009688')">
                        <div class="dice-label-color-preview" style="background: #009688;"></div>
                        <span>Petrol</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#ff5722" onclick="DiceRoller.setLabelColor('#ff5722')">
                        <div class="dice-label-color-preview" style="background: #ff5722;"></div>
                        <span>Koralle</span>
                    </button>
                </div>
            </div>
            
            <!-- RIFT Gold -->
            <div class="tier-section">
                <div class="tier-header">
                    <span class="tier-badge tier-badge--gold">RIFT Gold</span>
                    <span class="tier-count">10 Premium</span>
                </div>
                <div class="dice-label-color-grid">
                    <button class="dice-label-color-btn" data-color="#ffd700" onclick="DiceRoller.setLabelColor('#ffd700')">
                        <div class="dice-label-color-preview" style="background: linear-gradient(135deg, #ffd700, #ffec8b, #ffd700);"></div>
                        <span>Gold</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#c0c0c0" onclick="DiceRoller.setLabelColor('#c0c0c0')">
                        <div class="dice-label-color-preview" style="background: linear-gradient(135deg, #e8e8e8, #a0a0a0, #e8e8e8);"></div>
                        <span>Silber</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#b87333" onclick="DiceRoller.setLabelColor('#b87333')">
                        <div class="dice-label-color-preview" style="background: linear-gradient(135deg, #da8a67, #b87333, #da8a67);"></div>
                        <span>Kupfer</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#cd7f32" onclick="DiceRoller.setLabelColor('#cd7f32')">
                        <div class="dice-label-color-preview" style="background: linear-gradient(135deg, #d4a574, #cd7f32, #d4a574);"></div>
                        <span>Bronze</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#e0115f" onclick="DiceRoller.setLabelColor('#e0115f')">
                        <div class="dice-label-color-preview" style="background: radial-gradient(circle at 30% 30%, #ff1a5c, #e0115f);"></div>
                        <span>Rubin</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#0f52ba" onclick="DiceRoller.setLabelColor('#0f52ba')">
                        <div class="dice-label-color-preview" style="background: radial-gradient(circle at 30% 30%, #1a5cff, #0f52ba);"></div>
                        <span>Saphir</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#50c878" onclick="DiceRoller.setLabelColor('#50c878')">
                        <div class="dice-label-color-preview" style="background: radial-gradient(circle at 30% 30%, #5df08c, #50c878);"></div>
                        <span>Smaragd</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#9966cc" onclick="DiceRoller.setLabelColor('#9966cc')">
                        <div class="dice-label-color-preview" style="background: radial-gradient(circle at 30% 30%, #b388e8, #9966cc);"></div>
                        <span>Amethyst</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#00ffff" onclick="DiceRoller.setLabelColor('#00ffff')">
                        <div class="dice-label-color-preview" style="background: linear-gradient(135deg, #00ffff, #00d4ff, #00ffff); box-shadow: 0 0 8px rgba(0,255,255,0.5);"></div>
                        <span>Neon Cyan</span>
                    </button>
                    <button class="dice-label-color-btn" data-color="#ff00ff" onclick="DiceRoller.setLabelColor('#ff00ff')">
                        <div class="dice-label-color-preview" style="background: linear-gradient(135deg, #ff00ff, #ff66ff, #ff00ff); box-shadow: 0 0 8px rgba(255,0,255,0.5);"></div>
                        <span>Neon Pink</span>
                    </button>
                </div>
            </div>
        </div>
    </div><!-- Ende Tab Zahlenfarbe -->
    
    <!-- TAB CONTENT: Effekte -->
    <div class="dice-settings-tab-content" id="tabEffects">
        <div class="dice-settings-popup__section">
            <span class="dice-settings-popup__label">Würfel-Effekte</span>
            <p class="dice-settings-popup__hint">Verleihe deinen Würfeln besondere visuelle Effekte.</p>
            
            <!-- RIFT Silver -->
            <div class="tier-section">
                <div class="tier-header">
                    <span class="tier-badge tier-badge--silver">RIFT Silver</span>
                    <span class="tier-count">Basis-Effekte</span>
                </div>
                <div class="dice-effects-grid">
                    <button class="dice-effect-btn dice-effect-btn--locked" data-effect="glow" disabled>
                        <div class="dice-effect-btn__icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
                        </div>
                        <span class="dice-effect-btn__label">Glow</span>
                        <span class="dice-effect-btn__desc">Würfel leuchten sanft</span>
                        <span class="dice-effect-btn__badge">Bald</span>
                    </button>
                    <button class="dice-effect-btn dice-effect-btn--locked" data-effect="pulse" disabled>
                        <div class="dice-effect-btn__icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
                        </div>
                        <span class="dice-effect-btn__label">Pulsieren</span>
                        <span class="dice-effect-btn__desc">Rhythmisches Leuchten</span>
                        <span class="dice-effect-btn__badge">Bald</span>
                    </button>
                </div>
            </div>
            
            <!-- RIFT Gold -->
            <div class="tier-section">
                <div class="tier-header">
                    <span class="tier-badge tier-badge--gold">RIFT Gold</span>
                    <span class="tier-count">Premium-Effekte</span>
                </div>
                <div class="dice-effects-grid">
                    <button class="dice-effect-btn dice-effect-btn--locked" data-effect="particles" disabled>
                        <div class="dice-effect-btn__icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3l1.912 5.813a2 2 0 0 0 1.275 1.275l5.813 1.912l-5.813 1.912a2 2 0 0 0 -1.275 1.275l-1.912 5.813l-1.912 -5.813a2 2 0 0 0 -1.275 -1.275l-5.813 -1.912l5.813 -1.912a2 2 0 0 0 1.275 -1.275z"/></svg>
                        </div>
                        <span class="dice-effect-btn__label">Partikel-Trail</span>
                        <span class="dice-effect-btn__desc">Funkenspur beim Rollen</span>
                        <span class="dice-effect-btn__badge">Bald</span>
                    </button>
                    <button class="dice-effect-btn dice-effect-btn--locked" data-effect="crit" disabled>
                        <div class="dice-effect-btn__icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>
                        </div>
                        <span class="dice-effect-btn__label">Crit-Effekte</span>
                        <span class="dice-effect-btn__desc">Epische Nat20 Explosionen</span>
                        <span class="dice-effect-btn__badge">Bald</span>
                    </button>
                    <button class="dice-effect-btn dice-effect-btn--locked" data-effect="holographic" disabled>
                        <div class="dice-effect-btn__icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l10 6v8l-10 6-10-6V8z"/><path d="M12 22V10"/><path d="M22 8l-10 4-10-4"/></svg>
                        </div>
                        <span class="dice-effect-btn__label">Holografisch</span>
                        <span class="dice-effect-btn__desc">Schillernde Oberfläche</span>
                        <span class="dice-effect-btn__badge">Bald</span>
                    </button>
                    <button class="dice-effect-btn dice-effect-btn--locked" data-effect="smoke" disabled>
                        <div class="dice-effect-btn__icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 18 0 9 9 0 1 0-18 0"/><path d="M12 7v5l3 3"/></svg>
                        </div>
                        <span class="dice-effect-btn__label">Rauch</span>
                        <span class="dice-effect-btn__desc">Mystischer Nebel</span>
                        <span class="dice-effect-btn__badge">Bald</span>
                    </button>
                </div>
            </div>
        </div>
    </div><!-- Ende Tab Effekte -->
    
    <!-- TAB CONTENT: Arena-Theme -->
    <div class="dice-settings-tab-content" id="tabArenaTheme">
        <div class="dice-settings-popup__section">
            <span class="dice-settings-popup__label">Würfelareal</span>
            <p class="dice-settings-popup__hint">Wähle das Aussehen der Würfelfläche.</p>
            
            <!-- Dynamic Arena Themes Container -->
            <div id="arenaThemesContent">
                <div style="text-align:center;padding:40px;color:rgba(255,255,255,0.5);">
                    <div class="loading-spinner" style="width:24px;height:24px;border:2px solid rgba(255,255,255,0.2);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 12px;"></div>
                    Lade Themes...
                </div>
            </div>
        </div>
    </div><!-- Ende Tab Arena-Theme -->
    
    <div class="dice-settings-popup__section">
        <span class="dice-settings-popup__label">Optionen</span>
        <div class="dice-settings-popup__toggles">
            <button class="dice-settings-toggle active" id="soundToggle2" onclick="DiceRoller.toggleSound()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                </svg>
                <span>Sound</span>
            </button>
            <button class="dice-settings-toggle" id="secretToggle2" onclick="DiceRoller.toggleSecret()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
                <span>Geheim</span>
            </button>
        </div>
    </div>
</body>
</html>
