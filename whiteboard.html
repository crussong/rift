<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/icon_rift_r.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <meta name="view-transition" content="same-origin">
    <title>RIFT – Whiteboard</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/dock.css">
    <link rel="stylesheet" href="assets/css/hub.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    
    <style>
        /* KRITISCH: Verhindere body scroll bei Whiteboard */
        html, body {
            overflow: hidden !important;
            height: 100% !important;
            position: fixed !important;
            width: 100% !important;
        }
        
        .app {
            height: 100vh !important;
            overflow: hidden !important;
        }
        
        /* Whiteboard braucht VOLLE BREITE - aber TopNav Abstand behalten! */
        .main--fullwidth {
            max-width: none !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
            width: 100% !important;
            overflow: hidden !important;
        }
        .main--fullwidth::before {
            display: none !important;
        }
        .main__content--fullwidth {
            max-width: none !important;
            padding-left: 12px !important;
            padding-right: 12px !important;
            padding-bottom: 0 !important;
            width: 100% !important;
            overflow: hidden !important;
            /* padding-top bleibt von hub.css (130px für TopNav+MegaNav) */
        }
        
        .whiteboard-page { 
            min-height: calc(100vh - 130px - var(--dock-height, 72px)); 
            padding: 0; 
            display: flex; 
            flex-direction: column;
            width: 100%;
            position: relative;
            overflow: hidden;
        }
        .whiteboard-container { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            background: #0a0a0a; 
            border-radius: 16px; 
            border: 1px solid rgba(255,255,255,0.08); 
            overflow: hidden; 
            max-height: calc(100vh - 130px - var(--dock-height, 72px) - 24px); 
        }
        
        /* ===== Dropdown Toolbar ===== */
        .wb-toolbar { background: rgba(22,22,22,0.98); border-bottom: 1px solid rgba(255,255,255,0.08); z-index: 100; flex-shrink: 0; display: flex; align-items: center; padding: 4px 10px; gap: 4px; }
        .wb-toolbar__left { display: flex; align-items: center; gap: 3px; flex-shrink: 0; }
        .wb-toolbar__center { flex: 1; display: flex; align-items: center; justify-content: center; gap: 3px; min-width: 0; }
        .wb-toolbar__right { display: flex; align-items: center; gap: 3px; flex-shrink: 0; }
        .wb-toolbar__sep { width: 1px; height: 20px; background: rgba(255,255,255,0.08); margin: 0 2px; flex-shrink: 0; }
        .wb-lock-badge { display: none; padding: 2px 8px; background: rgba(239,68,68,0.9); color: white; font-size: 9px; font-weight: 600; border-radius: 4px; }
        .wb-toolbar.locked .wb-lock-badge { display: block; }
        
        /* Dropdown menus */
        .wb-menu { position: relative; }
        .wb-menu__trigger { padding: 5px 10px; border: none; background: rgba(255,255,255,0.04); color: rgba(255,255,255,0.55); font-size: 11px; font-weight: 500; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 5px; transition: all 0.15s; white-space: nowrap; }
        .wb-menu__trigger:hover, .wb-menu.open .wb-menu__trigger { background: rgba(255,255,255,0.12); color: white; }
        .wb-menu__trigger.has-active { color: #c4b5fd; background: rgba(139,92,246,0.12); }
        .wb-menu__trigger svg:first-child { width: 13px; height: 13px; flex-shrink: 0; }
        .wb-menu__chev { width: 8px; height: 8px; opacity: 0.35; transition: transform 0.2s; }
        .wb-menu.open .wb-menu__chev { transform: rotate(180deg); opacity: 0.7; }
        
        .wb-dropdown { display: none; position: absolute; top: calc(100% + 4px); left: 50%; transform: translateX(-50%); background: rgba(18,18,18,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 5px; min-width: 200px; z-index: 250; box-shadow: 0 12px 40px rgba(0,0,0,0.6); }
        .wb-menu.open .wb-dropdown { display: block; }
        .wb-dropdown::before { content:''; position: absolute; top: -10px; left: 0; right: 0; height: 10px; }
        
        .wb-dd-item { display: flex; align-items: center; gap: 8px; padding: 6px 10px; border: none; background: transparent; color: rgba(255,255,255,0.65); font-size: 12px; border-radius: 6px; cursor: pointer; width: 100%; text-align: left; white-space: nowrap; transition: all 0.12s; }
        .wb-dd-item:hover { background: rgba(255,255,255,0.08); color: white; }
        .wb-dd-item.active { background: rgba(139,92,246,0.2); color: #c4b5fd; }
        .wb-dd-item.active-red { background: rgba(239,68,68,0.15); color: #ef4444; }
        .wb-dd-item--danger:hover { background: rgba(239,68,68,0.15); color: #ef4444; }
        .wb-dd-item svg { width: 15px; height: 15px; flex-shrink: 0; opacity: 0.7; }
        .wb-dd-item.active svg, .wb-dd-item:hover svg { opacity: 1; }
        .wb-dd-item__key { font-size: 10px; color: rgba(255,255,255,0.25); margin-left: auto; padding-left: 16px; font-family: monospace; }
        .wb-dd-sep { height: 1px; background: rgba(255,255,255,0.06); margin: 3px 6px; }
        .wb-dd-label { font-size: 9px; color: rgba(255,255,255,0.25); text-transform: uppercase; letter-spacing: 0.5px; padding: 4px 10px 2px; }
        .wb-dd-row { display: flex; align-items: center; gap: 4px; padding: 3px 8px; }
        /* Flyout submenu */
        .wb-dd-submenu { position: relative; }
        .wb-dd-submenu > .wb-dd-item::after { content: ''; border: 4px solid transparent; border-left-color: rgba(255,255,255,0.3); margin-left: auto; }
        .wb-dd-submenu__panel { display: none; position: absolute; left: 100%; top: -4px; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 4px; min-width: 130px; z-index: 2100; box-shadow: 0 8px 24px rgba(0,0,0,0.5); }
        .wb-dd-submenu:hover > .wb-dd-submenu__panel { display: block; }
        .wb-dd-submenu__panel .wb-dd-item { font-size: 12px; padding: 7px 12px; }
        .wb-dd-submenu__panel .wb-dd-item.active { background: rgba(139,92,246,0.25); color: white; }
        
        .wb-btn { width: 28px; height: 28px; border: none; background: transparent; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; color: rgba(255,255,255,0.5); }
        .wb-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-btn.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-btn.active-red { background: rgba(239,68,68,0.25); color: #ef4444; }
        .wb-btn svg { width: 15px; height: 15px; }
        .wb-btn--danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        
        .wb-color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.15s; }
        .wb-color-btn:hover { transform: scale(1.15); }
        .wb-color-btn.active { border-color: white; box-shadow: 0 0 0 2px rgba(255,255,255,0.3); }
        
        .wb-size-btn { width: 22px; height: 22px; border: none; background: rgba(255,255,255,0.06); border-radius: 5px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .wb-size-btn:hover { background: rgba(255,255,255,0.12); }
        .wb-size-btn.active { background: var(--accent, #8b5cf6); }
        .wb-size-btn__dot { background: white; border-radius: 50%; }
        
        .wb-toggle { display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: rgba(255,255,255,0.04); border-radius: 6px; cursor: pointer; font-size: 10px; color: rgba(255,255,255,0.5); border: none; transition: all 0.15s; }
        .wb-toggle:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-toggle.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-toggle__dot { width: 5px; height: 5px; border-radius: 50%; background: currentColor; }
        .wb-toggle.active .wb-toggle__dot { box-shadow: 0 0 6px currentColor; }
        
        .wb-layers { display: flex; gap: 2px; background: rgba(0,0,0,0.3); padding: 2px; border-radius: 6px; }
        .wb-layer-tab { padding: 4px 8px; border: none; background: transparent; color: rgba(255,255,255,0.5); font-size: 10px; font-weight: 500; border-radius: 5px; cursor: pointer; transition: all 0.15s; }
        .wb-layer-tab:hover { color: white; background: rgba(255,255,255,0.1); }
        .wb-layer-tab.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-layer-tab--fog { color: rgba(239,68,68,0.7); }
        .wb-layer-tab--fog.active { background: #ef4444; }
        .wb-fog-ctrl { display: flex; align-items: center; gap: 2px; }
        .wb-fog-btn { padding: 3px 6px; border: 1px solid transparent; border-radius: 5px; font-size: 9px; cursor: pointer; display: flex; align-items: center; gap: 3px; transition: all 0.12s; color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.04); }
        .wb-fog-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-fog-btn.active { background: rgba(239,68,68,0.25); color: #ef4444; border-color: rgba(239,68,68,0.4); }
        .wb-fog-btn.active-green { background: rgba(34,197,94,0.15); color: #22c55e; border-color: rgba(34,197,94,0.3); }
        .wb-fog-btn svg { width: 10px; height: 10px; }
        
        /* Panel resize handle */
        .wb-panel-resize { position: absolute; bottom: 0; right: 0; width: 16px; height: 16px; cursor: nwse-resize; z-index: 5; }
        .wb-panel-resize::after { content: ''; position: absolute; bottom: 4px; right: 4px; width: 8px; height: 8px; border-right: 2px solid rgba(255,255,255,0.2); border-bottom: 2px solid rgba(255,255,255,0.2); }
        
        /* Iframe floating panel */
        .wb-iframe-panel { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; z-index: 150; display: none; overflow: hidden; box-shadow: 0 12px 48px rgba(0,0,0,0.6); min-width: 400px; min-height: 300px; }
        .wb-iframe-panel.visible { display: flex; flex-direction: column; }
        .wb-iframe-panel__header { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.08); cursor: grab; user-select: none; flex-shrink: 0; }
        .wb-iframe-panel__header:active { cursor: grabbing; }
        .wb-iframe-panel__title { font-size: 12px; font-weight: 600; color: rgba(255,255,255,0.7); }
        .wb-iframe-panel__close { width: 24px; height: 24px; background: none; border: none; color: rgba(255,255,255,0.5); cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; }
        .wb-iframe-panel__close:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-iframe-panel iframe { flex: 1; border: none; width: 100%; min-height: 400px; background: #111; }
        
        .wb-canvas-wrapper { flex: 1; position: relative; overflow: hidden; cursor: crosshair; min-height: 0; background: #0a0a0a; }
        .wb-canvas-wrapper.tool-select { cursor: default; }
        .wb-canvas-wrapper.tool-eraser { cursor: cell; }
        .wb-canvas-wrapper.tool-text { cursor: text; }
        .wb-canvas-wrapper.panning { cursor: grab; }
        
        /* Selection Box & Resize Handles */
        .wb-select-box { position: absolute; border: 2px solid #fbbf24; background: rgba(251,191,36,0.05); pointer-events: none; z-index: 200; display: none; }
        .wb-select-box.visible { display: block; }
        .wb-resize-handle { position: absolute; width: 12px; height: 12px; background: #fbbf24; border: 2px solid white; border-radius: 2px; pointer-events: auto; z-index: 201; }
        .wb-resize-handle--nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .wb-resize-handle--ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .wb-resize-handle--sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .wb-resize-handle--se { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .wb-resize-handle--n { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .wb-resize-handle--s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .wb-resize-handle--w { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .wb-resize-handle--e { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }
        
        /* Format Toolbar (appears above selected text/stroke) */
        .wb-format-bar { position: absolute; display: none; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 4px 8px; gap: 4px; z-index: 210; align-items: center; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
        .wb-format-bar.visible { display: flex; }
        .wb-format-bar__btn { width: 28px; height: 28px; border: none; background: transparent; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.7); font-size: 12px; }
        .wb-format-bar__btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-format-bar__btn.active { background: var(--accent); color: white; }
        .wb-format-bar__color { width: 20px; height: 20px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); cursor: pointer; }
        .wb-format-bar__sep { width: 1px; height: 20px; background: rgba(255,255,255,0.15); margin: 0 4px; }
        
        /* Draggable Image */
        .wb-image { position: absolute; left: 0; top: 0; cursor: move; z-index: 45; user-select: none; -webkit-user-drag: none; will-change: transform; }
        .wb-image.selected { outline: 3px solid #fbbf24; outline-offset: 2px; }
        .wb-image img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; -webkit-user-drag: none; }
        
        .wb-canvas { position: absolute; top: 0; left: 0; touch-action: none; will-change: contents; }
        #bgCanvas { z-index: 1; }
        #mainCanvas { z-index: 2; }
        #fogCanvas { z-index: 4; }
        #uiCanvas { z-index: 5; }
        
        #wbGrid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; background-image: linear-gradient(rgba(255,255,255,0.12) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.12) 1px, transparent 1px); background-size: 70px 70px; z-index: 10; transition: opacity 0.2s, background-position 0.05s ease-out; will-change: background-position, background-size; }
        #wbGrid.visible { opacity: 0.5; }
        
        #imagesContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; }
        #imagesContainer .wb-image { pointer-events: auto; }
        #tokensContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        #tokensContainer .wb-token { pointer-events: auto; }
        #tokensContainer.no-interact .wb-token { pointer-events: none; }
        #imagesContainer.no-interact .wb-image { pointer-events: none; }
        
        /* Movement & Range Radius Indicators */
        .wb-radius-indicator { position: absolute; border-radius: 50%; pointer-events: none; z-index: 45; display: none; transform: translate(-50%, -50%); }
        .wb-radius-indicator.visible { display: block; }
        .wb-radius-move { border: 3px dashed rgba(34,197,94,0.7); background: radial-gradient(circle, rgba(34,197,94,0.12) 0%, rgba(34,197,94,0.05) 70%, transparent 100%); box-shadow: 0 0 12px rgba(34,197,94,0.2), inset 0 0 20px rgba(34,197,94,0.05); }
        .wb-radius-move__label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); background: rgba(22,22,22,0.9); color: #22c55e; padding: 2px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; font-weight: 600; }
        .wb-radius-range { border: 2px dotted rgba(239,68,68,0.4); background: radial-gradient(circle, rgba(239,68,68,0.04) 0%, transparent 100%); }
        .wb-radius-origin { position: absolute; width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,0.4); border: 1px solid rgba(255,255,255,0.6); pointer-events: none; z-index: 46; display: none; transform: translate(-50%, -50%); }
        .wb-radius-origin.visible { display: block; }
        .wb-radius-distance { position: absolute; pointer-events: none; z-index: 46; display: none; background: rgba(22,22,22,0.9); color: #fbbf24; padding: 3px 10px; border-radius: 6px; font-size: 11px; font-weight: 700; white-space: nowrap; transform: translate(-50%, -100%); margin-top: -8px; }
        .wb-radius-distance.visible { display: block; }
        
        .wb-text-input { position: fixed; background: rgba(0,0,0,0.95); border: 2px solid var(--accent, #8b5cf6); border-radius: 8px; padding: 10px 14px; color: white; font-size: 18px; min-width: 200px; outline: none; z-index: 1000; display: none; }
        
        .wb-zoom-controls { position: absolute; bottom: 16px; right: 16px; display: flex; flex-direction: column; gap: 4px; background: rgba(22,22,22,0.95); border-radius: 10px; padding: 6px; border: 1px solid rgba(255,255,255,0.1); z-index: 100; }
        .wb-zoom-btn { width: 32px; height: 32px; border: none; background: transparent; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.6); }
        .wb-zoom-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-zoom-level { text-align: center; font-size: 10px; color: rgba(255,255,255,0.5); padding: 2px 0; }
        
        .wb-ping { position: absolute; pointer-events: none; z-index: 200; }
        .wb-ping__ring { position: absolute; border: 3px solid; border-radius: 50%; animation: ping-expand 1s ease-out forwards; }
        @keyframes ping-expand { 0% { width: 0; height: 0; opacity: 1; transform: translate(-50%, -50%); } 100% { width: 100px; height: 100px; opacity: 0; transform: translate(-50%, -50%); } }
        .wb-ping__dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; transform: translate(-50%, -50%); animation: ping-pulse 1s ease-out forwards; }
        @keyframes ping-pulse { 0%, 50% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } }
        
        .wb-ruler-info { position: absolute; background: rgba(0,0,0,0.9); color: #fbbf24; padding: 8px 14px; border-radius: 8px; font-size: 14px; font-weight: 600; pointer-events: none; z-index: 150; display: none; border: 2px solid #fbbf24; }
        
        .wb-token { position: absolute; left: 0; top: 0; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.5); cursor: move; display: flex; align-items: center; justify-content: center; font-weight: 700; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8); user-select: none; -webkit-user-drag: none; z-index: 50; will-change: transform; }
        .wb-token:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token.selected { border-color: #fbbf24; box-shadow: 0 0 0 4px rgba(251,191,36,0.4), 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token.dead { opacity: 0.5; filter: grayscale(80%); }
        .wb-token.active-turn { box-shadow: 0 0 0 4px rgba(34,197,94,0.6), 0 0 20px rgba(34,197,94,0.4), 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; pointer-events: none; -webkit-user-drag: none; }
        .wb-token__label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 2px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; pointer-events: none; }
        .wb-token__hp { position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); width: 80%; height: 6px; background: rgba(0,0,0,0.6); border-radius: 3px; overflow: hidden; pointer-events: none; }
        .wb-token__hp-fill { height: 100%; background: linear-gradient(90deg, #22c55e, #4ade80); border-radius: 3px; transition: width 0.3s ease; }
        .wb-token__hp-fill.low { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
        .wb-token__hp-fill.critical { background: linear-gradient(90deg, #ef4444, #f87171); }
        .wb-token__initiative { position: absolute; top: -8px; right: -8px; width: 22px; height: 22px; background: #1e1e1e; border: 2px solid #8b5cf6; border-radius: 50%; font-size: 11px; font-weight: 700; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        .wb-token__status { position: absolute; top: -6px; left: -6px; display: flex; gap: 2px; pointer-events: none; }
        .wb-token__status-icon { width: 18px; height: 18px; background: rgba(0,0,0,0.8); border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.2); }
        .wb-token__status-icon svg { width: 12px; height: 12px; }
        
        /* Token Hover Tooltip */
        .wb-token-tooltip { position: absolute; background: rgba(16,16,20,0.96); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 10px 14px; z-index: 300; pointer-events: none; min-width: 160px; max-width: 260px; opacity: 0; transition: opacity 0.15s; backdrop-filter: blur(8px); }
        .wb-token-tooltip.visible { opacity: 1; }
        .wb-token-tooltip__name { font-size: 13px; font-weight: 700; color: white; margin-bottom: 6px; }
        .wb-token-tooltip__row { display: flex; align-items: center; gap: 6px; font-size: 11px; color: rgba(255,255,255,0.6); margin-bottom: 3px; }
        .wb-token-tooltip__row svg { width: 12px; height: 12px; flex-shrink: 0; opacity: 0.5; }
        .wb-token-tooltip__hp-bar { width: 100%; height: 5px; background: rgba(255,255,255,0.08); border-radius: 3px; overflow: hidden; margin-top: 4px; margin-bottom: 4px; }
        .wb-token-tooltip__hp-fill { height: 100%; border-radius: 3px; }
        .wb-token-tooltip__items { font-size: 10px; color: rgba(255,255,255,0.45); margin-top: 4px; padding-top: 4px; border-top: 1px solid rgba(255,255,255,0.06); }
        
        /* Remote Cursors */
        .wb-remote-cursor { position: absolute; pointer-events: none; z-index: 55; transition: transform 0.1s linear; }
        .wb-remote-cursor__icon { width: 16px; height: 16px; }
        .wb-remote-cursor__icon path { stroke-width: 1; }
        .wb-remote-cursor__label { position: absolute; left: 16px; top: 14px; background: var(--cursor-color, #8b5cf6); color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; white-space: nowrap; }
        
        /* Visibility Toggle (eye icon) */
        .wb-vis-toggle { display: inline-flex; align-items: center; justify-content: center; width: 24px; height: 24px; border: none; background: rgba(255,255,255,0.05); border-radius: 4px; cursor: pointer; color: rgba(255,255,255,0.3); flex-shrink: 0; }
        .wb-vis-toggle:hover { background: rgba(255,255,255,0.1); }
        .wb-vis-toggle.visible-to-players { color: #22c55e; }
        .wb-vis-toggle svg { width: 14px; height: 14px; }
        
        /* Token field row with vis toggle */
        .wb-token-field-row { display: flex; align-items: flex-end; gap: 6px; }
        .wb-token-field-row .wb-token-edit__field { flex: 1; }
        
        /* Toolbar Lock */
        .wb-toolbar.locked .wb-menu[data-menu="draw"],
        .wb-toolbar.locked .wb-menu[data-menu="insert"] { opacity: 0.3; pointer-events: none; }
        .wb-toolbar.locked .wb-layers { opacity: 0.3; pointer-events: none; }
        
        /* Multi-select marquee */
        .wb-marquee { position: absolute; border: 2px dashed rgba(139,92,246,0.7); background: rgba(139,92,246,0.08); pointer-events: none; z-index: 200; display: none; }
        .wb-marquee.visible { display: block; }
        
        /* Token drag line */
        .wb-drag-line { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 55; overflow: visible; }
        
        /* Token Library */
        .wb-lib-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 8px; max-height: 300px; overflow-y: auto; padding: 4px; }
        .wb-lib-item { display: flex; flex-direction: column; align-items: center; gap: 4px; padding: 8px 4px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); border-radius: 8px; cursor: pointer; transition: all 0.15s; position: relative; }
        .wb-lib-item:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.15); }
        .wb-lib-item__portrait { width: 44px; height: 44px; border-radius: 50%; background: #8b5cf6; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 16px; color: white; overflow: hidden; }
        .wb-lib-item__portrait img { width: 100%; height: 100%; object-fit: cover; }
        .wb-lib-item__name { font-size: 9px; color: rgba(255,255,255,0.6); text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 65px; }
        .wb-lib-item__delete { position: absolute; top: 2px; right: 2px; width: 16px; height: 16px; border-radius: 50%; background: rgba(239,68,68,0.8); border: none; color: white; font-size: 10px; cursor: pointer; display: none; align-items: center; justify-content: center; line-height: 1; }
        .wb-lib-item:hover .wb-lib-item__delete { display: flex; }
        
        /* Token Sidebar */
        .wb-token-sidebar { position: absolute; top: 70px; left: 16px; background: rgba(22,22,22,0.88); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 100; width: 280px; max-height: calc(100vh - 100px); display: none; overflow: hidden; backdrop-filter: blur(12px); }
        .wb-token-sidebar.visible { display: flex; flex-direction: column; }
        .wb-token-sidebar.collapsed .wb-token-sidebar__body { display: none; }
        .wb-token-sidebar.collapsed { max-height: none !important; height: auto !important; }
        .wb-token-sidebar.collapsed .wb-panel-resize { display: none; }
        .wb-token-sidebar__header { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; border-bottom: 1px solid rgba(255,255,255,0.08); flex-shrink: 0; cursor: grab; user-select: none; }
        .wb-token-sidebar__header:active { cursor: grabbing; }
        .wb-token-sidebar__title { font-size: 12px; font-weight: 600; color: rgba(255,255,255,0.6); text-transform: uppercase; letter-spacing: 0.5px; }
        .wb-token-sidebar__close { width: 24px; height: 24px; background: none; border: none; color: rgba(255,255,255,0.4); cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px; }
        .wb-token-sidebar__close:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-token-sidebar__body { overflow-y: auto; flex: 1; padding: 8px; }
        .wb-token-sidebar__group { margin-bottom: 6px; }
        .wb-token-sidebar__group-header { display: flex; align-items: center; gap: 6px; padding: 6px 8px; font-size: 10px; font-weight: 600; color: rgba(255,255,255,0.35); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; border-radius: 6px; user-select: none; }
        .wb-token-sidebar__group-header:hover { background: rgba(255,255,255,0.05); }
        .wb-token-sidebar__group-header .wb-group-arrow { transition: transform 0.15s; font-size: 8px; }
        .wb-token-sidebar__group.collapsed .wb-group-arrow { transform: rotate(-90deg); }
        .wb-token-sidebar__group.collapsed .wb-token-sidebar__item { display: none; }
        .wb-token-sidebar__group-count { background: rgba(255,255,255,0.1); padding: 1px 6px; border-radius: 8px; font-size: 9px; }
        .wb-token-sidebar__item { display: flex; align-items: center; gap: 10px; padding: 8px 10px; border-radius: 8px; cursor: pointer; transition: background 0.15s; }
        .wb-token-sidebar__item:hover { background: rgba(255,255,255,0.06); }
        .wb-token-sidebar__item.active { background: rgba(139,92,246,0.15); border: 1px solid rgba(139,92,246,0.3); }
        .wb-token-sidebar__item.dead { opacity: 0.4; }
        .wb-token-sidebar__item.multi-selected { background: rgba(139,92,246,0.1); outline: 1px solid rgba(139,92,246,0.4); }
        .wb-token-sidebar__portrait { width: 36px; height: 36px; border-radius: 50%; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: 700; color: white; font-size: 14px; border: 2px solid rgba(255,255,255,0.2); overflow: hidden; }
        .wb-token-sidebar__portrait img { width: 100%; height: 100%; object-fit: cover; }
        .wb-token-sidebar__info { flex: 1; min-width: 0; }
        .wb-token-sidebar__name { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.9); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .wb-token-sidebar__meta { font-size: 11px; color: rgba(255,255,255,0.4); display: flex; gap: 8px; margin-top: 2px; }
        .wb-token-sidebar__hp-bar { width: 100%; height: 4px; background: rgba(255,255,255,0.08); border-radius: 2px; margin-top: 4px; overflow: hidden; }
        .wb-token-sidebar__hp-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }
        .wb-token-sidebar__quick-hp { display: flex; gap: 4px; flex-shrink: 0; }
        .wb-token-sidebar__hp-btn { width: 24px; height: 24px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.6); font-size: 14px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .wb-token-sidebar__hp-btn:hover { background: rgba(255,255,255,0.12); color: white; }
        .wb-token-sidebar__empty { text-align: center; padding: 24px 16px; color: rgba(255,255,255,0.3); font-size: 12px; }
        
        /* Token type select */
        .wb-token-type-grid { display: flex; gap: 6px; margin-bottom: 14px; }
        .wb-token-type-btn { flex: 1; padding: 8px 6px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.5); font-size: 11px; font-weight: 600; cursor: pointer; text-align: center; transition: all 0.15s; }
        .wb-token-type-btn:hover { background: rgba(255,255,255,0.08); color: white; }
        .wb-token-type-btn.active { background: rgba(139,92,246,0.2); border-color: rgba(139,92,246,0.5); color: white; }
        .wb-token-type-btn.active[data-type="npc"] { background: rgba(59,130,246,0.15); border-color: rgba(59,130,246,0.4); }
        .wb-token-type-btn.active[data-type="monster"] { background: rgba(239,68,68,0.15); border-color: rgba(239,68,68,0.4); }
        .wb-token-type-btn.active[data-type="hidden"] { background: rgba(107,114,128,0.2); border-color: rgba(107,114,128,0.4); }
        .wb-tmgr-tabs { display: flex; gap: 4px; margin-bottom: 12px; flex-wrap: wrap; }
        .wb-tmgr-tab { padding: 5px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.5); font-size: 11px; cursor: pointer; transition: all 0.15s; position: relative; }
        .wb-tmgr-tab:hover { background: rgba(255,255,255,0.08); color: white; }
        .wb-tmgr-tab.active { background: rgba(139,92,246,0.2); border-color: rgba(139,92,246,0.5); color: white; }
        .wb-tmgr-tab .wb-tmgr-badge { font-size: 9px; background: rgba(255,255,255,0.12); padding: 1px 5px; border-radius: 8px; margin-left: 4px; }
        .wb-tmgr-list { max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; }
        .wb-tmgr-row { display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); border-radius: 8px; cursor: pointer; transition: all 0.15s; }
        .wb-tmgr-row:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.15); }
        .wb-tmgr-portrait { width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 13px; color: white; overflow: hidden; }
        .wb-tmgr-portrait img { width: 100%; height: 100%; object-fit: cover; }
        .wb-tmgr-info { flex: 1; min-width: 0; }
        .wb-tmgr-name { font-size: 12px; font-weight: 600; color: rgba(255,255,255,0.9); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .wb-tmgr-stats { display: flex; gap: 8px; font-size: 10px; color: rgba(255,255,255,0.4); margin-top: 1px; flex-wrap: wrap; }
        .wb-tmgr-stat { display: flex; align-items: center; gap: 2px; }
        .wb-tmgr-stat svg { width: 10px; height: 10px; opacity: 0.5; }
        .wb-tmgr-actions { display: flex; gap: 4px; flex-shrink: 0; }
        .wb-tmgr-actions button { width: 24px; height: 24px; border-radius: 4px; border: none; background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.5); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
        .wb-tmgr-actions button:hover { background: rgba(255,255,255,0.15); color: white; }
        .wb-tmgr-actions button.del:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        
        .wb-stamps-panel { position: fixed; top: 200px; left: 28px; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px; z-index: 200; display: none; max-width: 260px; }
        .wb-stamps-panel.visible { display: block; }
        .wb-stamps-panel__title { font-size: 11px; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .wb-stamps-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; }
        .wb-stamp { width: 34px; height: 34px; border: none; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; font-size: 18px; transition: all 0.15s; }
        .wb-stamp:hover { background: rgba(255,255,255,0.15); transform: scale(1.1); }
        .wb-stamp.active { background: var(--accent); }
        
        .wb-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2000; }
        .wb-overlay.visible { display: flex; }
        .wb-upload-box { background: #1a1a1a; border: 2px dashed rgba(139,92,246,0.5); border-radius: 16px; padding: 48px; text-align: center; max-width: 90%; transition: all 0.2s; }
        .wb-upload-box.dragover { border-color: #8b5cf6; background: rgba(139,92,246,0.1); transform: scale(1.02); }
        .wb-upload-box svg { width: 56px; height: 56px; color: rgba(255,255,255,0.3); margin-bottom: 16px; }
        .wb-upload-box h3 { color: white; font-size: 18px; margin-bottom: 8px; }
        .wb-upload-box p { color: rgba(255,255,255,0.5); font-size: 13px; margin-bottom: 20px; }
        .wb-upload-actions { display: flex; gap: 12px; justify-content: center; }
        .wb-upload-btn { background: var(--accent, #8b5cf6); color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; }
        .wb-upload-btn:hover { filter: brightness(1.1); }
        .wb-upload-btn--secondary { background: rgba(255,255,255,0.1); }
        .wb-overlay-close { position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border: none; border-radius: 50%; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10; transition: background 0.15s; }
        .wb-overlay-close:hover { background: rgba(255,255,255,0.25); }
        
        .wb-modal__content { background: #1a1a1a; border-radius: 16px; padding: 24px; min-width: 380px; max-width: 90%; border: 1px solid rgba(255,255,255,0.1); }
        .wb-modal__title { font-size: 18px; font-weight: 600; color: white; margin-bottom: 16px; }
        .wb-modal__input { width: 100%; padding: 12px 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 14px; margin-bottom: 16px; box-sizing: border-box; }
        .wb-modal__input:focus { outline: none; border-color: var(--accent); }
        
        /* Grid Settings */
        .wb-grid-preset { padding: 8px 14px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; color: white; font-size: 13px; cursor: pointer; transition: all 0.15s; }
        .wb-grid-preset:hover { background: rgba(255,255,255,0.15); }
        .wb-grid-preset.active { background: var(--accent); border-color: var(--accent); }
        .wb-grid-color { width: 28px; height: 28px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.15s; }
        .wb-grid-color:hover { transform: scale(1.1); }
        .wb-grid-color.active { border-color: white; box-shadow: 0 0 0 2px var(--accent); }
        .wb-modal__actions { display: flex; gap: 12px; justify-content: flex-end; }
        .wb-save-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background 0.15s; }
        .wb-save-item:hover { background: rgba(255,255,255,0.1); }
        .wb-save-item__name { font-weight: 600; color: white; }
        .wb-save-item__date { font-size: 12px; color: rgba(255,255,255,0.5); }
        .wb-save-item__delete { background: rgba(239,68,68,0.2); border: none; color: #ef4444; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .wb-scene-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; max-height: 60vh; overflow-y: auto; padding: 4px; }
        .wb-scene-card { background: rgba(255,255,255,0.05); border-radius: 12px; overflow: hidden; cursor: pointer; transition: all 0.15s; border: 2px solid transparent; }
        .wb-scene-card:hover { background: rgba(255,255,255,0.08); border-color: rgba(139,92,246,0.3); }
        .wb-scene-card__thumb { width: 100%; aspect-ratio: 16/9; background: #0a0a0a; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .wb-scene-card__thumb img { width: 100%; height: 100%; object-fit: cover; }
        .wb-scene-card__thumb svg { width: 32px; height: 32px; color: rgba(255,255,255,0.15); }
        .wb-scene-card__info { padding: 10px 12px; }
        .wb-scene-card__name { font-weight: 600; color: white; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .wb-scene-card__meta { font-size: 11px; color: rgba(255,255,255,0.4); margin-top: 3px; }
        .wb-scene-card__actions { display: flex; gap: 6px; margin-top: 8px; }
        .wb-scene-card__btn { flex: 1; padding: 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.7); font-size: 11px; cursor: pointer; text-align: center; }
        .wb-scene-card__btn:hover { background: rgba(139,92,246,0.2); border-color: rgba(139,92,246,0.4); color: white; }
        .wb-scene-card__btn--danger { color: #ef4444; }
        .wb-scene-card__btn--danger:hover { background: rgba(239,68,68,0.2); border-color: rgba(239,68,68,0.3); }
        
        .wb-context-menu { position: fixed; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 6px; z-index: 3000; display: none; min-width: 150px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
        .wb-context-menu.visible { display: block; }
        .wb-context-item { display: flex; align-items: center; gap: 10px; padding: 10px 14px; border: none; background: transparent; color: rgba(255,255,255,0.8); font-size: 13px; width: 100%; text-align: left; cursor: pointer; border-radius: 6px; }
        .wb-context-item:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-context-item--danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        .wb-context-item svg { width: 16px; height: 16px; opacity: 0.7; }
        .wb-context-divider { height: 1px; background: rgba(255,255,255,0.1); margin: 4px 0; }
        
        .wb-toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(100px); background: rgba(22,22,22,0.95); border: 1px solid rgba(255,255,255,0.1); padding: 12px 24px; border-radius: 12px; color: white; font-size: 14px; z-index: 3000; opacity: 0; transition: all 0.3s; pointer-events: none; }
        .wb-toast.visible { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        /* Initiative Panel */
        .wb-initiative-panel { position: absolute; top: 70px; right: 16px; background: rgba(22,22,22,0.88); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 0; z-index: 100; min-width: 200px; max-height: 60vh; display: none; overflow: hidden; backdrop-filter: blur(12px); }
        .wb-initiative-panel.visible { display: flex; flex-direction: column; }
        .wb-initiative-panel.collapsed #initiativeList { display: none; }
        .wb-initiative-panel.collapsed .wb-initiative-panel__controls button:not(#initCollapseBtn):not(#initCloseBtn) { display: none; }
        .wb-initiative-panel.collapsed { max-height: none !important; height: auto !important; }
        .wb-initiative-panel.collapsed .wb-panel-resize { display: none; }
        .wb-initiative-panel__header { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.1); cursor: grab; user-select: none; flex-shrink: 0; }
        .wb-initiative-panel__header:active { cursor: grabbing; }
        .wb-initiative-panel__title { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.5px; }
        .wb-initiative-panel__controls { display: flex; gap: 6px; }
        .wb-initiative-panel__btn { width: 28px; height: 28px; background: rgba(255,255,255,0.08); border: none; border-radius: 6px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .wb-initiative-panel__btn:hover { background: rgba(255,255,255,0.15); }
        .wb-initiative-panel__btn.active { background: var(--accent); }
        .wb-initiative-item { display: flex; align-items: center; gap: 10px; padding: 8px 10px; border-radius: 8px; cursor: pointer; transition: background 0.15s; margin-bottom: 4px; }
        .wb-initiative-item:hover { background: rgba(255,255,255,0.08); }
        .wb-initiative-item.active { background: rgba(34,197,94,0.2); border: 1px solid rgba(34,197,94,0.4); }
        .wb-initiative-item.dead { opacity: 0.5; }
        .wb-initiative-item__portrait { width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; flex-shrink: 0; overflow: hidden; }
        .wb-initiative-item__portrait img { width: 100%; height: 100%; object-fit: cover; }
        .wb-initiative-item__info { flex: 1; min-width: 0; }
        .wb-initiative-item__name { font-size: 13px; font-weight: 500; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .wb-initiative-item__hp { font-size: 11px; color: rgba(255,255,255,0.5); }
        .wb-initiative-item__init { width: 28px; height: 28px; background: rgba(139,92,246,0.3); border-radius: 6px; font-size: 12px; font-weight: 700; color: white; display: flex; align-items: center; justify-content: center; }
        .wb-initiative-item__init input { width: 100%; height: 100%; background: transparent; border: none; color: white; font-size: 12px; font-weight: 700; text-align: center; }
        
        /* Token Edit Modal */
        .wb-token-edit { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        .wb-token-edit__field { display: flex; flex-direction: column; gap: 4px; }
        .wb-token-edit__label { font-size: 11px; color: rgba(255,255,255,0.5); text-transform: uppercase; }
        .wb-token-edit__input { padding: 10px 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: white; font-size: 14px; }
        .wb-token-edit__input:focus { outline: none; border-color: var(--accent); }
        .wb-size-preset { padding: 8px 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; color: white; font-size: 12px; cursor: pointer; }
        .wb-size-preset:hover { background: rgba(255,255,255,0.15); }
        .wb-size-preset.active { background: var(--accent); border-color: var(--accent); }
        .wb-status-grid { display: flex; flex-wrap: wrap; gap: 6px; }
        .wb-status-btn { width: 32px; height: 32px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; font-size: 16px; cursor: pointer; }
        .wb-status-btn:hover { background: rgba(255,255,255,0.15); }
        .wb-status-btn.active { background: var(--accent); border-color: var(--accent); }
        
        @media (max-width: 768px) {
            .wb-toolbar { padding: 3px 6px; gap: 2px; }
            .wb-menu__trigger { padding: 4px 7px; font-size: 10px; gap: 3px; }
            .wb-toggle { padding: 3px 6px; font-size: 9px; }
            .wb-btn { width: 26px; height: 26px; }
            .wb-btn svg { width: 13px; height: 13px; }
            .wb-layer-tab { padding: 3px 6px; font-size: 9px; }
            .wb-toolbar__sep { display: none; }
        }
        /* Player tokens: default cursor */
        body.player-mode .wb-token { cursor: default !important; }
        /* Aura templates */
        .wb-aura { position: absolute; pointer-events: none; z-index: 48; }
        .wb-aura canvas { position: absolute; top: 0; left: 0; }
        /* Map notes */
        .wb-note { position: absolute; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 49; transition: transform 0.15s; border: 2px solid rgba(255,255,255,0.3); }
        .wb-note:hover { transform: translate(-50%, -50%) scale(1.2); }
        .wb-note svg { width: 16px; height: 16px; }
        .wb-note__tooltip { position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background: rgba(22,22,22,0.95); color: white; padding: 8px 12px; border-radius: 8px; font-size: 12px; white-space: pre-wrap; max-width: 250px; display: none; border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 200; pointer-events: none; }
        .wb-note:hover .wb-note__tooltip, .wb-note.show-tooltip .wb-note__tooltip { display: block; }
        .wb-note--info { background: rgba(59,130,246,0.7); }
        .wb-note--loot { background: rgba(251,191,36,0.7); }
        .wb-note--trap { background: rgba(239,68,68,0.7); }
        .wb-note--door { background: rgba(139,92,246,0.7); }
        .wb-note--custom { background: rgba(107,114,128,0.7); }
        /* Drag & drop overlay */
        .wb-drop-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(139,92,246,0.15); border: 3px dashed rgba(139,92,246,0.6); display: none; align-items: center; justify-content: center; z-index: 500; pointer-events: none; }
        .wb-drop-overlay.visible { display: flex; }
        .wb-drop-overlay__label { background: rgba(22,22,22,0.9); color: white; padding: 16px 32px; border-radius: 12px; font-size: 18px; font-weight: 600; }
        /* Aura tool panel */
        /* Aura templates rendered on canvas, no panel needed */
    </style>

    <!-- Auth Guard: Hide until authenticated -->
    <style>
        body:not(.auth-ready) .app { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) .sheet-container { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) main { opacity: 0; pointer-events: none; }
        body.auth-ready .app { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready .sheet-container { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready main { opacity: 1; transition: opacity 0.15s ease; }
    </style>
</head>
<body>
    <!-- Unified Layout Placeholders -->
    <div id="topnav-placeholder"></div>
    <div id="meganav-placeholder"></div>
    
    <div class="app">
        <main class="main main--hub main--fullwidth">
            <div class="main__content main__content--fullwidth">
                <div class="whiteboard-page">
                <div class="whiteboard-container">
                    <div class="wb-toolbar" id="wbToolbar">
                        <div class="wb-lock-badge" id="lockBadge">Gesperrt</div>
                        
                        <!-- LEFT: Layers + Fog + Undo/Redo -->
                        <div class="wb-toolbar__left">
                            <div class="wb-layers">
                                <button class="wb-layer-tab active" data-layer="main" title="Hauptebene - Zeichnungen und Formen werden hier platziert.">Haupt</button>
                                <button class="wb-layer-tab" data-layer="token" title="Token-Ebene - Interaktion mit Spielfiguren und Markern.">Token</button>
                                <button class="wb-layer-tab wb-layer-tab--fog" data-layer="fog" id="fogTab" title="Nebelebene - Sichtbereiche f. Spieler verwalten. Nur GM.">Nebel</button>
                            </div>
                            <div id="fogControls" class="wb-fog-ctrl" style="display:none">
                                <button class="wb-fog-btn active fog-mode-btn" id="fogPlaceBtn" title="Nebel auf die Karte zeichnen, um Bereiche zu verbergen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>Setzen</button>
                                <button class="wb-fog-btn fog-mode-btn" id="fogRevealBtn" title="Nebel entfernen, um verborgene Bereiche f. Spieler aufzudecken."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2"/></svg>Aufdecken</button>
                                <button class="wb-fog-btn" id="fogAllBtn" title="Die gesamte Karte mit Nebel bedecken."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="1" y="1" width="22" height="22"/></svg>Alles</button>
                                <button class="wb-fog-btn" id="fogClearAllBtn" title="Allen Nebel von der Karte entfernen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/></svg>Leeren</button>
                            </div>
                            <div class="wb-toolbar__sep"></div>
                            <button class="wb-btn" id="undoBtn" title="Letzte Aktion rückgängig machen. Gilt für Zeichnungen und Token-Bewegungen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg></button>
                            <button class="wb-btn" id="redoBtn" title="Rückgängig gemachte Aktion wiederherstellen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.13-9.36L23 10"/></svg></button>
                        </div>
                        
                        <!-- CENTER: Dropdown Menus -->
                        <div class="wb-toolbar__center">
                            <!-- Werkzeuge -->
                            <div class="wb-menu" data-menu="tools">
                                <button class="wb-menu__trigger has-active"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-6 2-2 6z"/></svg>Werkzeuge<svg class="wb-menu__chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="6 9 12 15 18 9"/></svg></button>
                                <div class="wb-dropdown">
                                    <button class="wb-dd-item active" data-tool="select" title="Objekte auf der Karte auswählen, verschieben und bearbeiten."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-6 2-2 6z"/><path d="M14 14l5 5"/></svg>Auswählen<span class="wb-dd-item__key">V</span></button>
                                    <button class="wb-dd-item" data-tool="ruler" title="Entfernungen auf der Karte messen. Zeigt Felder, Fuß und Meter an."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0z"/></svg>Maßband<span class="wb-dd-item__key">M</span></button>
                                    <button class="wb-dd-item" data-tool="ping" title="Einen kurzen visuellen Impuls an eine Stelle senden, um Mitspieler darauf aufmerksam zu machen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="8" stroke-dasharray="4 4"/></svg>Ping</button>
                                    <button class="wb-dd-item" data-tool="focus" title="Kamera aller Spieler auf einen bestimmten Punkt auf der Karte zentrieren."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>Fokus<span class="wb-dd-item__key">F</span></button>
                                    <div class="wb-dd-submenu" id="auraToolBtn">
                                        <button class="wb-dd-item" data-tool="aura" title="Wirkungsbereich auf die Karte zeichnen. Klicken und ziehen um den Radius festzulegen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-dasharray="4 2"/><circle cx="12" cy="12" r="4"/></svg>Wirkungsbereich</button>
                                        <div class="wb-dd-submenu__panel" id="auraShapes">
                                            <button class="wb-dd-item active" data-shape="circle"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg>Kreis</button>
                                            <button class="wb-dd-item" data-shape="cone"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5l8 14H4z"/></svg>Kegel</button>
                                            <button class="wb-dd-item" data-shape="square"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/></svg>Quadrat</button>
                                            <button class="wb-dd-item" data-shape="line"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><line x1="4" y1="20" x2="20" y2="4"/></svg>Linie</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Zeichnen -->
                            <div class="wb-menu" data-menu="draw">
                                <button class="wb-menu__trigger"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>Zeichnen<svg class="wb-menu__chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="6 9 12 15 18 9"/></svg></button>
                                <div class="wb-dropdown" style="min-width:260px">
                                    <button class="wb-dd-item" data-tool="pen" title="Freihandlinien auf die Karte zeichnen. Ideal für schnelle Skizzen und Markierungen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>Freihand<span class="wb-dd-item__key">P</span></button>
                                    <button class="wb-dd-item" data-tool="line" title="Gerade Linie zwischen zwei Punkten zeichnen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg>Linie<span class="wb-dd-item__key">L</span></button>
                                    <button class="wb-dd-item" data-tool="rect" title="Rechteck oder Quadrat zeichnen. Mit Füllung oder nur als Umriss."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>Rechteck<span class="wb-dd-item__key">R</span></button>
                                    <button class="wb-dd-item" data-tool="circle" title="Kreis oder Ellipse zeichnen. Nützlich für Wirkungsbereiche und Markierungen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg>Kreis<span class="wb-dd-item__key">C</span></button>
                                    <button class="wb-dd-item" data-tool="arrow" title="Pfeil zeichnen, um Bewegungsrichtungen oder Ziele zu markieren."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="10 5 19 5 19 14"/></svg>Pfeil<span class="wb-dd-item__key">A</span></button>
                                    <button class="wb-dd-item" data-tool="polygon" title="Mehrseitiges Polygon Punkt für Punkt zeichnen. Doppelklick zum Abschließen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5"/></svg>Polygon<span class="wb-dd-item__key">Shift+P</span></button>
                                    <button class="wb-dd-item" data-tool="text" title="Textfeld auf die Karte setzen. Klicken und tippen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>Text<span class="wb-dd-item__key">T</span></button>
                                    <button class="wb-dd-item" data-tool="eraser" title="Zeichnungen und Striche von der Karte entfernen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 3a2 2 0 012.8 0L21 7.8a2 2 0 010 2.8L11.8 20"/></svg>Radierer<span class="wb-dd-item__key">E</span></button>
                                    <div class="wb-dd-sep"></div>
                                    <div class="wb-dd-label">Strichstärke</div>
                                    <div class="wb-dd-row">
                                        <button class="wb-size-btn" data-size="2" title="Feine Linie"><span class="wb-size-btn__dot" style="width:4px;height:4px"></span></button>
                                        <button class="wb-size-btn active" data-size="4" title="Normale Linie"><span class="wb-size-btn__dot" style="width:8px;height:8px"></span></button>
                                        <button class="wb-size-btn" data-size="8" title="Dicke Linie"><span class="wb-size-btn__dot" style="width:12px;height:12px"></span></button>
                                        <button class="wb-size-btn" data-size="16" title="Sehr dicke Linie"><span class="wb-size-btn__dot" style="width:16px;height:16px"></span></button>
                                    </div>
                                    <div class="wb-dd-label">Farbe</div>
                                    <div class="wb-dd-row" id="colorPalette">
                                        <button class="wb-color-btn active" data-color="#ffffff" style="background:#ffffff" title="Weiß"></button>
                                        <button class="wb-color-btn" data-color="#ef4444" style="background:#ef4444" title="Rot"></button>
                                        <button class="wb-color-btn" data-color="#f97316" style="background:#f97316" title="Orange"></button>
                                        <button class="wb-color-btn" data-color="#eab308" style="background:#eab308" title="Gelb"></button>
                                        <button class="wb-color-btn" data-color="#22c55e" style="background:#22c55e" title="Grün"></button>
                                        <button class="wb-color-btn" data-color="#3b82f6" style="background:#3b82f6" title="Blau"></button>
                                        <button class="wb-color-btn" data-color="#8b5cf6" style="background:#8b5cf6" title="Violett"></button>
                                        <button class="wb-color-btn" data-color="#ec4899" style="background:#ec4899" title="Pink"></button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Einfügen -->
                            <div class="wb-menu" data-menu="insert">
                                <button class="wb-menu__trigger"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>Einfügen<svg class="wb-menu__chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="6 9 12 15 18 9"/></svg></button>
                                <div class="wb-dropdown">
                                    <button class="wb-dd-item" id="imageBtn" title="Ein Bild oder Prop von deinem Gerät auf die Karte laden. Frei skalier- und verschiebbar."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>Bild / Prop</button>
                                    <button class="wb-dd-item" id="stampBtn" title="Vorgefertigte Sticker und Symbole schnell auf der Karte platzieren."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>Sticker</button>
                                    <div class="wb-dd-sep"></div>
                                    <button class="wb-dd-item" id="tokenBtn" title="Neuen Token erstellen. Tokens repräsentieren Spielfiguren, NSCs oder Monster."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg>Token erstellen</button>
                                    <button class="wb-dd-item" id="tokenMgrBtn" title="Alle gespeicherten Token-Vorlagen anzeigen, bearbeiten und auf die Karte laden."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>Token-Bibliothek</button>
                                </div>
                            </div>
                            
                            <!-- Szene -->
                            <div class="wb-menu" data-menu="scene">
                                <button class="wb-menu__trigger"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="9" height="9" rx="1"/><rect x="13" y="2" width="9" height="9" rx="1"/><rect x="2" y="13" width="9" height="9" rx="1"/></svg>Szene<svg class="wb-menu__chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="6 9 12 15 18 9"/></svg></button>
                                <div class="wb-dropdown">
                                    <button class="wb-dd-item" id="sceneManagerBtn" title="Zwischen gespeicherten Szenen wechseln. Jede Szene enthält Karte, Token und Zeichnungen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="9" height="9" rx="1"/><rect x="13" y="2" width="9" height="9" rx="1"/><rect x="2" y="13" width="9" height="9" rx="1"/><rect x="13" y="13" width="9" height="9" rx="1"/></svg>Szenen-Manager</button>
                                    <div class="wb-dd-sep"></div>
                                    <button class="wb-dd-item" id="bgBtn" title="Ein Hintergrundbild als Battlemap laden. Unterstützt JPG, PNG und WebP."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/><path d="M21 15l-5-5L5 21"/></svg>Bild/Map laden</button>
                                    <button class="wb-dd-item" id="saveBtn" title="Aktuelle Szene als JSON-Datei auf deinem Gerät speichern."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>Szene speichern</button>
                                    <button class="wb-dd-item" id="loadBtn" title="Eine zuvor gespeicherte Szene aus einer JSON-Datei wiederherstellen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>Szene laden</button>
                                    <div class="wb-dd-sep"></div>
                                    <button class="wb-dd-item" id="exportBtn" title="Screenshot der aktuellen Kartenansicht als PNG-Bild exportieren."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="12" cy="12" r="3"/><path d="M3 7h2M19 7h2"/></svg>Screenshot</button>
                                    <button class="wb-dd-item" id="exportDataBtn" title="Alle Szenendaten als JSON-Datei exportieren, inklusive Token und Zeichnungen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="M9 15l3 3 3-3"/></svg>Daten exportieren</button>
                                    <input type="file" id="sceneFileInput" accept=".json" style="display:none">
                                </div>
                            </div>
                            
                            <!-- GM -->
                            <div class="wb-menu" data-menu="gm" id="gmMenu" style="display:none">
                                <button class="wb-menu__trigger"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 15a7 7 0 1 0 0-14 7 7 0 0 0 0 14zM2 21a10 10 0 0 1 20 0"/></svg>Spielleitung<svg class="wb-menu__chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="6 9 12 15 18 9"/></svg></button>
                                <div class="wb-dropdown" style="min-width:240px">
                                    <button class="wb-dd-item" id="tokenSidebarBtn" title="Seitenleiste mit allen Token auf der Karte anzeigen. Schneller Zugriff auf HP, Status und Position."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><line x1="14" y1="6" x2="21" y2="6"/><line x1="14" y1="17" x2="21" y2="17"/></svg>Token-Seitenleiste</button>
                                    <button class="wb-dd-item" id="initiativeBtn" title="Initiative-Reihenfolge verwalten. Legt die Zugreihenfolge im Kampf fest."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"/></svg>Initiative-Tracker</button>
                                    <div class="wb-dd-sep"></div>
                                    <button class="wb-dd-item" id="cursorToggleBtn" title="Eigenen Mauszeiger für alle Spieler sichtbar oder unsichtbar machen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-6 2-2 6z"/><path d="M14 14l5 5"/></svg>Cursor anzeigen</button>
                                    <button class="wb-dd-item" id="toolbarLockBtn" title="Zeichenwerkzeuge für Spieler sperren. Spieler können weiterhin Auswählen, Messen und Pingen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>Werkzeuge sperren</button>
                                    <div class="wb-dd-sep"></div>
                                    <button class="wb-dd-item" id="effectsBtn" title="Visuelle Effekte auf der Karte abspielen, z.B. Explosionen oder Wettereffekte."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>Effekte</button>
                                    <button class="wb-dd-item" id="broadcastBtn" title="Nachricht oder Bild an alle Spieler gleichzeitig senden."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4.9 19.1C1 15.2 1 8.8 4.9 4.9"/><path d="M7.8 16.2c-2.3-2.3-2.3-6.1 0-8.4"/><circle cx="12" cy="12" r="2"/><path d="M16.2 7.8c2.3 2.3 2.3 6.1 0 8.4"/><path d="M19.1 4.9C23 8.8 23 15.2 19.1 19.1"/></svg>Broadcast</button>
                                    <button class="wb-dd-item" id="noteBtn" title="Kartennotiz erstellen. Verschiedene Typen: Info, Loot, Gefahr, Quest, Geheim."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>Kartennotiz</button>
                                    <div class="wb-dd-sep"></div>
                                    <button class="wb-dd-item wb-dd-item--danger" id="clearBtn" title="Alle Zeichnungen, Token und Bilder von der Karte entfernen. Kann nicht rückgängig gemacht werden."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>Karte leeren</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- RIGHT: Drawing Toggles + Grid -->
                        <div class="wb-toolbar__right">
                            <button class="wb-toggle" id="fillToggle" title="Formen mit Farbe füllen oder nur den Umriss zeichnen."><span class="wb-toggle__dot"></span>Füllen</button>
                            <button class="wb-toggle" id="snapToggle" title="Objekte automatisch am Raster ausrichten."><span class="wb-toggle__dot"></span>Snap</button>
                            <button class="wb-toggle" id="gridToggle" title="Rasterlinien auf der Karte ein- oder ausblenden."><span class="wb-toggle__dot"></span>Raster</button>
                            <button class="wb-btn" id="gridSettingsBtn" title="Rastergröße, Versatz und Farbe anpassen."><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg></button>
                        </div>
                    </div>
                    <div class="wb-canvas-wrapper" id="canvasWrapper">
                        <canvas class="wb-canvas" id="bgCanvas"></canvas>
                        <canvas class="wb-canvas" id="mainCanvas"></canvas>
                        <canvas class="wb-canvas" id="fogCanvas"></canvas>
                        <canvas class="wb-canvas" id="uiCanvas"></canvas>
                        <div id="wbGrid"></div>
                        <div id="imagesContainer"></div>
                        <div class="wb-radius-indicator wb-radius-move" id="moveRadius"><div class="wb-radius-move__label" id="moveRadiusLabel"></div></div>
                        <div class="wb-radius-origin" id="moveOrigin"></div>
                        <div class="wb-radius-distance" id="moveDistance"></div>
                        <div id="tokensContainer"></div>
                        <div id="remoteCursors"></div>
                        <div id="notesContainer" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:49"></div>
                        <div class="wb-drop-overlay" id="dropOverlay"><div class="wb-drop-overlay__label">Bild hier ablegen</div></div>
                        <div class="wb-token-tooltip" id="tokenTooltip"></div>
                        <!-- Selection Box with Resize Handles -->
                        <div class="wb-select-box" id="selectBox">
                            <div class="wb-resize-handle wb-resize-handle--nw" data-handle="nw"></div>
                            <div class="wb-resize-handle wb-resize-handle--ne" data-handle="ne"></div>
                            <div class="wb-resize-handle wb-resize-handle--sw" data-handle="sw"></div>
                            <div class="wb-resize-handle wb-resize-handle--se" data-handle="se"></div>
                            <div class="wb-resize-handle wb-resize-handle--n" data-handle="n"></div>
                            <div class="wb-resize-handle wb-resize-handle--s" data-handle="s"></div>
                            <div class="wb-resize-handle wb-resize-handle--w" data-handle="w"></div>
                            <div class="wb-resize-handle wb-resize-handle--e" data-handle="e"></div>
                        </div>
                        <div class="wb-marquee" id="marquee"></div>
                        <!-- Format Toolbar for selected elements -->
                        <div class="wb-format-bar" id="formatBar">
                            <button class="wb-format-bar__btn" id="fmtColorBtn" title="Farbe"><div class="wb-format-bar__color" id="fmtColorPreview" style="background:#ffffff"></div></button>
                            <div class="wb-format-bar__sep"></div>
                            <button class="wb-format-bar__btn" id="fmtSizeDown" title="Kleiner">−</button>
                            <span id="fmtSizeLabel" style="color:white;font-size:11px;min-width:24px;text-align:center">4</span>
                            <button class="wb-format-bar__btn" id="fmtSizeUp" title="Größer">+</button>
                            <div class="wb-format-bar__sep"></div>
                            <button class="wb-format-bar__btn" id="fmtBgToggle" title="Hintergrund">BG</button>
                        </div>
                        <input type="color" id="fmtColorPicker" style="position:absolute;opacity:0;pointer-events:none">
                        <div class="wb-ruler-info" id="rulerInfo"></div>
                        <div class="wb-zoom-controls">
                            <button class="wb-zoom-btn" id="zoomInBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                            <div class="wb-zoom-level" id="zoomLevel">100%</div>
                            <button class="wb-zoom-btn" id="zoomOutBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                            <button class="wb-zoom-btn" id="zoomResetBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                        </div>
                    </div>
                </div>
                <div class="wb-stamps-panel" id="stampsPanel"><div class="wb-stamps-panel__title">Sticker</div><div class="wb-stamps-grid" id="stampsGrid"></div></div>
                <input type="text" class="wb-text-input" id="textInput" placeholder="Text...">
                <div class="wb-overlay" id="bgOverlay"><button class="wb-overlay-close" onclick="document.getElementById('bgOverlay').classList.remove('visible')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-upload-box" id="bgUploadBox"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg><h3>Hintergrund</h3><p>Battle Map hochladen</p><div class="wb-upload-actions"><button class="wb-upload-btn" id="bgSelectBtn">Auswählen</button><button class="wb-upload-btn wb-upload-btn--secondary" id="bgRemoveBtn">Entfernen</button></div><input type="file" id="bgFileInput" accept="image/*" style="display:none"></div></div>
                <div class="wb-overlay" id="imageOverlay"><button class="wb-overlay-close" onclick="document.getElementById('imageOverlay').classList.remove('visible');WB._pendingImagePos=null"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-upload-box" id="imageUploadBox"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg><h3>Bild/Prop einfügen</h3><p>Wird platzierbar eingefügt</p><div class="wb-upload-actions"><button class="wb-upload-btn" id="imageSelectBtn">Auswählen</button><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('imageOverlay').classList.remove('visible');WB._pendingImagePos=null">Schliessen</button></div><input type="file" id="imageFileInput" accept="image/*" style="display:none"></div></div>
                <div class="wb-overlay" id="saveOverlay"><div class="wb-modal__content"><div class="wb-modal__title">Szene speichern</div><input type="text" class="wb-modal__input" id="saveNameInput" placeholder="Szene-Name..."><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('saveOverlay').classList.remove('visible')">Abbrechen</button><button class="wb-upload-btn" id="saveConfirmBtn">Speichern</button></div></div></div>
                <div class="wb-overlay" id="sceneManagerOverlay"><button class="wb-overlay-close" onclick="document.getElementById('sceneManagerOverlay').classList.remove('visible')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-modal__content" style="min-width:550px;max-width:800px"><div class="wb-modal__title" style="display:flex;justify-content:space-between;align-items:center">Szene-Manager <span id="sceneCount" style="font-size:12px;color:rgba(255,255,255,0.4);font-weight:400"></span></div><div id="sceneGrid" class="wb-scene-grid"></div><div style="margin-top:16px;text-align:center"><p id="sceneEmpty" style="color:rgba(255,255,255,0.4);font-size:13px;display:none">Noch keine Szenen gespeichert.</p></div><div class="wb-modal__actions" style="margin-top:12px"><button class="wb-upload-btn" id="sceneManagerSaveBtn">Akt. Szene Speichern</button><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('sceneManagerOverlay').classList.remove('visible')">Schließen</button></div></div></div>
                <div class="wb-overlay" id="tokenOverlay">
                    <div class="wb-modal__content" style="min-width:400px;max-height:85vh;overflow-y:auto">
                        <div class="wb-modal__title" style="display:flex;justify-content:space-between;align-items:center">Token erstellen <button id="tokenLoadLibBtn" style="background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:6px;padding:4px 10px;color:rgba(255,255,255,0.7);font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>Token-Manager</button></div>
                        
                        <!-- Type Selection -->
                        <div class="wb-token-type-grid">
                            <button class="wb-token-type-btn active" data-type="player">Spieler</button>
                            <button class="wb-token-type-btn" data-type="npc">NPC</button>
                            <button class="wb-token-type-btn" data-type="monster">Monster</button>
                            <button class="wb-token-type-btn" data-type="hidden">Versteckt</button>
                        </div>
                        
                        <!-- Name -->
                        <input type="text" class="wb-modal__input" id="tokenNameInput" placeholder="Name...">
                        
                        <!-- Portrait + Colors -->
                        <div style="display:flex;gap:16px;margin-bottom:16px">
                            <div id="tokenPortraitPreview" style="width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;cursor:pointer;overflow:hidden;flex-shrink:0;border:3px solid #8b5cf6" title="Portrait hochladen">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                            </div>
                            <div style="flex:1">
                                <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px">Hintergrund</div>
                                <div style="display:flex;gap:6px;flex-wrap:wrap" id="tokenColorPicker"></div>
                            </div>
                        </div>
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px">Rahmenfarbe</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap" id="tokenBorderPicker"></div>
                        </div>
                        <input type="file" id="tokenPortraitInput" accept="image/*" style="display:none">
                        
                        <!-- Stats Grid -->
                        <div class="wb-token-edit">
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">HP</label>
                                <input type="number" class="wb-token-edit__input" id="createTokenHp" placeholder="0" min="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Max HP</label>
                                <input type="number" class="wb-token-edit__input" id="createTokenMaxHp" placeholder="0" min="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">AC / Rüstung</label>
                                <input type="number" class="wb-token-edit__input" id="createTokenAc" placeholder="10" min="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Bewegung (Felder)</label>
                                <input type="number" class="wb-token-edit__input" id="createTokenSpeed" placeholder="6" min="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Reichweite (Felder)</label>
                                <input type="number" class="wb-token-edit__input" id="createTokenRange" placeholder="1" min="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Initiative</label>
                                <input type="number" class="wb-token-edit__input" id="createTokenInit" placeholder="--" min="0">
                            </div>
                        </div>
                        
                        <!-- Size Presets -->
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Token-Größe</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap" id="createTokenSizePresets">
                                <button class="wb-size-preset" data-size="44" data-grid="1">Klein (1x1)</button>
                                <button class="wb-size-preset active" data-size="70" data-grid="1">Normal (1x1)</button>
                                <button class="wb-size-preset" data-size="140" data-grid="2">Groß (2x2)</button>
                                <button class="wb-size-preset" data-size="210" data-grid="3">Riesig (3x3)</button>
                                <button class="wb-size-preset" data-size="280" data-grid="4">Kolossal (4x4)</button>
                            </div>
                        </div>
                        
                        <!-- GM Notes -->
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px;text-transform:uppercase">GM-Notiz</div>
                            <textarea class="wb-token-edit__input" id="createTokenNotes" placeholder="Nur für den GM sichtbar..." style="width:100%;min-height:48px;resize:vertical;font-family:inherit;box-sizing:border-box"></textarea>
                        </div>
                        
                        <!-- Zugehörigkeit -->
                        <div style="margin-bottom:16px">
                            <div class="wb-token-field-row">
                                <div class="wb-token-edit__field">
                                    <label class="wb-token-edit__label">Zugehörigkeit</label>
                                    <input type="text" class="wb-token-edit__input" id="createTokenAffiliation" placeholder="z.B. Gilde der Magier, Orks...">
                                </div>
                                <button class="wb-vis-toggle visible-to-players" id="createAffVis" title="Für Spieler sichtbar"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></button>
                            </div>
                        </div>
                        
                        <!-- Items -->
                        <div style="margin-bottom:16px">
                            <div class="wb-token-field-row">
                                <div class="wb-token-edit__field">
                                    <label class="wb-token-edit__label">Items</label>
                                    <input type="text" class="wb-token-edit__input" id="createTokenItems" placeholder="z.B. Schwert, Heiltrank, Schlüssel...">
                                </div>
                                <button class="wb-vis-toggle visible-to-players" id="createItemsVis" title="Für Spieler sichtbar"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></button>
                            </div>
                        </div>
                        
                        <div class="wb-modal__actions">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('tokenOverlay').classList.remove('visible')">Abbrechen</button>
                            <button class="wb-upload-btn wb-upload-btn--secondary" id="tokenSaveLibBtn" title="Token im Manager speichern"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" style="display:inline;vertical-align:middle;margin-right:4px"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>Speichern</button>
                            <button class="wb-upload-btn" id="tokenCreateBtn">Erstellen</button>
                        </div>
                    </div>
                </div>
                
                <!-- Token Library Overlay -->
                <div class="wb-overlay" id="tokenLibOverlay">
                    <div class="wb-modal__content" style="min-width:500px;max-width:650px;max-height:85vh;overflow-y:auto">
                        <div class="wb-modal__title" style="display:flex;justify-content:space-between;align-items:center">Token-Manager <span id="tokenLibCount" style="font-size:11px;color:rgba(255,255,255,0.4);font-weight:400"></span></div>
                        <div class="wb-tmgr-tabs" id="tmgrTabs">
                            <button class="wb-tmgr-tab active" data-tab="all">Alle</button>
                            <button class="wb-tmgr-tab" data-tab="player">Spieler</button>
                            <button class="wb-tmgr-tab" data-tab="npc">NPC</button>
                            <button class="wb-tmgr-tab" data-tab="monster">Monster</button>
                            <button class="wb-tmgr-tab" data-tab="hidden">Versteckt</button>
                        </div>
                        <div class="wb-tmgr-list" id="tokenLibGrid"></div>
                        <div class="wb-modal__actions" style="margin-top:12px">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('tokenLibOverlay').classList.remove('visible')">Schliessen</button>
                            <button class="wb-upload-btn" id="tmgrNewTokenBtn">Neuen Token erstellen</button>
                        </div>
                    </div>
                </div>
                <div class="wb-context-menu" id="contextMenu"></div>
                
                <!-- Token Sidebar -->
                <div class="wb-token-sidebar" id="tokenSidebar">
                    <div class="wb-token-sidebar__header">
                        <span class="wb-token-sidebar__title">Tokens</span>
                        <div style="display:flex;gap:4px">
                            <button class="wb-token-sidebar__close" id="tokenSidebarCollapse" title="Ein-/Ausklappen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></button>
                            <button class="wb-token-sidebar__close" id="tokenSidebarClose" title="Schliessen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                        </div>
                    </div>
                    <div class="wb-token-sidebar__body" id="tokenSidebarBody"></div>
                    <div class="wb-panel-resize" data-resize="tokenSidebar"></div>
                </div>
                
                <!-- Initiative Panel -->
                <div class="wb-initiative-panel" id="initiativePanel">
                    <div class="wb-initiative-panel__header">
                        <span class="wb-initiative-panel__title">Initiative</span>
                        <div class="wb-initiative-panel__controls">
                            <button class="wb-initiative-panel__btn" id="initPrevBtn" title="Vorheriger"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initNextBtn" title="Nächster"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initSortBtn" title="Sortieren"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5h10M11 9h7M11 13h4M3 17l3 3 3-3M6 18V4"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initCollapseBtn" title="Ein-/Ausklappen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initCloseBtn" title="Schliessen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                        </div>
                    </div>
                    <div id="initiativeList" style="overflow-y:auto;flex:1;padding:8px 12px"></div>
                    <div class="wb-panel-resize" data-resize="initiativePanel"></div>
                </div>
                
                <!-- Effects iframe panel -->
                <div class="wb-iframe-panel" id="effectsPanel" style="width:1300px;height:800px">
                    <div class="wb-iframe-panel__header">
                        <span class="wb-iframe-panel__title">Effekte</span>
                        <button class="wb-iframe-panel__close" onclick="document.getElementById('effectsPanel').classList.remove('visible');document.getElementById('effectsFrame').src='about:blank'"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                    </div>
                    <iframe id="effectsFrame" src="about:blank"></iframe>
                    <div class="wb-panel-resize" data-resize="effectsPanel"></div>
                </div>
                
                <!-- Broadcast iframe panel -->
                <div class="wb-iframe-panel" id="broadcastPanel" style="width:1300px;height:800px">
                    <div class="wb-iframe-panel__header">
                        <span class="wb-iframe-panel__title">Broadcast</span>
                        <button class="wb-iframe-panel__close" onclick="document.getElementById('broadcastPanel').classList.remove('visible');document.getElementById('broadcastFrame').src='about:blank'"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                    </div>
                    <iframe id="broadcastFrame" src="about:blank"></iframe>
                    <div class="wb-panel-resize" data-resize="broadcastPanel"></div>
                </div>
                
                <!-- Token Edit Modal -->
                <div class="wb-overlay" id="tokenEditOverlay">
                    <div class="wb-modal__content" style="min-width:400px;max-height:85vh;overflow-y:auto">
                        <div class="wb-modal__title">Token bearbeiten</div>
                        
                        <!-- Type Selection -->
                        <div class="wb-token-type-grid" id="editTokenTypeGrid">
                            <button class="wb-token-type-btn active" data-type="player">Spieler</button>
                            <button class="wb-token-type-btn" data-type="npc">NPC</button>
                            <button class="wb-token-type-btn" data-type="monster">Monster</button>
                            <button class="wb-token-type-btn" data-type="hidden">Versteckt</button>
                        </div>
                        
                        <input type="text" class="wb-modal__input" id="editTokenName" placeholder="Name...">
                        
                        <!-- Portrait Edit -->
                        <div style="display:flex;gap:16px;margin-bottom:16px">
                            <div id="editTokenPortraitPreview" style="width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;cursor:pointer;overflow:hidden;flex-shrink:0;border:3px solid #8b5cf6" title="Portrait ändern">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                            </div>
                            <div style="flex:1">
                                <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:4px">Portrait</div>
                                <div style="display:flex;gap:6px">
                                    <button class="wb-upload-btn" id="editTokenPortraitBtn" style="font-size:11px;padding:6px 12px">Ändern</button>
                                    <button class="wb-upload-btn wb-upload-btn--secondary" id="editTokenPortraitRemoveBtn" style="font-size:11px;padding:6px 12px">Entfernen</button>
                                </div>
                                <input type="file" id="editTokenPortraitInput" accept="image/*" style="display:none">
                            </div>
                        </div>
                        
                        <!-- Border Color -->
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px;text-transform:uppercase">Rahmenfarbe</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap" id="editTokenBorderPicker"></div>
                        </div>
                        
                        <div class="wb-token-edit">
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">HP</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenHp" placeholder="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Max HP</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenMaxHp" placeholder="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Initiative</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenInit" placeholder="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">AC / Rüstung</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenAc" placeholder="10">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Bewegung (Felder)</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenSpeed" placeholder="6">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Reichweite (Felder)</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenRange" placeholder="1">
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Token-Größe</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap" id="tokenSizePresets">
                                <button class="wb-size-preset" data-size="44" data-grid="1">Klein (1x1)</button>
                                <button class="wb-size-preset" data-size="70" data-grid="1">Normal (1x1)</button>
                                <button class="wb-size-preset" data-size="140" data-grid="2">Groß (2x2)</button>
                                <button class="wb-size-preset" data-size="210" data-grid="3">Riesig (3x3)</button>
                                <button class="wb-size-preset" data-size="280" data-grid="4">Kolossal (4x4)</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Status-Effekte</div>
                            <div class="wb-status-grid" id="statusGrid">
                                <button class="wb-status-btn" data-status="dead" title="Tot"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#ef4444" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 8l8 8M16 8l-8 8"/></svg></button>
                                <button class="wb-status-btn" data-status="unconscious" title="Bewusstlos"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#f59e0b" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 15s0-3 4-3 4 3 4 3"/><line x1="9" y1="9" x2="9.01" y2="9" stroke-width="3"/><line x1="15" y1="9" x2="15.01" y2="9" stroke-width="3"/></svg></button>
                                <button class="wb-status-btn" data-status="poisoned" title="Vergiftet"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#22c55e" stroke-width="2"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2z"/><path d="M12 8v4M12 16h.01"/></svg></button>
                                <button class="wb-status-btn" data-status="burning" title="Brennend"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#f97316" stroke-width="2"><path d="M12 22c-4-3-8-6-8-11a8 8 0 0 1 16 0c0 5-4 8-8 11z"/><path d="M12 22c-1.5-2-3-3.5-3-6a3 3 0 0 1 6 0c0 2.5-1.5 4-3 6z"/></svg></button>
                                <button class="wb-status-btn" data-status="frozen" title="Gefroren"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#38bdf8" stroke-width="2"><line x1="12" y1="2" x2="12" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/><line x1="19.07" y1="4.93" x2="4.93" y2="19.07"/></svg></button>
                                <button class="wb-status-btn" data-status="stunned" title="Betäubt"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#eab308" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></button>
                                <button class="wb-status-btn" data-status="invisible" title="Unsichtbar"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#a78bfa" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/><line x1="2" y1="2" x2="22" y2="22" stroke="#ef4444"/></svg></button>
                                <button class="wb-status-btn" data-status="blessed" title="Gesegnet"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#fbbf24" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg></button>
                                <button class="wb-status-btn" data-status="cursed" title="Verflucht"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#a855f7" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg></button>
                                <button class="wb-status-btn" data-status="prone" title="Liegend"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#6b7280" stroke-width="2"><path d="M4 16h16M8 12h8M6 8h12"/></svg></button>
                                <button class="wb-status-btn" data-status="grappled" title="Gepackt"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#f87171" stroke-width="2"><path d="M18 8a6 6 0 0 0-12 0c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg></button>
                                <button class="wb-status-btn" data-status="concentrating" title="Konzentriert"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#3b82f6" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg></button>
                            </div>
                        </div>
                        
                        <!-- GM Notes -->
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px;text-transform:uppercase">GM-Notiz</div>
                            <textarea class="wb-token-edit__input" id="editTokenNotes" placeholder="Nur für den GM sichtbar..." style="width:100%;min-height:56px;resize:vertical;font-family:inherit;box-sizing:border-box"></textarea>
                        </div>
                        
                        <!-- Zugehörigkeit -->
                        <div style="margin-bottom:16px">
                            <div class="wb-token-field-row">
                                <div class="wb-token-edit__field">
                                    <label class="wb-token-edit__label">Zugehörigkeit</label>
                                    <input type="text" class="wb-token-edit__input" id="editTokenAffiliation" placeholder="z.B. Gilde der Magier, Orks...">
                                </div>
                                <button class="wb-vis-toggle visible-to-players" id="editAffVis" title="Für Spieler sichtbar"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></button>
                            </div>
                        </div>
                        
                        <!-- Items -->
                        <div style="margin-bottom:16px">
                            <div class="wb-token-field-row">
                                <div class="wb-token-edit__field">
                                    <label class="wb-token-edit__label">Items</label>
                                    <input type="text" class="wb-token-edit__input" id="editTokenItems" placeholder="z.B. Schwert, Heiltrank, Schlüssel...">
                                </div>
                                <button class="wb-vis-toggle visible-to-players" id="editItemsVis" title="Für Spieler sichtbar"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></button>
                            </div>
                        </div>
                        
                        <div class="wb-modal__actions">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('tokenEditOverlay').classList.remove('visible')">Abbrechen</button>
                            <button class="wb-upload-btn" id="tokenEditSaveBtn">Speichern</button>
                        </div>
                    </div>
                </div>
                
                <!-- Grid Settings Overlay -->
                <div class="wb-overlay" id="gridOverlay">
                    <div class="wb-modal__content" style="min-width:380px">
                        <div class="wb-modal__title">Raster-Einstellungen</div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Raster-Größe (px pro Feld)</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px" id="gridPresets">
                                <button class="wb-grid-preset" data-size="40">40</button>
                                <button class="wb-grid-preset" data-size="50">50</button>
                                <button class="wb-grid-preset active" data-size="70">70</button>
                                <button class="wb-grid-preset" data-size="100">100</button>
                                <button class="wb-grid-preset" data-size="140">140</button>
                            </div>
                            <div style="display:flex;align-items:center;gap:8px">
                                <span style="font-size:12px;color:rgba(255,255,255,0.6)">Custom:</span>
                                <input type="number" id="gridSizeInput" class="wb-modal__input" style="width:80px;padding:6px 10px" value="70" min="10" max="500">
                                <span style="font-size:12px;color:rgba(255,255,255,0.4)">px</span>
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Raster-Offset (Verschiebung)</div>
                            <div style="display:flex;gap:16px">
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">X:</label>
                                    <input type="number" id="gridOffsetX" class="wb-modal__input" style="width:100%;padding:6px 10px" value="0">
                                </div>
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">Y:</label>
                                    <input type="number" id="gridOffsetY" class="wb-modal__input" style="width:100%;padding:6px 10px" value="0">
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.05);border-radius:8px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">An Karte anpassen</div>
                            <div style="font-size:11px;color:rgba(255,255,255,0.4);margin-bottom:10px">Gib die Anzahl Felder der Karte ein</div>
                            <div style="display:flex;gap:12px;align-items:end">
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">Breite:</label>
                                    <input type="number" id="gridFitWidth" class="wb-modal__input" style="width:100%;padding:6px 10px" placeholder="z.B. 30">
                                </div>
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">Höhe:</label>
                                    <input type="number" id="gridFitHeight" class="wb-modal__input" style="width:100%;padding:6px 10px" placeholder="z.B. 20">
                                </div>
                                <button class="wb-upload-btn" id="gridFitBtn" style="white-space:nowrap">Anpassen</button>
                            </div>
                            <div id="gridFitInfo" style="font-size:11px;color:rgba(139,92,246,0.8);margin-top:8px;display:none"></div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Raster-Farbe</div>
                            <div style="display:flex;gap:6px" id="gridColorPicker">
                                <button class="wb-grid-color active" data-color="rgba(255,255,255,0.12)" style="background:rgba(255,255,255,0.3)"></button>
                                <button class="wb-grid-color" data-color="rgba(0,0,0,0.2)" style="background:rgba(0,0,0,0.5)"></button>
                                <button class="wb-grid-color" data-color="rgba(139,92,246,0.3)" style="background:rgba(139,92,246,0.6)"></button>
                                <button class="wb-grid-color" data-color="rgba(59,130,246,0.3)" style="background:rgba(59,130,246,0.6)"></button>
                                <button class="wb-grid-color" data-color="rgba(234,179,8,0.3)" style="background:rgba(234,179,8,0.6)"></button>
                            </div>
                        </div>
                        
                        <div class="wb-modal__actions">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('gridOverlay').classList.remove('visible')">Schließen</button>
                            <button class="wb-upload-btn" id="gridApplyBtn">Anwenden</button>
                        </div>
                    </div>
                </div>
                
                <!-- Note Creation Overlay -->
                <div class="wb-overlay" id="noteOverlay">
                    <div class="wb-modal__content" style="min-width:340px">
                        <div class="wb-modal__title">Notiz erstellen</div>
                        <label style="font-size:11px;color:rgba(255,255,255,0.5);display:block;margin-bottom:4px">Typ</label>
                        <div style="display:flex;gap:6px;margin-bottom:12px" id="noteTypes">
                            <button class="wb-btn active" data-type="info" style="background:rgba(59,130,246,0.4);flex:1;font-size:11px">Info</button>
                            <button class="wb-btn" data-type="loot" style="background:rgba(251,191,36,0.3);flex:1;font-size:11px">Loot</button>
                            <button class="wb-btn" data-type="trap" style="background:rgba(239,68,68,0.3);flex:1;font-size:11px">Falle</button>
                            <button class="wb-btn" data-type="door" style="background:rgba(139,92,246,0.3);flex:1;font-size:11px">Tür</button>
                            <button class="wb-btn" data-type="custom" style="background:rgba(107,114,128,0.3);flex:1;font-size:11px">Marker</button>
                        </div>
                        <label style="font-size:11px;color:rgba(255,255,255,0.5);display:block;margin-bottom:4px">Titel</label>
                        <input type="text" class="wb-modal__input" id="noteTitle" placeholder="z.B. Geheimtür" style="margin-bottom:8px">
                        <label style="font-size:11px;color:rgba(255,255,255,0.5);display:block;margin-bottom:4px">Beschreibung (GM only)</label>
                        <textarea class="wb-modal__input" id="noteText" placeholder="Nur für GM sichtbar..." style="height:80px;resize:vertical"></textarea>
                        <label style="display:flex;align-items:center;gap:6px;margin-top:8px;font-size:12px;color:rgba(255,255,255,0.6);cursor:pointer"><input type="checkbox" id="noteVisibleToPlayers" checked> Marker für Spieler sichtbar</label>
                        <div class="wb-modal__actions" style="margin-top:12px">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('noteOverlay').classList.remove('visible');WB._editingNoteId=null">Abbrechen</button>
                            <button class="wb-upload-btn" id="noteSaveBtn">Platzieren</button>
                        </div>
                    </div>
                </div>
                
                <div class="wb-toast" id="wbToast"></div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Dock Placeholder -->
    <div id="dock-placeholder"></div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    <script src="assets/js/firebase-config.js"></script>
    <script>
        // Auth Guard - redirect to login if not authenticated
        (function() {
            function waitForAuth() {
                // Wait for Firebase SDK
                if (typeof firebase === 'undefined' || !firebase.auth) {
                    return setTimeout(waitForAuth, 50);
                }
                // Wait for Firebase app initialization
                try {
                    var auth = firebase.auth();
                    auth.onAuthStateChanged(function(user) {
                        if (!user) {
                            window.location.href = '/login';
                        } else {
                            document.body.classList.add('auth-ready');
                        }
                    });
                } catch(e) {
                    // Firebase not initialized yet, retry
                    setTimeout(waitForAuth, 50);
                }
            }
            waitForAuth();
        })();
    </script>

    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    <script src="assets/js/pro-status.js"></script>
    <script src="assets/js/toast-service.js"></script>
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/layout-unified.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/admin.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    <script>initUnifiedLayout();</script>
    <script src="assets/js/broadcast.js"></script>
    <script>
const WB = {
    // Canvases
    bgCanvas: null, bgCtx: null, mainCanvas: null, mainCtx: null,
    fogCanvas: null, fogCtx: null, uiCanvas: null, uiCtx: null,
    
    // State
    layer: 'main', tool: 'select', color: '#ffffff', size: 4,
    fill: false, snap: true, gridSize: 70, gridOffsetX: 0, gridOffsetY: 0,
    gridColor: 'rgba(0,0,0,0.25)', zoom: 1, panX: 0, panY: 0,
    
    // Smooth animation targets
    targetZoom: 1, targetPanX: 0, targetPanY: 0,
    animationFrame: null, lastFrameTime: 0,
    
    // Drawing
    isDrawing: false, isPanning: false, isDragging: false, isResizing: false,
    spacePressed: false, // For hand tool (spacebar pan)
    startPoint: null, currentPath: [], polygonPoints: [],
    resizeHandle: null, dragOffset: { x: 0, y: 0 },
    
    // Data
    strokes: [], images: [], tokens: [], fogAreas: [],
    selected: null, // Single selected item
    bgImage: null, bgDataUrl: null, history: [], historyIdx: -1,
    toolbarLocked: false, multiSelected: [], isMarquee: false, marqueeStart: null,
    
    // User
    roomCode: null, db: null, userId: null, userName: null,
    userColor: '#8b5cf6', isGM: false,
    
    // Stamps
    stamps: ['⚔️','🛡️','💀','👑','🗝️','💎','🔥','❄️','⚡','💧','🌟','🏰','🚪','⬆️','⬇️','⬅️','➡️','❌','✅','❓','💰','📜','🧪','🗡️','🏹','🪄','🎭','👁️','🐉','🧙'],
    selectedStamp: null, pendingTokenColor: '#8b5cf6',
    
    // Initiative tracker
    initiativeActive: null, // Token ID of currently active turn
    initiativeOrder: [], // Sorted list of token IDs
    editingToken: null, // Token being edited in modal
    
    async init() {
        console.log('[WB] Starting...');
        this.bgCanvas = document.getElementById('bgCanvas');
        this.mainCanvas = document.getElementById('mainCanvas');
        this.fogCanvas = document.getElementById('fogCanvas');
        this.uiCanvas = document.getElementById('uiCanvas');
        this.bgCtx = this.bgCanvas.getContext('2d');
        this.mainCtx = this.mainCanvas.getContext('2d');
        this.fogCtx = this.fogCanvas.getContext('2d');
        this.uiCtx = this.uiCanvas.getContext('2d');
        
        // Enable high-quality image rendering
        [this.bgCtx, this.mainCtx, this.fogCtx, this.uiCtx].forEach(ctx => {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        });
        
        this.roomCode = localStorage.getItem('rift_current_room');
        const u = JSON.parse(localStorage.getItem('rift_user') || '{}');
        this.userId = u.odUserId || Math.random().toString(36).substr(2, 9);
        this.userName = u.displayName || 'Anonym';
        this.userColor = u.color || '#8b5cf6';
        this.isGM = u.isGM || u.isCogm || false;
        
        // For players: fog layer covers tokens visually but allows mouse events through
        if (!this.isGM) {
            const fc = document.getElementById('fogCanvas');
            fc.style.zIndex = '51'; // Above tokens (50), below cursors (55)
            fc.style.pointerEvents = 'none'; // Allow hover/click on tokens through fog
            document.body.classList.add('player-mode');
        }
        
        this.addUserColor();
        if (this.isGM) {
            document.getElementById('gmMenu').style.display = '';
            // Default open panels for GM
            document.getElementById('tokenSidebar').classList.add('visible');
            document.getElementById('initiativePanel').classList.add('visible');
            document.getElementById('tokenSidebarBtn').classList.add('active-red');
            document.getElementById('initiativeBtn').classList.add('active-red');
            this.renderTokenSidebar();
        }
        else document.getElementById('fogTab').style.display = 'none';
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.setupToolbar();
        this.setupCanvas();
        this.setupKeyboard();
        this.setupUploads();
        this.setupStamps();
        this.setupModals();
        this.setupContextMenu();
        this.setupResizeHandles();
        this.setupFormatBar();
        this.setupTokenEditModal();
        this.setupInitiative();
        this.setupTokenSidebar();
        this.setupCursorTracking();
        this.setupTokenTooltip();
        this.setupToolbarLock();
        this.setupTokenLibrary();
        this.setupAura();
        this.setupNotes();
        this.setupDraggablePanels();
        this.setupDragDrop();
        
        if (this.roomCode) await this.connectFirebase();
        this.updateCursor();
        this.render();
        console.log('[WB] Ready!');
    },
    
    resize() {
        const w = document.getElementById('canvasWrapper');
        const r = w.getBoundingClientRect();
        [this.bgCanvas, this.mainCanvas, this.fogCanvas, this.uiCanvas].forEach(c => {
            c.width = r.width; c.height = r.height;
        });
        this.render();
    },
    
    addUserColor() {
        const p = document.getElementById('colorPalette');
        const cols = [...p.querySelectorAll('.wb-color-btn')].map(b => b.dataset.color.toLowerCase());
        if (!cols.includes(this.userColor.toLowerCase())) {
            const btn = document.createElement('button');
            btn.className = 'wb-color-btn';
            btn.dataset.color = this.userColor;
            btn.style.background = this.userColor;
            btn.onclick = () => this.setColor(this.userColor);
            // Insert after last color button, not before chevron
            const lastColorBtn = [...p.querySelectorAll('.wb-color-btn')].pop();
            if (lastColorBtn && lastColorBtn.nextSibling) p.insertBefore(btn, lastColorBtn.nextSibling);
            else p.appendChild(btn);
        }
    },
    
    // ==================== TOOLBAR ====================
    setupToolbar() {
        // Dropdown menus: open on hover (CSS handles display), click trigger closes
        document.querySelectorAll('.wb-menu').forEach(menu => {
            const trigger = menu.querySelector('.wb-menu__trigger');
            let closeTimeout;
            menu.addEventListener('mouseenter', () => { clearTimeout(closeTimeout); menu.classList.add('open'); });
            menu.addEventListener('mouseleave', () => { closeTimeout = setTimeout(() => menu.classList.remove('open'), 120); });
            // Click on trigger toggles open state (for touch devices)
            if (trigger) trigger.onclick = (e) => { e.stopPropagation(); menu.classList.toggle('open'); };
        });
        // Click outside closes all menus
        document.addEventListener('click', () => { document.querySelectorAll('.wb-menu').forEach(m => m.classList.remove('open')); });
        
        // Aura tool: GM only
        if (!this.isGM) {
            document.getElementById('auraToolBtn')?.remove();
        }
        
        document.querySelectorAll('.wb-layer-tab').forEach(t => {
            t.onclick = () => {
                document.querySelectorAll('.wb-layer-tab').forEach(x => x.classList.remove('active'));
                t.classList.add('active');
                this.layer = t.dataset.layer;
                // Toggle fog controls visibility
                const fogControls = document.getElementById('fogControls');
                if (fogControls) {
                    fogControls.style.display = (this.layer === 'fog' && this.isGM) ? 'flex' : 'none';
                }
                // Auto-switch tool when entering fog mode (allow pen, rect, circle, polygon)
                if (this.layer === 'fog' && this.isGM) {
                    this._fogMode = this._fogMode || 'place';
                    const fogTools = ['rect', 'circle', 'pen', 'polygon'];
                    if (!fogTools.includes(this.tool)) {
                        document.querySelectorAll('[data-tool]').forEach(x => x.classList.remove('active'));
                        document.querySelector('[data-tool="rect"]')?.classList.add('active');
                        this.tool = 'rect';
                    }
                    this.fill = true;
                    document.getElementById('fillToggle')?.classList.add('active');
                    this.updateCursor();
                    this.toast(this._fogMode === 'place' ? 'Nebel: Zeichne/Ziehe um Nebel zu setzen' : 'Nebel: Zeichne/Ziehe um aufzudecken');
                }
            };
        });
        
        // Fog Place button
        const fogPlaceBtn = document.getElementById('fogPlaceBtn');
        if (fogPlaceBtn) {
            fogPlaceBtn.onclick = () => {
                this._fogMode = 'place';
                document.querySelectorAll('.fog-mode-btn').forEach(b => { b.classList.remove('active'); b.classList.remove('active-green'); });
                fogPlaceBtn.classList.add('active');
                this.fill = true;
                this.updateCursor();
                this.toast('Nebel setzen: Zeichne/Ziehe zum Setzen');
            };
        }
        
        // Fog Reveal button
        const fogRevealBtn = document.getElementById('fogRevealBtn');
        if (fogRevealBtn) {
            fogRevealBtn.onclick = () => {
                this._fogMode = 'reveal';
                document.querySelectorAll('.fog-mode-btn').forEach(b => { b.classList.remove('active'); b.classList.remove('active-green'); });
                fogRevealBtn.classList.add('active-green');
                this.fill = true;
                this.updateCursor();
                this.toast('Nebel aufdecken: Zeichne/Ziehe zum Aufdecken');
            };
        }
        
        // Fog cover all
        const fogAllBtn = document.getElementById('fogAllBtn');
        if (fogAllBtn) {
            fogAllBtn.onclick = () => {
                if (!confirm('Gesamte Map mit Nebel bedecken?')) return;
                const ctx = this.fogCtx;
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.fillRect(0, 0, this.fogCanvas.width, this.fogCanvas.height);
                // Save as a full-cover stroke
                const stroke = {
                    id: 'fog-all-' + Date.now(), layer: 'fog', tool: 'rect',
                    color: 'rgba(0,0,0,1)', size: 1, fill: true,
                    start: { x: -10000, y: -10000 }, end: { x: 10000, y: 10000 },
                    userId: this.userId, ts: Date.now()
                };
                this.strokes.push(stroke);
                this.syncStroke(stroke);
                this.toast('Gesamte Map mit Nebel bedeckt');
            };
        }
        
        // Fog clear all
        const fogClearAllBtn = document.getElementById('fogClearAllBtn');
        if (fogClearAllBtn) {
            fogClearAllBtn.onclick = () => {
                if (!confirm('Allen Nebel entfernen?')) return;
                // Save fog stroke IDs before removing
                const fogStrokeIds = this.strokes.filter(s => s.layer === 'fog').map(s => s.id);
                this.strokes = this.strokes.filter(s => s.layer !== 'fog');
                // Remove fog strokes from Firebase
                if (this.db && this.roomCode) {
                    fogStrokeIds.forEach(id => {
                        this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + id).remove();
                    });
                }
                this.fogCtx.clearRect(0, 0, this.fogCanvas.width, this.fogCanvas.height);
                this.render();
                this.toast('Nebel entfernt');
            };
        }
        
        document.querySelectorAll('[data-tool]').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('[data-tool]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                this.tool = b.dataset.tool;
                this.updateCursor();
                if (this.tool !== 'polygon') this.finishPolygon();
                if (this.tool !== 'select') this.deselect();
                
                // Highlight parent menu trigger when a tool inside is active
                const menu = b.closest('.wb-menu');
                document.querySelectorAll('.wb-menu__trigger').forEach(t => t.classList.remove('has-active'));
                if (menu) {
                    menu.querySelector('.wb-menu__trigger')?.classList.add('has-active');
                }
                
                // Deactivate note placing mode when switching tools
                if (this._placingNote) {
                    this._placingNote = false;
                    document.getElementById('noteBtn')?.classList.remove('active');
                }
                
                // Auto snap control: off for drawing tools, restore for others
                const drawTools = ['pen', 'line', 'rect', 'circle', 'arrow', 'polygon', 'text', 'eraser'];
                const snapToggle = document.getElementById('snapToggle');
                if (drawTools.includes(this.tool)) {
                    if (this._snapAutoOff === undefined) this._snapAutoOff = this.snap;
                    this.snap = false;
                    snapToggle.classList.remove('active');
                } else if (this._snapAutoOff !== undefined) {
                    this.snap = this._snapAutoOff;
                    snapToggle.classList.toggle('active', this.snap);
                    delete this._snapAutoOff;
                }
            };
        });
        
        document.querySelectorAll('.wb-color-btn').forEach(b => {
            b.onclick = () => this.setColor(b.dataset.color);
        });
        
        document.querySelectorAll('.wb-size-btn').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('.wb-size-btn').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                this.size = parseInt(b.dataset.size);
            };
        });
        
        document.getElementById('fillToggle').onclick = function() {
            this.classList.toggle('active');
            WB.fill = this.classList.contains('active');
        };
        document.getElementById('snapToggle').onclick = function() {
            this.classList.toggle('active');
            WB.snap = this.classList.contains('active');
        };
        document.getElementById('gridToggle').onclick = function() {
            this.classList.toggle('active');
            document.getElementById('wbGrid').classList.toggle('visible');
        };
        // Defaults: snap + grid ON
        document.getElementById('snapToggle').classList.add('active');
        document.getElementById('gridToggle').classList.add('active');
        document.getElementById('wbGrid').classList.add('visible');
        document.getElementById('gridSettingsBtn').onclick = () => this.showGridSettings();
        
        document.getElementById('undoBtn').onclick = () => this.undo();
        document.getElementById('redoBtn').onclick = () => this.redo();
        document.getElementById('zoomInBtn').onclick = () => this.setZoom(this.targetZoom + 0.25);
        document.getElementById('zoomOutBtn').onclick = () => this.setZoom(this.targetZoom - 0.25);
        document.getElementById('zoomResetBtn').onclick = () => { 
            this.targetZoom = 1; 
            this.targetPanX = 0; 
            this.targetPanY = 0; 
            this.startAnimation(); 
        };
        document.getElementById('clearBtn')?.addEventListener('click', () => { if(confirm('Whiteboard leeren? (Szenen bleiben erhalten)')) this.clearAll(); });
        document.getElementById('stampBtn').onclick = () => document.getElementById('stampsPanel').classList.toggle('visible');
        document.getElementById('tokenBtn').onclick = () => this.showTokenModal();
        document.getElementById('tokenMgrBtn').onclick = () => this.showTokenManager();
    },
    
    setColor(c) {
        this.color = c;
        document.querySelectorAll('.wb-color-btn').forEach(b => b.classList.toggle('active', b.dataset.color === c));
    },
    
    updateCursor() {
        const w = document.getElementById('canvasWrapper');
        w.className = 'wb-canvas-wrapper';
        w.style.cursor = '';
        if (this.tool === 'select') w.classList.add('tool-select');
        else if (this.tool === 'eraser') w.classList.add('tool-eraser');
        else if (this.tool === 'text') w.classList.add('tool-text');
        else if (this.tool === 'aura') w.style.cursor = 'crosshair';
        // Disable token/image pointer-events for non-select tools (GM only; players always need hover for tooltips)
        const selectMode = this.tool === 'select';
        document.getElementById('tokensContainer')?.classList.toggle('no-interact', !selectMode && this.isGM);
        document.getElementById('imagesContainer')?.classList.toggle('no-interact', !selectMode);
    },
    
    setZoom(z) { 
        this.targetZoom = Math.max(0.25, Math.min(4, z)); 
        this.startAnimation();
    },
    
    smoothZoomTo(z, centerX, centerY) {
        // Zoom towards a point (for wheel zoom)
        const oldZoom = this.zoom;
        const newZoom = Math.max(0.25, Math.min(4, z));
        
        // Calculate pan adjustment to zoom towards cursor
        if (centerX !== undefined && centerY !== undefined) {
            const zoomRatio = newZoom / oldZoom;
            this.targetPanX = centerX - (centerX - this.panX) * zoomRatio;
            this.targetPanY = centerY - (centerY - this.panY) * zoomRatio;
        }
        
        this.targetZoom = newZoom;
        this.startAnimation();
    },
    
    updateZoom() { 
        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%'; 
    },
    
    // ==================== SMOOTH ANIMATION ====================
    startAnimation() {
        if (!this.animationFrame) {
            this.lastFrameTime = performance.now();
            this.animationFrame = requestAnimationFrame(t => this.animateLoop(t));
        }
    },
    
    animateLoop(timestamp) {
        const deltaTime = Math.min((timestamp - this.lastFrameTime) / 1000, 0.1); // Cap at 100ms
        this.lastFrameTime = timestamp;
        
        // Lerp factor - exponential decay for smooth deceleration
        // Higher base = faster animation (0.00001 = very smooth, 0.001 = snappy)
        const lerpFactor = 1 - Math.pow(0.00005, deltaTime);
        
        // Smooth zoom
        const zoomDiff = Math.abs(this.targetZoom - this.zoom);
        if (zoomDiff > 0.001) {
            this.zoom += (this.targetZoom - this.zoom) * lerpFactor;
            this.updateZoom();
        } else {
            this.zoom = this.targetZoom;
        }
        
        // Smooth pan
        const panXDiff = Math.abs(this.targetPanX - this.panX);
        const panYDiff = Math.abs(this.targetPanY - this.panY);
        
        if (panXDiff > 0.5) {
            this.panX += (this.targetPanX - this.panX) * lerpFactor;
        } else {
            this.panX = this.targetPanX;
        }
        
        if (panYDiff > 0.5) {
            this.panY += (this.targetPanY - this.panY) * lerpFactor;
        } else {
            this.panY = this.targetPanY;
        }
        
        // Render
        this.render();
        
        // Continue animation if not settled
        const needsMore = zoomDiff > 0.001 || panXDiff > 0.5 || panYDiff > 0.5;
        if (needsMore) {
            this.animationFrame = requestAnimationFrame(t => this.animateLoop(t));
        } else {
            this.animationFrame = null;
        }
    },
    
    // Immediate pan (for dragging - no animation delay)
    setPanImmediate(x, y) {
        this.panX = x;
        this.panY = y;
        this.targetPanX = x;
        this.targetPanY = y;
        this.scheduleRender();
    },
    
    // Throttled render - max once per frame
    renderScheduled: false,
    scheduleRender() {
        if (!this.renderScheduled) {
            this.renderScheduled = true;
            requestAnimationFrame(() => {
                this.renderScheduled = false;
                this.render();
            });
        }
    },
    
    // ==================== GRID SETTINGS ====================
    showGridSettings() {
        const overlay = document.getElementById('gridOverlay');
        
        // Set current values
        document.getElementById('gridSizeInput').value = this.gridSize;
        document.getElementById('gridOffsetX').value = this.gridOffsetX;
        document.getElementById('gridOffsetY').value = this.gridOffsetY;
        
        // Update preset buttons
        document.querySelectorAll('.wb-grid-preset').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === this.gridSize);
        });
        
        // Update color buttons
        document.querySelectorAll('.wb-grid-color').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.color === this.gridColor);
        });
        
        // Setup event handlers if not already done
        if (!this.gridSettingsInitialized) {
            this.setupGridSettingsEvents();
            this.gridSettingsInitialized = true;
        }
        
        overlay.classList.add('visible');
    },
    
    setupGridSettingsEvents() {
        // Preset buttons
        document.querySelectorAll('.wb-grid-preset').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.wb-grid-preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('gridSizeInput').value = btn.dataset.size;
            };
        });
        
        // Custom input updates presets
        document.getElementById('gridSizeInput').oninput = (e) => {
            const val = parseInt(e.target.value);
            document.querySelectorAll('.wb-grid-preset').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.size) === val);
            });
        };
        
        // Color buttons
        document.querySelectorAll('.wb-grid-color').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.wb-grid-color').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        // Fit to map button
        document.getElementById('gridFitBtn').onclick = () => this.fitGridToMap();
        
        // Apply button
        document.getElementById('gridApplyBtn').onclick = () => this.applyGridSettings();
    },
    
    fitGridToMap() {
        if (!this.bgImage) {
            this.toast('Kein Hintergrund geladen!');
            return;
        }
        
        const widthFields = parseInt(document.getElementById('gridFitWidth').value);
        const heightFields = parseInt(document.getElementById('gridFitHeight').value);
        
        if (!widthFields || !heightFields) {
            this.toast('Bitte Breite und Höhe eingeben');
            return;
        }
        
        // Calculate grid size based on background image dimensions
        const bgW = this.bgImage.width;
        const bgH = this.bgImage.height;
        
        const gridFromWidth = bgW / widthFields;
        const gridFromHeight = bgH / heightFields;
        
        // Use average or the one that fits better
        const calculatedSize = Math.round((gridFromWidth + gridFromHeight) / 2);
        
        document.getElementById('gridSizeInput').value = calculatedSize;
        
        // Update preset buttons
        document.querySelectorAll('.wb-grid-preset').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === calculatedSize);
        });
        
        // Show info
        const info = document.getElementById('gridFitInfo');
        info.style.display = 'block';
        info.innerHTML = `
            Berechnet: <strong>${calculatedSize}px</strong> pro Feld<br>
            Karte: ${bgW}×${bgH}px → ${widthFields}×${heightFields} Felder
        `;
        
        this.toast(`Grid: ${calculatedSize}px (${widthFields}×${heightFields})`);
    },
    
    applyGridSettings() {
        this.gridSize = parseInt(document.getElementById('gridSizeInput').value) || 70;
        this.gridOffsetX = parseInt(document.getElementById('gridOffsetX').value) || 0;
        this.gridOffsetY = parseInt(document.getElementById('gridOffsetY').value) || 0;
        
        // Get selected color
        const activeColor = document.querySelector('.wb-grid-color.active');
        if (activeColor) {
            this.gridColor = activeColor.dataset.color;
        }
        
        this.updateGrid();
        this.syncGridSettings();
        document.getElementById('gridOverlay').classList.remove('visible');
        this.toast(`Raster: ${this.gridSize}px`);
    },
    
    updateGrid() {
        const grid = document.getElementById('wbGrid');
        const size = this.gridSize * this.zoom;
        const offsetX = this.gridOffsetX * this.zoom + this.panX;
        const offsetY = this.gridOffsetY * this.zoom + this.panY;
        
        grid.style.backgroundImage = `
            linear-gradient(${this.gridColor} 1px, transparent 1px),
            linear-gradient(90deg, ${this.gridColor} 1px, transparent 1px)
        `;
        grid.style.backgroundSize = `${size}px ${size}px`;
        grid.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
    },
    
    // ==================== CANVAS EVENTS ====================
    setupCanvas() {
        const ui = this.uiCanvas;
        const wrapper = document.getElementById('canvasWrapper');
        
        // Prevent native drag on all elements in the canvas area
        wrapper.addEventListener('dragstart', e => e.preventDefault());
        
        ui.addEventListener('mousedown', e => this.onDown(e));
        ui.addEventListener('dblclick', e => this.onDblClick(e));
        ui.addEventListener('contextmenu', e => this.onContext(e));
        
        // Mouse move/up on WINDOW so dragging works when mouse leaves canvas or is over DOM elements
        window.addEventListener('mousemove', e => {
            if (this.isDragging || this.isDrawing || this.isResizing || this.isMarquee) {
                this.onMove(e);
            }
        });
        window.addEventListener('mouseup', e => {
            if (this.isDragging || this.isDrawing || this.isResizing || this.isMarquee) {
                this.onUp(e);
            }
        });
        
        // Also listen on canvas for regular drawing
        ui.addEventListener('mousemove', e => {
            if (!this.isDragging && !this.isResizing && !this.isMarquee) {
                this.onMove(e);
            }
        });
        ui.addEventListener('mouseleave', e => {
            if (!this.isDragging && !this.isResizing && !this.isMarquee) {
                this.onUp(e);
            }
        });
        
        ui.addEventListener('touchstart', e => { e.preventDefault(); this.onDown(e.touches[0]); }, { passive: false });
        ui.addEventListener('touchmove', e => { e.preventDefault(); this.onMove(e.touches[0]); }, { passive: false });
        ui.addEventListener('touchend', e => { e.preventDefault(); this.onUp(e); }, { passive: false });
        
        // Middle mouse pan
        ui.addEventListener('mousedown', e => {
            if (e.button === 1) { e.preventDefault(); this.isPanning = true; this.lastPan = { x: e.clientX, y: e.clientY }; }
        });
        window.addEventListener('mousemove', e => {
            if (this.isPanning && this.lastPan) {
                const dx = e.clientX - this.lastPan.x;
                const dy = e.clientY - this.lastPan.y;
                this.panX += dx;
                this.panY += dy;
                this.targetPanX = this.panX;
                this.targetPanY = this.panY;
                this.lastPan = { x: e.clientX, y: e.clientY };
                this.scheduleRender();
            }
        });
        window.addEventListener('mouseup', e => { if (e.button === 1) this.isPanning = false; });
        
        // Spacebar hand tool (pan mode)
        window.addEventListener('keydown', e => {
            if (e.code === 'Space' && !this.spacePressed && !e.target.matches('input, textarea')) {
                e.preventDefault();
                this.spacePressed = true;
                wrapper.style.cursor = 'grab';
            }
        });
        window.addEventListener('keyup', e => {
            if (e.code === 'Space') {
                this.spacePressed = false;
                this.isPanning = false;
                this.lastPan = null;
                wrapper.style.cursor = '';
                this.updateCursor();
            }
        });
        // Spacebar + mouse = pan
        wrapper.addEventListener('mousedown', e => {
            if (this.spacePressed && e.button === 0) {
                e.preventDefault();
                e.stopPropagation();
                this.isPanning = true;
                this.lastPan = { x: e.clientX, y: e.clientY };
                wrapper.style.cursor = 'grabbing';
            }
        });
        window.addEventListener('mouseup', e => {
            if (this.spacePressed && e.button === 0) {
                this.isPanning = false;
                this.lastPan = null;
                wrapper.style.cursor = 'grab';
            }
        });
        
        // Wheel zoom (smooth, towards cursor)
        document.getElementById('canvasWrapper').addEventListener('wheel', e => {
            e.preventDefault();
            const rect = wrapper.getBoundingClientRect();
            const cursorX = e.clientX - rect.left;
            const cursorY = e.clientY - rect.top;
            
            // Smaller steps for smoother feel
            const zoomDelta = e.deltaY > 0 ? -0.15 : 0.15;
            this.smoothZoomTo(this.targetZoom + zoomDelta, cursorX, cursorY);
        }, { passive: false });
        
        // Close panels on click outside
        document.addEventListener('click', e => {
            if (!e.target.closest('#stampsPanel') && !e.target.closest('#stampBtn'))
                document.getElementById('stampsPanel').classList.remove('visible');
            if (!e.target.closest('.wb-context-menu'))
                document.getElementById('contextMenu').classList.remove('visible');
        });
    },
    
    getPoint(e) {
        const r = this.uiCanvas.getBoundingClientRect();
        const rawX = (e.clientX - r.left - this.panX) / this.zoom;
        const rawY = (e.clientY - r.top - this.panY) / this.zoom;
        let x = rawX, y = rawY;
        if (this.snap) {
            x = Math.round((x - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX;
            y = Math.round((y - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY;
        }
        // rx, ry = relative to canvasWrapper (for DOM elements like ping)
        // rawX, rawY = unsnapped world coords
        return { x, y, rawX, rawY, sx: e.clientX, sy: e.clientY, rx: e.clientX - r.left, ry: e.clientY - r.top };
    },
    
    onDown(e) {
        if (this.isPanning || this.isResizing || this.spacePressed) return;
        // Safety cleanup: reset stale states from previous incomplete interactions
        if (this.isMarquee) {
            this.isMarquee = false;
            this.marqueeStart = null;
            document.getElementById('marquee').classList.remove('visible');
        }
        if (this._tokenDrag) {
            this.hideDragLine();
            this._tokenDrag = null;
            this._multiDrag = null;
        }
        const p = this.getPoint(e);
        this.startPoint = p;
        this.currentPath = [p];
        this.lastDragPoint = p; // Track for delta movement
        
        // Note placement mode takes priority over any tool
        if (this._placingNote && this.isGM) { this.showNoteDialog(p); return; }
        
        // SELECT TOOL - Main new logic
        if (this.tool === 'select') {
            const hit = this.hitTest(p);
            if (hit) {
                this.select(hit);
                if (hit.type === 'token') {
                    if (!this.isGM) {
                        // Players can only select tokens, not drag them
                        return;
                    }
                    // Token drag mode: draw line, teleport on release
                    this._tokenDrag = { token: hit.item, startX: hit.item.x, startY: hit.item.y, startScreen: { rx: p.rx, ry: p.ry } };
                    this._dragOrigin = { x: hit.item.x, y: hit.item.y };
                    this.showMoveRadius(hit.item);
                    this.isDragging = true;
                    this.lastDragPoint = p;
                    this.uiCanvas.style.zIndex = '52';
                } else if (hit.type === 'aura' && this.isGM) {
                    this._auraDragMove = { aura: hit.item, startX: hit.item.x, startY: hit.item.y };
                    this.isDragging = true;
                    this.lastDragPoint = p;
                } else {
                    this.isDragging = true;
                    this.lastDragPoint = p;
                }
            } else {
                this.deselect();
                this.multiSelected = [];
                // Start marquee selection - use raw world coords for precision
                this.isMarquee = true;
                this.marqueeStart = { rx: p.rx, ry: p.ry, x: p.rawX, y: p.rawY };
            }
            return;
        }
        
        if (this.tool === 'ping') { this.createPing(p.rx, p.ry, p.x, p.y); return; }
        if (this.tool === 'focus') { this.createFocus(p.x, p.y, p.rx, p.ry); return; }
        if (this.tool === 'text') { this.showTextInput(p); return; }
        if (this.tool === 'stamp' && this.selectedStamp) { this.placeStamp(p); return; }
        if (this.tool === 'aura') { this.placeAura(p); return; }
        if (this.tool === 'polygon') { this.polygonPoints.push(p); this.renderUI(); return; }
        
        this.isDrawing = true;
    },
    
    onMove(e) {
        const p = this.getPoint(e);
        
        // Token drag mode: draw line from start to cursor
        if (this.isDragging && this._tokenDrag) {
            this.drawDragLine(this._tokenDrag, p);
            return;
        }
        
        // Dragging non-token selected item - use delta movement
        if (this.isDragging && this.selected && this.lastDragPoint) {
            const dx = p.x - this.lastDragPoint.x;
            const dy = p.y - this.lastDragPoint.y;
            this.lastDragPoint = p;
            this.moveSelected(dx, dy);
            return;
        }
        
        // Marquee selection
        if (this.isMarquee && this.marqueeStart) {
            this.drawMarquee(this.marqueeStart, p);
            return;
        }
        
        // Resizing selected item
        if (this.isResizing && this.selected && this.resizeHandle) {
            this.handleResize(e);
            return;
        }
        
        if (!this.isDrawing) return;
        this.currentPath.push(p);
        
        if (this.tool === 'pen') this.drawLivePen(p);
        else if (this.tool === 'eraser') this.eraseLive(p);
        else if (this.tool === 'ruler') this.showRuler(this.startPoint, p);
        else if (this.tool === 'aura' && this._auraDragging) {
            const d = this._auraDragging;
            const dx = p.rawX - d.ox, dy = p.rawY - d.oy;
            const radiusPx = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const ctx = this.uiCtx;
            ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
            const sx = d.ox * this.zoom + this.panX;
            const sy = d.oy * this.zoom + this.panY;
            const sr = radiusPx * this.zoom;
            const shape = d.shape || 'circle';
            ctx.strokeStyle = d.color.replace(/[\d.]+\)$/, '0.7)');
            ctx.fillStyle = d.color;
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            if (shape === 'circle') {
                ctx.arc(sx, sy, sr, 0, Math.PI * 2);
            } else if (shape === 'cone') {
                const spread = Math.PI / 3; // 60 degree cone
                ctx.moveTo(sx, sy);
                ctx.arc(sx, sy, sr, angle - spread / 2, angle + spread / 2);
                ctx.closePath();
            } else if (shape === 'square') {
                ctx.save(); ctx.translate(sx, sy); ctx.rotate(angle);
                ctx.rect(-sr, -sr, sr * 2, sr * 2);
                ctx.restore();
            } else if (shape === 'line') {
                const lw = Math.max(this.gridSize * this.zoom * 0.5, 6);
                const ex = sx + Math.cos(angle) * sr;
                const ey = sy + Math.sin(angle) * sr;
                const nx = -Math.sin(angle) * lw / 2;
                const ny = Math.cos(angle) * lw / 2;
                ctx.moveTo(sx + nx, sy + ny); ctx.lineTo(ex + nx, ey + ny);
                ctx.lineTo(ex - nx, ey - ny); ctx.lineTo(sx - nx, sy - ny);
                ctx.closePath();
            }
            ctx.fill(); ctx.stroke();
            ctx.setLineDash([]);
            // Show size label
            const grids = Math.round(radiusPx / this.gridSize);
            const ft = grids * 5;
            const meters = (ft * 0.3048).toFixed(1);
            const info = document.getElementById('rulerInfo');
            info.style.display = 'block';
            info.style.left = (p.sx + 8) + 'px';
            info.style.top = (p.sy - 8) + 'px';
            info.innerHTML = `<strong>${grids}</strong> Felder<br><span style="opacity:0.7;font-size:12px">${ft} ft / ${meters} m</span>`;
        }
        else this.renderUI();
    },
    
    onUp(e) {
        // Aura cone drag finish
        if (this._auraDragging) {
            const p = this.getPoint(e);
            this.finishAuraDrag(p);
            return;
        }
        
        // Token drag mode: teleport to destination
        if (this.isDragging && this._tokenDrag) {
            const p = this.getPoint(e);
            const t = this._tokenDrag.token;
            const fromX = this._tokenDrag.startX, fromY = this._tokenDrag.startY;
            // Use raw (unsnapped) world coords, then snap to field CENTER once
            let targetX = p.rawX, targetY = p.rawY;
            if (this.snap && this.gridSize) {
                targetX = Math.floor((targetX - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX + this.gridSize / 2;
                targetY = Math.floor((targetY - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY + this.gridSize / 2;
            }
            
            // Multi-drag: move all selected tokens by the same offset
            if (this._multiDrag && this._multiDrag.tokens.length > 1) {
                const dx = targetX - this._tokenDrag.startX;
                const dy = targetY - this._tokenDrag.startY;
                const targets = [];
                this._multiDrag.origins.forEach(orig => {
                    const tk = this.tokens.find(x => x.id === orig.id);
                    if (tk) {
                        let nx = orig.x + dx, ny = orig.y + dy;
                        if (this.snap && this.gridSize) {
                            nx = Math.floor((nx - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX + this.gridSize / 2;
                            ny = Math.floor((ny - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY + this.gridSize / 2;
                        }
                        targets.push({ token: tk, startX: tk.x, startY: tk.y, targetX: nx, targetY: ny });
                    }
                });
                this.animateMultiTokenMove(targets);
            } else {
                // Animate token to new position
                this.animateTokenMove(t, targetX, targetY);
            }
            
            // Track for undo
            this.pushTokenUndo({ type: 'move', tokenId: t.id, from: { x: fromX, y: fromY }, to: { x: targetX, y: targetY } });
            
            this.renderInitiative();
            this.renderTokenSidebar();
            this.hideDragLine();
            this.hideMoveRadius();
            this._tokenDrag = null;
            this._multiDrag = null;
            this._dragOrigin = null;
            this.isDragging = false;
            this.lastDragPoint = null;
            return;
        }
        
        if (this.isDragging) {
            this.isDragging = false;
            this.lastDragPoint = null;
            this.hideMoveRadius();
            this._dragOrigin = null;
            this._auraDragMove = null;
            this._noteDrag = null;
            return;
        }
        
        // Marquee selection finish
        if (this.isMarquee && this.marqueeStart) {
            const p = this.getPoint(e);
            this.finishMarquee(this.marqueeStart, p);
            this.isMarquee = false;
            this.marqueeStart = null;
            document.getElementById('marquee').classList.remove('visible');
            return;
        }
        
        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            // Sync resized image to Firebase
            if (this.selected?.type === 'image') this.syncImageToFirebase(this.selected.item);
            return;
        }
        
        if (this.tool === 'ruler') {
            document.getElementById('rulerInfo').style.display = 'none';
            this.renderUI();
            // Clear ruler from Firebase
            if (this.db && this.roomCode) {
                this.db.ref('whiteboard/' + this.roomCode + '/ruler/' + this.userId).remove();
            }
        }
        
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        if (this.currentPath.length < 2) return;
        
        const end = this.currentPath[this.currentPath.length - 1];
        const isFogReveal = this.layer === 'fog' && this._fogMode === 'reveal';
        const isFogPlace = this.layer === 'fog' && this._fogMode !== 'reveal';
        const stroke = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: this.layer, tool: this.tool,
            color: this.tool === 'eraser' ? '#0a0a0a' : (isFogPlace ? 'rgba(0,0,0,1)' : (isFogReveal ? 'rgba(255,255,255,1)' : this.color)),
            size: this.tool === 'eraser' ? this.size * 4 : this.size,
            fill: (isFogPlace || isFogReveal) ? true : this.fill,
            fogReveal: isFogReveal || false,
            path: ['pen', 'eraser'].includes(this.tool) ? [...this.currentPath] : null,
            start: this.startPoint, end: end,
            userId: this.userId, ts: Date.now()
        };
        
        this.addStroke(stroke);
        this.syncStroke(stroke);
        this.currentPath = [];
        this.startPoint = null;
        this.renderUI();
    },
    
    onDblClick(e) {
        const p = this.getPoint(e);
        
        // Double-click on text to edit
        if (this.tool === 'select' && this.selected?.type === 'stroke' && this.selected.item.tool === 'text') {
            this.editText(this.selected.item, p);
            return;
        }
        
        if (this.tool === 'polygon' && this.polygonPoints.length >= 3) this.finishPolygon();
        else this.createPing(p.rx, p.ry, p.x, p.y);
    },
    
    editText(stroke, p) {
        const inp = document.getElementById('textInput');
        const canvasRect = this.uiCanvas.getBoundingClientRect();
        inp.style.left = (stroke.start.x * this.zoom + this.panX + canvasRect.left) + 'px';
        inp.style.top = (stroke.start.y * this.zoom + this.panY + canvasRect.top) + 'px';
        inp.style.display = 'block';
        inp.style.color = stroke.color;
        inp.dataset.strokeId = stroke.id;
        inp.dataset.x = stroke.start.x;
        inp.dataset.y = stroke.start.y;
        inp.value = stroke.text || '';
        setTimeout(() => { inp.focus(); inp.select(); }, 50);
    },
    
    onContext(e) {
        e.preventDefault();
        const p = this.getPoint(e);
        const hit = this.hitTest(p) || this._contextHit;
        this._contextHit = null;
        
        const m = document.getElementById('contextMenu');
        let html = '';
        
        // No hit on empty space: GM gets creation menu
        if (!hit) {
            if (!this.isGM) return;
            this._contextWorldPoint = { x: p.rawX, y: p.rawY };
            html += `<button class="wb-context-item" data-action="ctx-load-token"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>Token-Manager</button>`;
            html += `<button class="wb-context-item" data-action="ctx-create-token"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg>Token erstellen</button>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="ctx-image"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>Bild/Prop einfügen</button>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="ctx-ping"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="8" stroke-dasharray="4 4"/></svg>Ping</button>`;
            html += `<button class="wb-context-item" data-action="ctx-focus"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>Fokus</button>`;
            if (this._auras && this._auras.length > 0) {
                html += `<div class="wb-context-divider"></div>`;
                html += `<button class="wb-context-item" data-action="ctx-clear-auras"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-dasharray="4 2"/><line x1="4" y1="4" x2="20" y2="20"/></svg>Alle Bereiche entfernen</button>`;
            }
            
            m.innerHTML = html;
            m.querySelectorAll('.wb-context-item').forEach(item => {
                item.onclick = () => {
                    const action = item.dataset.action;
                    const wp = this._contextWorldPoint;
                    if (action === 'ctx-load-token') this.showTokenManager();
                    else if (action === 'ctx-create-token') {
                        this._pendingTokenPos = wp;
                        document.getElementById('tokenOverlay').classList.add('visible');
                    }
                    else if (action === 'ctx-image') {
                        this._pendingImagePos = wp;
                        document.getElementById('imageOverlay').classList.add('visible');
                    }
                    else if (action === 'ctx-ping') this.createPing(p.rx, p.ry, wp.x, wp.y);
                    else if (action === 'ctx-focus') this.createFocus(wp.x, wp.y, p.rx, p.ry);
                    else if (action === 'ctx-clear-auras') {
                        this._auras = [];
                        if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/auras').remove();
                        this.renderAuras();
                        this.toast('Alle Bereiche entfernt');
                    }
                    m.classList.remove('visible');
                };
            });
            
            m.style.left = e.clientX + 'px';
            m.style.top = e.clientY + 'px';
            m.classList.add('visible');
            return;
        }
        
        this.select(hit);
        const isToken = hit.type === 'token';
        const token = isToken ? hit.item : null;
        
        // Check if this token is part of a multi-selection
        const isMulti = isToken && this.multiSelected.length > 1 && this.multiSelected.includes(token);
        const multiTokens = isMulti ? this.multiSelected : (isToken ? [token] : []);
        
        // Build context menu dynamically
        if (isToken && isMulti) {
            // Multi-select token menu - group actions only
            html += `<div style="padding:4px 14px;font-size:11px;color:rgba(255,255,255,0.4)">${multiTokens.length} Tokens ausgewählt</div>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="multi-damage"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/></svg>Schaden (alle)</button>`;
            html += `<button class="wb-context-item" data-action="multi-heal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8"/></svg>Heilen (alle)</button>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="multi-duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren (alle)</button>`;
            html += `<button class="wb-context-item wb-context-item--danger" data-action="multi-delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>Löschen (alle)</button>`;
        } else if (isToken) {
            // Token-specific menu
            html += `<button class="wb-context-item" data-action="edit"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>Bearbeiten</button>`;
            if (token.maxHp > 0) {
                html += `<div class="wb-context-divider"></div>`;
                html += `<div style="display:flex;align-items:center;gap:8px;padding:4px 14px 4px 14px">
                    <span style="font-size:12px;color:rgba(255,255,255,0.5);flex-shrink:0">HP ${token.hp}/${token.maxHp}</span>
                    <div style="flex:1;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden">
                        <div style="height:100%;width:${Math.max(0, Math.min(100, (token.hp / token.maxHp) * 100))}%;background:${(token.hp / token.maxHp) <= 0.25 ? '#ef4444' : (token.hp / token.maxHp) <= 0.5 ? '#f59e0b' : '#22c55e'};border-radius:2px"></div>
                    </div>
                </div>`;
                html += `<button class="wb-context-item" data-action="damage"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/></svg>Schaden</button>`;
                html += `<button class="wb-context-item" data-action="heal"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8"/></svg>Heilen</button>`;
            }
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren</button>`;
            html += `<button class="wb-context-item wb-context-item--danger" data-action="delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>Löschen</button>`;
        } else if (hit.type === 'aura') {
            const aura = hit.item;
            const shName = ({circle:'Kreis',cone:'Kegel',square:'Quadrat',line:'Linie',sphere:'Kreis'})[aura.shape||'circle']||'Bereich';
            html += `<div style="padding:4px 14px;font-size:11px;color:rgba(255,255,255,0.4)">${shName} (${aura.grids||'?'} Felder)</div>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="aura-color"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>Farbe ändern</button>`;
            html += `<button class="wb-context-item" data-action="aura-resize"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 21l-6-6m6 6v-4.8m0 4.8h-4.8"/><path d="M3 16.2V21m0 0h4.8M3 21l6-6"/></svg>Größe ändern</button>`;
            html += `<button class="wb-context-item" data-action="aura-label"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>Beschriftung</button>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="aura-duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren</button>`;
            html += `<button class="wb-context-item wb-context-item--danger" data-action="aura-delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>Löschen</button>`;
        } else if (hit.type === 'note') {
            const note = hit.item;
            html += `<div style="padding:4px 14px;font-size:11px;color:rgba(255,255,255,0.4)">Notiz: ${note.title || note.type}</div>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="note-edit"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>Bearbeiten</button>`;
            html += `<button class="wb-context-item" data-action="note-duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren</button>`;
            html += `<button class="wb-context-item wb-context-item--danger" data-action="note-delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>Löschen</button>`;
        } else {
            // Generic context menu for strokes/images
            html += `<button class="wb-context-item" data-action="duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren</button>`;
            html += `<button class="wb-context-item" data-action="front"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>Nach vorne</button>`;
            html += `<button class="wb-context-item" data-action="back"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>Nach hinten</button>`;
            html += `<div class="wb-context-divider"></div>`;
            html += `<button class="wb-context-item" data-action="edit"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>Bearbeiten</button>`;
            html += `<button class="wb-context-item wb-context-item--danger" data-action="delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>Löschen</button>`;
        }
        
        m.innerHTML = html;
        
        // Wire up action handlers
        m.querySelectorAll('.wb-context-item').forEach(item => {
            item.onclick = () => {
                const action = item.dataset.action;
                if (action === 'delete') this.deleteSelected();
                else if (action === 'duplicate') this.duplicateSelected();
                else if (action === 'front') this.moveToFront();
                else if (action === 'back') this.moveToBack();
                else if (action === 'edit') this.editSelected();
                else if (action === 'damage' && token) {
                    const amount = prompt('Schaden:', '1');
                    if (amount && !isNaN(parseInt(amount))) {
                        token.hp = Math.max(0, token.hp - parseInt(amount));
                        this.syncToken(token);
                        this.renderTokens();
                        this.renderInitiative();
                        this.renderTokenSidebar();
                        this.toast(`${token.name}: -${parseInt(amount)} HP (${token.hp}/${token.maxHp})`);
                    }
                } else if (action === 'heal' && token) {
                    const amount = prompt('Heilung:', '1');
                    if (amount && !isNaN(parseInt(amount))) {
                        token.hp = Math.min(token.maxHp || 999, token.hp + parseInt(amount));
                        this.syncToken(token);
                        this.renderTokens();
                        this.renderInitiative();
                        this.renderTokenSidebar();
                        this.toast(`${token.name}: +${parseInt(amount)} HP (${token.hp}/${token.maxHp})`);
                    }
                }
                // Multi-select group actions
                else if (action === 'multi-damage') {
                    const amount = prompt(`Schaden für ${multiTokens.length} Tokens:`, '1');
                    if (amount && !isNaN(parseInt(amount))) {
                        const dmg = parseInt(amount);
                        multiTokens.forEach(tk => {
                            if (tk.maxHp > 0) { tk.hp = Math.max(0, tk.hp - dmg); this.syncToken(tk); }
                        });
                        this.renderTokens(); this.renderInitiative(); this.renderTokenSidebar();
                        this.toast(`${multiTokens.length} Tokens: -${dmg} HP`);
                    }
                }
                else if (action === 'multi-heal') {
                    const amount = prompt(`Heilung für ${multiTokens.length} Tokens:`, '1');
                    if (amount && !isNaN(parseInt(amount))) {
                        const heal = parseInt(amount);
                        multiTokens.forEach(tk => {
                            if (tk.maxHp > 0) { tk.hp = Math.min(tk.maxHp, tk.hp + heal); this.syncToken(tk); }
                        });
                        this.renderTokens(); this.renderInitiative(); this.renderTokenSidebar();
                        this.toast(`${multiTokens.length} Tokens: +${heal} HP`);
                    }
                }
                else if (action === 'multi-duplicate') {
                    multiTokens.forEach(tk => {
                        const copy = JSON.parse(JSON.stringify(tk));
                        copy.id = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        copy.x = tk.x + this.gridSize;
                        copy.y = tk.y + this.gridSize;
                        copy.name = tk.name + ' (K)';
                        this.tokens.push(copy);
                        this.syncToken(copy);
                    });
                    this.multiSelected = [];
                    this.renderTokens(); this.renderTokenSidebar();
                    this.toast(`${multiTokens.length} Tokens dupliziert`);
                }
                else if (action === 'multi-delete') {
                    if (!confirm(`${multiTokens.length} Tokens löschen?`)) { m.classList.remove('visible'); return; }
                    multiTokens.forEach(tk => {
                        const idx = this.tokens.findIndex(t2 => t2.id === tk.id);
                        if (idx !== -1) {
                            this.tokens.splice(idx, 1);
                            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + tk.id).remove();
                        }
                    });
                    this.multiSelected = [];
                    this.deselect();
                    this.renderTokens(); this.renderInitiative(); this.renderTokenSidebar();
                    this.toast(`${multiTokens.length} Tokens gelöscht`);
                }
                // Aura context actions
                else if (action === 'aura-color' && hit.type === 'aura') {
                    const colors = [
                        { name: 'Rot', val: 'rgba(239,68,68,0.3)' },
                        { name: 'Blau', val: 'rgba(59,130,246,0.3)' },
                        { name: 'Grün', val: 'rgba(34,197,94,0.3)' },
                        { name: 'Gelb', val: 'rgba(234,179,8,0.3)' },
                        { name: 'Lila', val: 'rgba(168,85,247,0.3)' },
                        { name: 'Orange', val: 'rgba(249,115,22,0.3)' },
                        { name: 'Weiß', val: 'rgba(255,255,255,0.2)' },
                    ];
                    const choice = prompt('Farbe wählen:\n' + colors.map((c,i) => `${i+1}. ${c.name}`).join('\n'), '1');
                    const idx = parseInt(choice) - 1;
                    if (idx >= 0 && idx < colors.length) {
                        hit.item.color = colors[idx].val;
                        this.syncAura(hit.item); this.renderAuras();
                        this.toast('Farbe: ' + colors[idx].name);
                    }
                }
                else if (action === 'aura-resize' && hit.type === 'aura') {
                    const cur = hit.item.grids || Math.round(hit.item.radius / this.gridSize);
                    const newGrids = prompt('Neue Größe (Felder):', cur);
                    if (newGrids && !isNaN(parseInt(newGrids))) {
                        const g = parseInt(newGrids);
                        hit.item.radius = g * this.gridSize;
                        hit.item.grids = g; hit.item.ft = g * 5; hit.item.meters = +(g * 5 * 0.3048).toFixed(1);
                        this.syncAura(hit.item); this.renderAuras();
                        this.toast(`Größe: ${g} Felder`);
                    }
                }
                else if (action === 'aura-label' && hit.type === 'aura') {
                    const label = prompt('Beschriftung:', hit.item.label || '');
                    if (label !== null) {
                        hit.item.label = label;
                        this.syncAura(hit.item); this.renderAuras();
                    }
                }
                else if (action === 'aura-duplicate' && hit.type === 'aura') {
                    const copy = { ...hit.item, id: Date.now() + '-' + Math.random().toString(36).substr(2,5), x: hit.item.x + this.gridSize, y: hit.item.y + this.gridSize };
                    this._auras.push(copy); this.syncAura(copy); this.renderAuras();
                    this.toast('Bereich dupliziert');
                }
                else if (action === 'aura-delete' && hit.type === 'aura') {
                    this.removeAura(hit.item.id); this.deselect();
                    this.toast('Bereich gelöscht');
                }
                // Note context actions
                else if (action === 'note-edit' && hit.type === 'note') {
                    const note = hit.item;
                    this._pendingNotePos = { x: note.x, y: note.y };
                    this._editingNoteId = note.id;
                    document.getElementById('noteTitle').value = note.title || '';
                    document.getElementById('noteText').value = note.text || '';
                    document.getElementById('noteVisibleToPlayers').checked = note.visibleToPlayers !== false;
                    document.getElementById('noteOverlay').classList.add('visible');
                    document.getElementById('noteTitle').focus();
                }
                else if (action === 'note-duplicate' && hit.type === 'note') {
                    const copy = { ...hit.item, id: Date.now() + '-' + Math.random().toString(36).substr(2,5), x: hit.item.x + this.gridSize, y: hit.item.y + this.gridSize };
                    this._notes.push(copy); this.syncNote(copy); this.renderNotes();
                    this.toast('Notiz dupliziert');
                }
                else if (action === 'note-delete' && hit.type === 'note') {
                    this._notes = this._notes.filter(n => n.id !== hit.item.id);
                    if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/notes/' + hit.item.id).remove();
                    this.renderNotes(); this.deselect();
                    this.toast('Notiz gelöscht');
                }
                m.classList.remove('visible');
            };
        });
        
        m.style.left = e.clientX + 'px';
        m.style.top = e.clientY + 'px';
        m.classList.add('visible');
    },
    
    // ==================== SELECTION ====================
    hitTest(p) {
        // Check tokens first (top layer) - circles
        for (let i = this.tokens.length - 1; i >= 0; i--) {
            const t = this.tokens[i];
            const dx = p.x - t.x, dy = p.y - t.y;
            if (Math.sqrt(dx * dx + dy * dy) < t.size / 2) return { type: 'token', item: t, index: i };
        }
        // Check images - rectangles
        for (let i = this.images.length - 1; i >= 0; i--) {
            const img = this.images[i];
            if (p.x >= img.x && p.x <= img.x + img.w && p.y >= img.y && p.y <= img.y + img.h) 
                return { type: 'image', item: img, index: i };
        }
        // Check auras
        if (this._auras) {
            for (let i = this._auras.length - 1; i >= 0; i--) {
                const a = this._auras[i];
                if (this.hitTestAura(a, p)) return { type: 'aura', item: a, index: i };
            }
        }
        // Check notes (small circle hit area)
        if (this._notes) {
            const noteRadius = 18 / this.zoom; // 18px screen radius
            for (let i = this._notes.length - 1; i >= 0; i--) {
                const n = this._notes[i];
                if (!this.isGM && !n.visibleToPlayers) continue;
                const dx = p.rawX - n.x, dy = p.rawY - n.y;
                if (Math.sqrt(dx * dx + dy * dy) < noteRadius) return { type: 'note', item: n, index: i };
            }
        }
        // Check strokes (text, stamps, shapes) - use raw coords for precision (stamps are 40px but grid snaps to 70px)
        const rx = p.rawX !== undefined ? p.rawX : p.x;
        const ry = p.rawY !== undefined ? p.rawY : p.y;
        const rawP = { x: rx, y: ry };
        for (let i = this.strokes.length - 1; i >= 0; i--) {
            const s = this.strokes[i];
            if (s.layer !== 'main') continue;
            if (this.hitTestStroke(s, rawP)) return { type: 'stroke', item: s, index: i };
        }
        return null;
    },
    
    hitTestStroke(s, p) {
        // More accurate hit testing for each stroke type
        if (s.tool === 'stamp') {
            const size = s.stampSize || 40;
            // fillText: x = left edge, y = baseline (bottom of emoji)
            // Emoji goes from x to x+size horizontally, and from y-size to y vertically
            return p.x >= s.x && p.x <= s.x + size && 
                   p.y >= s.y - size && p.y <= s.y;
        }
        if (s.tool === 'text') {
            const fontSize = s.size * 4 + 12;
            const textWidth = Math.max((s.text?.length || 5) * fontSize * 0.55, 40);
            // Text baseline at start.y - text renders above
            return p.x >= s.start.x && p.x <= s.start.x + textWidth &&
                   p.y >= s.start.y - fontSize * 0.9 && p.y <= s.start.y + fontSize * 0.2;
        }
        if (s.tool === 'pen' && s.path && s.path.length > 0) {
            // Check proximity to any point in path
            const threshold = Math.max(s.size * 2, 15);
            for (const pt of s.path) {
                const dx = p.x - pt.x, dy = p.y - pt.y;
                if (Math.sqrt(dx*dx + dy*dy) < threshold) return true;
            }
            return false;
        }
        if (s.tool === 'polygon' && s.points && s.points.length > 0) {
            // Check if point is inside polygon or near edges
            return this.pointInPolygon(p, s.points) || this.nearPolygonEdge(p, s.points, s.size + 5);
        }
        if (['line', 'rect', 'circle', 'arrow'].includes(s.tool) && s.start && s.end) {
            const bounds = this.getShapeBounds(s);
            const pad = Math.max(s.size, 8);
            return p.x >= bounds.x - pad && p.x <= bounds.x + bounds.w + pad &&
                   p.y >= bounds.y - pad && p.y <= bounds.y + bounds.h + pad;
        }
        return false;
    },
    
    pointInPolygon(p, points) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, yi = points[i].y;
            const xj = points[j].x, yj = points[j].y;
            if (((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    },
    
    nearPolygonEdge(p, points, threshold) {
        for (let i = 0; i < points.length; i++) {
            const a = points[i], b = points[(i + 1) % points.length];
            if (this.distToSegment(p, a, b) < threshold) return true;
        }
        return false;
    },
    
    distToSegment(p, a, b) {
        const l2 = (b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y);
        if (l2 === 0) return Math.sqrt((p.x-a.x)*(p.x-a.x) + (p.y-a.y)*(p.y-a.y));
        let t = ((p.x-a.x)*(b.x-a.x) + (p.y-a.y)*(b.y-a.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const proj = { x: a.x + t*(b.x-a.x), y: a.y + t*(b.y-a.y) };
        return Math.sqrt((p.x-proj.x)*(p.x-proj.x) + (p.y-proj.y)*(p.y-proj.y));
    },
    
    getShapeBounds(s) {
        if (!s.start || !s.end) return null;
        return {
            x: Math.min(s.start.x, s.end.x),
            y: Math.min(s.start.y, s.end.y),
            w: Math.abs(s.end.x - s.start.x),
            h: Math.abs(s.end.y - s.start.y)
        };
    },
    
    getStrokeBounds(s) {
        if (s.tool === 'text') {
            const fontSize = s.size * 4 + 12;
            const textWidth = Math.max((s.text?.length || 5) * fontSize * 0.55, 40);
            return { x: s.start.x, y: s.start.y - fontSize * 0.9, w: textWidth, h: fontSize * 1.1 };
        }
        if (s.tool === 'stamp') {
            const size = s.stampSize || 40;
            // fillText: x = left edge, y = baseline. Emoji goes from y-size to y
            return { x: s.x, y: s.y - size, w: size, h: size };
        }
        if (s.tool === 'pen' && s.path && s.path.length > 0) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            s.path.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
            const pad = Math.max(s.size * 2, 10);
            return { x: minX - pad, y: minY - pad, w: Math.max(maxX - minX + pad*2, 20), h: Math.max(maxY - minY + pad*2, 20) };
        }
        if (s.tool === 'polygon' && s.points && s.points.length > 0) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            s.points.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
            const pad = Math.max(s.size, 5);
            return { x: minX - pad, y: minY - pad, w: maxX - minX + pad*2, h: maxY - minY + pad*2 };
        }
        if (['line', 'rect', 'circle', 'arrow'].includes(s.tool) && s.start && s.end) {
            const b = this.getShapeBounds(s);
            const pad = Math.max(s.size, 5);
            return { x: b.x - pad, y: b.y - pad, w: b.w + pad*2, h: b.h + pad*2 };
        }
        return null;
    },
    
    select(hit) {
        this.selected = hit;
        this.render();
        this.updateSelectBox();
    },
    
    deselect() {
        this.selected = null;
        document.getElementById('selectBox').classList.remove('visible');
        document.getElementById('formatBar').classList.remove('visible');
        this.render();
    },
    
    updateSelectBox() {
        const box = document.getElementById('selectBox');
        if (!this.selected) { box.classList.remove('visible'); return; }
        
        const bounds = this.getSelectedBounds();
        if (!bounds) { box.classList.remove('visible'); return; }
        
        const x = bounds.x * this.zoom + this.panX;
        const y = bounds.y * this.zoom + this.panY;
        const w = bounds.w * this.zoom;
        const h = bounds.h * this.zoom;
        
        box.style.left = x + 'px';
        box.style.top = y + 'px';
        box.style.width = w + 'px';
        box.style.height = h + 'px';
        box.classList.add('visible');
        
        // Show format bar for text and strokes
        this.updateFormatBar(x, y, w, h);
    },
    
    updateFormatBar(x, y, w, h) {
        const bar = document.getElementById('formatBar');
        if (!this.selected) { bar.classList.remove('visible'); return; }
        
        const { type, item } = this.selected;
        
        // Show format bar for text, stamps, and shapes
        if (type === 'stroke' && ['text', 'stamp', 'rect', 'circle', 'line', 'arrow', 'polygon', 'pen'].includes(item.tool)) {
            bar.style.left = x + 'px';
            bar.style.top = (y - 44) + 'px';
            bar.classList.add('visible');
            
            // Update color preview
            document.getElementById('fmtColorPreview').style.background = item.color || '#ffffff';
            document.getElementById('fmtSizeLabel').textContent = item.tool === 'stamp' ? (item.stampSize || 40) : (item.size || 4);
            
            // Show/hide BG toggle for text
            document.getElementById('fmtBgToggle').style.display = item.tool === 'text' ? 'flex' : 'none';
            if (item.tool === 'text') {
                document.getElementById('fmtBgToggle').classList.toggle('active', !!item.bg);
            }
        } else {
            bar.classList.remove('visible');
        }
    },
    
    setupFormatBar() {
        document.getElementById('fmtColorBtn').onclick = () => {
            const picker = document.getElementById('fmtColorPicker');
            picker.value = this.selected?.item?.color || '#ffffff';
            picker.click();
        };
        
        document.getElementById('fmtColorPicker').oninput = (e) => {
            if (this.selected?.type === 'stroke') {
                this.selected.item.color = e.target.value;
                document.getElementById('fmtColorPreview').style.background = e.target.value;
                this.syncStroke(this.selected.item);
                this.render();
            }
        };
        
        document.getElementById('fmtSizeUp').onclick = () => {
            if (!this.selected?.item) return;
            const item = this.selected.item;
            if (item.tool === 'stamp') {
                item.stampSize = Math.min(120, (item.stampSize || 40) + 5);
            } else {
                item.size = Math.min(32, (item.size || 4) + 1);
            }
            document.getElementById('fmtSizeLabel').textContent = item.tool === 'stamp' ? item.stampSize : item.size;
            this.syncStroke(item);
            this.render();
            this.updateSelectBox();
        };
        
        document.getElementById('fmtSizeDown').onclick = () => {
            if (!this.selected?.item) return;
            const item = this.selected.item;
            if (item.tool === 'stamp') {
                item.stampSize = Math.max(20, (item.stampSize || 40) - 5);
            } else {
                item.size = Math.max(1, (item.size || 4) - 1);
            }
            document.getElementById('fmtSizeLabel').textContent = item.tool === 'stamp' ? item.stampSize : item.size;
            this.syncStroke(item);
            this.render();
            this.updateSelectBox();
        };
        
        document.getElementById('fmtBgToggle').onclick = () => {
            if (!this.selected?.item || this.selected.item.tool !== 'text') return;
            const item = this.selected.item;
            item.bg = !item.bg;
            document.getElementById('fmtBgToggle').classList.toggle('active', item.bg);
            this.syncStroke(item);
            this.render();
        };
    },
    
    getSelectedBounds() {
        if (!this.selected) return null;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            return { x: item.x - item.size/2, y: item.y - item.size/2, w: item.size, h: item.size };
        }
        if (type === 'image') {
            return { x: item.x, y: item.y, w: item.w, h: item.h };
        }
        if (type === 'stroke') {
            return this.getStrokeBounds(item);
        }
        if (type === 'aura') {
            const r = item.radius;
            const shape = item.shape || 'circle';
            if (shape === 'line') {
                const ex = item.x + Math.cos(item.angle || 0) * r;
                const ey = item.y + Math.sin(item.angle || 0) * r;
                const pad = Math.max(this.gridSize * 0.25, 5);
                return { x: Math.min(item.x, ex) - pad, y: Math.min(item.y, ey) - pad, w: Math.abs(ex - item.x) + pad * 2, h: Math.abs(ey - item.y) + pad * 2 };
            }
            return { x: item.x - r, y: item.y - r, w: r * 2, h: r * 2 };
        }
        if (type === 'note') {
            const s = 20 / this.zoom;
            return { x: item.x - s, y: item.y - s, w: s * 2, h: s * 2 };
        }
        return null;
    },
    
    // Move selected item by delta
    moveSelected(dx, dy) {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            item.x += dx;
            item.y += dy;
            if (this.snap) {
                // Snap token CENTER to field CENTER (not grid lines)
                item.x = Math.floor((item.x - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX + this.gridSize / 2;
                item.y = Math.floor((item.y - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY + this.gridSize / 2;
            }
            // Update move radius display
            this.updateMoveRadius(item);
            // Real-time sync
            this.syncToken(item);
        }
        if (type === 'image') {
            item.x += dx;
            item.y += dy;
            if (this.snap) {
                item.x = Math.round((item.x - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX;
                item.y = Math.round((item.y - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY;
            }
            this.syncImageToFirebase(item);
        }
        if (type === 'stroke') {
            // Move stroke points
            if (item.start) { item.start.x += dx; item.start.y += dy; }
            if (item.end) { item.end.x += dx; item.end.y += dy; }
            if (item.path) item.path.forEach(p => { p.x += dx; p.y += dy; });
            if (item.points) item.points.forEach(p => { p.x += dx; p.y += dy; });
            if (item.x !== undefined) { item.x += dx; item.y += dy; }
            // Sync stroke
            this.syncStroke(item);
        }
        if (type === 'aura') {
            item.x += dx;
            item.y += dy;
            this.syncAura(item);
            this.renderAuras();
        }
        if (type === 'note') {
            item.x += dx;
            item.y += dy;
            // No snap for notes
            this.syncNote(item);
            this.renderNotes();
        }
        
        this.scheduleRender();
        this.updateSelectBox();
    },
    
    // ==================== RESIZE HANDLES ====================
    setupResizeHandles() {
        document.querySelectorAll('.wb-resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', e => {
                e.stopPropagation();
                if (!this.selected) return;
                this.isResizing = true;
                this.resizeHandle = handle.dataset.handle;
                // Store original state for resize
                const { type, item } = this.selected;
                this.resizeStart = { 
                    x: e.clientX, 
                    y: e.clientY, 
                    bounds: this.getSelectedBounds(),
                    // Store original item properties
                    origItem: JSON.parse(JSON.stringify(item))
                };
            });
        });
        
        window.addEventListener('mousemove', e => {
            if (this.isResizing) this.handleResize(e);
        });
        
        window.addEventListener('mouseup', () => {
            if (this.isResizing) {
                this.isResizing = false;
                this.resizeHandle = null;
                this.resizeStart = null;
                // Sync after resize
                if (this.selected?.type === 'token') this.syncToken(this.selected.item);
                if (this.selected?.type === 'stroke') this.syncStroke(this.selected.item);
            }
        });
    },
    
    handleResize(e) {
        if (!this.selected || !this.resizeStart) return;
        
        const dx = (e.clientX - this.resizeStart.x) / this.zoom;
        const dy = (e.clientY - this.resizeStart.y) / this.zoom;
        const h = this.resizeHandle;
        const { type, item } = this.selected;
        const orig = this.resizeStart.bounds;
        const origItem = this.resizeStart.origItem;
        
        if (type === 'token') {
            // Token: resize = change size (keep center)
            let sizeDelta = 0;
            if (h.includes('e') || h.includes('s')) sizeDelta = Math.max(dx, dy);
            if (h.includes('w') || h.includes('n')) sizeDelta = -Math.min(dx, dy);
            item.size = Math.max(20, Math.min(200, origItem.size + sizeDelta * 2));
        } 
        else if (type === 'image') {
            // Image: resize by edge/corner
            if (h.includes('e')) item.w = Math.max(30, origItem.w + dx);
            if (h.includes('w')) { item.x = origItem.x + dx; item.w = Math.max(30, origItem.w - dx); }
            if (h.includes('s')) item.h = Math.max(30, origItem.h + dy);
            if (h.includes('n')) { item.y = origItem.y + dy; item.h = Math.max(30, origItem.h - dy); }
        }
        else if (type === 'stroke') {
            // Handle different stroke types
            if (item.tool === 'text') {
                // Text: resize = change font size
                let sizeDelta = Math.max(dx, dy) / 4;
                if (h.includes('w') || h.includes('n')) sizeDelta = -sizeDelta;
                item.size = Math.max(1, Math.min(32, origItem.size + sizeDelta));
            }
            else if (item.tool === 'stamp') {
                // Stamp: resize = change stamp size
                let sizeDelta = Math.max(dx, dy);
                if (h.includes('w') || h.includes('n')) sizeDelta = -sizeDelta;
                item.stampSize = Math.max(20, Math.min(120, (origItem.stampSize || 40) + sizeDelta));
            }
            else if (['rect', 'circle', 'line', 'arrow'].includes(item.tool)) {
                // Shapes: resize by moving start/end points
                if (h.includes('e')) item.end.x = origItem.end.x + dx;
                if (h.includes('w')) item.start.x = origItem.start.x + dx;
                if (h.includes('s')) item.end.y = origItem.end.y + dy;
                if (h.includes('n')) item.start.y = origItem.start.y + dy;
                // Corner handles move both
                if (h === 'se') { item.end.x = origItem.end.x + dx; item.end.y = origItem.end.y + dy; }
                if (h === 'nw') { item.start.x = origItem.start.x + dx; item.start.y = origItem.start.y + dy; }
                if (h === 'ne') { item.end.x = origItem.end.x + dx; item.start.y = origItem.start.y + dy; }
                if (h === 'sw') { item.start.x = origItem.start.x + dx; item.end.y = origItem.end.y + dy; }
            }
        }
        
        this.scheduleRender();
        this.updateSelectBox();
    },
    
    // ==================== DRAWING ====================
    drawLivePen(p) {
        const ctx = this.layer === 'fog' ? this.fogCtx : this.mainCtx;
        const isFogReveal = this.layer === 'fog' && this._fogMode === 'reveal';
        if (isFogReveal) ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = this.layer === 'fog' ? (isFogReveal ? 'rgba(255,255,255,1)' : 'rgba(0,0,0,1)') : this.color;
        ctx.lineWidth = this.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (this.currentPath.length >= 2) {
            const prev = this.currentPath[this.currentPath.length - 2];
            ctx.beginPath();
            ctx.moveTo(prev.x * this.zoom + this.panX, prev.y * this.zoom + this.panY);
            ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY);
            ctx.stroke();
        }
        if (isFogReveal) ctx.globalCompositeOperation = 'source-over';
    },
    
    eraseLive(p) {
        // Use fog canvas if on fog layer, otherwise main canvas
        const ctx = this.layer === 'fog' ? this.fogCtx : this.mainCtx;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
    },
    
    // Reveal fog with shape tools (rect, circle)
    revealFogShape(start, end) {
        const ctx = this.fogCtx;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'black';
        
        const sx = start.x * this.zoom + this.panX;
        const sy = start.y * this.zoom + this.panY;
        const ex = end.x * this.zoom + this.panX;
        const ey = end.y * this.zoom + this.panY;
        
        ctx.beginPath();
        if (this.tool === 'rect') {
            ctx.fillRect(Math.min(sx, ex), Math.min(sy, ey), Math.abs(ex - sx), Math.abs(ey - sy));
        } else if (this.tool === 'circle') {
            const rx = Math.abs(ex - sx) / 2;
            const ry = Math.abs(ey - sy) / 2;
            ctx.ellipse((sx + ex) / 2, (sy + ey) / 2, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
    },
    
    addStroke(s) {
        if (this.historyIdx < this.history.length - 1) this.history = this.history.slice(0, this.historyIdx + 1);
        this.strokes.push(s);
        this.history.push({ type: 'stroke', data: s });
        this.historyIdx = this.history.length - 1;
        this.render();
    },
    
    finishPolygon() {
        if (this.polygonPoints.length < 3) { this.polygonPoints = []; this.renderUI(); return; }
        const isFogReveal = this.layer === 'fog' && this._fogMode === 'reveal';
        const isFogPlace = this.layer === 'fog' && this._fogMode !== 'reveal';
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: this.layer, tool: 'polygon',
            color: isFogPlace ? 'rgba(0,0,0,1)' : (isFogReveal ? 'rgba(255,255,255,1)' : this.color),
            size: this.size, fill: (isFogPlace || isFogReveal) ? true : this.fill,
            fogReveal: isFogReveal || false,
            points: [...this.polygonPoints], userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
        this.polygonPoints = [];
        this.renderUI();
    },
    
    // ==================== RENDER ====================
    render() {
        this.renderBg();
        this.renderMain();
        this.renderImages();
        this.renderTokens();
        this.renderFog();
        this.updateGrid();
        if (this.selected) this.updateSelectBox();
        if (this._remoteCursors) this.renderRemoteCursors(this._remoteCursors);
        if (this._remoteRulers) this.renderRemoteRulers();
        if (this._auras) this.renderAuras();
        if (this._notes) this.renderNotes();
    },
    
    renderBg() {
        const ctx = this.bgCtx;
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
        if (this.bgImage && this.bgImage.complete)
            ctx.drawImage(this.bgImage, this.panX, this.panY, this.bgImage.width * this.zoom, this.bgImage.height * this.zoom);
    },
    
    renderMain() {
        const ctx = this.mainCtx;
        ctx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
        this.strokes.filter(s => s.layer === 'main').forEach(s => this.drawStroke(ctx, s));
    },
    
    renderImages() {
        const c = document.getElementById('imagesContainer');
        c.innerHTML = '';
        this.images.forEach((img, i) => {
            const el = document.createElement('div');
            const isSelected = this.selected?.type === 'image' && this.selected?.item === img;
            const x = img.x * this.zoom + this.panX;
            const y = img.y * this.zoom + this.panY;
            const w = img.w * this.zoom;
            const h = img.h * this.zoom;
            
            el.className = 'wb-image' + (isSelected ? ' selected' : '');
            el.style.width = w + 'px';
            el.style.height = h + 'px';
            el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            el.innerHTML = `<img src="${img.src}" draggable="false">`;
            el.dataset.idx = i;
            el.draggable = false;
            el.ondragstart = () => false;
            el.onmousedown = e => {
                if (e.button !== 0) return; // Only left-click
                e.preventDefault();
                e.stopPropagation();
                if (this.tool === 'select') {
                    this.select({ type: 'image', item: img, index: i });
                    this.isDragging = true;
                    this.lastDragPoint = this.getPoint(e);
                }
            };
            c.appendChild(el);
        });
    },
    
    renderTokens() {
        // Process remote token animations
        const now = performance.now();
        let needsRerender = false;
        this.tokens.forEach(t => {
            if (t._animTarget) {
                const elapsed = now - t._animTime;
                const progress = Math.min(1, elapsed / t._animDuration);
                // Ease out cubic for smooth deceleration
                const ease = 1 - Math.pow(1 - progress, 3);
                t.x = t._animStart.x + (t._animTarget.x - t._animStart.x) * ease;
                t.y = t._animStart.y + (t._animTarget.y - t._animStart.y) * ease;
                if (progress >= 1) {
                    t.x = t._animTarget.x;
                    t.y = t._animTarget.y;
                    delete t._animTarget;
                    delete t._animStart;
                    delete t._animTime;
                    delete t._animDuration;
                } else {
                    needsRerender = true;
                }
            }
        });
        if (needsRerender) {
            requestAnimationFrame(() => this.renderTokens());
        }
        
        const c = document.getElementById('tokensContainer');
        c.innerHTML = '';
        this.tokens.forEach((t, i) => {
            const el = document.createElement('div');
            el.dataset.id = t.id;
            const isSelected = this.selected?.type === 'token' && this.selected?.item === t;
            const isActiveTurn = this.initiativeActive === t.id;
            const isDead = t.status?.includes('dead') || (t.hp !== undefined && t.hp <= 0);
            const displaySize = t.size * this.zoom;
            const x = t.x * this.zoom + this.panX - displaySize / 2;
            const y = t.y * this.zoom + this.panY - displaySize / 2;
            
            const isMultiSel = this.multiSelected.includes(t);
            el.className = 'wb-token' + (isSelected ? ' selected' : '') + (isActiveTurn ? ' active-turn' : '') + (isDead ? ' dead' : '');
            el.style.width = displaySize + 'px';
            el.style.height = displaySize + 'px';
            el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            el.style.background = t.img ? 'transparent' : t.color;
            el.style.borderColor = t.borderColor || '#8b5cf6';
            if (isMultiSel) el.style.outline = '3px solid rgba(139,92,246,0.8)';
            else el.style.outline = 'none';
            el.style.fontSize = (displaySize * 0.4) + 'px';
            
            // Inner content (portrait or letter)
            let html = '';
            if (t.img) {
                html += `<img src="${t.img}" style="width:100%;height:100%;object-fit:cover;border-radius:50%" draggable="false">`;
            } else {
                html += t.label || t.name?.charAt(0) || '?';
            }
            
            // HP bar (only show if maxHp > 0)
            if (t.maxHp && t.maxHp > 0) {
                const hpPercent = Math.max(0, Math.min(100, (t.hp / t.maxHp) * 100));
                const hpClass = hpPercent <= 25 ? 'critical' : hpPercent <= 50 ? 'low' : '';
                html += `<div class="wb-token__hp"><div class="wb-token__hp-fill ${hpClass}" style="width:${hpPercent}%"></div></div>`;
            }
            
            // Name label (moved down if HP bar exists)
            const labelBottom = (t.maxHp && t.maxHp > 0) ? '-28px' : '-20px';
            html += `<span class="wb-token__label" style="bottom:${labelBottom}">${t.name || ''}</span>`;
            
            // Initiative badge
            if (t.initiative !== undefined && t.initiative !== null && t.initiative !== '') {
                html += `<div class="wb-token__initiative">${t.initiative}</div>`;
            }
            
            // Status effects
            if (t.status && t.status.length > 0) {
                const statusSvgs = {
                    dead: '<svg viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 8l8 8M16 8l-8 8"/></svg>',
                    unconscious: '<svg viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 15s0-3 4-3 4 3 4 3"/></svg>',
                    poisoned: '<svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 8v4M12 16h.01"/></svg>',
                    burning: '<svg viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2"><path d="M12 22c-4-3-8-6-8-11a8 8 0 0 1 16 0c0 5-4 8-8 11z"/></svg>',
                    frozen: '<svg viewBox="0 0 24 24" fill="none" stroke="#38bdf8" stroke-width="2"><line x1="12" y1="2" x2="12" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>',
                    stunned: '<svg viewBox="0 0 24 24" fill="none" stroke="#eab308" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>',
                    invisible: '<svg viewBox="0 0 24 24" fill="none" stroke="#a78bfa" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><line x1="2" y1="2" x2="22" y2="22"/></svg>',
                    blessed: '<svg viewBox="0 0 24 24" fill="none" stroke="#fbbf24" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
                    cursed: '<svg viewBox="0 0 24 24" fill="none" stroke="#a855f7" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>',
                    prone: '<svg viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2"><path d="M4 16h16M8 12h8M6 8h12"/></svg>',
                    grappled: '<svg viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2"><path d="M18 8a6 6 0 0 0-12 0c0 7-3 9-3 9h18s-3-2-3-9"/></svg>',
                    concentrating: '<svg viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>'
                };
                html += '<div class="wb-token__status">';
                t.status.forEach(s => {
                    if (statusSvgs[s]) html += `<div class="wb-token__status-icon">${statusSvgs[s]}</div>`;
                });
                html += '</div>';
            }
            
            el.innerHTML = html;
            el.dataset.idx = i;
            el.draggable = false;
            el.ondragstart = () => false;
            el.onmousedown = e => {
                if (e.button !== 0) return; // Only left-click starts drag
                e.preventDefault();
                e.stopPropagation();
                this.hideTokenTooltip();
                
                // Players cannot move tokens
                if (!this.isGM) return;
                
                // If this token is part of a multi-selection, drag all
                if (this.multiSelected.length > 1 && this.multiSelected.includes(t)) {
                    this._multiDrag = { tokens: [...this.multiSelected], origins: this.multiSelected.map(tk => ({ id: tk.id, x: tk.x, y: tk.y })) };
                    this._tokenDrag = { token: t, startX: t.x, startY: t.y };
                } else {
                    this.multiSelected = [];
                    this._multiDrag = null;
                    this._tokenDrag = { token: t, startX: t.x, startY: t.y };
                }
                
                this.select({ type: 'token', item: t, index: i });
                this._dragOrigin = { x: t.x, y: t.y };
                this.showMoveRadius(t);
                this.isDragging = true;
                this.lastDragPoint = this.getPoint(e);
                this.uiCanvas.style.zIndex = '52';
            };
            el.ondblclick = e => {
                e.preventDefault();
                e.stopPropagation();
                if (this.isGM) this.showTokenEditModal(t);
            };
            el.oncontextmenu = e => {
                e.preventDefault();
                e.stopPropagation();
                if (!this.isGM) return;
                this._contextHit = { type: 'token', item: t, index: i };
                this.onContext(e);
            };
            el.onmouseenter = e => {
                if (this.isDragging) return;
                clearTimeout(this._tooltipTimer);
                this._tooltipTimer = setTimeout(() => {
                    const r = document.getElementById('canvasWrapper').getBoundingClientRect();
                    this.showTokenTooltip(t, e.clientX - r.left, e.clientY - r.top);
                }, 350);
            };
            el.onmouseleave = () => {
                this.hideTokenTooltip();
            };
            c.appendChild(el);
        });
        
        // Refresh sidebar if open
        if (document.getElementById('tokenSidebar')?.classList.contains('visible')) {
            clearTimeout(this._sidebarTimer);
            this._sidebarTimer = setTimeout(() => this.renderTokenSidebar(), 50);
        }
    },
    
    renderFog() {
        const ctx = this.fogCtx;
        ctx.clearRect(0, 0, this.fogCanvas.width, this.fogCanvas.height);
        this.strokes.filter(s => s.layer === 'fog').forEach(s => this.drawStroke(ctx, s));
    },
    
    renderUI() {
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        
        // Shape preview
        if (this.isDrawing && this.startPoint && this.currentPath.length > 0) {
            const end = this.currentPath[this.currentPath.length - 1];
            this.drawShapePreview(ctx, this.startPoint, end);
        }
        
        // Polygon preview
        if (this.polygonPoints.length > 0) {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(this.polygonPoints[0].x * this.zoom + this.panX, this.polygonPoints[0].y * this.zoom + this.panY);
            this.polygonPoints.forEach(pt => ctx.lineTo(pt.x * this.zoom + this.panX, pt.y * this.zoom + this.panY));
            ctx.stroke();
            ctx.setLineDash([]);
            this.polygonPoints.forEach(pt => {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(pt.x * this.zoom + this.panX, pt.y * this.zoom + this.panY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    },
    
    drawStroke(ctx, s) {
        // Fog reveal strokes use destination-out to cut through fog
        if (s.fogReveal) ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = s.fogReveal ? 'rgba(255,255,255,1)' : s.color;
        ctx.fillStyle = s.fogReveal ? 'rgba(255,255,255,1)' : s.color;
        ctx.lineWidth = s.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (s.tool === 'pen' || s.tool === 'eraser') {
            if (s.tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
            if (s.path && s.path.length > 1) {
                ctx.beginPath();
                ctx.moveTo(s.path[0].x * this.zoom + this.panX, s.path[0].y * this.zoom + this.panY);
                s.path.forEach(p => ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY));
                ctx.stroke();
            }
            if (s.tool === 'eraser') ctx.globalCompositeOperation = 'source-over';
        } else if (s.tool === 'text') {
            const fontSize = (s.size * 4 + 12) * this.zoom;
            ctx.font = fontSize + 'px sans-serif';
            const tx = s.start.x * this.zoom + this.panX;
            const ty = s.start.y * this.zoom + this.panY;
            
            // Draw background if enabled
            if (s.bg) {
                const textWidth = ctx.measureText(s.text).width;
                const pad = 4 * this.zoom;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(tx - pad, ty - fontSize * 0.85, textWidth + pad * 2, fontSize * 1.1);
            }
            
            ctx.fillStyle = s.color;
            ctx.fillText(s.text, tx, ty);
        } else if (s.tool === 'stamp') {
            const stampSize = (s.stampSize || 40) * this.zoom;
            ctx.font = stampSize + 'px sans-serif';
            ctx.fillText(s.stamp, s.x * this.zoom + this.panX, s.y * this.zoom + this.panY);
        } else if (s.tool === 'polygon' && s.points) {
            ctx.beginPath();
            ctx.moveTo(s.points[0].x * this.zoom + this.panX, s.points[0].y * this.zoom + this.panY);
            s.points.forEach(p => ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY));
            ctx.closePath();
            if (s.fill) ctx.fill();
            ctx.stroke();
        } else {
            this.drawShape(ctx, s);
        }
        if (s.fogReveal) ctx.globalCompositeOperation = 'source-over';
    },
    
    drawShape(ctx, s) {
        if (!s.start || !s.end) return;
        const sx = s.start.x * this.zoom + this.panX, sy = s.start.y * this.zoom + this.panY;
        const ex = s.end.x * this.zoom + this.panX, ey = s.end.y * this.zoom + this.panY;
        ctx.beginPath();
        switch (s.tool) {
            case 'line': ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); break;
            case 'rect':
                if (s.fill) ctx.fillRect(sx, sy, ex - sx, ey - sy);
                ctx.strokeRect(sx, sy, ex - sx, ey - sy); return;
            case 'circle':
                const rx = Math.abs(ex - sx) / 2, ry = Math.abs(ey - sy) / 2;
                ctx.ellipse(sx + (ex - sx) / 2, sy + (ey - sy) / 2, rx, ry, 0, 0, Math.PI * 2);
                if (s.fill) ctx.fill(); break;
            case 'arrow':
                ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
                const a = Math.atan2(ey - sy, ex - sx), hl = 15 * this.zoom;
                ctx.lineTo(ex - hl * Math.cos(a - Math.PI / 6), ey - hl * Math.sin(a - Math.PI / 6));
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - hl * Math.cos(a + Math.PI / 6), ey - hl * Math.sin(a + Math.PI / 6)); break;
        }
        ctx.stroke();
    },
    
    drawShapePreview(ctx, start, end) {
        const isFogReveal = this.layer === 'fog' && this._fogMode === 'reveal';
        const isFogPlace = this.layer === 'fog' && this._fogMode !== 'reveal';
        ctx.strokeStyle = isFogReveal ? '#22c55e' : (isFogPlace ? 'rgba(0,0,0,0.7)' : this.color);
        ctx.fillStyle = isFogReveal ? 'rgba(34,197,94,0.25)' : (isFogPlace ? 'rgba(0,0,0,0.5)' : this.color + '40');
        ctx.lineWidth = isFogReveal || isFogPlace ? 2 : this.size;
        ctx.setLineDash([5, 5]);
        const sx = start.x * this.zoom + this.panX, sy = start.y * this.zoom + this.panY;
        const ex = end.x * this.zoom + this.panX, ey = end.y * this.zoom + this.panY;
        ctx.beginPath();
        switch (this.tool) {
            case 'line': ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); break;
            case 'rect':
                if (this.fill) ctx.fillRect(sx, sy, ex - sx, ey - sy);
                ctx.strokeRect(sx, sy, ex - sx, ey - sy); ctx.setLineDash([]); return;
            case 'circle':
                const rx = Math.abs(ex - sx) / 2, ry = Math.abs(ey - sy) / 2;
                ctx.ellipse(sx + (ex - sx) / 2, sy + (ey - sy) / 2, rx, ry, 0, 0, Math.PI * 2);
                if (this.fill) ctx.fill(); break;
            case 'arrow':
                ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
                const a = Math.atan2(ey - sy, ex - sx);
                ctx.lineTo(ex - 15 * Math.cos(a - Math.PI / 6), ey - 15 * Math.sin(a - Math.PI / 6));
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - 15 * Math.cos(a + Math.PI / 6), ey - 15 * Math.sin(a + Math.PI / 6)); break;
        }
        ctx.stroke();
        ctx.setLineDash([]);
    },
    
    // ==================== TOOLS ====================
    showTextInput(p) {
        const inp = document.getElementById('textInput');
        inp.style.left = p.sx + 'px';
        inp.style.top = p.sy + 'px';
        inp.style.display = 'block';
        inp.style.color = this.color;
        inp.dataset.x = p.x;
        inp.dataset.y = p.y;
        inp.value = '';
        setTimeout(() => inp.focus(), 50);
    },
    
    placeText(text, x, y) {
        if (!text.trim()) return;
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: 'main', tool: 'text', color: this.color, size: this.size, text,
            start: { x: parseFloat(x), y: parseFloat(y) }, userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
    },
    
    createPing(sx, sy, wx, wy) {
        const ping = document.createElement('div');
        ping.className = 'wb-ping';
        ping.style.left = sx + 'px';
        ping.style.top = sy + 'px';
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'wb-ping__ring';
            ring.style.borderColor = this.userColor;
            ring.style.animationDelay = (i * 0.15) + 's';
            ping.appendChild(ring);
        }
        const dot = document.createElement('div');
        dot.className = 'wb-ping__dot';
        dot.style.background = this.userColor;
        ping.appendChild(dot);
        document.getElementById('canvasWrapper').appendChild(ping);
        // Sync world coordinates for other users
        this.syncPing(wx, wy);
        setTimeout(() => ping.remove(), 1500);
    },
    
    showRuler(start, end) {
        const dx = end.rawX - start.rawX, dy = end.rawY - start.rawY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const gridsExact = dist / this.gridSize;
        const grids = Math.round(gridsExact);
        const ft = gridsExact * 5;
        const meters = ft * 0.3048;
        const info = document.getElementById('rulerInfo');
        info.style.display = 'block';
        info.style.left = (end.sx + 8) + 'px';
        info.style.top = (end.sy - 8) + 'px';
        info.innerHTML = `<strong>${grids}</strong> Felder<br><span style="opacity:0.7;font-size:12px">${ft.toFixed(1)} ft / ${meters.toFixed(1)} m</span><br><span style="opacity:0.4;font-size:10px">${Math.round(dist)}px</span>`;
        
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(start.rawX * this.zoom + this.panX, start.rawY * this.zoom + this.panY);
        ctx.lineTo(end.rawX * this.zoom + this.panX, end.rawY * this.zoom + this.panY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Sync ruler to Firebase so players can see it
        if (this.db && this.roomCode) {
            const now = Date.now();
            if (!this._lastRulerSync || now - this._lastRulerSync > 80) {
                this._lastRulerSync = now;
                this.db.ref('whiteboard/' + this.roomCode + '/ruler/' + this.userId).set({
                    sx: start.rawX, sy: start.rawY, ex: end.rawX, ey: end.rawY,
                    grids: String(grids), ft: ft.toFixed(1), meters: meters.toFixed(1),
                    name: this.userName, color: this.userColor, ts: now
                });
            }
        }
    },
    
    setupStamps() {
        const grid = document.getElementById('stampsGrid');
        this.stamps.forEach(st => {
            const btn = document.createElement('button');
            btn.className = 'wb-stamp';
            btn.textContent = st;
            btn.onclick = () => {
                document.querySelectorAll('.wb-stamp').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                this.selectedStamp = st;
                this.tool = 'stamp';
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                document.getElementById('stampsPanel').classList.remove('visible');
                // If opened from context menu, place immediately at that position
                if (this._pendingStampPos) {
                    const pos = this._pendingStampPos;
                    this._pendingStampPos = null;
                    const s = {
                        id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                        layer: 'main', tool: 'stamp', stamp: st,
                        x: pos.x, y: pos.y, stampSize: 40, userId: this.userId, ts: Date.now()
                    };
                    this.addStroke(s);
                    this.syncStroke(s);
                    this.tool = 'select';
                    document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === 'select'));
                    this.updateCursor();
                }
            };
            grid.appendChild(btn);
        });
    },
    
    placeStamp(p) {
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: 'main', tool: 'stamp', stamp: this.selectedStamp,
            x: p.x, y: p.y, stampSize: 40, userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
    },
    
    showTokenModal() {
        this._editingLibIdx = undefined;
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280', this.userColor];
        
        // Background color picker
        const picker = document.getElementById('tokenColorPicker');
        picker.innerHTML = '';
        this.pendingTokenColor = this.pendingTokenColor || this.userColor;
        colors.forEach(c => {
            const btn = document.createElement('button');
            btn.style.cssText = `width:28px;height:28px;border-radius:50%;border:3px solid ${c === this.pendingTokenColor ? 'white' : 'transparent'};background:${c};cursor:pointer`;
            btn.onclick = () => {
                this.pendingTokenColor = c;
                picker.querySelectorAll('button').forEach(b => b.style.borderColor = 'transparent');
                btn.style.borderColor = 'white';
            };
            picker.appendChild(btn);
        });
        
        // Border color picker
        const borderPicker = document.getElementById('tokenBorderPicker');
        borderPicker.innerHTML = '';
        this.pendingTokenBorder = this.pendingTokenBorder || '#8b5cf6';
        colors.forEach(c => {
            const btn = document.createElement('button');
            btn.style.cssText = `width:28px;height:28px;border-radius:50%;border:3px solid ${c === this.pendingTokenBorder ? 'white' : 'transparent'};background:${c};cursor:pointer`;
            btn.onclick = () => {
                this.pendingTokenBorder = c;
                borderPicker.querySelectorAll('button').forEach(b => b.style.borderColor = 'transparent');
                btn.style.borderColor = 'white';
                document.getElementById('tokenPortraitPreview').style.borderColor = c;
            };
            borderPicker.appendChild(btn);
        });
        
        // Portrait preview & upload
        this.pendingTokenImg = null;
        const preview = document.getElementById('tokenPortraitPreview');
        preview.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>';
        preview.style.borderColor = this.pendingTokenBorder;
        preview.onclick = () => document.getElementById('tokenPortraitInput').click();
        
        document.getElementById('tokenPortraitInput').onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                this.pendingTokenImg = ev.target.result;
                preview.innerHTML = `<img src="${ev.target.result}" style="width:100%;height:100%;object-fit:cover">`;
            };
            reader.readAsDataURL(file);
        };
        
        document.getElementById('tokenNameInput').value = '';
        document.getElementById('createTokenHp').value = '';
        document.getElementById('createTokenMaxHp').value = '';
        document.getElementById('createTokenAc').value = '';
        document.getElementById('createTokenSpeed').value = '';
        document.getElementById('createTokenRange').value = '';
        document.getElementById('createTokenInit').value = '';
        document.getElementById('createTokenNotes').value = '';
        document.getElementById('createTokenAffiliation').value = '';
        document.getElementById('createTokenItems').value = '';
        
        // Visibility toggles default: visible
        document.getElementById('createAffVis').classList.add('visible-to-players');
        document.getElementById('createItemsVis').classList.add('visible-to-players');
        
        // Wire vis toggles
        ['createAffVis', 'createItemsVis'].forEach(id => {
            document.getElementById(id).onclick = () => document.getElementById(id).classList.toggle('visible-to-players');
        });
        
        // Type buttons in creation modal
        document.querySelectorAll('#tokenOverlay .wb-token-type-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === 'player');
            btn.onclick = () => {
                document.querySelectorAll('#tokenOverlay .wb-token-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        // Size presets in creation modal
        document.querySelectorAll('#createTokenSizePresets .wb-size-preset').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === 70);
            btn.onclick = () => {
                document.querySelectorAll('#createTokenSizePresets .wb-size-preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        document.getElementById('tokenOverlay').classList.add('visible');
    },
    
    createToken(name, color, x, y, borderColor, img, opts) {
        opts = opts || {};
        let tx = x ?? (this.mainCanvas.width / 2 / this.zoom - this.panX / this.zoom);
        let ty = y ?? (this.mainCanvas.height / 2 / this.zoom - this.panY / this.zoom);
        // Snap to field center if grid snap is on
        if (this.snap && this.gridSize) {
            tx = Math.floor((tx - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX + this.gridSize / 2;
            ty = Math.floor((ty - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY + this.gridSize / 2;
        }
        const t = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            x: tx,
            y: ty,
            size: opts.size || this.gridSize || 70,
            color: color || this.userColor,
            borderColor: borderColor || '#8b5cf6',
            name: name || this.userName, 
            label: (name || this.userName).charAt(0).toUpperCase(),
            userId: this.userId,
            hp: opts.hp || 0,
            maxHp: opts.maxHp || 0,
            initiative: opts.initiative !== undefined ? opts.initiative : null,
            ac: opts.ac || 10,
            speed: opts.speed || 6,
            range: opts.range || 1,
            type: opts.type || 'player',
            notes: opts.notes || '',
            affiliation: opts.affiliation || '',
            items: opts.items || '',
            affVisible: opts.affVisible !== false,
            itemsVisible: opts.itemsVisible !== false,
            status: []
        };
        if (img) t.img = img;
        this.tokens.push(t);
        this.syncToken(t);
        this.renderTokens();
        this.renderInitiative();
        this.renderTokenSidebar();
        this.toast('Token: ' + t.name);
    },
    
    // ==================== TOKEN EDIT MODAL ====================
    showTokenEditModal(token) {
        this.editingToken = token;
        document.getElementById('editTokenName').value = token.name || '';
        document.getElementById('editTokenHp').value = token.hp || 0;
        document.getElementById('editTokenMaxHp').value = token.maxHp || 0;
        document.getElementById('editTokenInit').value = token.initiative ?? '';
        document.getElementById('editTokenAc').value = token.ac || 10;
        document.getElementById('editTokenSpeed').value = token.speed ?? 6;
        document.getElementById('editTokenRange').value = token.range ?? 1;
        document.getElementById('editTokenNotes').value = token.notes || '';
        document.getElementById('editTokenAffiliation').value = token.affiliation || '';
        document.getElementById('editTokenItems').value = token.items || '';
        
        // Visibility toggles
        document.getElementById('editAffVis').classList.toggle('visible-to-players', token.affVisible !== false);
        document.getElementById('editItemsVis').classList.toggle('visible-to-players', token.itemsVisible !== false);
        ['editAffVis', 'editItemsVis'].forEach(id => {
            document.getElementById(id).onclick = () => document.getElementById(id).classList.toggle('visible-to-players');
        });
        
        // Portrait preview
        const preview = document.getElementById('editTokenPortraitPreview');
        this._editTokenImg = token.img || null;
        if (token.img) {
            preview.innerHTML = `<img src="${token.img}" style="width:100%;height:100%;object-fit:cover">`;
        } else {
            preview.innerHTML = `<span style="font-size:24px;font-weight:700">${token.label || '?'}</span>`;
            preview.style.background = token.color || '#8b5cf6';
        }
        preview.style.borderColor = token.borderColor || '#8b5cf6';
        
        // Portrait change
        document.getElementById('editTokenPortraitBtn').onclick = () => document.getElementById('editTokenPortraitInput').click();
        document.getElementById('editTokenPortraitInput').onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                this._editTokenImg = ev.target.result;
                preview.innerHTML = `<img src="${ev.target.result}" style="width:100%;height:100%;object-fit:cover">`;
            };
            reader.readAsDataURL(file);
        };
        document.getElementById('editTokenPortraitRemoveBtn').onclick = () => {
            this._editTokenImg = null;
            preview.innerHTML = `<span style="font-size:24px;font-weight:700">${(token.name || '?').charAt(0)}</span>`;
            preview.style.background = token.color || '#8b5cf6';
        };
        
        // Type buttons
        document.querySelectorAll('#editTokenTypeGrid .wb-token-type-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === (token.type || 'player'));
        });
        
        // Size presets
        document.querySelectorAll('#tokenSizePresets .wb-size-preset').forEach(btn => {
            const size = parseInt(btn.dataset.size);
            btn.classList.toggle('active', Math.abs(token.size - size) < 10);
        });
        
        // Status effects - ensure explicit boolean (undefined causes toggle instead of set!)
        const tokenStatuses = Array.isArray(token.status) ? token.status : [];
        document.querySelectorAll('#statusGrid .wb-status-btn').forEach(btn => {
            const status = btn.dataset.status;
            btn.classList.toggle('active', tokenStatuses.includes(status));
        });
        
        // Border color picker
        const borderPicker = document.getElementById('editTokenBorderPicker');
        borderPicker.innerHTML = '';
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280', '#ffffff'];
        this._editBorderColor = token.borderColor || '#8b5cf6';
        colors.forEach(c => {
            const btn = document.createElement('button');
            btn.style.cssText = `width:28px;height:28px;border-radius:50%;border:3px solid ${c === this._editBorderColor ? 'white' : 'transparent'};background:${c};cursor:pointer`;
            btn.onclick = () => {
                this._editBorderColor = c;
                borderPicker.querySelectorAll('button').forEach(b => b.style.borderColor = 'transparent');
                btn.style.borderColor = 'white';
            };
            borderPicker.appendChild(btn);
        });
        
        document.getElementById('tokenEditOverlay').classList.add('visible');
    },
    
    saveTokenEdit() {
        if (!this.editingToken) return;
        
        const t = this.editingToken;
        t.name = document.getElementById('editTokenName').value || t.name;
        t.label = t.name.charAt(0).toUpperCase();
        t.hp = parseInt(document.getElementById('editTokenHp').value) || 0;
        t.maxHp = parseInt(document.getElementById('editTokenMaxHp').value) || 0;
        const initVal = document.getElementById('editTokenInit').value;
        t.initiative = initVal === '' ? null : parseInt(initVal);
        t.ac = parseInt(document.getElementById('editTokenAc').value) || 10;
        t.speed = parseInt(document.getElementById('editTokenSpeed').value) || 6;
        t.range = parseInt(document.getElementById('editTokenRange').value) || 1;
        t.notes = document.getElementById('editTokenNotes').value || '';
        t.affiliation = document.getElementById('editTokenAffiliation').value || '';
        t.items = document.getElementById('editTokenItems').value || '';
        t.affVisible = document.getElementById('editAffVis').classList.contains('visible-to-players');
        t.itemsVisible = document.getElementById('editItemsVis').classList.contains('visible-to-players');
        
        // Portrait
        if (this._editTokenImg !== undefined) {
            if (this._editTokenImg) {
                t.img = this._editTokenImg;
            } else {
                delete t.img;
            }
        }
        t.label = t.name.charAt(0).toUpperCase();
        
        // Border color
        if (this._editBorderColor) t.borderColor = this._editBorderColor;
        
        // Get type
        const activeType = document.querySelector('#editTokenTypeGrid .wb-token-type-btn.active');
        if (activeType) t.type = activeType.dataset.type;
        
        // Get selected size
        const activeSize = document.querySelector('#tokenSizePresets .wb-size-preset.active');
        if (activeSize) t.size = parseInt(activeSize.dataset.size);
        
        // Get active statuses
        t.status = [];
        document.querySelectorAll('#statusGrid .wb-status-btn.active').forEach(btn => {
            t.status.push(btn.dataset.status);
        });
        
        this.syncToken(t);
        this.renderTokens();
        this.renderInitiative();
        this.renderTokenSidebar();
        document.getElementById('tokenEditOverlay').classList.remove('visible');
        this.editingToken = null;
        this.toast('Token aktualisiert');
    },
    
    setupTokenEditModal() {
        // Size presets
        document.querySelectorAll('#tokenSizePresets .wb-size-preset').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('#tokenSizePresets .wb-size-preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        // Status toggles
        document.querySelectorAll('#statusGrid .wb-status-btn').forEach(btn => {
            btn.onclick = () => btn.classList.toggle('active');
        });
        
        // Type buttons in edit modal
        document.querySelectorAll('#editTokenTypeGrid .wb-token-type-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('#editTokenTypeGrid .wb-token-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        // Save button
        document.getElementById('tokenEditSaveBtn').onclick = () => this.saveTokenEdit();
    },
    
    // ==================== INITIATIVE TRACKER ====================
    setupInitiative() {
        document.getElementById('initiativeBtn').onclick = () => {
            document.getElementById('initiativePanel').classList.toggle('visible');
            document.getElementById('initiativeBtn').classList.toggle('active-red');
            this.renderInitiative();
        };
        
        const hideIframeChrome = (frame) => {
            try {
                const doc = frame.contentDocument || frame.contentWindow.document;
                const style = doc.createElement('style');
                style.textContent = 'nav,.topbar,.top-bar,.navbar,.navigation-bar,.dock,.footer,footer,.site-footer,.bottombar,[class*="topnav"],[class*="TopNav"],[id*="topnav"],[id*="TopNav"],[class*="footer"],[id*="footer"],[class*="dock"],[id*="dock"]{display:none!important} body{padding-top:0!important;margin-top:0!important} main,.main-content,[class*="main"]{margin-top:0!important;padding-top:12px!important}';
                doc.head.appendChild(style);
            } catch(e) { /* cross-origin fallback - ignore */ }
        };
        document.getElementById('effectsBtn').onclick = () => {
            const panel = document.getElementById('effectsPanel');
            const frame = document.getElementById('effectsFrame');
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible'); frame.src = 'about:blank';
            } else {
                frame.src = 'gm.html#effects';
                frame.onload = () => hideIframeChrome(frame);
                panel.classList.add('visible');
            }
        };
        document.getElementById('broadcastBtn').onclick = () => {
            const panel = document.getElementById('broadcastPanel');
            const frame = document.getElementById('broadcastFrame');
            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible'); frame.src = 'about:blank';
            } else {
                frame.src = 'gm.html#broadcast';
                frame.onload = () => hideIframeChrome(frame);
                panel.classList.add('visible');
            }
        };
        
        document.getElementById('initNextBtn').onclick = () => this.nextTurn();
        document.getElementById('initPrevBtn').onclick = () => this.prevTurn();
        document.getElementById('initSortBtn').onclick = () => this.sortInitiative();
        document.getElementById('initCollapseBtn').onclick = () => {
            const panel = document.getElementById('initiativePanel');
            panel.classList.toggle('collapsed');
            document.getElementById('initCollapseBtn').querySelector('svg').style.transform = panel.classList.contains('collapsed') ? 'rotate(-90deg)' : '';
        };
        document.getElementById('initCloseBtn').onclick = () => {
            document.getElementById('initiativePanel').classList.remove('visible');
            document.getElementById('initiativeBtn').classList.remove('active-red');
        };
    },
    
    renderInitiative() {
        const list = document.getElementById('initiativeList');
        if (!list) return;
        
        // Build initiative order from tokens with initiative values
        const tokensWithInit = this.tokens
            .filter(t => t.initiative !== null && t.initiative !== undefined)
            .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        
        list.innerHTML = '';
        tokensWithInit.forEach(t => {
            const isDead = t.status?.includes('dead') || (t.hp !== undefined && t.hp <= 0);
            const isActive = this.initiativeActive === t.id;
            
            const item = document.createElement('div');
            item.className = 'wb-initiative-item' + (isActive ? ' active' : '') + (isDead ? ' dead' : '');
            item.dataset.id = t.id;
            
            item.innerHTML = `
                <div class="wb-initiative-item__portrait" style="background:${t.img ? 'transparent' : t.color}">
                    ${t.img ? `<img src="${t.img}">` : t.label || '?'}
                </div>
                <div class="wb-initiative-item__info">
                    <div class="wb-initiative-item__name">${t.name || 'Token'}</div>
                    <div class="wb-initiative-item__hp">${t.maxHp ? `HP: ${t.hp}/${t.maxHp}` : ''} ${t.ac ? `AC: ${t.ac}` : ''}</div>
                </div>
                <div class="wb-initiative-item__init" style="display:flex;align-items:center;justify-content:center;font-weight:700;font-size:16px;color:white;min-width:32px">
                    ${t.initiative ?? ''}
                </div>
            `;
            
            // Click to make active turn
            item.onclick = e => {
                this.initiativeActive = t.id;
                this.renderTokens();
                this.renderInitiative();
                // Pan to token
                this.targetPanX = this.mainCanvas.width / 2 - t.x * this.zoom;
                this.targetPanY = this.mainCanvas.height / 2 - t.y * this.zoom;
                this.startAnimation();
            };
            
            // Double-click to edit initiative via token edit modal
            item.ondblclick = e => {
                e.stopPropagation();
                this.showTokenEditModal(t);
            };
            
            list.appendChild(item);
        });
        
        // If no tokens with initiative, show hint
        if (tokensWithInit.length === 0) {
            list.innerHTML = '<div style="text-align:center;padding:20px;color:rgba(255,255,255,0.4);font-size:12px">Doppelklicke auf Token um Initiative zu setzen</div>';
        }
    },
    
    nextTurn() {
        const tokensWithInit = this.tokens
            .filter(t => t.initiative !== null && t.initiative !== undefined)
            .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        
        if (tokensWithInit.length === 0) return;
        
        const currentIdx = tokensWithInit.findIndex(t => t.id === this.initiativeActive);
        const nextIdx = (currentIdx + 1) % tokensWithInit.length;
        this.initiativeActive = tokensWithInit[nextIdx].id;
        
        // Skip dead tokens
        const nextToken = tokensWithInit[nextIdx];
        if (nextToken.status?.includes('dead') || (nextToken.hp !== undefined && nextToken.hp <= 0)) {
            this.nextTurn(); // Recursive skip
            return;
        }
        
        this.renderTokens();
        this.renderInitiative();
        
        // Pan to active token
        const t = tokensWithInit[nextIdx];
        this.targetPanX = this.mainCanvas.width / 2 - t.x * this.zoom;
        this.targetPanY = this.mainCanvas.height / 2 - t.y * this.zoom;
        this.startAnimation();
        this.toast(`${t.name} ist dran!`);
    },
    
    prevTurn() {
        const tokensWithInit = this.tokens
            .filter(t => t.initiative !== null && t.initiative !== undefined)
            .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        
        if (tokensWithInit.length === 0) return;
        
        const currentIdx = tokensWithInit.findIndex(t => t.id === this.initiativeActive);
        const prevIdx = currentIdx <= 0 ? tokensWithInit.length - 1 : currentIdx - 1;
        this.initiativeActive = tokensWithInit[prevIdx].id;
        
        this.renderTokens();
        this.renderInitiative();
        
        const t = tokensWithInit[prevIdx];
        this.targetPanX = this.mainCanvas.width / 2 - t.x * this.zoom;
        this.targetPanY = this.mainCanvas.height / 2 - t.y * this.zoom;
        this.startAnimation();
    },
    
    sortInitiative() {
        // Already sorted in renderInitiative, just re-render
        this.renderInitiative();
        this.toast('Initiative sortiert');
    },
    
    resetInitiative() {
        this.initiativeActive = null;
        this.tokens.forEach(t => {
            t.initiative = null;
        });
        this.renderTokens();
        this.renderInitiative();
        this.toast('Initiative zurückgesetzt');
    },
    
    // ==================== FOCUS TOOL ====================
    createFocus(wx, wy, rx, ry) {
        // Broadcast focus command to all users
        if (this.db && this.roomCode) {
            this.db.ref('whiteboard/' + this.roomCode + '/focus').set({
                wx, wy,
                userId: this.userId,
                ts: Date.now()
            });
        }
        // Apply focus locally too
        this.applyFocus({ wx, wy });
        this.toast('Fokus gesetzt');
    },
    
    applyFocus(f) {
        // Pan camera so that wx,wy is at center of viewport
        const canvasRect = this.uiCanvas.getBoundingClientRect();
        const centerX = canvasRect.width / 2;
        const centerY = canvasRect.height / 2;
        this.targetPanX = centerX - f.wx * this.zoom;
        this.targetPanY = centerY - f.wy * this.zoom;
        this.startAnimation();
    },
    
    // ==================== GRID PERSISTENCE ====================
    syncGridSettings() {
        if (!this.db || !this.roomCode) return;
        this.db.ref('whiteboard/' + this.roomCode + '/gridSettings').set({
            gridSize: this.gridSize,
            gridOffsetX: this.gridOffsetX,
            gridOffsetY: this.gridOffsetY,
            gridColor: this.gridColor
        });
    },
    
    loadGridSettings() {
        if (!this.db || !this.roomCode) return;
        this.db.ref('whiteboard/' + this.roomCode + '/gridSettings').once('value').then(snap => {
            const s = snap.val();
            if (s) {
                this.gridSize = s.gridSize || 70;
                this.gridOffsetX = s.gridOffsetX || 0;
                this.gridOffsetY = s.gridOffsetY || 0;
                this.gridColor = s.gridColor || 'rgba(255,255,255,0.12)';
                this.updateGrid();
            }
        });
    },
    
    // ==================== TOKEN DRAG LINE ====================
    drawDragLine(drag, p) {
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        
        const startSX = drag.startX * this.zoom + this.panX;
        const startSY = drag.startY * this.zoom + this.panY;
        
        // Use raw world coords for distance calc and snap target
        const dx = p.rawX - drag.startX;
        const dy = p.rawY - drag.startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const fields = Math.round(dist / (this.gridSize || 70));
        const maxFields = drag.token.speed || 6;
        const over = fields > maxFields;
        const lineColor = drag.token.borderColor || '#8b5cf6';
        const distColor = over ? '#ef4444' : fields === maxFields ? '#f59e0b' : '#22c55e';
        
        // Snapped target for endpoint indicator
        let snapSX = p.rx, snapSY = p.ry;
        if (this.snap && this.gridSize) {
            const snapX = Math.floor((p.rawX - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX + this.gridSize / 2;
            const snapY = Math.floor((p.rawY - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY + this.gridSize / 2;
            snapSX = snapX * this.zoom + this.panX;
            snapSY = snapY * this.zoom + this.panY;
        }
        
        // Draw dashed line
        ctx.save();
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 6]);
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(startSX, startSY);
        ctx.lineTo(snapSX, snapSY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Arrow at end
        const angle = Math.atan2(snapSY - startSY, snapSX - startSX);
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = lineColor;
        ctx.beginPath();
        ctx.moveTo(snapSX, snapSY);
        ctx.lineTo(snapSX - 14 * Math.cos(angle - 0.4), snapSY - 14 * Math.sin(angle - 0.4));
        ctx.lineTo(snapSX - 14 * Math.cos(angle + 0.4), snapSY - 14 * Math.sin(angle + 0.4));
        ctx.closePath();
        ctx.fill();
        
        // Destination circle
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = lineColor;
        ctx.beginPath();
        ctx.arc(snapSX, snapSY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.6;
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Distance badge
        if (fields > 0) {
            const mx = (startSX + snapSX) / 2;
            const my = (startSY + snapSY) / 2;
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(16,16,20,0.9)';
            const tw = ctx.measureText(fields + ' / ' + maxFields).width + 20;
            ctx.beginPath();
            ctx.roundRect(mx - tw / 2, my - 13, tw, 26, 6);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.fillStyle = distColor;
            ctx.font = '700 13px inherit';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(fields + ' / ' + maxFields, mx, my);
        }
        
        ctx.restore();
    },
    
    hideDragLine() {
        this.uiCtx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        this.uiCanvas.style.zIndex = '5';
    },
    
    animateTokenMove(token, targetX, targetY) {
        const startX = token.x, startY = token.y;
        const dx = targetX - startX, dy = targetY - startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1) { token.x = targetX; token.y = targetY; this.syncToken(token); this.renderTokens(); this.select({ type: 'token', item: token }); return; }
        
        // Clear any remote animation state
        delete token._animTarget; delete token._animStart; delete token._animTime; delete token._animDuration;
        
        const duration = Math.min(800, Math.max(350, dist * 1.2));
        const startTime = performance.now();
        let lastSync = 0;
        
        const animate = (now) => {
            const elapsed = now - startTime;
            const progress = Math.min(1, elapsed / duration);
            const ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
            
            token.x = startX + dx * ease;
            token.y = startY + dy * ease;
            this._repositionTokenDOM(token);
            
            if (now - lastSync > 120 && progress < 1) {
                lastSync = now;
                this.syncToken(token);
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                token.x = targetX;
                token.y = targetY;
                this.syncToken(token);
                this.renderTokens();
                this.select({ type: 'token', item: token });
            }
        };
        requestAnimationFrame(animate);
    },
    
    animateMultiTokenMove(targets) {
        if (!targets.length) return;
        let maxDist = 0;
        targets.forEach(t => {
            const d = Math.sqrt((t.targetX - t.startX) ** 2 + (t.targetY - t.startY) ** 2);
            if (d > maxDist) maxDist = d;
            // Clear any remote animation state
            delete t.token._animTarget; delete t.token._animStart; delete t.token._animTime; delete t.token._animDuration;
        });
        if (maxDist < 1) {
            targets.forEach(t => { t.token.x = t.targetX; t.token.y = t.targetY; this.syncToken(t.token); });
            this.renderTokens();
            return;
        }
        const duration = Math.min(800, Math.max(350, maxDist * 1.2));
        const startTime = performance.now();
        let lastSync = 0;
        
        const animate = (now) => {
            const elapsed = now - startTime;
            const progress = Math.min(1, elapsed / duration);
            const ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
            
            targets.forEach(t => {
                t.token.x = t.startX + (t.targetX - t.startX) * ease;
                t.token.y = t.startY + (t.targetY - t.startY) * ease;
                this._repositionTokenDOM(t.token);
            });
            
            if (now - lastSync > 120 && progress < 1) {
                lastSync = now;
                targets.forEach(t => this.syncToken(t.token));
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                targets.forEach(t => {
                    t.token.x = t.targetX; t.token.y = t.targetY;
                    this.syncToken(t.token);
                });
                this.renderTokens();
            }
        };
        requestAnimationFrame(animate);
    },
    
    // Fast DOM reposition for token animation (avoids full rebuild)
    _repositionTokenDOM(token) {
        const c = document.getElementById('tokensContainer');
        const el = c.querySelector(`[data-id="${token.id}"]`);
        if (!el) return;
        const displaySize = token.size * this.zoom;
        const x = token.x * this.zoom + this.panX - displaySize / 2;
        const y = token.y * this.zoom + this.panY - displaySize / 2;
        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    },
    
    // ==================== MARQUEE MULTI-SELECT ====================
    drawMarquee(start, p) {
        const el = document.getElementById('marquee');
        const left = Math.min(start.rx, p.rx);
        const top = Math.min(start.ry, p.ry);
        const w = Math.abs(p.rx - start.rx);
        const h = Math.abs(p.ry - start.ry);
        el.style.left = left + 'px';
        el.style.top = top + 'px';
        el.style.width = w + 'px';
        el.style.height = h + 'px';
        el.classList.add('visible');
    },
    
    finishMarquee(start, end) {
        const minX = Math.min(start.x, end.rawX);
        const maxX = Math.max(start.x, end.rawX);
        const minY = Math.min(start.y, end.rawY);
        const maxY = Math.max(start.y, end.rawY);
        
        // If marquee is too small (less than ~5 world units), ignore
        if (Math.abs(maxX - minX) < 5 && Math.abs(maxY - minY) < 5) return;
        
        this.multiSelected = this.tokens.filter(t => {
            return t.x >= minX && t.x <= maxX && t.y >= minY && t.y <= maxY;
        });
        
        if (this.multiSelected.length > 0) {
            this.toast(this.multiSelected.length + ' Tokens ausgewählt');
            this.renderTokens(); // Re-render with highlight
        }
    },
    
    // ==================== TOOLBAR LOCK ====================
    setupToolbarLock() {
        const lockBtn = document.getElementById('toolbarLockBtn');
        if (!lockBtn) return;
        
        lockBtn.onclick = () => {
            this.toolbarLocked = !this.toolbarLocked;
            lockBtn.classList.toggle('active', this.toolbarLocked);
            if (this.db && this.roomCode) {
                this.db.ref('whiteboard/' + this.roomCode + '/toolbarLocked').set(this.toolbarLocked);
            }
            this.toast(this.toolbarLocked ? 'Werkzeuge gesperrt' : 'Werkzeuge entsperrt');
        };
        
        // Listen for lock state changes (for players)
        if (this.db && this.roomCode) {
            this.db.ref('whiteboard/' + this.roomCode + '/toolbarLocked').on('value', snap => {
                const locked = snap.val();
                if (!this.isGM && locked !== null) {
                    this.toolbarLocked = locked;
                    const toolbar = document.getElementById('wbToolbar');
                    toolbar.classList.toggle('locked', locked);
                    if (locked && this.tool !== 'select' && this.tool !== 'ruler' && this.tool !== 'ping') {
                        this.tool = 'select';
                        document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === 'select'));
                        this.updateCursor();
                    }
                }
            });
        }
    },
    
    // ==================== TOKEN LIBRARY ====================
    setupTokenLibrary() {
        // Save button
        document.getElementById('tokenSaveLibBtn').onclick = async () => {
            const lib = this.getTokenLibrary();
            const isPro = window.riftPro || false;
            const limit = isPro ? 50 : 20;
            
            if (lib.length >= limit) {
                this.toast(`Bibliothek voll (${limit} Token). ${isPro ? '' : 'Pro: 50'}`);
                return;
            }
            
            const name = document.getElementById('tokenNameInput').value.trim() || 'Token';
            const activeType = document.querySelector('#tokenOverlay .wb-token-type-btn.active');
            const activeSize = document.querySelector('#createTokenSizePresets .wb-size-preset.active');
            
            // Compress portrait image for storage (128px thumbnail, JPEG 0.6 quality)
            let compressedImg = null;
            if (this.pendingTokenImg) {
                try {
                    compressedImg = await this.compressTokenImage(this.pendingTokenImg, 128, 0.6);
                } catch (err) {
                    compressedImg = null;
                }
            }
            
            const template = {
                id: Date.now(),
                name,
                color: this.pendingTokenColor,
                borderColor: this.pendingTokenBorder,
                img: compressedImg,
                hp: parseInt(document.getElementById('createTokenHp').value) || 0,
                maxHp: parseInt(document.getElementById('createTokenMaxHp').value) || 0,
                ac: parseInt(document.getElementById('createTokenAc').value) || 10,
                speed: parseInt(document.getElementById('createTokenSpeed').value) || 6,
                range: parseInt(document.getElementById('createTokenRange').value) || 1,
                initiative: document.getElementById('createTokenInit').value !== '' ? parseInt(document.getElementById('createTokenInit').value) : null,
                type: activeType?.dataset.type || 'player',
                notes: document.getElementById('createTokenNotes').value || '',
                affiliation: document.getElementById('createTokenAffiliation').value || '',
                items: document.getElementById('createTokenItems').value || '',
                size: activeSize ? parseInt(activeSize.dataset.size) : (this.gridSize || 70),
            };
            
            // Update existing or add new
            if (this._editingLibIdx !== undefined && this._editingLibIdx !== null && lib[this._editingLibIdx]) {
                template.id = lib[this._editingLibIdx].id || Date.now();
                lib[this._editingLibIdx] = template;
                this._editingLibIdx = undefined;
                this.toast('Token aktualisiert: ' + name);
            } else {
                lib.push(template);
                this.toast('Token gespeichert: ' + name);
            }
            this.saveTokenLibrary(lib);
        };
        
        // Token Manager button
        document.getElementById('tokenLoadLibBtn').onclick = () => {
            this.showTokenManager();
        };
        
        // New token button inside manager
        document.getElementById('tmgrNewTokenBtn').onclick = () => {
            document.getElementById('tokenLibOverlay').classList.remove('visible');
            this.showTokenModal();
        };
        
        // Tab switching in manager
        document.getElementById('tmgrTabs').onclick = e => {
            const tab = e.target.closest('.wb-tmgr-tab');
            if (!tab) return;
            document.querySelectorAll('#tmgrTabs .wb-tmgr-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            this._tmgrFilter = tab.dataset.tab;
            this.renderTokenManager();
        };
    },
    
    compressTokenImage(dataUrl, maxSize, quality) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
                canvas.width = Math.round(img.width * scale);
                canvas.height = Math.round(img.height * scale);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                resolve(canvas.toDataURL('image/jpeg', quality));
            };
            img.onerror = reject;
            img.src = dataUrl;
        });
    },
    
    getTokenLibrary() {
        return JSON.parse(localStorage.getItem('rift_token_library') || '[]');
    },
    
    saveTokenLibrary(lib) {
        try {
            localStorage.setItem('rift_token_library', JSON.stringify(lib));
        } catch (e) {
            this.toast('Speicher voll - komprimiere...');
            for (let i = 0; i < lib.length - 1; i++) {
                if (lib[i].img) { lib[i].img = null; }
                try {
                    localStorage.setItem('rift_token_library', JSON.stringify(lib));
                    return;
                } catch (e2) { /* keep stripping */ }
            }
            this.toast('Speicher voll! Token ohne Bild gespeichert.');
            lib[lib.length - 1].img = null;
            try { localStorage.setItem('rift_token_library', JSON.stringify(lib)); } catch(e3) {}
        }
    },
    
    showTokenManager(filter) {
        this._tmgrFilter = filter || 'all';
        document.querySelectorAll('#tmgrTabs .wb-tmgr-tab').forEach(t => {
            t.classList.toggle('active', t.dataset.tab === this._tmgrFilter);
        });
        this.renderTokenManager();
        document.getElementById('tokenLibOverlay').classList.add('visible');
    },
    
    renderTokenManager() {
        const lib = this.getTokenLibrary();
        const isPro = window.riftPro || false;
        const limit = isPro ? 50 : 20;
        const grid = document.getElementById('tokenLibGrid');
        const filter = this._tmgrFilter || 'all';
        
        document.getElementById('tokenLibCount').textContent = `${lib.length} / ${limit}`;
        
        // Update tab badges
        const counts = { all: lib.length, player: 0, npc: 0, monster: 0, hidden: 0 };
        lib.forEach(t => { const tp = t.type || 'player'; if (counts[tp] !== undefined) counts[tp]++; });
        document.querySelectorAll('#tmgrTabs .wb-tmgr-tab').forEach(tab => {
            const c = counts[tab.dataset.tab];
            let badge = tab.querySelector('.wb-tmgr-badge');
            if (!badge) { badge = document.createElement('span'); badge.className = 'wb-tmgr-badge'; tab.appendChild(badge); }
            badge.textContent = c !== undefined ? c : '0';
        });
        
        const filtered = filter === 'all' ? lib : lib.filter(t => (t.type || 'player') === filter);
        
        if (filtered.length === 0) {
            grid.innerHTML = '<p style="color:rgba(255,255,255,0.4);text-align:center;padding:24px;font-size:12px">Keine Tokens in dieser Kategorie</p>';
            return;
        }
        
        const sizeLabels = { 44: 'S', 70: 'M', 140: 'L(2x2)', 210: 'XL(3x3)', 280: 'XXL(4x4)' };
        const typeColors = { player: '#8b5cf6', npc: '#3b82f6', monster: '#ef4444', hidden: '#6b7280' };
        
        grid.innerHTML = filtered.map((t, fi) => {
            const origIdx = lib.indexOf(t);
            const sz = sizeLabels[t.size] || (t.size ? t.size + 'px' : 'M');
            const tc = typeColors[t.type || 'player'] || '#8b5cf6';
            return `<div class="wb-tmgr-row" data-idx="${origIdx}">
                <div class="wb-tmgr-portrait" style="background:${t.img ? 'transparent' : (t.color || tc)};border:2px solid ${t.borderColor || tc}">
                    ${t.img ? `<img src="${t.img}">` : `<span>${(t.name || '?').charAt(0).toUpperCase()}</span>`}
                </div>
                <div class="wb-tmgr-info">
                    <div class="wb-tmgr-name">${t.name || 'Token'}</div>
                    <div class="wb-tmgr-stats">
                        ${t.maxHp ? `<span class="wb-tmgr-stat"><svg viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>${t.hp || 0}/${t.maxHp}</span>` : ''}
                        ${t.ac ? `<span class="wb-tmgr-stat"><svg viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>${t.ac}</span>` : ''}
                        ${t.speed ? `<span class="wb-tmgr-stat"><svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>${t.speed}/${t.range || 1}</span>` : ''}
                        ${t.initiative != null ? `<span class="wb-tmgr-stat"><svg viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>${t.initiative}</span>` : ''}
                        <span class="wb-tmgr-stat" style="opacity:0.35">${sz}</span>
                    </div>
                </div>
                <div class="wb-tmgr-actions">
                    <button data-place="${origIdx}" title="Auf Whiteboard platzieren"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                    <button data-edit="${origIdx}" title="Bearbeiten"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>
                    <button data-del="${origIdx}" class="del" title="Löschen"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
                </div>
            </div>`;
        }).join('');
        
        // Wire handlers
        grid.querySelectorAll('.wb-tmgr-row').forEach(row => {
            // Click row = load into create form
            row.onclick = e => {
                if (e.target.closest('.wb-tmgr-actions')) return;
                const idx = parseInt(row.dataset.idx);
                this.loadTokenFromLibrary(lib[idx]);
                document.getElementById('tokenLibOverlay').classList.remove('visible');
            };
        });
        
        grid.querySelectorAll('[data-place]').forEach(btn => {
            btn.onclick = e => {
                e.stopPropagation();
                const idx = parseInt(btn.dataset.place);
                const t = lib[idx];
                if (!t) return;
                // Place token at center of viewport
                const cx = (-this.panX + this.bgCanvas.width / 2) / this.zoom;
                const cy = (-this.panY + this.bgCanvas.height / 2) / this.zoom;
                const opts = {
                    hp: t.hp || 0, maxHp: t.maxHp || 0, ac: t.ac || 10,
                    speed: t.speed || 6, range: t.range || 1, initiative: t.initiative ?? null,
                    type: t.type || 'player', notes: t.notes || '',
                    affiliation: t.affiliation || '', items: t.items || '',
                    size: t.size || (this.gridSize || 70)
                };
                this.createToken(t.name || 'Token', t.color || '#8b5cf6', cx, cy, t.borderColor || '#8b5cf6', t.img || null, opts);
                document.getElementById('tokenLibOverlay').classList.remove('visible');
                this.toast('Token platziert: ' + (t.name || 'Token'));
            };
        });
        
        grid.querySelectorAll('[data-edit]').forEach(btn => {
            btn.onclick = e => {
                e.stopPropagation();
                const idx = parseInt(btn.dataset.edit);
                this.loadTokenFromLibrary(lib[idx]);
                this._editingLibIdx = idx;
                document.getElementById('tokenLibOverlay').classList.remove('visible');
            };
        });
        
        grid.querySelectorAll('[data-del]').forEach(btn => {
            btn.onclick = e => {
                e.stopPropagation();
                const idx = parseInt(btn.dataset.del);
                if (!confirm('Token "' + (lib[idx]?.name || 'Token') + '" löschen?')) return;
                lib.splice(idx, 1);
                this.saveTokenLibrary(lib);
                this.renderTokenManager();
            };
        });
    },
    
    loadTokenFromLibrary(template) {
        // Fill the create form with template data
        document.getElementById('tokenNameInput').value = template.name || '';
        document.getElementById('createTokenHp').value = template.hp || '';
        document.getElementById('createTokenMaxHp').value = template.maxHp || '';
        document.getElementById('createTokenAc').value = template.ac || '';
        document.getElementById('createTokenSpeed').value = template.speed || '';
        document.getElementById('createTokenRange').value = template.range || '';
        document.getElementById('createTokenInit').value = template.initiative ?? '';
        document.getElementById('createTokenNotes').value = template.notes || '';
        document.getElementById('createTokenAffiliation').value = template.affiliation || '';
        document.getElementById('createTokenItems').value = template.items || '';
        
        this.pendingTokenColor = template.color || '#8b5cf6';
        this.pendingTokenBorder = template.borderColor || '#8b5cf6';
        this.pendingTokenImg = template.img || null;
        
        // Update type buttons
        document.querySelectorAll('#tokenOverlay .wb-token-type-btn').forEach(b => {
            b.classList.toggle('active', b.dataset.type === (template.type || 'player'));
        });
        
        // Update size presets
        document.querySelectorAll('#createTokenSizePresets .wb-size-preset').forEach(b => {
            b.classList.toggle('active', parseInt(b.dataset.size) === (template.size || 70));
        });
        
        // Update portrait preview
        const preview = document.getElementById('tokenPortraitPreview');
        if (preview) {
            if (template.img) {
                preview.innerHTML = `<img src="${template.img}" style="width:100%;height:100%;object-fit:cover;border-radius:50%">`;
                preview.style.borderColor = template.borderColor || '#8b5cf6';
            } else {
                preview.style.background = template.color || '#8b5cf6';
                preview.style.borderColor = template.borderColor || '#8b5cf6';
                preview.innerHTML = '';
            }
        }
        
        // Update border colors in preview
        const borderBtns = document.querySelectorAll('#tokenOverlay .wb-token-color-btn, #tokenOverlay [data-border]');
        borderBtns.forEach(b => {
            if (b.dataset.border === template.borderColor) b.classList.add('active');
        });
        
        this.toast('Template geladen: ' + template.name);
        // Show create overlay
        document.getElementById('tokenOverlay').classList.add('visible');
    },
    
    // ==================== CURSOR TRACKING ====================
    setupCursorTracking() {
        this.cursorVisible = true;
        this._lastCursorSync = 0;
        this._remoteCursors = {};
        
        const cursorBtn = document.getElementById('cursorToggleBtn');
        if (cursorBtn) {
            cursorBtn.onclick = () => {
                this.cursorVisible = !this.cursorVisible;
                // Active (red) = cursor hidden, normal = cursor visible
                cursorBtn.classList.toggle('active-red', !this.cursorVisible);
                if (!this.cursorVisible && this.db && this.roomCode) {
                    this.db.ref('whiteboard/' + this.roomCode + '/cursors/' + this.userId).remove();
                }
            };
            // Cursor visible by default, so button is normal (not active)
        }
        
        const wrapper = document.getElementById('canvasWrapper');
        wrapper.addEventListener('mousemove', e => {
            if (!this.cursorVisible || !this.db || !this.roomCode) return;
            const now = Date.now();
            if (now - this._lastCursorSync < 80) return;
            this._lastCursorSync = now;
            
            const r = this.uiCanvas.getBoundingClientRect();
            const wx = (e.clientX - r.left - this.panX) / this.zoom;
            const wy = (e.clientY - r.top - this.panY) / this.zoom;
            
            this.db.ref('whiteboard/' + this.roomCode + '/cursors/' + this.userId).set({
                x: wx, y: wy,
                name: this.userName,
                color: this.userColor,
                ts: now
            });
        });
        
        wrapper.addEventListener('mouseleave', () => {
            if (this.db && this.roomCode) {
                this.db.ref('whiteboard/' + this.roomCode + '/cursors/' + this.userId).remove();
            }
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (this.db && this.roomCode) {
                this.db.ref('whiteboard/' + this.roomCode + '/cursors/' + this.userId).remove();
                this.db.ref('whiteboard/' + this.roomCode + '/ruler/' + this.userId).remove();
            }
        });
    },
    
    renderRemoteCursors(cursors) {
        const container = document.getElementById('remoteCursors');
        if (!container) return;
        container.innerHTML = '';
        
        Object.entries(cursors).forEach(([uid, c]) => {
            if (uid === this.userId) return;
            if (Date.now() - c.ts > 10000) return; // Stale cursor
            
            const screenX = c.x * this.zoom + this.panX;
            const screenY = c.y * this.zoom + this.panY;
            
            const el = document.createElement('div');
            el.className = 'wb-remote-cursor';
            el.style.cssText = `--cursor-color:${c.color || '#8b5cf6'};transform:translate3d(${screenX}px,${screenY}px,0)`;
            el.innerHTML = `<svg class="wb-remote-cursor__icon" viewBox="0 0 24 24" fill="${c.color || '#8b5cf6'}" stroke="white"><path d="M5 3l14 9-6 2-2 6z"/></svg><span class="wb-remote-cursor__label">${c.name || 'Spieler'}</span>`;
            container.appendChild(el);
        });
    },
    
    // ==================== TOKEN HOVER TOOLTIP ====================
    setupTokenTooltip() {
        this._tooltipTimer = null;
        this._tooltipToken = null;
    },
    
    showTokenTooltip(token, screenX, screenY) {
        const tip = document.getElementById('tokenTooltip');
        if (!tip) return;
        
        let html = `<div class="wb-token-tooltip__name">${token.name || 'Token'}</div>`;
        
        // HP bar
        if (token.maxHp > 0) {
            const pct = Math.max(0, Math.min(100, (token.hp / token.maxHp) * 100));
            const color = pct <= 25 ? '#ef4444' : pct <= 50 ? '#f59e0b' : '#22c55e';
            html += `<div class="wb-token-tooltip__row"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>HP ${token.hp}/${token.maxHp}</div>`;
            html += `<div class="wb-token-tooltip__hp-bar"><div class="wb-token-tooltip__hp-fill" style="width:${pct}%;background:${color}"></div></div>`;
        }
        
        // AC
        if (token.ac) {
            html += `<div class="wb-token-tooltip__row"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>AC ${token.ac}</div>`;
        }
        
        // Status effects
        if (token.status && token.status.length > 0) {
            const statusLabels = { dead: 'Tot', unconscious: 'Bewusstlos', poisoned: 'Vergiftet', burning: 'Brennend', frozen: 'Gefroren', stunned: 'Betäubt', invisible: 'Unsichtbar', blessed: 'Gesegnet', cursed: 'Verflucht', prone: 'Liegend', grappled: 'Gepackt', concentrating: 'Konzentriert' };
            const statusColors = { dead: '#ef4444', unconscious: '#f59e0b', poisoned: '#22c55e', burning: '#f97316', frozen: '#38bdf8', stunned: '#eab308', invisible: '#a78bfa', blessed: '#fbbf24', cursed: '#a855f7', prone: '#6b7280', grappled: '#f87171', concentrating: '#3b82f6' };
            const tags = token.status.map(s => `<span style="display:inline-block;padding:1px 6px;border-radius:4px;font-size:10px;background:${statusColors[s] || '#666'}22;color:${statusColors[s] || '#999'};border:1px solid ${statusColors[s] || '#666'}44">${statusLabels[s] || s}</span>`).join(' ');
            html += `<div style="margin-top:4px;display:flex;flex-wrap:wrap;gap:3px">${tags}</div>`;
        }
        
        // Affiliation (only if visible to players or GM)
        if (token.affiliation && (token.affVisible || this.isGM)) {
            html += `<div class="wb-token-tooltip__row"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>${token.affiliation}${(!token.affVisible && this.isGM) ? ' <span style="color:#f59e0b;font-size:9px">(versteckt)</span>' : ''}</div>`;
        }
        
        // Items (only if visible to players or GM)
        if (token.items && (token.itemsVisible || this.isGM)) {
            html += `<div class="wb-token-tooltip__items"><svg viewBox="0 0 24 24" width="10" height="10" fill="none" stroke="currentColor" stroke-width="2" style="display:inline;vertical-align:middle;margin-right:4px"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/></svg>${token.items}${(!token.itemsVisible && this.isGM) ? ' <span style="color:#f59e0b;font-size:9px">(versteckt)</span>' : ''}</div>`;
        }
        
        // GM notes
        if (token.notes && this.isGM) {
            html += `<div class="wb-token-tooltip__items" style="color:rgba(251,191,36,0.6)"><svg viewBox="0 0 24 24" width="10" height="10" fill="none" stroke="currentColor" stroke-width="2" style="display:inline;vertical-align:middle;margin-right:4px"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>${token.notes}</div>`;
        }
        
        tip.innerHTML = html;
        
        // Position tooltip
        const wrapperRect = document.getElementById('canvasWrapper').getBoundingClientRect();
        let left = screenX + 20;
        let top = screenY - 10;
        if (left + 260 > wrapperRect.width) left = screenX - 180;
        if (top < 0) top = 10;
        
        tip.style.left = left + 'px';
        tip.style.top = top + 'px';
        tip.classList.add('visible');
    },
    
    hideTokenTooltip() {
        clearTimeout(this._tooltipTimer);
        this._tooltipToken = null;
        const tip = document.getElementById('tokenTooltip');
        if (tip) tip.classList.remove('visible');
    },
    
    // ==================== MOVEMENT RADIUS ====================
    showMoveRadius(token) {
        if (!token.speed || !this.gridSize) return;
        const radiusWorld = token.speed * this.gridSize;
        const radiusPx = radiusWorld * this.zoom * 2;
        
        const el = document.getElementById('moveRadius');
        const originEl = document.getElementById('moveOrigin');
        const originX = token.x * this.zoom + this.panX;
        const originY = token.y * this.zoom + this.panY;
        
        el.style.width = radiusPx + 'px';
        el.style.height = radiusPx + 'px';
        el.style.left = originX + 'px';
        el.style.top = originY + 'px';
        el.classList.add('visible');
        
        // Show origin marker
        originEl.style.left = originX + 'px';
        originEl.style.top = originY + 'px';
        originEl.classList.add('visible');
        
        document.getElementById('moveRadiusLabel').textContent = `${token.speed} Felder`;
        
        // Hide distance initially
        document.getElementById('moveDistance').classList.remove('visible');
    },
    
    updateMoveRadius(token) {
        if (!this._dragOrigin || !this.gridSize) return;
        
        const el = document.getElementById('moveRadius');
        const originEl = document.getElementById('moveOrigin');
        const distEl = document.getElementById('moveDistance');
        
        if (!el.classList.contains('visible')) return;
        
        // Origin stays at drag start position
        const originX = this._dragOrigin.x * this.zoom + this.panX;
        const originY = this._dragOrigin.y * this.zoom + this.panY;
        el.style.left = originX + 'px';
        el.style.top = originY + 'px';
        originEl.style.left = originX + 'px';
        originEl.style.top = originY + 'px';
        
        // Calculate distance moved in grid squares
        const dx = token.x - this._dragOrigin.x;
        const dy = token.y - this._dragOrigin.y;
        const distWorld = Math.sqrt(dx * dx + dy * dy);
        const distFields = Math.round(distWorld / this.gridSize);
        
        if (distFields > 0) {
            const tokenScreenX = token.x * this.zoom + this.panX;
            const tokenScreenY = token.y * this.zoom + this.panY;
            distEl.style.left = tokenScreenX + 'px';
            distEl.style.top = tokenScreenY + 'px';
            
            const maxFields = token.speed || 6;
            const over = distFields > maxFields;
            distEl.textContent = `${distFields} / ${maxFields} Felder`;
            distEl.style.color = over ? '#ef4444' : distFields === maxFields ? '#f59e0b' : '#22c55e';
            distEl.classList.add('visible');
        } else {
            distEl.classList.remove('visible');
        }
    },
    
    hideMoveRadius() {
        document.getElementById('moveRadius').classList.remove('visible');
        document.getElementById('moveOrigin').classList.remove('visible');
        document.getElementById('moveDistance').classList.remove('visible');
    },
    
    // ==================== TOKEN SIDEBAR ====================
    setupTokenSidebar() {
        document.getElementById('tokenSidebarBtn').onclick = () => {
            document.getElementById('tokenSidebar').classList.toggle('visible');
            document.getElementById('tokenSidebarBtn').classList.toggle('active-red');
            this.renderTokenSidebar();
        };
        document.getElementById('tokenSidebarClose').onclick = () => {
            document.getElementById('tokenSidebar').classList.remove('visible');
            document.getElementById('tokenSidebarBtn').classList.remove('active-red');
        };
        document.getElementById('tokenSidebarCollapse').onclick = () => {
            const sb = document.getElementById('tokenSidebar');
            sb.classList.toggle('collapsed');
            const btn = document.getElementById('tokenSidebarCollapse');
            btn.querySelector('svg').style.transform = sb.classList.contains('collapsed') ? 'rotate(-90deg)' : '';
        };
    },
    
    renderTokenSidebar() {
        const body = document.getElementById('tokenSidebarBody');
        if (!body) return;
        if (!document.getElementById('tokenSidebar').classList.contains('visible')) return;
        
        // Group tokens by type
        const groups = {
            player: { label: 'Spieler', tokens: [], color: '#8b5cf6' },
            npc: { label: 'NPCs', tokens: [], color: '#3b82f6' },
            monster: { label: 'Monster / Gegner', tokens: [], color: '#ef4444' },
            hidden: { label: 'Versteckt (GM)', tokens: [], color: '#6b7280' }
        };
        
        this.tokens.forEach(t => {
            const type = t.type || 'player';
            if (groups[type]) groups[type].tokens.push(t);
            else groups.player.tokens.push(t);
        });
        
        if (this.tokens.length === 0) {
            body.innerHTML = '<div class="wb-token-sidebar__empty"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom:8px;opacity:0.3"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg><br>Noch keine Tokens platziert.<br>Klicke auf das Token-Tool um einen zu erstellen.</div>';
            return;
        }
        
        let html = '';
        if (!this._collapsedGroups) this._collapsedGroups = {};
        
        for (const [type, group] of Object.entries(groups)) {
            if (group.tokens.length === 0) continue;
            const isCollapsed = this._collapsedGroups[type];
            
            html += `<div class="wb-token-sidebar__group${isCollapsed ? ' collapsed' : ''}" data-group="${type}">`;
            html += `<div class="wb-token-sidebar__group-header" data-toggle-group="${type}">
                <svg class="wb-group-arrow" width="8" height="8" viewBox="0 0 24 24" fill="currentColor"><path d="M6 9l6 6 6-6"/></svg>
                <span>${group.label}</span>
                <span class="wb-token-sidebar__group-count">${group.tokens.length}</span>
            </div>`;
            
            group.tokens.forEach(t => {
                const isDead = t.status?.includes('dead') || (t.maxHp > 0 && t.hp <= 0);
                const isSelected = this.selected?.type === 'token' && this.selected?.item === t;
                const isMultiSel = this.multiSelected.includes(t);
                const hpPercent = t.maxHp ? Math.max(0, Math.min(100, (t.hp / t.maxHp) * 100)) : 0;
                const hpColor = hpPercent <= 25 ? '#ef4444' : hpPercent <= 50 ? '#f59e0b' : '#22c55e';
                
                html += `<div class="wb-token-sidebar__item${isSelected ? ' active' : ''}${isDead ? ' dead' : ''}${isMultiSel ? ' multi-selected' : ''}" data-token-id="${t.id}">
                    <input type="checkbox" class="wb-token-sidebar__check" data-check-id="${t.id}" ${isMultiSel ? 'checked' : ''} style="width:14px;height:14px;cursor:pointer;accent-color:#8b5cf6;flex-shrink:0">
                    <div class="wb-token-sidebar__portrait" style="background:${t.img ? 'transparent' : t.color};border-color:${t.borderColor || group.color}">
                        ${t.img ? `<img src="${t.img}">` : `<span>${t.label || '?'}</span>`}
                    </div>
                    <div class="wb-token-sidebar__info">
                        <div class="wb-token-sidebar__name">${t.name || 'Token'}</div>
                        <div class="wb-token-sidebar__meta">
                            ${t.maxHp ? `<span>HP ${t.hp}/${t.maxHp}</span>` : ''}
                            ${t.ac ? `<span>AC ${t.ac}</span>` : ''}
                            ${t.speed ? `<span>Bew ${t.speed}</span>` : ''}
                            ${t.initiative !== null && t.initiative !== undefined ? `<span>Init ${t.initiative}</span>` : ''}
                        </div>
                        ${t.maxHp ? `<div class="wb-token-sidebar__hp-bar"><div class="wb-token-sidebar__hp-fill" style="width:${hpPercent}%;background:${hpColor}"></div></div>` : ''}
                    </div>
                    <div class="wb-token-sidebar__quick-hp">
                        <button class="wb-token-sidebar__hp-btn" data-action="damage" data-id="${t.id}" title="Schaden">-</button>
                        <button class="wb-token-sidebar__hp-btn" data-action="heal" data-id="${t.id}" title="Heilen">+</button>
                    </div>
                </div>`;
            });
            
            html += '</div>';
        }
        
        body.innerHTML = html;
        
        // Group collapse toggle
        body.querySelectorAll('[data-toggle-group]').forEach(hdr => {
            hdr.onclick = e => {
                const type = hdr.dataset.toggleGroup;
                const grp = hdr.closest('.wb-token-sidebar__group');
                if (grp) grp.classList.toggle('collapsed');
                this._collapsedGroups[type] = grp?.classList.contains('collapsed') || false;
            };
        });
        
        // Wire up click handlers
        body.querySelectorAll('.wb-token-sidebar__item').forEach(item => {
            item.onclick = e => {
                if (e.target.closest('.wb-token-sidebar__hp-btn')) return;
                if (e.target.closest('.wb-token-sidebar__check')) return; // handled separately
                const tokenId = item.dataset.tokenId;
                const token = this.tokens.find(t => t.id === tokenId);
                if (!token) return;
                
                // Ctrl/Cmd+click = toggle multi-select
                if (e.ctrlKey || e.metaKey) {
                    const idx = this.multiSelected.indexOf(token);
                    if (idx >= 0) this.multiSelected.splice(idx, 1);
                    else this.multiSelected.push(token);
                    this.renderTokens();
                    this.renderTokenSidebar();
                    return;
                }
                
                // Normal click: select and pan to token
                this.multiSelected = [];
                const tidx = this.tokens.indexOf(token);
                this.select({ type: 'token', item: token, index: tidx });
                this.targetPanX = this.mainCanvas.width / 2 - token.x * this.zoom;
                this.targetPanY = this.mainCanvas.height / 2 - token.y * this.zoom;
                this.startAnimation();
                this.renderTokens();
                this.renderTokenSidebar();
            };
            
            item.ondblclick = e => {
                if (e.target.closest('.wb-token-sidebar__hp-btn')) return;
                if (e.target.closest('.wb-token-sidebar__check')) return;
                const tokenId = item.dataset.tokenId;
                const token = this.tokens.find(t => t.id === tokenId);
                if (token) this.showTokenEditModal(token);
            };
        });
        
        // Checkbox handlers for multi-select
        body.querySelectorAll('.wb-token-sidebar__check').forEach(cb => {
            cb.onclick = e => {
                e.stopPropagation();
                const tokenId = cb.dataset.checkId;
                const token = this.tokens.find(t => t.id === tokenId);
                if (!token) return;
                if (cb.checked) {
                    if (!this.multiSelected.includes(token)) this.multiSelected.push(token);
                } else {
                    const idx = this.multiSelected.indexOf(token);
                    if (idx >= 0) this.multiSelected.splice(idx, 1);
                }
                this.renderTokens();
                // Don't re-render sidebar to avoid checkbox flicker
            };
        });
        
        // Quick HP buttons
        body.querySelectorAll('.wb-token-sidebar__hp-btn').forEach(btn => {
            btn.onclick = e => {
                e.stopPropagation();
                const tokenId = btn.dataset.id;
                const action = btn.dataset.action;
                const token = this.tokens.find(t => t.id === tokenId);
                if (!token) return;
                
                const amount = prompt(action === 'damage' ? 'Schaden:' : 'Heilung:', '1');
                if (!amount || isNaN(parseInt(amount))) return;
                const val = parseInt(amount);
                
                if (action === 'damage') {
                    token.hp = Math.max(0, token.hp - val);
                } else {
                    token.hp = Math.min(token.maxHp || 999, token.hp + val);
                }
                
                this.syncToken(token);
                this.renderTokens();
                this.renderInitiative();
                this.renderTokenSidebar();
                this.toast(`${token.name}: ${action === 'damage' ? '-' : '+'}${val} HP (${token.hp}/${token.maxHp})`);
            };
        });
    },
    
    // ==================== UPLOADS ====================
    setupUploads() {
        document.getElementById('bgBtn').onclick = () => document.getElementById('bgOverlay').classList.add('visible');
        document.getElementById('bgSelectBtn').onclick = () => document.getElementById('bgFileInput').click();
        document.getElementById('bgFileInput').onchange = e => { if (e.target.files[0]) this.loadBg(e.target.files[0]); };
        document.getElementById('bgRemoveBtn').onclick = () => {
            this.bgImage = null; this.bgDataUrl = null; this.render();
            this.syncBackground(null);
            document.getElementById('bgOverlay').classList.remove('visible');
            this.toast('Hintergrund entfernt');
        };
        
        document.getElementById('imageBtn').onclick = () => document.getElementById('imageOverlay').classList.add('visible');
        document.getElementById('imageSelectBtn').onclick = () => document.getElementById('imageFileInput').click();
        document.getElementById('imageFileInput').onchange = e => { if (e.target.files[0]) this.loadImage(e.target.files[0]); };
        
        ['bgUploadBox', 'imageUploadBox'].forEach(id => {
            const box = document.getElementById(id);
            box.ondragover = e => { e.preventDefault(); box.classList.add('dragover'); };
            box.ondragleave = () => box.classList.remove('dragover');
            box.ondrop = e => {
                e.preventDefault(); box.classList.remove('dragover');
                if (e.dataTransfer.files[0]) {
                    if (id === 'bgUploadBox') this.loadBg(e.dataTransfer.files[0]);
                    else this.loadImage(e.dataTransfer.files[0]);
                }
            };
        });
    },
    
    loadBg(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                this.bgImage = img;
                this.bgDataUrl = e.target.result;
                this.render();
                document.getElementById('bgOverlay').classList.remove('visible');
                this.toast('Hintergrund geladen');
                // Sync to Firebase
                this.syncBackground(e.target.result);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    syncBackground(dataUrl) {
        if (!this.db || !this.roomCode) return;
        this.db.ref('whiteboard/' + this.roomCode + '/background').set({
            dataUrl: dataUrl || null,
            updatedBy: this.userId,
            ts: Date.now()
        });
    },
    
    loadBgFromUrl(dataUrl) {
        if (!dataUrl) { this.bgImage = null; this.bgDataUrl = null; this.render(); return; }
        const img = new Image();
        img.onload = () => {
            this.bgImage = img;
            this.bgDataUrl = dataUrl;
            this.render();
        };
        img.src = dataUrl;
    },
    
    loadImage(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                const maxW = 400, maxH = 400;
                let w = img.width, h = img.height;
                if (w > maxW) { h = h * maxW / w; w = maxW; }
                if (h > maxH) { w = w * maxH / h; h = maxH; }
                // Use pending position from context menu, or center of viewport
                const pos = this._pendingImagePos;
                this._pendingImagePos = null;
                const ix = pos ? pos.x - w/2 : (this.uiCanvas.width / 2 - this.panX) / this.zoom - w/2;
                const iy = pos ? pos.y - h/2 : (this.uiCanvas.height / 2 - this.panY) / this.zoom - h/2;
                const imgData = {
                    id: Date.now() + '-' + Math.random().toString(36).substr(2,6),
                    src: e.target.result,
                    x: ix, y: iy, w, h
                };
                this.images.push(imgData);
                this.syncImageToFirebase(imgData);
                this.renderImages();
                document.getElementById('imageOverlay').classList.remove('visible');
                this.toast('Bild eingefügt');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    syncImageToFirebase(imgData) {
        if (!this.db || !this.roomCode) return;
        this.db.ref('whiteboard/' + this.roomCode + '/images/' + imgData.id).set(imgData);
    },
    
    removeImageFromFirebase(imgId) {
        if (!this.db || !this.roomCode) return;
        this.db.ref('whiteboard/' + this.roomCode + '/images/' + imgId).remove();
    },
    
    // ==================== MODALS ====================
    setupModals() {
        const inp = document.getElementById('textInput');
        inp.onkeydown = e => {
            e.stopPropagation();
            if (e.key === 'Enter' && inp.value.trim()) { 
                this.handleTextInput(inp);
                inp.style.display = 'none'; 
            }
            if (e.key === 'Escape') { inp.style.display = 'none'; inp.dataset.strokeId = ''; }
        };
        inp.onblur = () => {
            setTimeout(() => {
                if (inp.style.display !== 'none' && inp.value.trim()) this.handleTextInput(inp);
                inp.style.display = 'none';
                inp.dataset.strokeId = '';
            }, 150);
        };
        
        document.getElementById('saveBtn').onclick = () => {
            document.getElementById('saveOverlay').classList.add('visible');
            document.getElementById('saveNameInput').value = '';
            document.getElementById('saveNameInput').focus();
        };
        document.getElementById('saveConfirmBtn').onclick = () => this.saveScene();
        document.getElementById('loadBtn').onclick = () => document.getElementById('sceneFileInput').click();
        document.getElementById('sceneFileInput').onchange = e => { if (e.target.files[0]) this.importSceneJSON(e.target.files[0]); e.target.value = ''; };
        document.getElementById('sceneManagerBtn').onclick = () => this.showSceneManager();
        document.getElementById('sceneManagerSaveBtn').onclick = () => {
            document.getElementById('sceneManagerOverlay').classList.remove('visible');
            document.getElementById('saveOverlay').classList.add('visible');
            document.getElementById('saveNameInput').value = '';
            document.getElementById('saveNameInput').focus();
        };
        document.getElementById('exportBtn').onclick = () => this.exportPNG();
        document.getElementById('exportDataBtn').onclick = () => this.exportDataJSON();
        
        document.getElementById('tokenCreateBtn').onclick = () => {
            const name = document.getElementById('tokenNameInput').value.trim() || 'Token';
            const activeType = document.querySelector('#tokenOverlay .wb-token-type-btn.active');
            const activeSize = document.querySelector('#createTokenSizePresets .wb-size-preset.active');
            const opts = {
                hp: parseInt(document.getElementById('createTokenHp').value) || 0,
                maxHp: parseInt(document.getElementById('createTokenMaxHp').value) || 0,
                ac: parseInt(document.getElementById('createTokenAc').value) || 10,
                speed: parseInt(document.getElementById('createTokenSpeed').value) || 6,
                range: parseInt(document.getElementById('createTokenRange').value) || 1,
                initiative: document.getElementById('createTokenInit').value !== '' ? parseInt(document.getElementById('createTokenInit').value) : null,
                type: activeType?.dataset.type || 'player',
                notes: document.getElementById('createTokenNotes').value || '',
                affiliation: document.getElementById('createTokenAffiliation').value || '',
                items: document.getElementById('createTokenItems').value || '',
                affVisible: document.getElementById('createAffVis').classList.contains('visible-to-players'),
                itemsVisible: document.getElementById('createItemsVis').classList.contains('visible-to-players'),
                size: activeSize ? parseInt(activeSize.dataset.size) : (this.gridSize || 70)
            };
            const pos = this._pendingTokenPos || null;
            this._pendingTokenPos = null;
            this.createToken(name, this.pendingTokenColor, pos ? pos.x : null, pos ? pos.y : null, this.pendingTokenBorder, this.pendingTokenImg, opts);
            document.getElementById('tokenOverlay').classList.remove('visible');
        };
    },
    
    handleTextInput(inp) {
        const strokeId = inp.dataset.strokeId;
        if (strokeId) {
            // Editing existing text
            const stroke = this.strokes.find(s => s.id === strokeId);
            if (stroke) {
                stroke.text = inp.value;
                this.syncStroke(stroke);
                this.render();
            }
        } else {
            // New text
            this.placeText(inp.value, inp.dataset.x, inp.dataset.y);
        }
        inp.dataset.strokeId = '';
    },
    
    generateThumbnail() {
        return new Promise(resolve => {
            try {
                const c = document.createElement('canvas');
                const tw = 320, th = 180;
                c.width = tw; c.height = th;
                const ctx = c.getContext('2d');
                // Draw bg
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, tw, th);
                // Scale viewport to thumbnail
                const sx = tw / this.bgCanvas.width;
                const sy = th / this.bgCanvas.height;
                const sc = Math.max(sx, sy);
                ctx.drawImage(this.bgCanvas, 0, 0, this.bgCanvas.width * sc, this.bgCanvas.height * sc);
                ctx.drawImage(this.mainCanvas, 0, 0, this.mainCanvas.width * sc, this.mainCanvas.height * sc);
                resolve(c.toDataURL('image/jpeg', 0.5));
            } catch(e) { resolve(null); }
        });
    },
    
    async saveScene() {
        const name = document.getElementById('saveNameInput').value.trim() || 'Szene ' + new Date().toLocaleDateString();
        const thumb = await this.generateThumbnail();
        
        const sceneData = {
            name, date: Date.now(), thumb,
            strokes: this.strokes, tokens: this.tokens, images: this.images,
            fogAreas: this.fogAreas, auras: this._auras || [], notes: this._notes || [],
            bgDataUrl: this.bgDataUrl || null,
            bgOrigWidth: this.bgImage ? this.bgImage.width : null,
            bgOrigHeight: this.bgImage ? this.bgImage.height : null,
            gridSize: this.gridSize, gridOffsetX: this.gridOffsetX, gridOffsetY: this.gridOffsetY,
            gridColor: this.gridColor, panX: this.panX, panY: this.panY, zoom: this.zoom
        };
        
        if (this.db && this.roomCode) {
            const sceneId = Date.now() + '-' + Math.random().toString(36).substr(2, 6);
            try {
                await this.db.ref('whiteboard/' + this.roomCode + '/scenes/' + sceneId).set(sceneData);
                document.getElementById('saveOverlay').classList.remove('visible');
                this.toast('Szene gespeichert: ' + name);
            } catch(e) {
                // Retry with compressed bg if original too large
                if (this.bgDataUrl) {
                    try {
                        const c2 = document.createElement('canvas');
                        const img = this.bgImage;
                        const maxDim = 2000;
                        let w = img.width, h = img.height;
                        if (w > maxDim || h > maxDim) {
                            const s = Math.min(maxDim / w, maxDim / h);
                            w = Math.round(w * s); h = Math.round(h * s);
                        }
                        c2.width = w; c2.height = h;
                        c2.getContext('2d').drawImage(img, 0, 0, w, h);
                        sceneData.bgDataUrl = c2.toDataURL('image/jpeg', 0.8);
                        sceneData.bgOrigWidth = w;
                        sceneData.bgOrigHeight = h;
                        await this.db.ref('whiteboard/' + this.roomCode + '/scenes/' + sceneId).set(sceneData);
                        document.getElementById('saveOverlay').classList.remove('visible');
                        this.toast('Szene gespeichert (Bild komprimiert): ' + name);
                    } catch(e2) {
                        sceneData.bgDataUrl = null;
                        await this.db.ref('whiteboard/' + this.roomCode + '/scenes/' + sceneId).set(sceneData);
                        document.getElementById('saveOverlay').classList.remove('visible');
                        this.toast('Szene gespeichert (ohne Hintergrund): ' + name);
                    }
                } else {
                    console.error('Scene save error:', e);
                    this.toast('Fehler beim Speichern: ' + (e.message || 'Unbekannt'));
                }
            }
        } else {
            // Fallback localStorage with quota handling
            try {
                const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
                saves.unshift(sceneData);
                if (saves.length > 10) saves.pop();
                localStorage.setItem('rift_wb_saves', JSON.stringify(saves));
                document.getElementById('saveOverlay').classList.remove('visible');
                this.toast('Szene gespeichert: ' + name);
            } catch(e) {
                // Strip images on quota error
                sceneData.images = sceneData.images.map(i => ({ ...i, src: null }));
                sceneData.bgDataUrl = null;
                sceneData.thumb = null;
                try {
                    const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
                    saves.unshift(sceneData);
                    if (saves.length > 5) saves.pop();
                    localStorage.setItem('rift_wb_saves', JSON.stringify(saves));
                    document.getElementById('saveOverlay').classList.remove('visible');
                    this.toast('Szene gespeichert (ohne Bilder, Speicher voll)');
                } catch(e2) {
                    this.toast('Speicher voll! Bitte alte Szenen löschen.');
                }
            }
        }
    },
    
    async showSceneManager() {
        const grid = document.getElementById('sceneGrid');
        const empty = document.getElementById('sceneEmpty');
        const count = document.getElementById('sceneCount');
        grid.innerHTML = '<p style="color:rgba(255,255,255,0.4);text-align:center;padding:20px">Lade Szenen...</p>';
        document.getElementById('sceneManagerOverlay').classList.add('visible');
        
        let scenes = [];
        
        if (this.db && this.roomCode) {
            try {
                const snap = await this.db.ref('whiteboard/' + this.roomCode + '/scenes').once('value');
                const data = snap.val();
                if (data) {
                    scenes = Object.entries(data).map(([id, s]) => ({ ...s, _id: id }));
                    scenes.sort((a, b) => (b.date || 0) - (a.date || 0));
                }
            } catch(e) { console.error(e); }
        } else {
            const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
            scenes = saves.map((s, i) => ({ ...s, _id: String(i) }));
        }
        
        count.textContent = scenes.length + ' Szene' + (scenes.length !== 1 ? 'n' : '');
        
        if (scenes.length === 0) {
            grid.innerHTML = '';
            empty.style.display = 'block';
            return;
        }
        empty.style.display = 'none';
        
        grid.innerHTML = scenes.map(s => `
            <div class="wb-scene-card" data-scene-id="${s._id}">
                <div class="wb-scene-card__thumb">
                    ${s.thumb ? `<img src="${s.thumb}" alt="">` : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>'}
                </div>
                <div class="wb-scene-card__info">
                    <div class="wb-scene-card__name">${s.name || 'Unbenannt'}</div>
                    <div class="wb-scene-card__meta">${new Date(s.date).toLocaleString()} - ${(s.tokens || []).length} Tokens</div>
                    <div class="wb-scene-card__actions">
                        <button class="wb-scene-card__btn" data-action="load">Laden</button>
                        <button class="wb-scene-card__btn" data-action="rename">Umbenennen</button>
                        <button class="wb-scene-card__btn" data-action="export">Export</button>
                        <button class="wb-scene-card__btn wb-scene-card__btn--danger" data-action="delete">X</button>
                    </div>
                </div>
            </div>
        `).join('');
        
        // Wire handlers
        grid.querySelectorAll('.wb-scene-card__btn').forEach(btn => {
            btn.onclick = e => {
                e.stopPropagation();
                const card = btn.closest('.wb-scene-card');
                const sceneId = card.dataset.sceneId;
                const action = btn.dataset.action;
                if (action === 'load') this.loadScene(sceneId, scenes);
                else if (action === 'rename') this.renameScene(sceneId, scenes);
                else if (action === 'export') this.exportSceneById(sceneId, scenes);
                else if (action === 'delete') this.deleteScene(sceneId);
            };
        });
        // Click card to load
        grid.querySelectorAll('.wb-scene-card').forEach(card => {
            card.onclick = e => {
                if (e.target.closest('.wb-scene-card__btn')) return;
                this.loadScene(card.dataset.sceneId, scenes);
            };
        });
    },
    
    async loadScene(sceneId, scenes) {
        const scene = scenes.find(s => s._id === sceneId);
        if (!scene) return;
        
        // Wipe current whiteboard first
        this.isClearing = true;
        this.strokes = []; this.images = []; this.tokens = []; this.fogAreas = [];
        this._auras = []; this._notes = [];
        this.bgImage = null; this.bgDataUrl = null;
        this.history = []; this.historyIdx = -1;
        this.initiativeActive = null; this.initiativeOrder = [];
        this.deselect();
        
        if (this.db && this.roomCode) {
            const base = 'whiteboard/' + this.roomCode;
            this.detachFirebaseListeners();
            await Promise.all([
                this.db.ref(base + '/strokes').remove(),
                this.db.ref(base + '/tokens').remove(),
                this.db.ref(base + '/images').remove(),
                this.db.ref(base + '/pings').remove(),
                this.db.ref(base + '/background').remove(),
                this.db.ref(base + '/cursors').remove(),
                this.db.ref(base + '/focus').remove(),
                this.db.ref(base + '/ruler').remove(),
                this.db.ref(base + '/auras').remove(),
                this.db.ref(base + '/notes').remove()
            ]).catch(e => console.warn('[WB] Wipe error:', e));
        }
        this.isClearing = false;
        
        // Load scene data
        this.strokes = scene.strokes || [];
        this.tokens = scene.tokens || [];
        this.images = scene.images || [];
        this.fogAreas = scene.fogAreas || [];
        this._auras = scene.auras || [];
        this._notes = scene.notes || [];
        if (scene.gridSize) this.gridSize = scene.gridSize;
        if (scene.gridOffsetX !== undefined) this.gridOffsetX = scene.gridOffsetX;
        if (scene.gridOffsetY !== undefined) this.gridOffsetY = scene.gridOffsetY;
        if (scene.gridColor) this.gridColor = scene.gridColor;
        if (scene.panX !== undefined) { this.panX = scene.panX; this.targetPanX = scene.panX; }
        if (scene.panY !== undefined) { this.panY = scene.panY; this.targetPanY = scene.panY; }
        if (scene.zoom) { this.zoom = scene.zoom; this.targetZoom = scene.zoom; }
        
        if (scene.bgDataUrl) {
            this.loadBgFromUrl(scene.bgDataUrl);
        } else {
            this.bgImage = null; this.bgDataUrl = null;
        }
        
        // Sync all to Firebase
        if (this.db && this.roomCode) {
            this.strokes.forEach(s => this.syncStroke(s));
            this.tokens.forEach(t => this.syncToken(t));
            this.images.forEach(i => this.syncImageToFirebase(i));
            this._auras.forEach(a => this.syncAura(a));
            this._notes.forEach(n => this.syncNote(n));
            if (scene.bgDataUrl) this.syncBackground(scene.bgDataUrl);
            // Re-attach listeners after sync
            setTimeout(() => this.setupFirebaseListeners(), 500);
        }
        
        this.render();
        this.renderInitiative();
        document.getElementById('sceneManagerOverlay').classList.remove('visible');
        this.toast('Szene geladen: ' + (scene.name || 'Unbenannt'));
    },
    
    async deleteScene(sceneId) {
        if (!confirm('Szene wirklich löschen?')) return;
        
        if (this.db && this.roomCode) {
            await this.db.ref('whiteboard/' + this.roomCode + '/scenes/' + sceneId).remove();
        } else {
            const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
            const idx = parseInt(sceneId);
            if (!isNaN(idx)) { saves.splice(idx, 1); localStorage.setItem('rift_wb_saves', JSON.stringify(saves)); }
        }
        this.toast('Szene gelöscht');
        this.showSceneManager(); // Refresh
    },
    
    async renameScene(sceneId, scenes) {
        const scene = scenes.find(s => s._id === sceneId);
        if (!scene) return;
        const newName = prompt('Neuer Name:', scene.name || 'Unbenannt');
        if (!newName || newName === scene.name) return;
        
        if (this.db && this.roomCode) {
            await this.db.ref('whiteboard/' + this.roomCode + '/scenes/' + sceneId + '/name').set(newName);
        } else {
            const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
            const idx = parseInt(sceneId);
            if (!isNaN(idx) && saves[idx]) { saves[idx].name = newName; localStorage.setItem('rift_wb_saves', JSON.stringify(saves)); }
        }
        this.toast('Umbenannt: ' + newName);
        this.showSceneManager(); // Refresh
    },
    
    exportSceneById(sceneId, scenes) {
        const scene = scenes.find(s => s._id === sceneId);
        if (!scene) return;
        const exported = { ...scene };
        delete exported._id;
        const blob = new Blob([JSON.stringify(exported, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = (scene.name || 'scene').replace(/[^a-zA-Z0-9_-]/g, '_') + '.json';
        a.click();
        URL.revokeObjectURL(a.href);
        this.toast('Szene exportiert');
    },
    
    exportDataJSON() {
        const data = {
            version: 2,
            exportDate: new Date().toISOString(),
            roomCode: this.roomCode || null,
            strokes: this.strokes,
            tokens: this.tokens,
            images: this.images,
            fogAreas: this.fogAreas,
            bgDataUrl: this.bgDataUrl || null,
            gridSize: this.gridSize,
            gridOffsetX: this.gridOffsetX,
            gridOffsetY: this.gridOffsetY,
            gridColor: this.gridColor,
            panX: this.panX, panY: this.panY, zoom: this.zoom
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'whiteboard_export_' + new Date().toISOString().slice(0,10) + '.json';
        a.click();
        URL.revokeObjectURL(a.href);
        this.toast('Daten exportiert (.json)');
    },
    
    importSceneJSON(file) {
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);
                this.strokes = data.strokes || [];
                this.tokens = data.tokens || [];
                this.images = data.images || [];
                this.fogAreas = data.fogAreas || [];
                if (data.gridSize) this.gridSize = data.gridSize;
                if (data.gridOffsetX !== undefined) this.gridOffsetX = data.gridOffsetX;
                if (data.gridOffsetY !== undefined) this.gridOffsetY = data.gridOffsetY;
                if (data.gridColor) this.gridColor = data.gridColor;
                if (data.panX !== undefined) { this.panX = data.panX; this.targetPanX = data.panX; }
                if (data.panY !== undefined) { this.panY = data.panY; this.targetPanY = data.panY; }
                if (data.zoom) { this.zoom = data.zoom; this.targetZoom = data.zoom; }
                
                if (data.bgDataUrl) {
                    this.loadBgFromUrl(data.bgDataUrl);
                } else {
                    this.bgImage = null; this.bgDataUrl = null;
                }
                
                // Sync to Firebase
                if (this.db && this.roomCode) {
                    this.strokes.forEach(s => this.syncStroke(s));
                    this.tokens.forEach(t => this.syncToken(t));
                    this.images.forEach(i => this.syncImageToFirebase(i));
                    if (data.bgDataUrl) this.syncBackground(data.bgDataUrl);
                }
                
                this.render();
                this.toast('Szene importiert: ' + (data.name || file.name));
            } catch(err) {
                console.error(err);
                this.toast('Fehler beim Import: Ungültige JSON-Datei');
            }
        };
        reader.readAsText(file);
    },
    
    // ==================== CONTEXT MENU ====================
    setupContextMenu() {
        // Context menu is now built dynamically in onContext()
    },
    
    editSelected() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        if (type === 'token') {
            this.showTokenEditModal(item);
        }
    },
    
    deleteSelected() {
        if (!this.selected) return;
        const { type, item, index } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) this.tokens.splice(idx, 1);
            // Delete from Firebase
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + item.id).remove();
            // Update initiative if this token was active
            if (this.initiativeActive === item.id) this.initiativeActive = null;
            this.renderInitiative();
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) this.images.splice(idx, 1);
            this.removeImageFromFirebase(item.id);
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) this.strokes.splice(idx, 1);
            // Delete from Firebase
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + item.id).remove();
        }
        if (type === 'aura') {
            this.removeAura(item.id);
        }
        if (type === 'note') {
            this._notes = this._notes.filter(n => n.id !== item.id);
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/notes/' + item.id).remove();
            this.renderNotes();
        }
        
        this.deselect();
        this.render();
        this.toast('Gelöscht');
    },
    
    duplicateSelected() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        const newId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        if (type === 'token') {
            const copy = { 
                ...item, 
                id: newId, 
                x: item.x + 50, 
                y: item.y + 50,
                status: item.status ? [...item.status] : [], // Deep copy status array
                initiative: null // Reset initiative for duplicate
            };
            this.tokens.push(copy);
            this.syncToken(copy);
            this.renderInitiative();
        }
        if (type === 'image') {
            const copy = { ...item, id: Date.now(), x: item.x + 50, y: item.y + 50 };
            this.images.push(copy);
        }
        if (type === 'stroke') {
            const copy = JSON.parse(JSON.stringify(item));
            copy.id = newId;
            // Offset the duplicate
            if (copy.start) { copy.start.x += 50; copy.start.y += 50; }
            if (copy.end) { copy.end.x += 50; copy.end.y += 50; }
            if (copy.path) copy.path.forEach(p => { p.x += 50; p.y += 50; });
            if (copy.points) copy.points.forEach(p => { p.x += 50; p.y += 50; });
            if (copy.x !== undefined) { copy.x += 50; copy.y += 50; }
            this.strokes.push(copy);
            this.syncStroke(copy);
        }
        
        this.render();
        this.toast('Dupliziert');
    },
    
    moveToFront() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) { this.tokens.splice(idx, 1); this.tokens.push(item); }
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) { this.images.splice(idx, 1); this.images.push(item); }
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) { this.strokes.splice(idx, 1); this.strokes.push(item); }
        }
        this.render();
    },
    
    moveToBack() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) { this.tokens.splice(idx, 1); this.tokens.unshift(item); }
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) { this.images.splice(idx, 1); this.images.unshift(item); }
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) { this.strokes.splice(idx, 1); this.strokes.unshift(item); }
        }
        this.render();
    },
    
    // ==================== HISTORY ====================
    undo() {
        // Check which history has a more recent action
        const strokeAction = this.historyIdx >= 0 ? this.history[this.historyIdx] : null;
        const tokenAction = (this._tokenHistory && this._tokenHistoryIdx >= 0) ? this._tokenHistory[this._tokenHistoryIdx] : null;
        
        if (!strokeAction && !tokenAction) return;
        
        // Undo whichever is more recent (by timestamp), prefer token if both exist
        const undoToken = tokenAction && (!strokeAction || (tokenAction.ts || 0) >= (strokeAction.data?.ts || 0));
        
        if (undoToken) {
            this.undoToken();
        } else if (strokeAction) {
            if (strokeAction.type === 'stroke') this.strokes = this.strokes.filter(s => s.id !== strokeAction.data.id);
            this.historyIdx--;
            this.render();
            this.toast('Rückgängig');
        }
    },
    
    redo() {
        // Check which history has a redo available
        const hasStrokeRedo = this.historyIdx < this.history.length - 1;
        const hasTokenRedo = this._tokenHistory && this._tokenHistoryIdx < this._tokenHistory.length - 1;
        
        if (hasTokenRedo && !hasStrokeRedo) {
            this.redoToken();
        } else if (hasStrokeRedo) {
            this.historyIdx++;
            const action = this.history[this.historyIdx];
            if (action.type === 'stroke') this.strokes.push(action.data);
            this.render();
            this.toast('Wiederholt');
        }
    },
    
    clearAll() {
        // Set flag to prevent listeners from re-adding data
        this.isClearing = true;
        
        // Clear local state
        this.strokes = []; 
        this.images = []; 
        this.tokens = []; 
        this.fogAreas = [];
        this._auras = [];
        this._notes = [];
        this.bgImage = null;
        this.bgDataUrl = null;
        this.history = []; 
        this.historyIdx = -1;
        this.initiativeActive = null;
        this.initiativeOrder = [];
        this.deselect();
        this.render();
        this.renderInitiative();
        
        // Clear Firebase data for this room (but KEEP scenes!)
        if (this.db && this.roomCode) {
            const base = 'whiteboard/' + this.roomCode;
            
            // Detach listeners BEFORE deleting to prevent re-sync
            this.detachFirebaseListeners();
            
            // Delete individual paths, NOT the entire room (preserves /scenes)
            Promise.all([
                this.db.ref(base + '/strokes').remove(),
                this.db.ref(base + '/tokens').remove(),
                this.db.ref(base + '/images').remove(),
                this.db.ref(base + '/pings').remove(),
                this.db.ref(base + '/background').remove(),
                this.db.ref(base + '/cursors').remove(),
                this.db.ref(base + '/focus').remove(),
                this.db.ref(base + '/ruler').remove(),
                this.db.ref(base + '/auras').remove(),
                this.db.ref(base + '/notes').remove()
            ])
                .then(() => {
                    console.log('[WB] Firebase data REMOVED for room:', this.roomCode);
                    
                    // Re-attach listeners after delete is confirmed
                    setTimeout(() => {
                        this.isClearing = false;
                        this.setupFirebaseListeners();
                        console.log('[WB] Listeners re-attached');
                    }, 1000);
                })
                .catch(err => {
                    console.error('[WB] ❌ Error removing Firebase data:', err);
                    this.isClearing = false;
                    // Re-attach listeners anyway
                    this.setupFirebaseListeners();
                });
        } else {
            console.warn('[WB] No Firebase connection, only cleared locally');
            this.isClearing = false;
        }
        
        this.toast('Whiteboard geleert');
    },
    
    async exportPNG() {
        this.toast('Screenshot wird erstellt...');
        
        const wrapper = document.getElementById('canvasWrapper');
        const ww = wrapper.offsetWidth;
        const wh = wrapper.offsetHeight;
        const dpr = window.devicePixelRatio || 1;
        
        const canvas = document.createElement('canvas');
        canvas.width = ww * dpr;
        canvas.height = wh * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        // 1. Background canvas
        ctx.drawImage(this.bgCanvas, 0, 0, ww, wh);
        
        // 2. Grid lines (if visible)
        const gridEl = document.getElementById('wbGrid');
        if (gridEl && gridEl.classList.contains('visible')) {
            const size = this.gridSize * this.zoom;
            const ox = this.gridOffsetX * this.zoom + this.panX;
            const oy = this.gridOffsetY * this.zoom + this.panY;
            ctx.strokeStyle = this.gridColor || 'rgba(0,0,0,0.25)';
            ctx.lineWidth = 1;
            const startX = ox % size; const startY = oy % size;
            ctx.globalAlpha = parseFloat(getComputedStyle(gridEl).opacity) || 0.5;
            for (let x = startX; x < ww; x += size) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, wh); ctx.stroke();
            }
            for (let y = startY; y < wh; y += size) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(ww, y); ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }
        
        // 3. Strokes (main canvas)
        ctx.drawImage(this.mainCanvas, 0, 0, ww, wh);
        
        // 4. Images
        const imgPromises = this.images.map(img => {
            return new Promise(resolve => {
                const el = new Image();
                el.crossOrigin = 'anonymous';
                el.onload = () => {
                    const x = img.x * this.zoom + this.panX;
                    const y = img.y * this.zoom + this.panY;
                    ctx.drawImage(el, x, y, img.w * this.zoom, img.h * this.zoom);
                    resolve();
                };
                el.onerror = () => resolve();
                el.src = img.src;
            });
        });
        await Promise.all(imgPromises);
        
        // 5. Tokens - full visual rendering
        const statusSvgs = {
            dead: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 8l8 8M16 8l-8 8"/></svg>',
            unconscious: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 15s0-3 4-3 4 3 4 3"/></svg>',
            poisoned: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 8v4M12 16h.01"/></svg>',
            burning: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2"><path d="M12 22c-4-3-8-6-8-11a8 8 0 0 1 16 0c0 5-4 8-8 11z"/></svg>',
            frozen: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#38bdf8" stroke-width="2"><line x1="12" y1="2" x2="12" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>',
            stunned: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#eab308" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>',
            invisible: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#a78bfa" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><line x1="2" y1="2" x2="22" y2="22"/></svg>',
            blessed: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#fbbf24" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
            cursed: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#a855f7" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>',
            prone: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2"><path d="M4 16h16M8 12h8M6 8h12"/></svg>',
            grappled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2"><path d="M18 8a6 6 0 0 0-12 0c0 7-3 9-3 9h18s-3-2-3-9"/></svg>',
            concentrating: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>'
        };
        
        // Helper to render SVG string to image
        const svgToImg = (svgStr, size) => {
            return new Promise(resolve => {
                const blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const img = new Image();
                img.onload = () => { resolve(img); URL.revokeObjectURL(url); };
                img.onerror = () => { resolve(null); URL.revokeObjectURL(url); };
                img.src = url;
            });
        };
        
        // Load all token portrait images first
        const tokenImgMap = {};
        const portraitLoads = this.tokens.filter(t => t.img).map(t => {
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => { tokenImgMap[t.id] = img; resolve(); };
                img.onerror = () => resolve();
                img.src = t.img;
            });
        });
        await Promise.all(portraitLoads);
        
        // Pre-render all needed status SVGs
        const statusImgCache = {};
        for (const [key, svg] of Object.entries(statusSvgs)) {
            statusImgCache[key] = await svgToImg(svg, 18);
        }
        
        // Draw each token
        for (const t of this.tokens) {
            const displaySize = t.size * this.zoom;
            const cx = t.x * this.zoom + this.panX;
            const cy = t.y * this.zoom + this.panY;
            const r = displaySize / 2;
            const isDead = t.status?.includes('dead') || (t.hp !== undefined && t.hp <= 0);
            const isActive = this.initiativeActive === t.id;
            
            ctx.save();
            
            // Dead token opacity
            if (isDead) ctx.globalAlpha = 0.5;
            
            // Active turn glow
            if (isActive) {
                ctx.shadowColor = '#fbbf24';
                ctx.shadowBlur = 15;
            }
            
            // Token circle background + border
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.closePath();
            
            // Fill with color
            ctx.fillStyle = t.color || '#8b5cf6';
            ctx.fill();
            
            // Portrait image (clipped to circle)
            if (tokenImgMap[t.id]) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, r - 2, 0, Math.PI * 2);
                ctx.clip();
                ctx.drawImage(tokenImgMap[t.id], cx - r + 2, cy - r + 2, (r - 2) * 2, (r - 2) * 2);
                ctx.restore();
            } else {
                // Letter label
                ctx.fillStyle = 'white';
                ctx.font = `bold ${displaySize * 0.4}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(t.label || (t.name ? t.name.charAt(0) : '?'), cx, cy);
            }
            
            // Border
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = t.borderColor || '#8b5cf6';
            ctx.lineWidth = Math.max(2, displaySize * 0.06);
            ctx.stroke();
            
            // HP bar
            if (t.maxHp && t.maxHp > 0) {
                const barW = displaySize * 0.8;
                const barH = Math.max(4, displaySize * 0.08);
                const barX = cx - barW / 2;
                const barY = cy + r - barH + 2;
                const hpPct = Math.max(0, Math.min(1, t.hp / t.maxHp));
                // Background
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW, barH, barH / 2);
                ctx.fill();
                // Fill
                if (hpPct > 0) {
                    ctx.fillStyle = hpPct <= 0.25 ? '#ef4444' : hpPct <= 0.5 ? '#f59e0b' : '#22c55e';
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barW * hpPct, barH, barH / 2);
                    ctx.fill();
                }
            }
            
            // Name label
            const nameY = cy + r + (t.maxHp && t.maxHp > 0 ? 18 : 14);
            ctx.fillStyle = 'white';
            ctx.font = `600 ${Math.max(10, displaySize * 0.2)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 3;
            ctx.fillText(t.name || '', cx, nameY);
            ctx.shadowBlur = 0;
            
            // Initiative badge
            if (t.initiative != null && t.initiative !== '') {
                const badgeR = Math.max(10, displaySize * 0.2);
                const bx = cx + r - badgeR * 0.3;
                const by = cy - r + badgeR * 0.3;
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(bx, by, badgeR, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = `bold ${badgeR * 1.1}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(String(t.initiative), bx, by);
            }
            
            // Status effects
            if (t.status && t.status.length > 0) {
                const iconSize = Math.max(14, displaySize * 0.25);
                let sx = cx - r - 4;
                let sy = cy - r - 4;
                for (const s of t.status) {
                    const sImg = statusImgCache[s];
                    if (sImg) {
                        // Background circle
                        ctx.fillStyle = 'rgba(0,0,0,0.8)';
                        ctx.beginPath();
                        ctx.arc(sx + iconSize / 2, sy + iconSize / 2, iconSize / 2 + 1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.drawImage(sImg, sx + 2, sy + 2, iconSize - 4, iconSize - 4);
                    }
                    sx += iconSize + 2;
                }
            }
            
            ctx.restore();
        }
        
        // 6. Fog of war
        if (this.fogAreas && this.fogAreas.length > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            this.fogAreas.forEach(f => {
                ctx.fillRect(f.x * this.zoom + this.panX, f.y * this.zoom + this.panY, f.w * this.zoom, f.h * this.zoom);
            });
        }
        
        // Download
        const link = document.createElement('a');
        link.download = 'whiteboard-' + Date.now() + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        this.toast('Screenshot exportiert');
    },
    
    // ==================== KEYBOARD ====================
    setupKeyboard() {
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Don't process tool shortcuts while overlays are open
            const overlayOpen = document.querySelector('.wb-overlay.visible');
            
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); this.undo(); }
            if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); this.redo(); }
            
            if (overlayOpen) return; // Block tool shortcuts while modal open
            
            const toolMap = { p: 'pen', l: 'line', r: 'rect', c: 'circle', a: 'arrow', t: 'text', e: 'eraser', v: 'select', m: 'ruler', f: 'focus' };
            const _key = e.key.toLowerCase();
            if (toolMap[_key]) {
                if (this.toolbarLocked && !this.isGM && !['v', 'm', 'f'].includes(_key)) return;
                document.querySelector(`[data-tool="${toolMap[_key]}"]`)?.click();
            }
            
            if (e.shiftKey && _key === 'p') {
                if (this.toolbarLocked && !this.isGM) return;
                document.querySelector('[data-tool="polygon"]')?.click();
            }
            if (e.key.toLowerCase() === 'g') document.getElementById('gridToggle').click();
            
            if ((e.key === 'Delete' || e.key === 'Backspace') && this.selected) this.deleteSelected();
            
            if (e.key === 'Escape') {
                this.deselect();
                this.polygonPoints = [];
                document.querySelectorAll('.wb-overlay').forEach(o => o.classList.remove('visible'));
                document.getElementById('stampsPanel').classList.remove('visible');
                document.getElementById('contextMenu').classList.remove('visible');
                this.renderUI();
            }
        });
    },
    
    // ==================== FIREBASE ====================
    firebaseListeners: [], // Track listeners for cleanup
    isClearing: false, // Flag to prevent re-adding during clear
    
    async connectFirebase() {
        try {
            this.db = firebase.database();
            
            // Force server sync, not cache
            const snap = await this.db.ref('whiteboard/' + this.roomCode).once('value');
            const data = snap.val();
            
            console.log('[WB] Firebase data loaded:', data ? 'has data' : 'empty');
            
            if (data) {
                this.strokes = data.strokes ? Object.values(data.strokes) : [];
                this.tokens = data.tokens ? Object.values(data.tokens) : [];
                console.log('[WB] Loaded', this.strokes.length, 'strokes,', this.tokens.length, 'tokens');
                this.render();
            } else {
                // Ensure local state is empty if Firebase is empty
                this.strokes = [];
                this.tokens = [];
                this.render();
                console.log('[WB] Firebase empty, cleared local state');
            }
            
            // Setup listeners and track them
            this.setupFirebaseListeners();
            
            console.log('[WB] Firebase connected');
        } catch (err) {
            console.error('[WB] Firebase error:', err);
        }
    },
    
    setupFirebaseListeners() {
        if (!this.db || !this.roomCode) return;
        
        // Clear existing listeners first
        this.detachFirebaseListeners();
        
        const strokesRef = this.db.ref('whiteboard/' + this.roomCode + '/strokes');
        const tokensRef = this.db.ref('whiteboard/' + this.roomCode + '/tokens');
        const pingsRef = this.db.ref('whiteboard/' + this.roomCode + '/pings');
        const bgRef = this.db.ref('whiteboard/' + this.roomCode + '/background');
        const cursorsRef = this.db.ref('whiteboard/' + this.roomCode + '/cursors');
        const lockRef = this.db.ref('whiteboard/' + this.roomCode + '/toolbarLocked');
        const focusRef = this.db.ref('whiteboard/' + this.roomCode + '/focus');
        const gridRef = this.db.ref('whiteboard/' + this.roomCode + '/gridSettings');
        const imagesRef = this.db.ref('whiteboard/' + this.roomCode + '/images');
        const rulerRef = this.db.ref('whiteboard/' + this.roomCode + '/ruler');
        const aurasRef = this.db.ref('whiteboard/' + this.roomCode + '/auras');
        const notesRef = this.db.ref('whiteboard/' + this.roomCode + '/notes');
        
        // Track initial load to ignore cached child_added events
        let strokesInitialized = false;
        
        // Strokes: Full value listener for reliable sync (initial load + updates)
        strokesRef.on('value', snap => {
            if (this.isClearing) return;
            const data = snap.val();
            
            if (!data) {
                if (this.strokes.length > 0) {
                    this.strokes = [];
                    this.render();
                }
                strokesInitialized = true;
                return;
            }
            
            const remoteStrokes = Object.values(data);
            const remoteIds = remoteStrokes.map(s => s.id);
            
            // Remove strokes that no longer exist remotely (keep own pending strokes)
            this.strokes = this.strokes.filter(s => {
                if (s.userId === this.userId) return true;
                return remoteIds.includes(s.id);
            });
            
            // Add/update remote strokes
            remoteStrokes.forEach(rs => {
                if (!this.strokes.find(s => s.id === rs.id)) {
                    this.strokes.push(rs);
                }
            });
            
            this.render();
            strokesInitialized = true;
        });
        
        // Tokens: value listener with proper null handling
        tokensRef.on('value', snap => {
            if (this.isClearing) return;
            const tokens = snap.val();
            
            if (!tokens) {
                // Firebase cleared - sync local state
                if (this.tokens.length > 0) {
                    this.tokens = [];
                    this.renderTokens();
                    console.log('[WB] Tokens cleared from remote');
                }
                return;
            }
            
            // Get remote token IDs
            const remoteIds = Object.keys(tokens);
            
            // Remove tokens that no longer exist remotely
            this.tokens = this.tokens.filter(t => {
                if (t.userId === this.userId) return true; // Keep own tokens
                return remoteIds.includes(t.id);
            });
            
            // Add/update remote tokens with smooth interpolation
            Object.values(tokens).forEach(rt => {
                const existing = this.tokens.find(t => t.id === rt.id);
                if (existing) { 
                    if (rt.userId !== this.userId) {
                        // Smooth interpolation for position changes
                        const oldX = existing.x, oldY = existing.y;
                        const newX = rt.x, newY = rt.y;
                        Object.assign(existing, rt);
                        const dx = newX - oldX, dy = newY - oldY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 2 && dist < 2000) {
                            // Animate remote token movement
                            existing.x = oldX; existing.y = oldY;
                            existing._animTarget = { x: newX, y: newY };
                            existing._animStart = { x: oldX, y: oldY };
                            existing._animTime = performance.now();
                            existing._animDuration = Math.min(500, Math.max(200, dist * 0.8));
                        }
                    }
                } else {
                    this.tokens.push(rt);
                }
            });
            this.renderTokens();
        });
        
        // Pings
        pingsRef.on('child_added', snap => {
            const p = snap.val();
            if (p && p.userId !== this.userId && Date.now() - p.ts < 3000) this.showRemotePing(p);
        });
        
        // Background: Load and listen for changes
        bgRef.on('value', snap => {
            const bg = snap.val();
            if (bg && bg.dataUrl) {
                if (bg.updatedBy !== this.userId || !this.bgImage) {
                    this.loadBgFromUrl(bg.dataUrl);
                }
            } else if (!bg || !bg.dataUrl) {
                if (this.bgImage) { this.bgImage = null; this.bgDataUrl = null; this.render(); }
            }
        });
        
        // Remote cursors
        cursorsRef.on('value', snap => {
            this._remoteCursors = snap.val() || {};
            this.renderRemoteCursors(this._remoteCursors);
        });
        
        // Toolbar lock state
        lockRef.on('value', snap => {
            const locked = snap.val();
            if (!this.isGM && locked !== null) {
                this.toolbarLocked = !!locked;
                const toolbar = document.getElementById('wbToolbar');
                toolbar.classList.toggle('locked', this.toolbarLocked);
                if (this.toolbarLocked && !['select', 'ruler', 'ping', 'focus'].includes(this.tool)) {
                    this.tool = 'select';
                    document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === 'select'));
                    this.updateCursor();
                }
            }
            if (this.isGM) {
                document.getElementById('toolbarLockBtn')?.classList.toggle('active', !!locked);
            }
        });
        
        // Focus: pan camera for all users
        focusRef.on('value', snap => {
            const f = snap.val();
            if (f && f.userId !== this.userId && Date.now() - f.ts < 5000) {
                this.applyFocus(f);
                // Show ping after pan animation completes so position is correct
                setTimeout(() => {
                    this.showRemotePing({ wx: f.wx, wy: f.wy, color: '#fbbf24' });
                }, 350);
            }
        });
        
        // Grid settings: load on connect, listen for changes
        gridRef.on('value', snap => {
            const s = snap.val();
            if (s) {
                this.gridSize = s.gridSize || 70;
                this.gridOffsetX = s.gridOffsetX || 0;
                this.gridOffsetY = s.gridOffsetY || 0;
                this.gridColor = s.gridColor || 'rgba(255,255,255,0.12)';
                this.updateGrid();
            }
        });
        
        // Images: sync across all users
        imagesRef.on('value', snap => {
            const data = snap.val();
            if (data) {
                this.images = Object.values(data);
            } else {
                this.images = [];
            }
            this.renderImages();
        });
        
        // Remote rulers: render other users' ruler lines
        rulerRef.on('value', snap => {
            this._remoteRulers = snap.val() || {};
            this.renderRemoteRulers();
        });
        
        // Auras: sync area templates across users
        aurasRef.on('value', snap => {
            this._auras = snap.val() ? Object.values(snap.val()) : [];
            this.renderAuras();
        });
        
        // Notes: sync map notes across users
        notesRef.on('value', snap => {
            this._notes = snap.val() ? Object.values(snap.val()) : [];
            this.renderNotes();
        });
        
        // Track refs for cleanup
        this.firebaseListeners = [
            { ref: strokesRef, event: 'value' },
            { ref: tokensRef, event: 'value' },
            { ref: pingsRef, event: 'child_added' },
            { ref: bgRef, event: 'value' },
            { ref: cursorsRef, event: 'value' },
            { ref: lockRef, event: 'value' },
            { ref: focusRef, event: 'value' },
            { ref: gridRef, event: 'value' },
            { ref: imagesRef, event: 'value' },
            { ref: rulerRef, event: 'value' },
            { ref: aurasRef, event: 'value' },
            { ref: notesRef, event: 'value' }
        ];
    },
    
    detachFirebaseListeners() {
        this.firebaseListeners.forEach(l => {
            try { l.ref.off(l.event); } catch(e) {}
        });
        this.firebaseListeners = [];
    },
    
    syncStroke(s) { if (!this.db || !this.roomCode) return; const clean = JSON.parse(JSON.stringify(s)); this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + s.id).set(clean); },
    syncToken(t) { if (!this.db || !this.roomCode) return; this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + t.id).set(t); },
    syncPing(wx, wy) {
        if (!this.db || !this.roomCode) return;
        const id = Date.now() + '-' + this.userId;
        this.db.ref('whiteboard/' + this.roomCode + '/pings/' + id).set({ wx, wy, color: this.userColor, userId: this.userId, ts: Date.now() });
        setTimeout(() => this.db.ref('whiteboard/' + this.roomCode + '/pings/' + id).remove(), 3000);
    },
    
    showRemotePing(p) {
        // Convert world coordinates to screen coordinates
        const sx = p.wx * this.zoom + this.panX;
        const sy = p.wy * this.zoom + this.panY;
        const ping = document.createElement('div');
        ping.className = 'wb-ping';
        ping.style.left = sx + 'px';
        ping.style.top = sy + 'px';
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'wb-ping__ring';
            ring.style.borderColor = p.color;
            ring.style.animationDelay = (i * 0.15) + 's';
            ping.appendChild(ring);
        }
        const dot = document.createElement('div');
        dot.className = 'wb-ping__dot';
        dot.style.background = p.color;
        ping.appendChild(dot);
        document.getElementById('canvasWrapper').appendChild(ping);
        setTimeout(() => ping.remove(), 1500);
    },
    
    renderRemoteRulers() {
        // Remove old ruler overlays
        document.querySelectorAll('.wb-remote-ruler').forEach(el => el.remove());
        if (!this._remoteRulers) return;
        
        const wrapper = document.getElementById('canvasWrapper');
        for (const [uid, r] of Object.entries(this._remoteRulers)) {
            if (uid === this.userId) continue;
            if (!r || !r.sx || Date.now() - r.ts > 10000) continue;
            
            // Draw ruler line on a temporary SVG overlay
            const x1 = r.sx * this.zoom + this.panX;
            const y1 = r.sy * this.zoom + this.panY;
            const x2 = r.ex * this.zoom + this.panX;
            const y2 = r.ey * this.zoom + this.panY;
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('wb-remote-ruler');
            svg.setAttribute('style', 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:140');
            svg.innerHTML = `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${r.color || '#fbbf24'}" stroke-width="3" stroke-dasharray="10 5" opacity="0.7"/>`;
            wrapper.appendChild(svg);
            
            // Label at endpoint
            const label = document.createElement('div');
            label.className = 'wb-remote-ruler';
            label.style.cssText = `position:absolute;left:${x2 + 12}px;top:${y2 - 12}px;background:rgba(0,0,0,0.85);color:${r.color || '#fbbf24'};padding:4px 8px;border-radius:6px;font-size:11px;font-weight:600;pointer-events:none;z-index:141;border:1px solid ${r.color || '#fbbf24'};white-space:nowrap`;
            label.innerHTML = `${r.name}: <strong>${r.grids}</strong> Felder &middot; ${r.ft} ft / ${r.meters} m`;
            wrapper.appendChild(label);
        }
    },
    
    // ==================== AURA TEMPLATES ====================
    setupAura() {
        this._auraColor = 'rgba(239,68,68,0.3)';
        this._auraShape = 'circle';
        this._auras = [];
        this._auraDragging = null;
        
        // Shape selection buttons
        document.getElementById('auraShapes')?.addEventListener('click', e => {
            const btn = e.target.closest('[data-shape]');
            if (!btn) return;
            e.stopPropagation();
            document.querySelectorAll('#auraShapes [data-shape]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this._auraShape = btn.dataset.shape;
            // Also activate the aura tool
            this.tool = 'aura';
            document.querySelectorAll('.wb-dd-item[data-tool]').forEach(b => b.classList.remove('active'));
            document.querySelector('.wb-dd-item[data-tool="aura"]')?.classList.add('active');
            // Close all dropdowns
            document.querySelectorAll('.wb-menu').forEach(m => m.classList.remove('open'));
        });
    },
    
    placeAura(p) {
        // Use raw (unsnapped) world coords for precision
        let ox = p.rawX, oy = p.rawY;
        if (this.snap && this.gridSize) {
            // Snap to nearest grid cell center
            ox = Math.floor((ox - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX + this.gridSize / 2;
            oy = Math.floor((oy - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY + this.gridSize / 2;
        }
        this._auraDragging = { ox, oy, color: this._auraColor, shape: this._auraShape || 'circle' };
        this.isDrawing = true;
    },
    
    finishAuraDrag(p) {
        const d = this._auraDragging;
        if (!d) return;
        this.isDrawing = false;
        const dx = p.rawX - d.ox, dy = p.rawY - d.oy;
        const radiusPx = Math.sqrt(dx * dx + dy * dy);
        if (radiusPx < 5) { 
            this._auraDragging = null; this.isDrawing = false; 
            document.getElementById('rulerInfo').style.display = 'none';
            this.uiCtx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
            return; 
        }
        
        const grids = radiusPx / this.gridSize;
        const ft = grids * 5;
        const shape = d.shape || 'circle';
        const aura = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
            shape, x: d.ox, y: d.oy,
            radius: radiusPx, angle: Math.atan2(dy, dx), color: d.color,
            grids: Math.round(grids), ft: Math.round(ft), meters: +(ft * 0.3048).toFixed(1),
            userId: this.userId, ts: Date.now()
        };
        this._auras.push(aura);
        this._auraDragging = null;
        this.renderAuras();
        this.syncAura(aura);
        document.getElementById('rulerInfo').style.display = 'none';
        this.uiCtx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        const shapeNames = { circle: 'Kreis', cone: 'Kegel', square: 'Quadrat', line: 'Linie' };
        this.toast(`${shapeNames[shape] || shape} (${aura.grids} Felder / ${aura.ft} ft) platziert`);
        // Switch back to select tool
        this.tool = 'select';
        this.updateCursor();
        document.querySelectorAll('.wb-dd-item[data-tool]').forEach(b => b.classList.remove('active'));
        document.querySelector('.wb-dd-item[data-tool="select"]')?.classList.add('active');
        document.querySelectorAll('.wb-menu__trigger').forEach(t => t.classList.remove('has-active'));
    },
    
    renderAuras() {
        const c = document.getElementById('notesContainer');
        c.querySelectorAll('.wb-aura-el').forEach(el => el.remove());
        
        this._auras.forEach(a => {
            const r = a.radius * this.zoom;
            const size = (a.shape === 'line' ? Math.max(r * 2, 60) : r * 2) + 40;
            const el = document.createElement('canvas');
            el.className = 'wb-aura-el';
            el.dataset.auraId = a.id;
            el.width = size; el.height = size;
            
            // Position: for line shape, offset is different
            const ox = a.x * this.zoom + this.panX - size / 2;
            const oy = a.y * this.zoom + this.panY - size / 2;
            const isSelected = this.selected && this.selected.type === 'aura' && this.selected.item.id === a.id;
            el.style.cssText = `position:absolute;pointer-events:none;z-index:48;transform:translate3d(${ox}px,${oy}px,0)`;
            
            const ctx = el.getContext('2d');
            const cx = size / 2, cy = size / 2;
            const fillColor = a.color;
            const strokeColor = a.color.replace(/[\d.]+\)$/, '0.7)');
            const shape = a.shape || 'circle';
            const angle = a.angle || 0;
            
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = isSelected ? '#fbbf24' : strokeColor;
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.setLineDash(isSelected ? [] : [8, 4]);
            ctx.beginPath();
            
            if (shape === 'circle' || shape === 'sphere') {
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
            } else if (shape === 'cone') {
                const spread = Math.PI / 3;
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, r, angle - spread / 2, angle + spread / 2);
                ctx.closePath();
            } else if (shape === 'square') {
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);
                ctx.rect(-r, -r, r * 2, r * 2);
                ctx.restore();
            } else if (shape === 'line') {
                const lw = Math.max(this.gridSize * this.zoom * 0.5, 6);
                const ex = cx + Math.cos(angle) * r;
                const ey = cy + Math.sin(angle) * r;
                const nx = -Math.sin(angle) * lw / 2;
                const ny = Math.cos(angle) * lw / 2;
                ctx.moveTo(cx + nx, cy + ny); ctx.lineTo(ex + nx, ey + ny);
                ctx.lineTo(ex - nx, ey - ny); ctx.lineTo(cx - nx, cy - ny);
                ctx.closePath();
            }
            ctx.fill(); ctx.stroke();
            
            // Label
            ctx.setLineDash([]);
            const grids = a.grids || Math.round(a.radius / this.gridSize);
            const ft = a.ft || grids * 5;
            const meters = a.meters || +(ft * 0.3048).toFixed(1);
            const fontSize = Math.max(9, Math.min(13, r * 0.15));
            const labelX = shape === 'line' ? cx + Math.cos(angle) * r * 0.5 : (shape === 'cone' ? cx + Math.cos(angle) * r * 0.4 : cx);
            const labelY = shape === 'line' ? cy + Math.sin(angle) * r * 0.5 : (shape === 'cone' ? cy + Math.sin(angle) * r * 0.4 : cy);
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = `600 ${fontSize}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 3;
            ctx.fillText(`${grids} Felder`, labelX, labelY - fontSize * (a.label ? 1.1 : 0.6));
            ctx.font = `500 ${fontSize * 0.85}px sans-serif`;
            ctx.fillStyle = 'rgba(255,255,255,0.65)';
            ctx.fillText(`${ft} ft / ${meters} m`, labelX, labelY + fontSize * (a.label ? -0.1 : 0.5));
            if (a.label) {
                ctx.font = `600 ${fontSize}px sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.fillText(a.label, labelX, labelY + fontSize * 0.9);
            }
            ctx.shadowBlur = 0;
            
            c.appendChild(el);
        });
    },
    
    removeAura(id) {
        this._auras = this._auras.filter(a => a.id !== id);
        if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/auras/' + id).remove();
        this.renderAuras();
    },
    
    hitTestAura(a, p) {
        const dx = p.x - a.x, dy = p.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const shape = a.shape || 'circle';
        if (shape === 'circle' || shape === 'sphere') {
            return dist <= a.radius;
        } else if (shape === 'cone') {
            if (dist > a.radius) return false;
            const angle = a.angle || 0;
            const pAngle = Math.atan2(dy, dx);
            let diff = pAngle - angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return Math.abs(diff) <= Math.PI / 6; // 60 degree cone / 2
        } else if (shape === 'square') {
            const angle = a.angle || 0;
            const cos = Math.cos(-angle), sin = Math.sin(-angle);
            const lx = dx * cos - dy * sin, ly = dx * sin + dy * cos;
            return Math.abs(lx) <= a.radius && Math.abs(ly) <= a.radius;
        } else if (shape === 'line') {
            const angle = a.angle || 0;
            const cos = Math.cos(-angle), sin = Math.sin(-angle);
            const lx = dx * cos - dy * sin, ly = dx * sin + dy * cos;
            const hw = Math.max(this.gridSize * 0.25, 5);
            return lx >= 0 && lx <= a.radius && Math.abs(ly) <= hw;
        }
        return false;
    },
    
    syncAura(a) {
        if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/auras/' + a.id).set(a);
    },
    
    // ==================== DRAGGABLE / RESIZABLE PANELS ====================
    setupDraggablePanels() {
        const STORAGE_KEY = 'wb_panel_layout';
        const savedLayout = (() => { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; } catch(e) { return {}; } })();
        
        const saveLayout = () => {
            const layout = {};
            ['tokenSidebar', 'initiativePanel'].forEach(id => {
                const p = document.getElementById(id);
                if (!p) return;
                layout[id] = { left: p.style.left, top: p.style.top, width: p.style.width, height: p.style.height, maxHeight: p.style.maxHeight };
            });
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(layout)); } catch(e) {}
        };
        
        // Restore saved positions/sizes
        ['tokenSidebar', 'initiativePanel'].forEach(id => {
            const p = document.getElementById(id);
            const s = savedLayout[id];
            if (!p || !s) return;
            if (s.left) { p.style.left = s.left; p.style.right = 'auto'; p.style.transform = 'none'; }
            if (s.top) p.style.top = s.top;
            if (s.width) p.style.width = s.width;
            if (s.height) { p.style.height = s.height; p.style.maxHeight = s.height; }
        });
        
        // Make panels draggable by their header
        const panels = [
            { el: 'tokenSidebar', header: '.wb-token-sidebar__header' },
            { el: 'initiativePanel', header: '.wb-initiative-panel__header' },
            { el: 'effectsPanel', header: '.wb-iframe-panel__header' },
            { el: 'broadcastPanel', header: '.wb-iframe-panel__header' },
        ];
        
        panels.forEach(({ el, header }) => {
            const panel = document.getElementById(el);
            if (!panel) return;
            const hdr = panel.querySelector(header);
            if (!hdr) return;
            
            let dragState = null;
            
            hdr.addEventListener('mousedown', e => {
                if (e.target.closest('button')) return;
                e.preventDefault();
                const rect = panel.getBoundingClientRect();
                const container = panel.parentElement.getBoundingClientRect();
                dragState = {
                    startX: e.clientX, startY: e.clientY,
                    startLeft: rect.left - container.left,
                    startTop: rect.top - container.top
                };
                panel.style.left = dragState.startLeft + 'px';
                panel.style.top = dragState.startTop + 'px';
                panel.style.right = 'auto';
                panel.style.bottom = 'auto';
                panel.style.transform = 'none';
                
                const onMove = ev => {
                    if (!dragState) return;
                    const dx = ev.clientX - dragState.startX;
                    const dy = ev.clientY - dragState.startY;
                    panel.style.left = (dragState.startLeft + dx) + 'px';
                    panel.style.top = (dragState.startTop + dy) + 'px';
                };
                const onUp = () => {
                    dragState = null;
                    saveLayout();
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                };
                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', onUp);
            });
        });
        
        // Make panels resizable by corner handle
        document.querySelectorAll('.wb-panel-resize').forEach(handle => {
            const panel = handle.parentElement;
            let resizeState = null;
            
            handle.addEventListener('mousedown', e => {
                e.preventDefault();
                e.stopPropagation();
                const rect = panel.getBoundingClientRect();
                resizeState = { startX: e.clientX, startY: e.clientY, startW: rect.width, startH: rect.height };
                
                const onMove = ev => {
                    if (!resizeState) return;
                    const w = Math.max(180, resizeState.startW + (ev.clientX - resizeState.startX));
                    const h = Math.max(120, resizeState.startH + (ev.clientY - resizeState.startY));
                    panel.style.width = w + 'px';
                    panel.style.height = h + 'px';
                    panel.style.maxHeight = h + 'px';
                };
                const onUp = () => {
                    resizeState = null;
                    saveLayout();
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                };
                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', onUp);
            });
        });
    },
    
    // ==================== MAP NOTES ====================
    setupNotes() {
        this._notes = [];
        this._pendingNotePos = null;
        this._noteType = 'info';
        
        // Note button
        const noteBtn = document.getElementById('noteBtn');
        if (noteBtn) {
            noteBtn.onclick = () => {
                this._placingNote = !this._placingNote;
                noteBtn.classList.toggle('active', this._placingNote);
                this.toast(this._placingNote ? 'Klicke auf die Map um Notiz zu setzen' : 'Notiz-Modus deaktiviert');
            };
        }
        
        // Note type selection
        document.getElementById('noteTypes')?.addEventListener('click', e => {
            const btn = e.target.closest('.wb-btn');
            if (!btn) return;
            document.querySelectorAll('#noteTypes .wb-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this._noteType = btn.dataset.type;
        });
        
        // Save note
        document.getElementById('noteSaveBtn')?.addEventListener('click', () => {
            const title = document.getElementById('noteTitle').value.trim();
            const text = document.getElementById('noteText').value.trim();
            if (!title && !text) { this.toast('Titel oder Text benötigt'); return; }
            
            if (this._editingNoteId) {
                // Edit existing note
                const existing = this._notes.find(n => n.id === this._editingNoteId);
                if (existing) {
                    existing.title = title || existing.type;
                    existing.text = text;
                    existing.type = this._noteType;
                    existing.visibleToPlayers = document.getElementById('noteVisibleToPlayers').checked;
                    this.syncNote(existing);
                    this.renderNotes();
                    this.toast('Notiz aktualisiert: ' + existing.title);
                }
                this._editingNoteId = null;
            } else {
                // Create new note
                const note = {
                    id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
                    type: this._noteType,
                    title: title || this._noteType,
                    text: text,
                    x: this._pendingNotePos.x,
                    y: this._pendingNotePos.y,
                    visibleToPlayers: document.getElementById('noteVisibleToPlayers').checked,
                    userId: this.userId, ts: Date.now()
                };
                this._notes.push(note);
                this.syncNote(note);
                this.renderNotes();
                this.toast('Notiz gesetzt: ' + note.title);
            }
            
            document.getElementById('noteOverlay').classList.remove('visible');
            document.getElementById('noteTitle').value = '';
            document.getElementById('noteText').value = '';
            this._placingNote = false;
            document.getElementById('noteBtn')?.classList.remove('active');
        });
    },
    
    showNoteDialog(p) {
        this._pendingNotePos = { x: p.rawX, y: p.rawY };
        this._editingNoteId = null;
        document.getElementById('noteOverlay').classList.add('visible');
        document.getElementById('noteTitle').focus();
    },
    
    renderNotes() {
        const c = document.getElementById('notesContainer');
        c.querySelectorAll('.wb-note').forEach(el => el.remove());
        
        const icons = {
            info: '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>',
            loot: '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
            trap: '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
            door: '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M18 3H6v18h12V3z"/><circle cx="15.5" cy="12" r="1"/></svg>',
            custom: '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>'
        };
        
        this._notes.forEach(n => {
            // Hide notes not visible to players if not GM
            if (!this.isGM && !n.visibleToPlayers) return;
            
            const el = document.createElement('div');
            el.className = `wb-note wb-note--${n.type}`;
            el.style.transform = 'translate(-50%, -50%)';
            el.style.left = (n.x * this.zoom + this.panX) + 'px';
            el.style.top = (n.y * this.zoom + this.panY) + 'px';
            el.style.pointerEvents = 'auto';
            el.innerHTML = (icons[n.type] || icons.custom);
            
            // Tooltip
            const tip = document.createElement('div');
            tip.className = 'wb-note__tooltip';
            const tipTitle = `<strong>${n.title}</strong>`;
            const tipText = (this.isGM && n.text) ? `<br><span style="opacity:0.7">${n.text}</span>` : '';
            tip.innerHTML = tipTitle + tipText;
            el.appendChild(tip);
            
            // GM context menu via main onContext
            if (this.isGM) {
                el.oncontextmenu = e => {
                    e.preventDefault(); e.stopPropagation();
                    this._contextHit = { type: 'note', item: n, index: this._notes.indexOf(n) };
                    this.onContext(e);
                };
                // Drag to move note (raw coords, no snap)
                el.onmousedown = e => {
                    if (e.button !== 0) return;
                    e.preventDefault(); e.stopPropagation();
                    this.select({ type: 'note', item: n, index: this._notes.indexOf(n) });
                    const startPoint = this.getPoint(e);
                    this._noteDrag = { note: n };
                    this.isDragging = true;
                    this.lastDragPoint = startPoint;
                    
                    const onNoteMove = ev => {
                        if (!this._noteDrag) return;
                        const p = this.getPoint(ev);
                        const dx = p.rawX - this.lastDragPoint.rawX;
                        const dy = p.rawY - this.lastDragPoint.rawY;
                        this._noteDrag.note.x += dx;
                        this._noteDrag.note.y += dy;
                        this.lastDragPoint = p;
                        this.renderNotes();
                    };
                    const onNoteUp = () => {
                        if (this._noteDrag) {
                            this.syncNote(this._noteDrag.note);
                            this._noteDrag = null;
                        }
                        this.isDragging = false;
                        this.lastDragPoint = null;
                        window.removeEventListener('mousemove', onNoteMove);
                        window.removeEventListener('mouseup', onNoteUp);
                    };
                    window.addEventListener('mousemove', onNoteMove);
                    window.addEventListener('mouseup', onNoteUp);
                };
            }

            
            c.appendChild(el);
        });
    },
    
    syncNote(n) {
        if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/notes/' + n.id).set(n);
    },
    
    // ==================== DRAG & DROP ====================
    setupDragDrop() {
        const wrapper = document.getElementById('canvasWrapper');
        const overlay = document.getElementById('dropOverlay');
        let dragCounter = 0;
        
        wrapper.addEventListener('dragenter', e => {
            e.preventDefault();
            dragCounter++;
            if (e.dataTransfer.types.includes('Files')) overlay.classList.add('visible');
        });
        wrapper.addEventListener('dragleave', e => {
            dragCounter--;
            if (dragCounter <= 0) { overlay.classList.remove('visible'); dragCounter = 0; }
        });
        wrapper.addEventListener('dragover', e => e.preventDefault());
        wrapper.addEventListener('drop', e => {
            e.preventDefault();
            overlay.classList.remove('visible');
            dragCounter = 0;
            
            const files = e.dataTransfer.files;
            if (!files.length) return;
            const file = files[0];
            if (!file.type.startsWith('image/')) { this.toast('Nur Bilder erlaubt'); return; }
            
            const reader = new FileReader();
            reader.onload = ev => {
                const rect = this.uiCanvas.getBoundingClientRect();
                const wx = (e.clientX - rect.left - this.panX) / this.zoom;
                const wy = (e.clientY - rect.top - this.panY) / this.zoom;
                
                const img = new Image();
                img.onload = () => {
                    const maxSize = this.gridSize * 6;
                    let w = img.width, h = img.height;
                    if (w > maxSize || h > maxSize) {
                        const scale = maxSize / Math.max(w, h);
                        w *= scale; h *= scale;
                    }
                    const imageObj = {
                        id: Date.now() + '-' + Math.random().toString(36).substr(2, 5),
                        src: ev.target.result, x: wx - w / 2, y: wy - h / 2, w, h,
                        userId: this.userId
                    };
                    this.images.push(imageObj);
                    this.syncImageToFirebase(imageObj);
                    this.renderImages();
                    this.toast('Bild eingefügt');
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        });
    },
    
    // ==================== TOKEN UNDO/REDO ====================
    pushTokenUndo(action) {
        if (!this._tokenHistory) this._tokenHistory = [];
        if (!this._tokenHistoryIdx) this._tokenHistoryIdx = -1;
        // Trim future
        this._tokenHistory = this._tokenHistory.slice(0, this._tokenHistoryIdx + 1);
        this._tokenHistory.push(action);
        this._tokenHistoryIdx = this._tokenHistory.length - 1;
        // Keep max 50
        if (this._tokenHistory.length > 50) {
            this._tokenHistory.shift();
            this._tokenHistoryIdx--;
        }
    },
    
    undoToken() {
        if (!this._tokenHistory || this._tokenHistoryIdx < 0) return;
        const action = this._tokenHistory[this._tokenHistoryIdx];
        this._tokenHistoryIdx--;
        
        if (action.type === 'move') {
            const t = this.tokens.find(x => x.id === action.tokenId);
            if (t) { t.x = action.from.x; t.y = action.from.y; this.syncToken(t); }
        } else if (action.type === 'hp') {
            const t = this.tokens.find(x => x.id === action.tokenId);
            if (t) { t.hp = action.from; this.syncToken(t); }
        } else if (action.type === 'delete') {
            this.tokens.push(action.token);
            this.syncToken(action.token);
        } else if (action.type === 'create') {
            const idx = this.tokens.findIndex(x => x.id === action.tokenId);
            if (idx !== -1) {
                if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + action.tokenId).remove();
                this.tokens.splice(idx, 1);
            }
        }
        this.renderTokens();
        this.renderInitiative();
        this.renderTokenSidebar();
        this.toast('Token-Aktion rückgängig');
    },
    
    redoToken() {
        if (!this._tokenHistory || this._tokenHistoryIdx >= this._tokenHistory.length - 1) return;
        this._tokenHistoryIdx++;
        const action = this._tokenHistory[this._tokenHistoryIdx];
        
        if (action.type === 'move') {
            const t = this.tokens.find(x => x.id === action.tokenId);
            if (t) { t.x = action.to.x; t.y = action.to.y; this.syncToken(t); }
        } else if (action.type === 'hp') {
            const t = this.tokens.find(x => x.id === action.tokenId);
            if (t) { t.hp = action.to; this.syncToken(t); }
        } else if (action.type === 'delete') {
            const idx = this.tokens.findIndex(x => x.id === action.token.id);
            if (idx !== -1) {
                if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + action.token.id).remove();
                this.tokens.splice(idx, 1);
            }
        } else if (action.type === 'create') {
            const t = action.token;
            this.tokens.push(t);
            this.syncToken(t);
        }
        this.renderTokens();
        this.renderInitiative();
        this.renderTokenSidebar();
        this.toast('Token-Aktion wiederhergestellt');
    },
    
    toast(msg) {
        const t = document.getElementById('wbToast');
        t.textContent = msg;
        t.classList.add('visible');
        setTimeout(() => t.classList.remove('visible'), 2000);
    }
};

function initWB() {
    // Unified layout: Check for topnav OR old sidebar/topbar
    const hasUnifiedLayout = document.querySelector('#topnav-placeholder') || document.querySelector('.topnav');
    const hasOldLayout = document.querySelector('.sidebar') && document.querySelector('.topbar');
    
    if (hasUnifiedLayout || hasOldLayout) {
        setTimeout(() => WB.init(), 100);
    } else {
        setTimeout(initWB, 100);
    }
}
document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', () => setTimeout(initWB, 200)) : setTimeout(initWB, 200);
    </script>
</body>
</html>
