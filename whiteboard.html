<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <meta name="view-transition" content="same-origin">
    <title>RIFT ‚Äì Whiteboard</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/sidebar.css">
    <link rel="stylesheet" href="assets/css/topbar.css">
    <link rel="stylesheet" href="assets/css/footer.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    
    <style>
        .footer { display: none !important; }
        .whiteboard-page { min-height: calc(100vh - 60px); padding: 0; display: flex; flex-direction: column; }
        .whiteboard-container { flex: 1; display: flex; flex-direction: column; background: #0a0a0a; margin: 12px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.08); overflow: hidden; max-height: calc(100vh - 84px); }
        
        .wb-toolbar { display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(22,22,22,0.98); border-bottom: 1px solid rgba(255,255,255,0.08); flex-wrap: wrap; z-index: 100; flex-shrink: 0; }
        .wb-toolbar__group { display: flex; align-items: center; gap: 2px; padding: 4px; background: rgba(255,255,255,0.03); border-radius: 8px; }
        .wb-toolbar__divider { width: 1px; height: 28px; background: rgba(255,255,255,0.1); margin: 0 4px; }
        
        .wb-btn { width: 36px; height: 36px; border: none; background: transparent; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; color: rgba(255,255,255,0.6); }
        .wb-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-btn.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-btn svg { width: 18px; height: 18px; }
        .wb-btn--danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        
        .wb-color-btn { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.15s; }
        .wb-color-btn:hover { transform: scale(1.15); }
        .wb-color-btn.active { border-color: white; box-shadow: 0 0 0 2px rgba(255,255,255,0.3); }
        
        .wb-size-btn { width: 28px; height: 28px; border: none; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .wb-size-btn:hover { background: rgba(255,255,255,0.1); }
        .wb-size-btn.active { background: var(--accent, #8b5cf6); }
        .wb-size-btn__dot { background: white; border-radius: 50%; }
        
        .wb-toggle { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; font-size: 11px; color: rgba(255,255,255,0.6); border: none; transition: all 0.15s; }
        .wb-toggle:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-toggle.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-toggle__dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .wb-toggle.active .wb-toggle__dot { box-shadow: 0 0 6px currentColor; }
        
        .wb-layers { display: flex; gap: 2px; background: rgba(0,0,0,0.3); padding: 3px; border-radius: 8px; }
        .wb-layer-tab { padding: 6px 12px; border: none; background: transparent; color: rgba(255,255,255,0.5); font-size: 11px; font-weight: 500; border-radius: 6px; cursor: pointer; transition: all 0.15s; }
        .wb-layer-tab:hover { color: white; background: rgba(255,255,255,0.1); }
        .wb-layer-tab.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-layer-tab--fog { color: rgba(239,68,68,0.7); }
        .wb-layer-tab--fog.active { background: #ef4444; }
        
        .wb-canvas-wrapper { flex: 1; position: relative; overflow: hidden; cursor: crosshair; min-height: 0; background: #0a0a0a; }
        .wb-canvas-wrapper.tool-select { cursor: default; }
        .wb-canvas-wrapper.tool-eraser { cursor: cell; }
        .wb-canvas-wrapper.tool-text { cursor: text; }
        .wb-canvas-wrapper.panning { cursor: grab; }
        
        /* Selection Box & Resize Handles */
        .wb-select-box { position: absolute; border: 2px solid #fbbf24; background: rgba(251,191,36,0.05); pointer-events: none; z-index: 200; display: none; }
        .wb-select-box.visible { display: block; }
        .wb-resize-handle { position: absolute; width: 12px; height: 12px; background: #fbbf24; border: 2px solid white; border-radius: 2px; pointer-events: auto; z-index: 201; }
        .wb-resize-handle--nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .wb-resize-handle--ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .wb-resize-handle--sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .wb-resize-handle--se { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .wb-resize-handle--n { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .wb-resize-handle--s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .wb-resize-handle--w { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .wb-resize-handle--e { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }
        
        /* Draggable Image */
        .wb-image { position: absolute; cursor: move; z-index: 45; user-select: none; }
        .wb-image.selected { outline: 3px solid #fbbf24; outline-offset: 2px; }
        .wb-image img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        
        .wb-canvas { position: absolute; top: 0; left: 0; touch-action: none; }
        #bgCanvas { z-index: 1; }
        #mainCanvas { z-index: 2; }
        #fogCanvas { z-index: 4; }
        #uiCanvas { z-index: 5; }
        
        #wbGrid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; background-image: linear-gradient(rgba(255,255,255,0.12) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.12) 1px, transparent 1px); background-size: 40px 40px; z-index: 10; transition: opacity 0.2s; }
        #wbGrid.visible { opacity: 0.5; }
        
        #imagesContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; }
        #imagesContainer .wb-image { pointer-events: auto; }
        #tokensContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        #tokensContainer .wb-token { pointer-events: auto; }
        
        .wb-text-input { position: fixed; background: rgba(0,0,0,0.95); border: 2px solid var(--accent, #8b5cf6); border-radius: 8px; padding: 10px 14px; color: white; font-size: 18px; min-width: 200px; outline: none; z-index: 1000; display: none; }
        
        .wb-zoom-controls { position: absolute; bottom: 16px; right: 16px; display: flex; flex-direction: column; gap: 4px; background: rgba(22,22,22,0.95); border-radius: 10px; padding: 6px; border: 1px solid rgba(255,255,255,0.1); z-index: 100; }
        .wb-zoom-btn { width: 32px; height: 32px; border: none; background: transparent; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.6); }
        .wb-zoom-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-zoom-level { text-align: center; font-size: 10px; color: rgba(255,255,255,0.5); padding: 2px 0; }
        
        .wb-ping { position: absolute; pointer-events: none; z-index: 200; }
        .wb-ping__ring { position: absolute; border: 3px solid; border-radius: 50%; animation: ping-expand 1s ease-out forwards; }
        @keyframes ping-expand { 0% { width: 0; height: 0; opacity: 1; transform: translate(-50%, -50%); } 100% { width: 100px; height: 100px; opacity: 0; transform: translate(-50%, -50%); } }
        .wb-ping__dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; transform: translate(-50%, -50%); animation: ping-pulse 1s ease-out forwards; }
        @keyframes ping-pulse { 0%, 50% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } }
        
        .wb-ruler-info { position: absolute; background: rgba(0,0,0,0.9); color: #fbbf24; padding: 8px 14px; border-radius: 8px; font-size: 14px; font-weight: 600; pointer-events: none; z-index: 150; display: none; border: 2px solid #fbbf24; }
        
        .wb-token { position: absolute; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.5); cursor: move; display: flex; align-items: center; justify-content: center; font-weight: 700; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8); user-select: none; z-index: 50; transition: transform 0.1s, box-shadow 0.1s; }
        .wb-token:hover { transform: scale(1.1); box-shadow: 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token.selected { border-color: #fbbf24; box-shadow: 0 0 0 4px rgba(251,191,36,0.4), 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; }
        .wb-token__label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 2px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; }
        
        .wb-stamps-panel { position: absolute; top: 60px; left: 16px; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px; z-index: 100; display: none; max-width: 260px; }
        .wb-stamps-panel.visible { display: block; }
        .wb-stamps-panel__title { font-size: 11px; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .wb-stamps-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; }
        .wb-stamp { width: 34px; height: 34px; border: none; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; font-size: 18px; transition: all 0.15s; }
        .wb-stamp:hover { background: rgba(255,255,255,0.15); transform: scale(1.1); }
        .wb-stamp.active { background: var(--accent); }
        
        .wb-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2000; }
        .wb-overlay.visible { display: flex; }
        .wb-upload-box { background: #1a1a1a; border: 2px dashed rgba(139,92,246,0.5); border-radius: 16px; padding: 48px; text-align: center; max-width: 90%; transition: all 0.2s; }
        .wb-upload-box.dragover { border-color: #8b5cf6; background: rgba(139,92,246,0.1); transform: scale(1.02); }
        .wb-upload-box svg { width: 56px; height: 56px; color: rgba(255,255,255,0.3); margin-bottom: 16px; }
        .wb-upload-box h3 { color: white; font-size: 18px; margin-bottom: 8px; }
        .wb-upload-box p { color: rgba(255,255,255,0.5); font-size: 13px; margin-bottom: 20px; }
        .wb-upload-actions { display: flex; gap: 12px; justify-content: center; }
        .wb-upload-btn { background: var(--accent, #8b5cf6); color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; }
        .wb-upload-btn:hover { filter: brightness(1.1); }
        .wb-upload-btn--secondary { background: rgba(255,255,255,0.1); }
        .wb-overlay-close { position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border: none; border-radius: 50%; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        
        .wb-modal__content { background: #1a1a1a; border-radius: 16px; padding: 24px; min-width: 380px; max-width: 90%; border: 1px solid rgba(255,255,255,0.1); }
        .wb-modal__title { font-size: 18px; font-weight: 600; color: white; margin-bottom: 16px; }
        .wb-modal__input { width: 100%; padding: 12px 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 14px; margin-bottom: 16px; box-sizing: border-box; }
        .wb-modal__input:focus { outline: none; border-color: var(--accent); }
        .wb-modal__actions { display: flex; gap: 12px; justify-content: flex-end; }
        .wb-save-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background 0.15s; }
        .wb-save-item:hover { background: rgba(255,255,255,0.1); }
        .wb-save-item__name { font-weight: 600; color: white; }
        .wb-save-item__date { font-size: 12px; color: rgba(255,255,255,0.5); }
        .wb-save-item__delete { background: rgba(239,68,68,0.2); border: none; color: #ef4444; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        
        .wb-context-menu { position: fixed; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 6px; z-index: 3000; display: none; min-width: 150px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
        .wb-context-menu.visible { display: block; }
        .wb-context-item { display: flex; align-items: center; gap: 10px; padding: 10px 14px; border: none; background: transparent; color: rgba(255,255,255,0.8); font-size: 13px; width: 100%; text-align: left; cursor: pointer; border-radius: 6px; }
        .wb-context-item:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-context-item--danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        .wb-context-item svg { width: 16px; height: 16px; opacity: 0.7; }
        .wb-context-divider { height: 1px; background: rgba(255,255,255,0.1); margin: 4px 0; }
        
        .wb-toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(100px); background: rgba(22,22,22,0.95); border: 1px solid rgba(255,255,255,0.1); padding: 12px 24px; border-radius: 12px; color: white; font-size: 14px; z-index: 3000; opacity: 0; transition: all 0.3s; pointer-events: none; }
        .wb-toast.visible { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        @media (max-width: 768px) {
            .wb-toolbar { padding: 6px 8px; gap: 4px; }
            .wb-toolbar__group { gap: 1px; padding: 2px; }
            .wb-btn { width: 32px; height: 32px; }
            .wb-btn svg { width: 16px; height: 16px; }
            .wb-toolbar__divider { display: none; }
            .wb-color-btn { width: 20px; height: 20px; }
            .wb-toggle { padding: 4px 8px; font-size: 10px; }
        }
    </style>
</head>
<body>
    <div class="app">
        <main class="main">
            <div class="main__content">
                <div class="whiteboard-page">
                <div class="whiteboard-container">
                    <div class="wb-toolbar">
                        <div class="wb-layers">
                            <button class="wb-layer-tab active" data-layer="main">Zeichnen</button>
                            <button class="wb-layer-tab" data-layer="token">Token</button>
                            <button class="wb-layer-tab wb-layer-tab--fog" data-layer="fog" id="fogTab">Nebel</button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group" id="drawTools">
                            <button class="wb-btn active" data-tool="pen" title="Stift (P)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg></button>
                            <button class="wb-btn" data-tool="line" title="Linie (L)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg></button>
                            <button class="wb-btn" data-tool="rect" title="Rechteck (R)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
                            <button class="wb-btn" data-tool="circle" title="Kreis (C)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg></button>
                            <button class="wb-btn" data-tool="arrow" title="Pfeil (A)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="10 5 19 5 19 14"/></svg></button>
                            <button class="wb-btn" data-tool="polygon" title="Polygon (Shift+P)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5"/></svg></button>
                            <button class="wb-btn" data-tool="text" title="Text (T)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
                            <button class="wb-btn" data-tool="eraser" title="Radierer (E)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 3a2 2 0 012.8 0L21 7.8a2 2 0 010 2.8L11.8 20"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" data-tool="select" title="Ausw√§hlen/Verschieben (V)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-6 2-2 6z"/><path d="M14 14l5 5"/></svg></button>
                            <button class="wb-btn" data-tool="ruler" title="Ma√üband (M)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0z"/><path d="M14 8l-2 2M17 11l-2 2M8 5l-2 2"/></svg></button>
                            <button class="wb-btn" data-tool="ping" title="Ping"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="8" stroke-dasharray="4 4"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" id="imageBtn" title="Bild einf√ºgen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg></button>
                            <button class="wb-btn" id="stampBtn" title="Sticker"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg></button>
                            <button class="wb-btn" id="tokenBtn" title="Token"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group" id="colorPalette">
                            <button class="wb-color-btn active" data-color="#ffffff" style="background:#ffffff"></button>
                            <button class="wb-color-btn" data-color="#ef4444" style="background:#ef4444"></button>
                            <button class="wb-color-btn" data-color="#f97316" style="background:#f97316"></button>
                            <button class="wb-color-btn" data-color="#eab308" style="background:#eab308"></button>
                            <button class="wb-color-btn" data-color="#22c55e" style="background:#22c55e"></button>
                            <button class="wb-color-btn" data-color="#3b82f6" style="background:#3b82f6"></button>
                            <button class="wb-color-btn" data-color="#8b5cf6" style="background:#8b5cf6"></button>
                            <button class="wb-color-btn" data-color="#ec4899" style="background:#ec4899"></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-size-btn" data-size="2"><span class="wb-size-btn__dot" style="width:4px;height:4px"></span></button>
                            <button class="wb-size-btn active" data-size="4"><span class="wb-size-btn__dot" style="width:8px;height:8px"></span></button>
                            <button class="wb-size-btn" data-size="8"><span class="wb-size-btn__dot" style="width:12px;height:12px"></span></button>
                            <button class="wb-size-btn" data-size="16"><span class="wb-size-btn__dot" style="width:16px;height:16px"></span></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <button class="wb-toggle" id="fillToggle"><span class="wb-toggle__dot"></span>F√ºllen</button>
                        <button class="wb-toggle" id="snapToggle"><span class="wb-toggle__dot"></span>Snap</button>
                        <button class="wb-toggle" id="gridToggle"><span class="wb-toggle__dot"></span>Raster</button>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" id="undoBtn" title="R√ºckg√§ngig"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M3 13a9 9 0 1 0 3-7.7L3 7"/></svg></button>
                            <button class="wb-btn" id="redoBtn" title="Wiederholen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 7v6h-6"/><path d="M21 13a9 9 0 1 1-3-7.7L21 7"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" id="saveBtn" title="Speichern"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></button>
                            <button class="wb-btn" id="loadBtn" title="Laden"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg></button>
                            <button class="wb-btn" id="bgBtn" title="Hintergrund"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/><path d="M21 15l-5-5L5 21"/></svg></button>
                            <button class="wb-btn" id="exportBtn" title="Export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group" id="gmActions" style="display:none">
                            <button class="wb-btn wb-btn--danger" id="clearBtn" title="L√∂schen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
                        </div>
                    </div>
                    <div class="wb-canvas-wrapper" id="canvasWrapper">
                        <canvas class="wb-canvas" id="bgCanvas"></canvas>
                        <canvas class="wb-canvas" id="mainCanvas"></canvas>
                        <canvas class="wb-canvas" id="fogCanvas"></canvas>
                        <canvas class="wb-canvas" id="uiCanvas"></canvas>
                        <div id="wbGrid"></div>
                        <div id="imagesContainer"></div>
                        <div id="tokensContainer"></div>
                        <!-- Selection Box with Resize Handles -->
                        <div class="wb-select-box" id="selectBox">
                            <div class="wb-resize-handle wb-resize-handle--nw" data-handle="nw"></div>
                            <div class="wb-resize-handle wb-resize-handle--ne" data-handle="ne"></div>
                            <div class="wb-resize-handle wb-resize-handle--sw" data-handle="sw"></div>
                            <div class="wb-resize-handle wb-resize-handle--se" data-handle="se"></div>
                            <div class="wb-resize-handle wb-resize-handle--n" data-handle="n"></div>
                            <div class="wb-resize-handle wb-resize-handle--s" data-handle="s"></div>
                            <div class="wb-resize-handle wb-resize-handle--w" data-handle="w"></div>
                            <div class="wb-resize-handle wb-resize-handle--e" data-handle="e"></div>
                        </div>
                        <div class="wb-ruler-info" id="rulerInfo"></div>
                        <div class="wb-zoom-controls">
                            <button class="wb-zoom-btn" id="zoomInBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                            <div class="wb-zoom-level" id="zoomLevel">100%</div>
                            <button class="wb-zoom-btn" id="zoomOutBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                            <button class="wb-zoom-btn" id="zoomResetBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                        </div>
                    </div>
                </div>
                <div class="wb-stamps-panel" id="stampsPanel"><div class="wb-stamps-panel__title">Sticker</div><div class="wb-stamps-grid" id="stampsGrid"></div></div>
                <input type="text" class="wb-text-input" id="textInput" placeholder="Text...">
                <div class="wb-overlay" id="bgOverlay"><button class="wb-overlay-close" onclick="document.getElementById('bgOverlay').classList.remove('visible')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-upload-box" id="bgUploadBox"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg><h3>Hintergrund</h3><p>Battle Map hochladen</p><div class="wb-upload-actions"><button class="wb-upload-btn" id="bgSelectBtn">Ausw√§hlen</button><button class="wb-upload-btn wb-upload-btn--secondary" id="bgRemoveBtn">Entfernen</button></div><input type="file" id="bgFileInput" accept="image/*" style="display:none"></div></div>
                <div class="wb-overlay" id="imageOverlay"><button class="wb-overlay-close" onclick="document.getElementById('imageOverlay').classList.remove('visible')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-upload-box" id="imageUploadBox"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg><h3>Bild einf√ºgen</h3><p>Wird platzierbar eingef√ºgt</p><div class="wb-upload-actions"><button class="wb-upload-btn" id="imageSelectBtn">Ausw√§hlen</button></div><input type="file" id="imageFileInput" accept="image/*" style="display:none"></div></div>
                <div class="wb-overlay" id="saveOverlay"><div class="wb-modal__content"><div class="wb-modal__title">Speichern</div><input type="text" class="wb-modal__input" id="saveNameInput" placeholder="Name..."><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('saveOverlay').classList.remove('visible')">Abbrechen</button><button class="wb-upload-btn" id="saveConfirmBtn">Speichern</button></div></div></div>
                <div class="wb-overlay" id="loadOverlay"><div class="wb-modal__content" style="min-width:450px"><div class="wb-modal__title">Laden</div><div id="savedList" style="max-height:350px;overflow-y:auto;margin-bottom:16px"></div><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('loadOverlay').classList.remove('visible')">Schlie√üen</button></div></div></div>
                <div class="wb-overlay" id="tokenOverlay"><div class="wb-modal__content"><div class="wb-modal__title">Token erstellen</div><input type="text" class="wb-modal__input" id="tokenNameInput" placeholder="Name..."><div style="display:flex;gap:8px;margin-bottom:16px;flex-wrap:wrap" id="tokenColorPicker"></div><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('tokenOverlay').classList.remove('visible')">Abbrechen</button><button class="wb-upload-btn" id="tokenCreateBtn">Erstellen</button></div></div></div>
                <div class="wb-context-menu" id="contextMenu"><button class="wb-context-item" data-action="duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren</button><button class="wb-context-item" data-action="front"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>Nach vorne</button><button class="wb-context-item" data-action="back"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>Nach hinten</button><div class="wb-context-divider"></div><button class="wb-context-item wb-context-item--danger" data-action="delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>L√∂schen</button></div>
                <div class="wb-toast" id="wbToast"></div>
                </div>
            </div>
        </main>
    </div>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    <script src="assets/js/firebase-config.js"></script>
    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    <script src="assets/js/toast-service.js"></script>
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/admin.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    <script>initLayout();</script>
    <script src="assets/js/broadcast.js"></script>
    <script>
const WB = {
    // Canvases
    bgCanvas: null, bgCtx: null, mainCanvas: null, mainCtx: null,
    fogCanvas: null, fogCtx: null, uiCanvas: null, uiCtx: null,
    
    // State
    layer: 'main', tool: 'pen', color: '#ffffff', size: 4,
    fill: false, snap: false, gridSize: 40, zoom: 1, panX: 0, panY: 0,
    
    // Drawing
    isDrawing: false, isPanning: false, isDragging: false, isResizing: false,
    startPoint: null, currentPath: [], polygonPoints: [],
    resizeHandle: null, dragOffset: { x: 0, y: 0 },
    
    // Data
    strokes: [], images: [], tokens: [], fogAreas: [],
    selected: null, // Single selected item
    bgImage: null, history: [], historyIdx: -1,
    
    // User
    roomCode: null, db: null, userId: null, userName: null,
    userColor: '#8b5cf6', isGM: false,
    
    // Stamps
    stamps: ['‚öîÔ∏è','üõ°Ô∏è','üíÄ','üëë','üóùÔ∏è','üíé','üî•','‚ùÑÔ∏è','‚ö°','üíß','üåü','üè∞','üö™','‚¨ÜÔ∏è','‚¨áÔ∏è','‚¨ÖÔ∏è','‚û°Ô∏è','‚ùå','‚úÖ','‚ùì','üí∞','üìú','üß™','üó°Ô∏è','üèπ','ü™Ñ','üé≠','üëÅÔ∏è','üêâ','üßô'],
    selectedStamp: null, pendingTokenColor: '#8b5cf6',
    
    async init() {
        console.log('[WB] Starting...');
        this.bgCanvas = document.getElementById('bgCanvas');
        this.mainCanvas = document.getElementById('mainCanvas');
        this.fogCanvas = document.getElementById('fogCanvas');
        this.uiCanvas = document.getElementById('uiCanvas');
        this.bgCtx = this.bgCanvas.getContext('2d');
        this.mainCtx = this.mainCanvas.getContext('2d');
        this.fogCtx = this.fogCanvas.getContext('2d');
        this.uiCtx = this.uiCanvas.getContext('2d');
        
        this.roomCode = localStorage.getItem('rift_current_room');
        const u = JSON.parse(localStorage.getItem('rift_user') || '{}');
        this.userId = u.odUserId || Math.random().toString(36).substr(2, 9);
        this.userName = u.displayName || 'Anonym';
        this.userColor = u.color || '#8b5cf6';
        this.isGM = u.isGM || u.isCogm || false;
        
        this.addUserColor();
        if (this.isGM) document.getElementById('gmActions').style.display = 'flex';
        else document.getElementById('fogTab').style.display = 'none';
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.setupToolbar();
        this.setupCanvas();
        this.setupKeyboard();
        this.setupUploads();
        this.setupStamps();
        this.setupModals();
        this.setupContextMenu();
        this.setupResizeHandles();
        
        if (this.roomCode) await this.connectFirebase();
        this.render();
        console.log('[WB] Ready!');
    },
    
    resize() {
        const w = document.getElementById('canvasWrapper');
        const r = w.getBoundingClientRect();
        [this.bgCanvas, this.mainCanvas, this.fogCanvas, this.uiCanvas].forEach(c => {
            c.width = r.width; c.height = r.height;
        });
        this.render();
    },
    
    addUserColor() {
        const p = document.getElementById('colorPalette');
        const cols = [...p.querySelectorAll('.wb-color-btn')].map(b => b.dataset.color.toLowerCase());
        if (!cols.includes(this.userColor.toLowerCase())) {
            const btn = document.createElement('button');
            btn.className = 'wb-color-btn';
            btn.dataset.color = this.userColor;
            btn.style.background = this.userColor;
            btn.onclick = () => this.setColor(this.userColor);
            p.insertBefore(btn, p.firstChild);
        }
    },
    
    // ==================== TOOLBAR ====================
    setupToolbar() {
        document.querySelectorAll('.wb-layer-tab').forEach(t => {
            t.onclick = () => {
                document.querySelectorAll('.wb-layer-tab').forEach(x => x.classList.remove('active'));
                t.classList.add('active');
                this.layer = t.dataset.layer;
            };
        });
        
        document.querySelectorAll('[data-tool]').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('[data-tool]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                this.tool = b.dataset.tool;
                this.updateCursor();
                if (this.tool !== 'polygon') this.finishPolygon();
                if (this.tool !== 'select') this.deselect();
            };
        });
        
        document.querySelectorAll('.wb-color-btn').forEach(b => {
            b.onclick = () => this.setColor(b.dataset.color);
        });
        
        document.querySelectorAll('.wb-size-btn').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('.wb-size-btn').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                this.size = parseInt(b.dataset.size);
            };
        });
        
        document.getElementById('fillToggle').onclick = function() {
            this.classList.toggle('active');
            WB.fill = this.classList.contains('active');
        };
        document.getElementById('snapToggle').onclick = function() {
            this.classList.toggle('active');
            WB.snap = this.classList.contains('active');
        };
        document.getElementById('gridToggle').onclick = function() {
            this.classList.toggle('active');
            document.getElementById('wbGrid').classList.toggle('visible');
        };
        
        document.getElementById('undoBtn').onclick = () => this.undo();
        document.getElementById('redoBtn').onclick = () => this.redo();
        document.getElementById('zoomInBtn').onclick = () => this.setZoom(this.zoom + 0.25);
        document.getElementById('zoomOutBtn').onclick = () => this.setZoom(this.zoom - 0.25);
        document.getElementById('zoomResetBtn').onclick = () => { this.zoom = 1; this.panX = 0; this.panY = 0; this.updateZoom(); this.render(); };
        document.getElementById('exportBtn').onclick = () => this.exportPNG();
        document.getElementById('clearBtn')?.addEventListener('click', () => { if(confirm('Alles l√∂schen?')) this.clearAll(); });
        document.getElementById('stampBtn').onclick = () => document.getElementById('stampsPanel').classList.toggle('visible');
        document.getElementById('tokenBtn').onclick = () => this.showTokenModal();
    },
    
    setColor(c) {
        this.color = c;
        document.querySelectorAll('.wb-color-btn').forEach(b => b.classList.toggle('active', b.dataset.color === c));
    },
    
    updateCursor() {
        const w = document.getElementById('canvasWrapper');
        w.className = 'wb-canvas-wrapper';
        if (this.tool === 'select') w.classList.add('tool-select');
        else if (this.tool === 'eraser') w.classList.add('tool-eraser');
        else if (this.tool === 'text') w.classList.add('tool-text');
    },
    
    setZoom(z) { this.zoom = Math.max(0.25, Math.min(4, z)); this.updateZoom(); this.render(); },
    updateZoom() { document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%'; },
    
    // ==================== CANVAS EVENTS ====================
    setupCanvas() {
        const ui = this.uiCanvas;
        ui.addEventListener('mousedown', e => this.onDown(e));
        ui.addEventListener('mousemove', e => this.onMove(e));
        ui.addEventListener('mouseup', e => this.onUp(e));
        ui.addEventListener('mouseleave', e => this.onUp(e));
        ui.addEventListener('dblclick', e => this.onDblClick(e));
        ui.addEventListener('contextmenu', e => this.onContext(e));
        
        ui.addEventListener('touchstart', e => { e.preventDefault(); this.onDown(e.touches[0]); }, { passive: false });
        ui.addEventListener('touchmove', e => { e.preventDefault(); this.onMove(e.touches[0]); }, { passive: false });
        ui.addEventListener('touchend', e => { e.preventDefault(); this.onUp(e); }, { passive: false });
        
        // Middle mouse pan
        ui.addEventListener('mousedown', e => {
            if (e.button === 1) { e.preventDefault(); this.isPanning = true; this.lastPan = { x: e.clientX, y: e.clientY }; }
        });
        window.addEventListener('mousemove', e => {
            if (this.isPanning && this.lastPan) {
                this.panX += e.clientX - this.lastPan.x;
                this.panY += e.clientY - this.lastPan.y;
                this.lastPan = { x: e.clientX, y: e.clientY };
                this.render();
            }
        });
        window.addEventListener('mouseup', e => { if (e.button === 1) this.isPanning = false; });
        
        // Wheel zoom
        document.getElementById('canvasWrapper').addEventListener('wheel', e => {
            e.preventDefault();
            this.setZoom(this.zoom + (e.deltaY > 0 ? -0.1 : 0.1));
        }, { passive: false });
        
        // Close panels on click outside
        document.addEventListener('click', e => {
            if (!e.target.closest('#stampsPanel') && !e.target.closest('#stampBtn'))
                document.getElementById('stampsPanel').classList.remove('visible');
            if (!e.target.closest('.wb-context-menu'))
                document.getElementById('contextMenu').classList.remove('visible');
        });
    },
    
    getPoint(e) {
        const r = this.uiCanvas.getBoundingClientRect();
        let x = (e.clientX - r.left - this.panX) / this.zoom;
        let y = (e.clientY - r.top - this.panY) / this.zoom;
        if (this.snap) {
            x = Math.round(x / this.gridSize) * this.gridSize;
            y = Math.round(y / this.gridSize) * this.gridSize;
        }
        return { x, y, sx: e.clientX, sy: e.clientY };
    },
    
    onDown(e) {
        if (this.isPanning || this.isResizing) return;
        const p = this.getPoint(e);
        this.startPoint = p;
        this.currentPath = [p];
        this.lastDragPoint = p; // Track for delta movement
        
        // SELECT TOOL - Main new logic
        if (this.tool === 'select') {
            const hit = this.hitTest(p);
            if (hit) {
                this.select(hit);
                this.isDragging = true;
                this.lastDragPoint = p;
            } else {
                this.deselect();
            }
            return;
        }
        
        if (this.tool === 'ping') { this.createPing(p.sx, p.sy); return; }
        if (this.tool === 'text') { this.showTextInput(p); return; }
        if (this.tool === 'stamp' && this.selectedStamp) { this.placeStamp(p); return; }
        if (this.tool === 'polygon') { this.polygonPoints.push(p); this.renderUI(); return; }
        
        this.isDrawing = true;
    },
    
    onMove(e) {
        const p = this.getPoint(e);
        
        // Dragging selected item - use delta movement
        if (this.isDragging && this.selected && this.lastDragPoint) {
            const dx = p.x - this.lastDragPoint.x;
            const dy = p.y - this.lastDragPoint.y;
            this.lastDragPoint = p;
            this.moveSelected(dx, dy);
            return;
        }
        
        // Resizing selected item
        if (this.isResizing && this.selected && this.resizeHandle) {
            this.handleResize(e);
            return;
        }
        
        if (!this.isDrawing) return;
        this.currentPath.push(p);
        
        if (this.tool === 'pen') this.drawLivePen(p);
        else if (this.tool === 'eraser') this.eraseLive(p);
        else if (this.tool === 'ruler') this.showRuler(this.startPoint, p);
        else this.renderUI();
    },
    
    onUp(e) {
        if (this.isDragging) {
            this.isDragging = false;
            this.lastDragPoint = null;
            // Already synced in real-time via moveSelected()
            return;
        }
        
        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            return;
        }
        
        if (this.tool === 'ruler') {
            document.getElementById('rulerInfo').style.display = 'none';
            this.renderUI();
        }
        
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        if (this.currentPath.length < 2) return;
        
        const end = this.currentPath[this.currentPath.length - 1];
        const stroke = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: this.layer, tool: this.tool,
            color: this.tool === 'eraser' ? '#0a0a0a' : this.color,
            size: this.tool === 'eraser' ? this.size * 4 : this.size,
            fill: this.fill,
            path: ['pen', 'eraser'].includes(this.tool) ? [...this.currentPath] : null,
            start: this.startPoint, end: end,
            userId: this.userId, ts: Date.now()
        };
        
        this.addStroke(stroke);
        this.syncStroke(stroke);
        this.currentPath = [];
        this.startPoint = null;
        this.renderUI();
    },
    
    onDblClick(e) {
        const p = this.getPoint(e);
        
        // Double-click on text to edit
        if (this.tool === 'select' && this.selected?.type === 'stroke' && this.selected.item.tool === 'text') {
            this.editText(this.selected.item, p);
            return;
        }
        
        if (this.tool === 'polygon' && this.polygonPoints.length >= 3) this.finishPolygon();
        else this.createPing(p.sx, p.sy);
    },
    
    editText(stroke, p) {
        const inp = document.getElementById('textInput');
        const canvasRect = this.uiCanvas.getBoundingClientRect();
        inp.style.left = (stroke.start.x * this.zoom + this.panX + canvasRect.left) + 'px';
        inp.style.top = (stroke.start.y * this.zoom + this.panY + canvasRect.top) + 'px';
        inp.style.display = 'block';
        inp.style.color = stroke.color;
        inp.dataset.strokeId = stroke.id;
        inp.dataset.x = stroke.start.x;
        inp.dataset.y = stroke.start.y;
        inp.value = stroke.text || '';
        setTimeout(() => { inp.focus(); inp.select(); }, 50);
    },
    
    onContext(e) {
        e.preventDefault();
        const p = this.getPoint(e);
        const hit = this.hitTest(p);
        if (hit) {
            this.select(hit);
            const m = document.getElementById('contextMenu');
            m.style.left = e.clientX + 'px';
            m.style.top = e.clientY + 'px';
            m.classList.add('visible');
        }
    },
    
    // ==================== SELECTION ====================
    hitTest(p) {
        // Check tokens first (top layer)
        for (let i = this.tokens.length - 1; i >= 0; i--) {
            const t = this.tokens[i];
            const dx = p.x - t.x, dy = p.y - t.y;
            if (Math.sqrt(dx * dx + dy * dy) < t.size / 2) return { type: 'token', item: t, index: i };
        }
        // Check images
        for (let i = this.images.length - 1; i >= 0; i--) {
            const img = this.images[i];
            if (p.x >= img.x && p.x <= img.x + img.w && p.y >= img.y && p.y <= img.y + img.h) 
                return { type: 'image', item: img, index: i };
        }
        // Check strokes (text, stamps, shapes) - reverse order for top-most first
        for (let i = this.strokes.length - 1; i >= 0; i--) {
            const s = this.strokes[i];
            if (s.layer !== 'main') continue;
            const bounds = this.getStrokeBounds(s);
            if (bounds && p.x >= bounds.x && p.x <= bounds.x + bounds.w && p.y >= bounds.y && p.y <= bounds.y + bounds.h)
                return { type: 'stroke', item: s, index: i };
        }
        return null;
    },
    
    getStrokeBounds(s) {
        if (s.tool === 'text') {
            const fontSize = s.size * 4 + 12;
            const textWidth = (s.text?.length || 5) * fontSize * 0.6;
            return { x: s.start.x, y: s.start.y - fontSize, w: textWidth, h: fontSize * 1.2 };
        }
        if (s.tool === 'stamp') {
            const size = s.stampSize || 40;
            return { x: s.x - size/2, y: s.y - size, w: size, h: size };
        }
        if (s.tool === 'pen' && s.path && s.path.length > 0) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            s.path.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
            return { x: minX - s.size, y: minY - s.size, w: maxX - minX + s.size*2, h: maxY - minY + s.size*2 };
        }
        if (s.tool === 'polygon' && s.points && s.points.length > 0) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            s.points.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
            return { x: minX - s.size, y: minY - s.size, w: maxX - minX + s.size*2, h: maxY - minY + s.size*2 };
        }
        if (['line', 'rect', 'circle', 'arrow'].includes(s.tool) && s.start && s.end) {
            const minX = Math.min(s.start.x, s.end.x), minY = Math.min(s.start.y, s.end.y);
            const maxX = Math.max(s.start.x, s.end.x), maxY = Math.max(s.start.y, s.end.y);
            return { x: minX - s.size, y: minY - s.size, w: maxX - minX + s.size*2, h: maxY - minY + s.size*2 };
        }
        return null;
    },
    
    select(hit) {
        this.selected = hit;
        this.render();
        this.updateSelectBox();
    },
    
    deselect() {
        this.selected = null;
        document.getElementById('selectBox').classList.remove('visible');
        this.render();
    },
    
    updateSelectBox() {
        const box = document.getElementById('selectBox');
        if (!this.selected) { box.classList.remove('visible'); return; }
        
        const bounds = this.getSelectedBounds();
        if (!bounds) { box.classList.remove('visible'); return; }
        
        const x = bounds.x * this.zoom + this.panX;
        const y = bounds.y * this.zoom + this.panY;
        const w = bounds.w * this.zoom;
        const h = bounds.h * this.zoom;
        
        box.style.left = x + 'px';
        box.style.top = y + 'px';
        box.style.width = w + 'px';
        box.style.height = h + 'px';
        box.classList.add('visible');
    },
    
    getSelectedBounds() {
        if (!this.selected) return null;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            return { x: item.x - item.size/2, y: item.y - item.size/2, w: item.size, h: item.size };
        }
        if (type === 'image') {
            return { x: item.x, y: item.y, w: item.w, h: item.h };
        }
        if (type === 'stroke') {
            return this.getStrokeBounds(item);
        }
        return null;
    },
    
    // Move selected item by delta
    moveSelected(dx, dy) {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            item.x += dx;
            item.y += dy;
            if (this.snap) {
                item.x = Math.round(item.x / this.gridSize) * this.gridSize;
                item.y = Math.round(item.y / this.gridSize) * this.gridSize;
            }
            // Real-time sync
            this.syncToken(item);
        }
        if (type === 'image') {
            item.x += dx;
            item.y += dy;
            if (this.snap) {
                item.x = Math.round(item.x / this.gridSize) * this.gridSize;
                item.y = Math.round(item.y / this.gridSize) * this.gridSize;
            }
        }
        if (type === 'stroke') {
            // Move stroke points
            if (item.start) { item.start.x += dx; item.start.y += dy; }
            if (item.end) { item.end.x += dx; item.end.y += dy; }
            if (item.path) item.path.forEach(p => { p.x += dx; p.y += dy; });
            if (item.points) item.points.forEach(p => { p.x += dx; p.y += dy; });
            if (item.x !== undefined) { item.x += dx; item.y += dy; }
            // Sync stroke
            this.syncStroke(item);
        }
        
        this.render();
        this.updateSelectBox();
    },
    
    // ==================== RESIZE HANDLES ====================
    setupResizeHandles() {
        document.querySelectorAll('.wb-resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', e => {
                e.stopPropagation();
                if (!this.selected) return;
                this.isResizing = true;
                this.resizeHandle = handle.dataset.handle;
                this.resizeStart = { x: e.clientX, y: e.clientY, bounds: this.getSelectedBounds() };
            });
        });
        
        window.addEventListener('mousemove', e => {
            if (this.isResizing) this.handleResize(e);
        });
        
        window.addEventListener('mouseup', () => {
            if (this.isResizing) {
                this.isResizing = false;
                this.resizeHandle = null;
                this.resizeStart = null;
                // Sync after resize
                if (this.selected?.type === 'token') this.syncToken(this.selected.item);
                if (this.selected?.type === 'stroke') this.syncStroke(this.selected.item);
            }
        });
    },
    
    handleResize(e) {
        if (!this.selected || !this.resizeStart) return;
        
        const dx = (e.clientX - this.resizeStart.x) / this.zoom;
        const dy = (e.clientY - this.resizeStart.y) / this.zoom;
        const h = this.resizeHandle;
        const { type, item } = this.selected;
        const orig = this.resizeStart.bounds;
        
        if (type === 'token') {
            // Token: resize = change size (keep center)
            let sizeDelta = 0;
            if (h.includes('e') || h.includes('s')) sizeDelta = Math.max(dx, dy);
            if (h.includes('w') || h.includes('n')) sizeDelta = -Math.min(dx, dy);
            item.size = Math.max(20, Math.min(200, orig.w + sizeDelta * 2));
        } 
        else if (type === 'image') {
            // Image: resize keeping aspect or free
            if (h.includes('e')) item.w = Math.max(30, orig.w + dx);
            if (h.includes('w')) { item.x = orig.x + dx; item.w = Math.max(30, orig.w - dx); }
            if (h.includes('s')) item.h = Math.max(30, orig.h + dy);
            if (h.includes('n')) { item.y = orig.y + dy; item.h = Math.max(30, orig.h - dy); }
        }
        // TODO: Add stroke scaling here if needed
        
        this.render();
        this.updateSelectBox();
    },
    
    // ==================== DRAWING ====================
    drawLivePen(p) {
        const ctx = this.layer === 'fog' ? this.fogCtx : this.mainCtx;
        ctx.strokeStyle = this.layer === 'fog' ? 'rgba(0,0,0,0.85)' : this.color;
        ctx.lineWidth = this.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (this.currentPath.length >= 2) {
            const prev = this.currentPath[this.currentPath.length - 2];
            ctx.beginPath();
            ctx.moveTo(prev.x * this.zoom + this.panX, prev.y * this.zoom + this.panY);
            ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY);
            ctx.stroke();
        }
    },
    
    eraseLive(p) {
        this.mainCtx.globalCompositeOperation = 'destination-out';
        this.mainCtx.beginPath();
        this.mainCtx.arc(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY, this.size * 2, 0, Math.PI * 2);
        this.mainCtx.fill();
        this.mainCtx.globalCompositeOperation = 'source-over';
    },
    
    addStroke(s) {
        if (this.historyIdx < this.history.length - 1) this.history = this.history.slice(0, this.historyIdx + 1);
        this.strokes.push(s);
        this.history.push({ type: 'stroke', data: s });
        this.historyIdx = this.history.length - 1;
        this.render();
    },
    
    finishPolygon() {
        if (this.polygonPoints.length < 3) { this.polygonPoints = []; this.renderUI(); return; }
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: this.layer, tool: 'polygon', color: this.color, size: this.size, fill: this.fill,
            points: [...this.polygonPoints], userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
        this.polygonPoints = [];
        this.renderUI();
    },
    
    // ==================== RENDER ====================
    render() {
        this.renderBg();
        this.renderMain();
        this.renderImages();
        this.renderTokens();
        this.renderFog();
        if (this.selected) this.updateSelectBox();
    },
    
    renderBg() {
        const ctx = this.bgCtx;
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
        if (this.bgImage && this.bgImage.complete)
            ctx.drawImage(this.bgImage, this.panX, this.panY, this.bgImage.width * this.zoom, this.bgImage.height * this.zoom);
    },
    
    renderMain() {
        const ctx = this.mainCtx;
        ctx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
        this.strokes.filter(s => s.layer === 'main').forEach(s => this.drawStroke(ctx, s));
    },
    
    renderImages() {
        const c = document.getElementById('imagesContainer');
        c.innerHTML = '';
        this.images.forEach((img, i) => {
            const el = document.createElement('div');
            const isSelected = this.selected?.type === 'image' && this.selected?.item === img;
            el.className = 'wb-image' + (isSelected ? ' selected' : '');
            el.style.left = (img.x * this.zoom + this.panX) + 'px';
            el.style.top = (img.y * this.zoom + this.panY) + 'px';
            el.style.width = (img.w * this.zoom) + 'px';
            el.style.height = (img.h * this.zoom) + 'px';
            el.innerHTML = `<img src="${img.src}">`;
            el.dataset.idx = i;
            el.onmousedown = e => {
                if (this.tool === 'select') {
                    e.stopPropagation();
                    this.select({ type: 'image', item: img, index: i });
                    this.isDragging = true;
                    this.lastDragPoint = this.getPoint(e);
                }
            };
            c.appendChild(el);
        });
    },
    
    renderTokens() {
        const c = document.getElementById('tokensContainer');
        c.innerHTML = '';
        this.tokens.forEach((t, i) => {
            const el = document.createElement('div');
            const isSelected = this.selected?.type === 'token' && this.selected?.item === t;
            el.className = 'wb-token' + (isSelected ? ' selected' : '');
            el.style.left = (t.x * this.zoom + this.panX - t.size / 2) + 'px';
            el.style.top = (t.y * this.zoom + this.panY - t.size / 2) + 'px';
            el.style.width = t.size + 'px';
            el.style.height = t.size + 'px';
            el.style.background = t.color;
            el.style.fontSize = (t.size * 0.4) + 'px';
            el.innerHTML = t.img ? `<img src="${t.img}">` : (t.label || t.name?.charAt(0) || '?');
            el.innerHTML += `<span class="wb-token__label">${t.name || ''}</span>`;
            el.dataset.idx = i;
            el.onmousedown = e => {
                e.stopPropagation();
                if (this.tool === 'select') {
                    this.select({ type: 'token', item: t, index: i });
                    this.isDragging = true;
                    this.lastDragPoint = this.getPoint(e);
                }
            };
            c.appendChild(el);
        });
    },
    
    renderFog() {
        const ctx = this.fogCtx;
        ctx.clearRect(0, 0, this.fogCanvas.width, this.fogCanvas.height);
        this.strokes.filter(s => s.layer === 'fog').forEach(s => this.drawStroke(ctx, s));
    },
    
    renderUI() {
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        
        // Shape preview
        if (this.isDrawing && this.startPoint && this.currentPath.length > 0) {
            const end = this.currentPath[this.currentPath.length - 1];
            this.drawShapePreview(ctx, this.startPoint, end);
        }
        
        // Polygon preview
        if (this.polygonPoints.length > 0) {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(this.polygonPoints[0].x * this.zoom + this.panX, this.polygonPoints[0].y * this.zoom + this.panY);
            this.polygonPoints.forEach(pt => ctx.lineTo(pt.x * this.zoom + this.panX, pt.y * this.zoom + this.panY));
            ctx.stroke();
            ctx.setLineDash([]);
            this.polygonPoints.forEach(pt => {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(pt.x * this.zoom + this.panX, pt.y * this.zoom + this.panY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    },
    
    drawStroke(ctx, s) {
        ctx.strokeStyle = s.color;
        ctx.fillStyle = s.color;
        ctx.lineWidth = s.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (s.tool === 'pen' || s.tool === 'eraser') {
            if (s.path && s.path.length > 1) {
                ctx.beginPath();
                ctx.moveTo(s.path[0].x * this.zoom + this.panX, s.path[0].y * this.zoom + this.panY);
                s.path.forEach(p => ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY));
                ctx.stroke();
            }
        } else if (s.tool === 'text') {
            ctx.font = ((s.size * 4 + 12) * this.zoom) + 'px sans-serif';
            ctx.fillText(s.text, s.start.x * this.zoom + this.panX, s.start.y * this.zoom + this.panY);
        } else if (s.tool === 'stamp') {
            ctx.font = (s.stampSize * this.zoom) + 'px sans-serif';
            ctx.fillText(s.stamp, s.x * this.zoom + this.panX, s.y * this.zoom + this.panY);
        } else if (s.tool === 'polygon' && s.points) {
            ctx.beginPath();
            ctx.moveTo(s.points[0].x * this.zoom + this.panX, s.points[0].y * this.zoom + this.panY);
            s.points.forEach(p => ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY));
            ctx.closePath();
            if (s.fill) ctx.fill();
            ctx.stroke();
        } else {
            this.drawShape(ctx, s);
        }
    },
    
    drawShape(ctx, s) {
        if (!s.start || !s.end) return;
        const sx = s.start.x * this.zoom + this.panX, sy = s.start.y * this.zoom + this.panY;
        const ex = s.end.x * this.zoom + this.panX, ey = s.end.y * this.zoom + this.panY;
        ctx.beginPath();
        switch (s.tool) {
            case 'line': ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); break;
            case 'rect':
                if (s.fill) ctx.fillRect(sx, sy, ex - sx, ey - sy);
                ctx.strokeRect(sx, sy, ex - sx, ey - sy); return;
            case 'circle':
                const rx = Math.abs(ex - sx) / 2, ry = Math.abs(ey - sy) / 2;
                ctx.ellipse(sx + (ex - sx) / 2, sy + (ey - sy) / 2, rx, ry, 0, 0, Math.PI * 2);
                if (s.fill) ctx.fill(); break;
            case 'arrow':
                ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
                const a = Math.atan2(ey - sy, ex - sx), hl = 15 * this.zoom;
                ctx.lineTo(ex - hl * Math.cos(a - Math.PI / 6), ey - hl * Math.sin(a - Math.PI / 6));
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - hl * Math.cos(a + Math.PI / 6), ey - hl * Math.sin(a + Math.PI / 6)); break;
        }
        ctx.stroke();
    },
    
    drawShapePreview(ctx, start, end) {
        ctx.strokeStyle = this.color;
        ctx.fillStyle = this.color + '40';
        ctx.lineWidth = this.size;
        ctx.setLineDash([5, 5]);
        const sx = start.x * this.zoom + this.panX, sy = start.y * this.zoom + this.panY;
        const ex = end.x * this.zoom + this.panX, ey = end.y * this.zoom + this.panY;
        ctx.beginPath();
        switch (this.tool) {
            case 'line': ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); break;
            case 'rect':
                if (this.fill) ctx.fillRect(sx, sy, ex - sx, ey - sy);
                ctx.strokeRect(sx, sy, ex - sx, ey - sy); ctx.setLineDash([]); return;
            case 'circle':
                const rx = Math.abs(ex - sx) / 2, ry = Math.abs(ey - sy) / 2;
                ctx.ellipse(sx + (ex - sx) / 2, sy + (ey - sy) / 2, rx, ry, 0, 0, Math.PI * 2);
                if (this.fill) ctx.fill(); break;
            case 'arrow':
                ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
                const a = Math.atan2(ey - sy, ex - sx);
                ctx.lineTo(ex - 15 * Math.cos(a - Math.PI / 6), ey - 15 * Math.sin(a - Math.PI / 6));
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - 15 * Math.cos(a + Math.PI / 6), ey - 15 * Math.sin(a + Math.PI / 6)); break;
        }
        ctx.stroke();
        ctx.setLineDash([]);
    },
    
    // ==================== TOOLS ====================
    showTextInput(p) {
        const inp = document.getElementById('textInput');
        inp.style.left = p.sx + 'px';
        inp.style.top = p.sy + 'px';
        inp.style.display = 'block';
        inp.style.color = this.color;
        inp.dataset.x = p.x;
        inp.dataset.y = p.y;
        inp.value = '';
        setTimeout(() => inp.focus(), 50);
    },
    
    placeText(text, x, y) {
        if (!text.trim()) return;
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: 'main', tool: 'text', color: this.color, size: this.size, text,
            start: { x: parseFloat(x), y: parseFloat(y) }, userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
    },
    
    createPing(sx, sy) {
        const ping = document.createElement('div');
        ping.className = 'wb-ping';
        ping.style.left = sx + 'px';
        ping.style.top = sy + 'px';
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'wb-ping__ring';
            ring.style.borderColor = this.userColor;
            ring.style.animationDelay = (i * 0.15) + 's';
            ping.appendChild(ring);
        }
        const dot = document.createElement('div');
        dot.className = 'wb-ping__dot';
        dot.style.background = this.userColor;
        ping.appendChild(dot);
        document.getElementById('canvasWrapper').appendChild(ping);
        this.syncPing(sx, sy);
        setTimeout(() => ping.remove(), 1500);
    },
    
    showRuler(start, end) {
        const dx = end.x - start.x, dy = end.y - start.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const grids = Math.round(dist / this.gridSize);
        const info = document.getElementById('rulerInfo');
        info.style.display = 'block';
        info.style.left = (end.sx + 15) + 'px';
        info.style.top = (end.sy - 15) + 'px';
        info.innerHTML = `<strong>${grids}</strong> Felder<br><span style="opacity:0.7;font-size:12px">${Math.round(dist)}px</span>`;
        
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(start.x * this.zoom + this.panX, start.y * this.zoom + this.panY);
        ctx.lineTo(end.x * this.zoom + this.panX, end.y * this.zoom + this.panY);
        ctx.stroke();
        ctx.setLineDash([]);
    },
    
    setupStamps() {
        const grid = document.getElementById('stampsGrid');
        this.stamps.forEach(st => {
            const btn = document.createElement('button');
            btn.className = 'wb-stamp';
            btn.textContent = st;
            btn.onclick = () => {
                document.querySelectorAll('.wb-stamp').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                this.selectedStamp = st;
                this.tool = 'stamp';
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                document.getElementById('stampsPanel').classList.remove('visible');
            };
            grid.appendChild(btn);
        });
    },
    
    placeStamp(p) {
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: 'main', tool: 'stamp', stamp: this.selectedStamp,
            x: p.x, y: p.y, stampSize: 40, userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
    },
    
    showTokenModal() {
        const picker = document.getElementById('tokenColorPicker');
        picker.innerHTML = '';
        ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280', this.userColor].forEach(c => {
            const btn = document.createElement('button');
            btn.style.cssText = `width:32px;height:32px;border-radius:50%;border:3px solid ${c === this.pendingTokenColor ? 'white' : 'transparent'};background:${c};cursor:pointer`;
            btn.onclick = () => {
                this.pendingTokenColor = c;
                picker.querySelectorAll('button').forEach(b => b.style.borderColor = 'transparent');
                btn.style.borderColor = 'white';
            };
            picker.appendChild(btn);
        });
        document.getElementById('tokenNameInput').value = '';
        document.getElementById('tokenOverlay').classList.add('visible');
    },
    
    createToken(name, color, x, y) {
        const t = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            x: x ?? (this.mainCanvas.width / 2 / this.zoom - this.panX / this.zoom),
            y: y ?? (this.mainCanvas.height / 2 / this.zoom - this.panY / this.zoom),
            size: 44, color: color || this.userColor,
            name: name || this.userName, label: (name || this.userName).charAt(0).toUpperCase(),
            userId: this.userId
        };
        this.tokens.push(t);
        this.syncToken(t);
        this.renderTokens();
        this.toast('Token: ' + t.name);
    },
    
    // ==================== UPLOADS ====================
    setupUploads() {
        document.getElementById('bgBtn').onclick = () => document.getElementById('bgOverlay').classList.add('visible');
        document.getElementById('bgSelectBtn').onclick = () => document.getElementById('bgFileInput').click();
        document.getElementById('bgFileInput').onchange = e => { if (e.target.files[0]) this.loadBg(e.target.files[0]); };
        document.getElementById('bgRemoveBtn').onclick = () => {
            this.bgImage = null; this.render();
            document.getElementById('bgOverlay').classList.remove('visible');
            this.toast('Hintergrund entfernt');
        };
        
        document.getElementById('imageBtn').onclick = () => document.getElementById('imageOverlay').classList.add('visible');
        document.getElementById('imageSelectBtn').onclick = () => document.getElementById('imageFileInput').click();
        document.getElementById('imageFileInput').onchange = e => { if (e.target.files[0]) this.loadImage(e.target.files[0]); };
        
        ['bgUploadBox', 'imageUploadBox'].forEach(id => {
            const box = document.getElementById(id);
            box.ondragover = e => { e.preventDefault(); box.classList.add('dragover'); };
            box.ondragleave = () => box.classList.remove('dragover');
            box.ondrop = e => {
                e.preventDefault(); box.classList.remove('dragover');
                if (e.dataTransfer.files[0]) {
                    if (id === 'bgUploadBox') this.loadBg(e.dataTransfer.files[0]);
                    else this.loadImage(e.dataTransfer.files[0]);
                }
            };
        });
    },
    
    loadBg(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                this.bgImage = img;
                this.render();
                document.getElementById('bgOverlay').classList.remove('visible');
                this.toast('Hintergrund geladen');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    loadImage(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                const maxW = 400, maxH = 400;
                let w = img.width, h = img.height;
                if (w > maxW) { h = h * maxW / w; w = maxW; }
                if (h > maxH) { w = w * maxH / h; h = maxH; }
                this.images.push({
                    id: Date.now(), src: e.target.result,
                    x: 100 - this.panX / this.zoom, y: 100 - this.panY / this.zoom, w, h
                });
                this.renderImages();
                document.getElementById('imageOverlay').classList.remove('visible');
                this.toast('Bild eingef√ºgt');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    // ==================== MODALS ====================
    setupModals() {
        const inp = document.getElementById('textInput');
        inp.onkeydown = e => {
            e.stopPropagation();
            if (e.key === 'Enter' && inp.value.trim()) { 
                this.handleTextInput(inp);
                inp.style.display = 'none'; 
            }
            if (e.key === 'Escape') { inp.style.display = 'none'; inp.dataset.strokeId = ''; }
        };
        inp.onblur = () => {
            setTimeout(() => {
                if (inp.style.display !== 'none' && inp.value.trim()) this.handleTextInput(inp);
                inp.style.display = 'none';
                inp.dataset.strokeId = '';
            }, 150);
        };
        
        document.getElementById('saveBtn').onclick = () => {
            document.getElementById('saveOverlay').classList.add('visible');
            document.getElementById('saveNameInput').focus();
        };
        document.getElementById('saveConfirmBtn').onclick = () => this.saveMap();
        document.getElementById('loadBtn').onclick = () => this.showLoadModal();
        document.getElementById('tokenCreateBtn').onclick = () => {
            const name = document.getElementById('tokenNameInput').value.trim() || 'Token';
            this.createToken(name, this.pendingTokenColor);
            document.getElementById('tokenOverlay').classList.remove('visible');
        };
    },
    
    handleTextInput(inp) {
        const strokeId = inp.dataset.strokeId;
        if (strokeId) {
            // Editing existing text
            const stroke = this.strokes.find(s => s.id === strokeId);
            if (stroke) {
                stroke.text = inp.value;
                this.syncStroke(stroke);
                this.render();
            }
        } else {
            // New text
            this.placeText(inp.value, inp.dataset.x, inp.dataset.y);
        }
        inp.dataset.strokeId = '';
    },
    
    saveMap() {
        const name = document.getElementById('saveNameInput').value.trim() || 'Map ' + new Date().toLocaleDateString();
        const data = { name, date: Date.now(), strokes: this.strokes, tokens: this.tokens, images: this.images, fogAreas: this.fogAreas };
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        saves.unshift(data);
        if (saves.length > 20) saves.pop();
        localStorage.setItem('rift_wb_saves', JSON.stringify(saves));
        document.getElementById('saveOverlay').classList.remove('visible');
        this.toast('Gespeichert: ' + name);
    },
    
    showLoadModal() {
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        const list = document.getElementById('savedList');
        if (saves.length === 0) {
            list.innerHTML = '<p style="color:rgba(255,255,255,0.5);text-align:center;padding:30px">Keine Maps</p>';
        } else {
            list.innerHTML = saves.map((s, i) => `<div class="wb-save-item" onclick="WB.loadMap(${i})"><div><div class="wb-save-item__name">${s.name}</div><div class="wb-save-item__date">${new Date(s.date).toLocaleString()}</div></div><button class="wb-save-item__delete" onclick="event.stopPropagation();WB.deleteMap(${i})">L√∂schen</button></div>`).join('');
        }
        document.getElementById('loadOverlay').classList.add('visible');
    },
    
    loadMap(idx) {
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        const save = saves[idx];
        if (!save) return;
        this.strokes = save.strokes || [];
        this.tokens = save.tokens || [];
        this.images = save.images || [];
        this.fogAreas = save.fogAreas || [];
        this.render();
        document.getElementById('loadOverlay').classList.remove('visible');
        this.toast('Geladen: ' + save.name);
    },
    
    deleteMap(idx) {
        if (!confirm('L√∂schen?')) return;
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        saves.splice(idx, 1);
        localStorage.setItem('rift_wb_saves', JSON.stringify(saves));
        this.showLoadModal();
    },
    
    // ==================== CONTEXT MENU ====================
    setupContextMenu() {
        document.querySelectorAll('.wb-context-item').forEach(item => {
            item.onclick = () => {
                const action = item.dataset.action;
                if (action === 'delete') this.deleteSelected();
                else if (action === 'duplicate') this.duplicateSelected();
                else if (action === 'front') this.moveToFront();
                else if (action === 'back') this.moveToBack();
                document.getElementById('contextMenu').classList.remove('visible');
            };
        });
    },
    
    deleteSelected() {
        if (!this.selected) return;
        const { type, item, index } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) this.tokens.splice(idx, 1);
            // Delete from Firebase
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + item.id).remove();
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) this.images.splice(idx, 1);
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) this.strokes.splice(idx, 1);
            // Delete from Firebase
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + item.id).remove();
        }
        
        this.deselect();
        this.render();
        this.toast('Gel√∂scht');
    },
    
    duplicateSelected() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        const newId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        if (type === 'token') {
            const copy = { ...item, id: newId, x: item.x + 50, y: item.y + 50 };
            this.tokens.push(copy);
            this.syncToken(copy);
        }
        if (type === 'image') {
            const copy = { ...item, id: Date.now(), x: item.x + 50, y: item.y + 50 };
            this.images.push(copy);
        }
        if (type === 'stroke') {
            const copy = JSON.parse(JSON.stringify(item));
            copy.id = newId;
            // Offset the duplicate
            if (copy.start) { copy.start.x += 50; copy.start.y += 50; }
            if (copy.end) { copy.end.x += 50; copy.end.y += 50; }
            if (copy.path) copy.path.forEach(p => { p.x += 50; p.y += 50; });
            if (copy.points) copy.points.forEach(p => { p.x += 50; p.y += 50; });
            if (copy.x !== undefined) { copy.x += 50; copy.y += 50; }
            this.strokes.push(copy);
            this.syncStroke(copy);
        }
        
        this.render();
        this.toast('Dupliziert');
    },
    
    moveToFront() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) { this.tokens.splice(idx, 1); this.tokens.push(item); }
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) { this.images.splice(idx, 1); this.images.push(item); }
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) { this.strokes.splice(idx, 1); this.strokes.push(item); }
        }
        this.render();
    },
    
    moveToBack() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) { this.tokens.splice(idx, 1); this.tokens.unshift(item); }
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) { this.images.splice(idx, 1); this.images.unshift(item); }
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) { this.strokes.splice(idx, 1); this.strokes.unshift(item); }
        }
        this.render();
    },
    
    // ==================== HISTORY ====================
    undo() {
        if (this.historyIdx < 0) return;
        const action = this.history[this.historyIdx];
        if (action.type === 'stroke') this.strokes = this.strokes.filter(s => s.id !== action.data.id);
        this.historyIdx--;
        this.render();
        this.toast('R√ºckg√§ngig');
    },
    
    redo() {
        if (this.historyIdx >= this.history.length - 1) return;
        this.historyIdx++;
        const action = this.history[this.historyIdx];
        if (action.type === 'stroke') this.strokes.push(action.data);
        this.render();
        this.toast('Wiederholt');
    },
    
    clearAll() {
        this.strokes = []; this.images = []; this.tokens = []; this.fogAreas = [];
        this.bgImage = null; this.history = []; this.historyIdx = -1;
        this.deselect();
        this.render();
        this.toast('Alles gel√∂scht');
    },
    
    exportPNG() {
        const canvas = document.createElement('canvas');
        canvas.width = this.bgCanvas.width;
        canvas.height = this.bgCanvas.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(this.bgCanvas, 0, 0);
        ctx.drawImage(this.mainCanvas, 0, 0);
        // Draw images
        this.images.forEach(img => {
            const el = new Image();
            el.src = img.src;
            ctx.drawImage(el, img.x * this.zoom + this.panX, img.y * this.zoom + this.panY, img.w * this.zoom, img.h * this.zoom);
        });
        // Draw tokens
        this.tokens.forEach(t => {
            ctx.fillStyle = t.color;
            ctx.beginPath();
            ctx.arc(t.x * this.zoom + this.panX, t.y * this.zoom + this.panY, t.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.font = 'bold ' + (t.size * 0.4) + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.label, t.x * this.zoom + this.panX, t.y * this.zoom + this.panY);
        });
        const link = document.createElement('a');
        link.download = 'whiteboard-' + Date.now() + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        this.toast('PNG exportiert');
    },
    
    // ==================== KEYBOARD ====================
    setupKeyboard() {
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); this.undo(); }
            if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); this.redo(); }
            
            const toolMap = { p: 'pen', l: 'line', r: 'rect', c: 'circle', a: 'arrow', t: 'text', e: 'eraser', v: 'select', m: 'ruler' };
            if (toolMap[e.key.toLowerCase()]) document.querySelector(`[data-tool="${toolMap[e.key.toLowerCase()]}"]`)?.click();
            
            if (e.shiftKey && e.key.toLowerCase() === 'p') document.querySelector('[data-tool="polygon"]')?.click();
            if (e.key.toLowerCase() === 'g') document.getElementById('gridToggle').click();
            
            if ((e.key === 'Delete' || e.key === 'Backspace') && this.selected) this.deleteSelected();
            
            if (e.key === 'Escape') {
                this.deselect();
                this.polygonPoints = [];
                document.querySelectorAll('.wb-overlay').forEach(o => o.classList.remove('visible'));
                document.getElementById('stampsPanel').classList.remove('visible');
                document.getElementById('contextMenu').classList.remove('visible');
                this.renderUI();
            }
        });
    },
    
    // ==================== FIREBASE ====================
    async connectFirebase() {
        try {
            this.db = firebase.database();
            const snap = await this.db.ref('whiteboard/' + this.roomCode).once('value');
            const data = snap.val();
            if (data) {
                this.strokes = data.strokes ? Object.values(data.strokes) : [];
                this.tokens = data.tokens ? Object.values(data.tokens) : [];
                this.render();
            }
            
            this.db.ref('whiteboard/' + this.roomCode + '/strokes').on('child_added', snap => {
                const s = snap.val();
                if (s && s.userId !== this.userId && !this.strokes.find(x => x.id === s.id)) {
                    this.strokes.push(s);
                    this.render();
                }
            });
            
            this.db.ref('whiteboard/' + this.roomCode + '/tokens').on('value', snap => {
                const tokens = snap.val();
                if (tokens) {
                    Object.values(tokens).forEach(rt => {
                        const existing = this.tokens.find(t => t.id === rt.id);
                        if (existing) { if (rt.userId !== this.userId) Object.assign(existing, rt); }
                        else this.tokens.push(rt);
                    });
                    this.renderTokens();
                }
            });
            
            this.db.ref('whiteboard/' + this.roomCode + '/pings').on('child_added', snap => {
                const p = snap.val();
                if (p && p.userId !== this.userId && Date.now() - p.ts < 3000) this.showRemotePing(p);
            });
            
            console.log('[WB] Firebase connected');
        } catch (err) {
            console.error('[WB] Firebase error:', err);
        }
    },
    
    syncStroke(s) { if (!this.db || !this.roomCode) return; this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + s.id).set(s); },
    syncToken(t) { if (!this.db || !this.roomCode) return; this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + t.id).set(t); },
    syncPing(sx, sy) {
        if (!this.db || !this.roomCode) return;
        const id = Date.now() + '-' + this.userId;
        this.db.ref('whiteboard/' + this.roomCode + '/pings/' + id).set({ sx, sy, color: this.userColor, userId: this.userId, ts: Date.now() });
        setTimeout(() => this.db.ref('whiteboard/' + this.roomCode + '/pings/' + id).remove(), 3000);
    },
    
    showRemotePing(p) {
        const ping = document.createElement('div');
        ping.className = 'wb-ping';
        ping.style.left = p.sx + 'px';
        ping.style.top = p.sy + 'px';
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'wb-ping__ring';
            ring.style.borderColor = p.color;
            ring.style.animationDelay = (i * 0.15) + 's';
            ping.appendChild(ring);
        }
        const dot = document.createElement('div');
        dot.className = 'wb-ping__dot';
        dot.style.background = p.color;
        ping.appendChild(dot);
        document.getElementById('canvasWrapper').appendChild(ping);
        setTimeout(() => ping.remove(), 1500);
    },
    
    toast(msg) {
        const t = document.getElementById('wbToast');
        t.textContent = msg;
        t.classList.add('visible');
        setTimeout(() => t.classList.remove('visible'), 2000);
    }
};

function initWB() {
    if (document.querySelector('.sidebar') && document.querySelector('.topbar')) setTimeout(() => WB.init(), 100);
    else setTimeout(initWB, 100);
}
document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', () => setTimeout(initWB, 200)) : setTimeout(initWB, 200);
    </script>
</body>
</html>
