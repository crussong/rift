<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/icon_rift_r.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <meta name="view-transition" content="same-origin">
    <title>RIFT ‚Äì Whiteboard</title>
    
    <link rel="stylesheet" href="assets/css/core.css">
    <link rel="stylesheet" href="assets/css/ui.css">
    <link rel="stylesheet" href="assets/css/dock.css">
    <link rel="stylesheet" href="assets/css/hub.css">
    <link rel="stylesheet" href="assets/css/settings.css">
    
    <style>
        .footer { display: none !important; }
        
        /* Whiteboard braucht VOLLE BREITE - override unified layout */
        .main--fullwidth,
        .main__content--fullwidth {
            max-width: none !important;
            padding: 0 !important;
            width: 100% !important;
        }
        
        .whiteboard-page { 
            min-height: calc(100vh - var(--topnav-total-height, 121px) - var(--dock-height, 72px)); 
            padding: 0; 
            display: flex; 
            flex-direction: column;
            width: 100%;
        }
        .whiteboard-container { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            background: #0a0a0a; 
            margin: 12px; 
            border-radius: 16px; 
            border: 1px solid rgba(255,255,255,0.08); 
            overflow: hidden; 
            max-height: calc(100vh - var(--topnav-total-height, 121px) - var(--dock-height, 72px) - 24px); 
        }
        
        .wb-toolbar { display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(22,22,22,0.98); border-bottom: 1px solid rgba(255,255,255,0.08); flex-wrap: wrap; z-index: 100; flex-shrink: 0; }
        .wb-toolbar__group { display: flex; align-items: center; gap: 2px; padding: 4px; background: rgba(255,255,255,0.03); border-radius: 8px; }
        .wb-toolbar__divider { width: 1px; height: 28px; background: rgba(255,255,255,0.1); margin: 0 4px; }
        
        .wb-btn { width: 36px; height: 36px; border: none; background: transparent; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; color: rgba(255,255,255,0.6); }
        .wb-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-btn.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-btn svg { width: 18px; height: 18px; }
        .wb-btn--danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        
        .wb-color-btn { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.15s; }
        .wb-color-btn:hover { transform: scale(1.15); }
        .wb-color-btn.active { border-color: white; box-shadow: 0 0 0 2px rgba(255,255,255,0.3); }
        
        .wb-size-btn { width: 28px; height: 28px; border: none; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .wb-size-btn:hover { background: rgba(255,255,255,0.1); }
        .wb-size-btn.active { background: var(--accent, #8b5cf6); }
        .wb-size-btn__dot { background: white; border-radius: 50%; }
        
        .wb-toggle { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; font-size: 11px; color: rgba(255,255,255,0.6); border: none; transition: all 0.15s; }
        .wb-toggle:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-toggle.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-toggle__dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .wb-toggle.active .wb-toggle__dot { box-shadow: 0 0 6px currentColor; }
        
        .wb-layers { display: flex; gap: 2px; background: rgba(0,0,0,0.3); padding: 3px; border-radius: 8px; }
        .wb-layer-tab { padding: 6px 12px; border: none; background: transparent; color: rgba(255,255,255,0.5); font-size: 11px; font-weight: 500; border-radius: 6px; cursor: pointer; transition: all 0.15s; }
        .wb-layer-tab:hover { color: white; background: rgba(255,255,255,0.1); }
        .wb-layer-tab.active { background: var(--accent, #8b5cf6); color: white; }
        .wb-layer-tab--fog { color: rgba(239,68,68,0.7); }
        .wb-layer-tab--fog.active { background: #ef4444; }
        
        .wb-canvas-wrapper { flex: 1; position: relative; overflow: hidden; cursor: crosshair; min-height: 0; background: #0a0a0a; }
        .wb-canvas-wrapper.tool-select { cursor: default; }
        .wb-canvas-wrapper.tool-eraser { cursor: cell; }
        .wb-canvas-wrapper.tool-text { cursor: text; }
        .wb-canvas-wrapper.panning { cursor: grab; }
        
        /* Selection Box & Resize Handles */
        .wb-select-box { position: absolute; border: 2px solid #fbbf24; background: rgba(251,191,36,0.05); pointer-events: none; z-index: 200; display: none; }
        .wb-select-box.visible { display: block; }
        .wb-resize-handle { position: absolute; width: 12px; height: 12px; background: #fbbf24; border: 2px solid white; border-radius: 2px; pointer-events: auto; z-index: 201; }
        .wb-resize-handle--nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .wb-resize-handle--ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .wb-resize-handle--sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .wb-resize-handle--se { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .wb-resize-handle--n { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .wb-resize-handle--s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .wb-resize-handle--w { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .wb-resize-handle--e { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }
        
        /* Format Toolbar (appears above selected text/stroke) */
        .wb-format-bar { position: absolute; display: none; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 4px 8px; gap: 4px; z-index: 210; align-items: center; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
        .wb-format-bar.visible { display: flex; }
        .wb-format-bar__btn { width: 28px; height: 28px; border: none; background: transparent; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.7); font-size: 12px; }
        .wb-format-bar__btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-format-bar__btn.active { background: var(--accent); color: white; }
        .wb-format-bar__color { width: 20px; height: 20px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); cursor: pointer; }
        .wb-format-bar__sep { width: 1px; height: 20px; background: rgba(255,255,255,0.15); margin: 0 4px; }
        
        /* Draggable Image */
        .wb-image { position: absolute; left: 0; top: 0; cursor: move; z-index: 45; user-select: none; -webkit-user-drag: none; will-change: transform; }
        .wb-image.selected { outline: 3px solid #fbbf24; outline-offset: 2px; }
        .wb-image img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; -webkit-user-drag: none; }
        
        .wb-canvas { position: absolute; top: 0; left: 0; touch-action: none; will-change: contents; }
        #bgCanvas { z-index: 1; }
        #mainCanvas { z-index: 2; }
        #fogCanvas { z-index: 4; }
        #uiCanvas { z-index: 5; }
        
        #wbGrid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; background-image: linear-gradient(rgba(255,255,255,0.12) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.12) 1px, transparent 1px); background-size: 70px 70px; z-index: 10; transition: opacity 0.2s, background-position 0.05s ease-out; will-change: background-position, background-size; }
        #wbGrid.visible { opacity: 0.5; }
        
        #imagesContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; }
        #imagesContainer .wb-image { pointer-events: auto; }
        #tokensContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        #tokensContainer .wb-token { pointer-events: auto; }
        
        .wb-text-input { position: fixed; background: rgba(0,0,0,0.95); border: 2px solid var(--accent, #8b5cf6); border-radius: 8px; padding: 10px 14px; color: white; font-size: 18px; min-width: 200px; outline: none; z-index: 1000; display: none; }
        
        .wb-zoom-controls { position: absolute; bottom: 16px; right: 16px; display: flex; flex-direction: column; gap: 4px; background: rgba(22,22,22,0.95); border-radius: 10px; padding: 6px; border: 1px solid rgba(255,255,255,0.1); z-index: 100; }
        .wb-zoom-btn { width: 32px; height: 32px; border: none; background: transparent; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.6); }
        .wb-zoom-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-zoom-level { text-align: center; font-size: 10px; color: rgba(255,255,255,0.5); padding: 2px 0; }
        
        .wb-ping { position: absolute; pointer-events: none; z-index: 200; }
        .wb-ping__ring { position: absolute; border: 3px solid; border-radius: 50%; animation: ping-expand 1s ease-out forwards; }
        @keyframes ping-expand { 0% { width: 0; height: 0; opacity: 1; transform: translate(-50%, -50%); } 100% { width: 100px; height: 100px; opacity: 0; transform: translate(-50%, -50%); } }
        .wb-ping__dot { position: absolute; width: 12px; height: 12px; border-radius: 50%; transform: translate(-50%, -50%); animation: ping-pulse 1s ease-out forwards; }
        @keyframes ping-pulse { 0%, 50% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } }
        
        .wb-ruler-info { position: absolute; background: rgba(0,0,0,0.9); color: #fbbf24; padding: 8px 14px; border-radius: 8px; font-size: 14px; font-weight: 600; pointer-events: none; z-index: 150; display: none; border: 2px solid #fbbf24; }
        
        .wb-token { position: absolute; left: 0; top: 0; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 12px rgba(0,0,0,0.5); cursor: move; display: flex; align-items: center; justify-content: center; font-weight: 700; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8); user-select: none; -webkit-user-drag: none; z-index: 50; will-change: transform; }
        .wb-token:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token.selected { border-color: #fbbf24; box-shadow: 0 0 0 4px rgba(251,191,36,0.4), 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token.dead { opacity: 0.5; filter: grayscale(80%); }
        .wb-token.active-turn { box-shadow: 0 0 0 4px rgba(34,197,94,0.6), 0 0 20px rgba(34,197,94,0.4), 0 4px 20px rgba(0,0,0,0.6); }
        .wb-token img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; pointer-events: none; -webkit-user-drag: none; }
        .wb-token__label { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 2px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; pointer-events: none; }
        .wb-token__hp { position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); width: 80%; height: 6px; background: rgba(0,0,0,0.6); border-radius: 3px; overflow: hidden; pointer-events: none; }
        .wb-token__hp-fill { height: 100%; background: linear-gradient(90deg, #22c55e, #4ade80); border-radius: 3px; transition: width 0.3s ease; }
        .wb-token__hp-fill.low { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
        .wb-token__hp-fill.critical { background: linear-gradient(90deg, #ef4444, #f87171); }
        .wb-token__initiative { position: absolute; top: -8px; right: -8px; width: 22px; height: 22px; background: #1e1e1e; border: 2px solid #8b5cf6; border-radius: 50%; font-size: 11px; font-weight: 700; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        .wb-token__status { position: absolute; top: -6px; left: -6px; display: flex; gap: 2px; pointer-events: none; }
        .wb-token__status-icon { width: 18px; height: 18px; background: rgba(0,0,0,0.8); border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.2); }
        
        .wb-stamps-panel { position: absolute; top: 60px; left: 16px; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px; z-index: 100; display: none; max-width: 260px; }
        .wb-stamps-panel.visible { display: block; }
        .wb-stamps-panel__title { font-size: 11px; font-weight: 600; color: rgba(255,255,255,0.5); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .wb-stamps-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; }
        .wb-stamp { width: 34px; height: 34px; border: none; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; font-size: 18px; transition: all 0.15s; }
        .wb-stamp:hover { background: rgba(255,255,255,0.15); transform: scale(1.1); }
        .wb-stamp.active { background: var(--accent); }
        
        .wb-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2000; }
        .wb-overlay.visible { display: flex; }
        .wb-upload-box { background: #1a1a1a; border: 2px dashed rgba(139,92,246,0.5); border-radius: 16px; padding: 48px; text-align: center; max-width: 90%; transition: all 0.2s; }
        .wb-upload-box.dragover { border-color: #8b5cf6; background: rgba(139,92,246,0.1); transform: scale(1.02); }
        .wb-upload-box svg { width: 56px; height: 56px; color: rgba(255,255,255,0.3); margin-bottom: 16px; }
        .wb-upload-box h3 { color: white; font-size: 18px; margin-bottom: 8px; }
        .wb-upload-box p { color: rgba(255,255,255,0.5); font-size: 13px; margin-bottom: 20px; }
        .wb-upload-actions { display: flex; gap: 12px; justify-content: center; }
        .wb-upload-btn { background: var(--accent, #8b5cf6); color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; }
        .wb-upload-btn:hover { filter: brightness(1.1); }
        .wb-upload-btn--secondary { background: rgba(255,255,255,0.1); }
        .wb-overlay-close { position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border: none; border-radius: 50%; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        
        .wb-modal__content { background: #1a1a1a; border-radius: 16px; padding: 24px; min-width: 380px; max-width: 90%; border: 1px solid rgba(255,255,255,0.1); }
        .wb-modal__title { font-size: 18px; font-weight: 600; color: white; margin-bottom: 16px; }
        .wb-modal__input { width: 100%; padding: 12px 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 14px; margin-bottom: 16px; box-sizing: border-box; }
        .wb-modal__input:focus { outline: none; border-color: var(--accent); }
        
        /* Grid Settings */
        .wb-grid-preset { padding: 8px 14px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; color: white; font-size: 13px; cursor: pointer; transition: all 0.15s; }
        .wb-grid-preset:hover { background: rgba(255,255,255,0.15); }
        .wb-grid-preset.active { background: var(--accent); border-color: var(--accent); }
        .wb-grid-color { width: 28px; height: 28px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.15s; }
        .wb-grid-color:hover { transform: scale(1.1); }
        .wb-grid-color.active { border-color: white; box-shadow: 0 0 0 2px var(--accent); }
        .wb-modal__actions { display: flex; gap: 12px; justify-content: flex-end; }
        .wb-save-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: background 0.15s; }
        .wb-save-item:hover { background: rgba(255,255,255,0.1); }
        .wb-save-item__name { font-weight: 600; color: white; }
        .wb-save-item__date { font-size: 12px; color: rgba(255,255,255,0.5); }
        .wb-save-item__delete { background: rgba(239,68,68,0.2); border: none; color: #ef4444; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        
        .wb-context-menu { position: fixed; background: rgba(22,22,22,0.98); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 6px; z-index: 3000; display: none; min-width: 150px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
        .wb-context-menu.visible { display: block; }
        .wb-context-item { display: flex; align-items: center; gap: 10px; padding: 10px 14px; border: none; background: transparent; color: rgba(255,255,255,0.8); font-size: 13px; width: 100%; text-align: left; cursor: pointer; border-radius: 6px; }
        .wb-context-item:hover { background: rgba(255,255,255,0.1); color: white; }
        .wb-context-item--danger:hover { background: rgba(239,68,68,0.2); color: #ef4444; }
        .wb-context-item svg { width: 16px; height: 16px; opacity: 0.7; }
        .wb-context-divider { height: 1px; background: rgba(255,255,255,0.1); margin: 4px 0; }
        
        .wb-toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(100px); background: rgba(22,22,22,0.95); border: 1px solid rgba(255,255,255,0.1); padding: 12px 24px; border-radius: 12px; color: white; font-size: 14px; z-index: 3000; opacity: 0; transition: all 0.3s; pointer-events: none; }
        .wb-toast.visible { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        /* Initiative Panel */
        .wb-initiative-panel { position: absolute; top: 70px; right: 16px; background: rgba(22,22,22,0.95); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px; z-index: 100; min-width: 200px; max-height: 60vh; overflow-y: auto; display: none; }
        .wb-initiative-panel.visible { display: block; }
        .wb-initiative-panel__header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .wb-initiative-panel__title { font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 0.5px; }
        .wb-initiative-panel__controls { display: flex; gap: 6px; }
        .wb-initiative-panel__btn { width: 28px; height: 28px; background: rgba(255,255,255,0.08); border: none; border-radius: 6px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .wb-initiative-panel__btn:hover { background: rgba(255,255,255,0.15); }
        .wb-initiative-panel__btn.active { background: var(--accent); }
        .wb-initiative-item { display: flex; align-items: center; gap: 10px; padding: 8px 10px; border-radius: 8px; cursor: pointer; transition: background 0.15s; margin-bottom: 4px; }
        .wb-initiative-item:hover { background: rgba(255,255,255,0.08); }
        .wb-initiative-item.active { background: rgba(34,197,94,0.2); border: 1px solid rgba(34,197,94,0.4); }
        .wb-initiative-item.dead { opacity: 0.5; }
        .wb-initiative-item__portrait { width: 32px; height: 32px; border-radius: 50%; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; flex-shrink: 0; overflow: hidden; }
        .wb-initiative-item__portrait img { width: 100%; height: 100%; object-fit: cover; }
        .wb-initiative-item__info { flex: 1; min-width: 0; }
        .wb-initiative-item__name { font-size: 13px; font-weight: 500; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .wb-initiative-item__hp { font-size: 11px; color: rgba(255,255,255,0.5); }
        .wb-initiative-item__init { width: 28px; height: 28px; background: rgba(139,92,246,0.3); border-radius: 6px; font-size: 12px; font-weight: 700; color: white; display: flex; align-items: center; justify-content: center; }
        .wb-initiative-item__init input { width: 100%; height: 100%; background: transparent; border: none; color: white; font-size: 12px; font-weight: 700; text-align: center; }
        
        /* Token Edit Modal */
        .wb-token-edit { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        .wb-token-edit__field { display: flex; flex-direction: column; gap: 4px; }
        .wb-token-edit__label { font-size: 11px; color: rgba(255,255,255,0.5); text-transform: uppercase; }
        .wb-token-edit__input { padding: 10px 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: white; font-size: 14px; }
        .wb-token-edit__input:focus { outline: none; border-color: var(--accent); }
        .wb-size-preset { padding: 8px 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; color: white; font-size: 12px; cursor: pointer; }
        .wb-size-preset:hover { background: rgba(255,255,255,0.15); }
        .wb-size-preset.active { background: var(--accent); border-color: var(--accent); }
        .wb-status-grid { display: flex; flex-wrap: wrap; gap: 6px; }
        .wb-status-btn { width: 32px; height: 32px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; font-size: 16px; cursor: pointer; }
        .wb-status-btn:hover { background: rgba(255,255,255,0.15); }
        .wb-status-btn.active { background: var(--accent); border-color: var(--accent); }
        
        @media (max-width: 768px) {
            .wb-toolbar { padding: 6px 8px; gap: 4px; }
            .wb-toolbar__group { gap: 1px; padding: 2px; }
            .wb-btn { width: 32px; height: 32px; }
            .wb-btn svg { width: 16px; height: 16px; }
            .wb-toolbar__divider { display: none; }
            .wb-color-btn { width: 20px; height: 20px; }
            .wb-toggle { padding: 4px 8px; font-size: 10px; }
        }
    </style>

    <!-- Auth Guard: Hide until authenticated -->
    <style>
        body:not(.auth-ready) .app { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) .sheet-container { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) main { opacity: 0; pointer-events: none; }
        body.auth-ready .app { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready .sheet-container { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready main { opacity: 1; transition: opacity 0.15s ease; }
    </style>
</head>
<body>
    <!-- Unified Layout Placeholders -->
    <div id="topnav-placeholder"></div>
    <div id="meganav-placeholder"></div>
    
    <div class="app">
        <main class="main main--hub main--fullwidth">
            <div class="main__content main__content--fullwidth">
                <div class="whiteboard-page">
                <div class="whiteboard-container">
                    <div class="wb-toolbar">
                        <div class="wb-layers">
                            <button class="wb-layer-tab active" data-layer="main">Zeichnen</button>
                            <button class="wb-layer-tab" data-layer="token">Token</button>
                            <button class="wb-layer-tab wb-layer-tab--fog" data-layer="fog" id="fogTab">Nebel</button>
                            <button class="wb-btn" id="fogRevealBtn" title="Nebel aufdecken (nur Radierer im Nebel-Modus)" style="display:none;background:rgba(34,197,94,0.3)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group" id="drawTools">
                            <button class="wb-btn active" data-tool="pen" title="Stift (P)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg></button>
                            <button class="wb-btn" data-tool="line" title="Linie (L)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg></button>
                            <button class="wb-btn" data-tool="rect" title="Rechteck (R)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
                            <button class="wb-btn" data-tool="circle" title="Kreis (C)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg></button>
                            <button class="wb-btn" data-tool="arrow" title="Pfeil (A)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="10 5 19 5 19 14"/></svg></button>
                            <button class="wb-btn" data-tool="polygon" title="Polygon (Shift+P)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5"/></svg></button>
                            <button class="wb-btn" data-tool="text" title="Text (T)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
                            <button class="wb-btn" data-tool="eraser" title="Radierer (E)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 3a2 2 0 012.8 0L21 7.8a2 2 0 010 2.8L11.8 20"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" data-tool="select" title="Ausw√§hlen/Verschieben (V)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-6 2-2 6z"/><path d="M14 14l5 5"/></svg></button>
                            <button class="wb-btn" data-tool="ruler" title="Ma√üband (M)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0z"/><path d="M14 8l-2 2M17 11l-2 2M8 5l-2 2"/></svg></button>
                            <button class="wb-btn" data-tool="ping" title="Ping"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="8" stroke-dasharray="4 4"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" id="imageBtn" title="Bild einf√ºgen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg></button>
                            <button class="wb-btn" id="stampBtn" title="Sticker"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg></button>
                            <button class="wb-btn" id="tokenBtn" title="Token"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 1 0-16 0"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group" id="colorPalette">
                            <button class="wb-color-btn active" data-color="#ffffff" style="background:#ffffff"></button>
                            <button class="wb-color-btn" data-color="#ef4444" style="background:#ef4444"></button>
                            <button class="wb-color-btn" data-color="#f97316" style="background:#f97316"></button>
                            <button class="wb-color-btn" data-color="#eab308" style="background:#eab308"></button>
                            <button class="wb-color-btn" data-color="#22c55e" style="background:#22c55e"></button>
                            <button class="wb-color-btn" data-color="#3b82f6" style="background:#3b82f6"></button>
                            <button class="wb-color-btn" data-color="#8b5cf6" style="background:#8b5cf6"></button>
                            <button class="wb-color-btn" data-color="#ec4899" style="background:#ec4899"></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-size-btn" data-size="2"><span class="wb-size-btn__dot" style="width:4px;height:4px"></span></button>
                            <button class="wb-size-btn active" data-size="4"><span class="wb-size-btn__dot" style="width:8px;height:8px"></span></button>
                            <button class="wb-size-btn" data-size="8"><span class="wb-size-btn__dot" style="width:12px;height:12px"></span></button>
                            <button class="wb-size-btn" data-size="16"><span class="wb-size-btn__dot" style="width:16px;height:16px"></span></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <button class="wb-toggle" id="fillToggle"><span class="wb-toggle__dot"></span>F√ºllen</button>
                        <button class="wb-toggle" id="snapToggle"><span class="wb-toggle__dot"></span>Snap</button>
                        <button class="wb-toggle" id="gridToggle"><span class="wb-toggle__dot"></span>Raster</button>
                        <button class="wb-btn" id="gridSettingsBtn" title="Raster-Einstellungen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg></button>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" id="undoBtn" title="R√ºckg√§ngig"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M3 13a9 9 0 1 0 3-7.7L3 7"/></svg></button>
                            <button class="wb-btn" id="redoBtn" title="Wiederholen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 7v6h-6"/><path d="M21 13a9 9 0 1 1-3-7.7L21 7"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group">
                            <button class="wb-btn" id="saveBtn" title="Speichern"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></button>
                            <button class="wb-btn" id="loadBtn" title="Laden"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg></button>
                            <button class="wb-btn" id="bgBtn" title="Hintergrund"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/><path d="M21 15l-5-5L5 21"/></svg></button>
                            <button class="wb-btn" id="exportBtn" title="Export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
                        </div>
                        <div class="wb-toolbar__divider"></div>
                        <div class="wb-toolbar__group" id="gmActions" style="display:none">
                            <button class="wb-btn" id="initiativeBtn" title="Initiative Tracker"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"/></svg></button>
                            <button class="wb-btn wb-btn--danger" id="clearBtn" title="L√∂schen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
                        </div>
                    </div>
                    <div class="wb-canvas-wrapper" id="canvasWrapper">
                        <canvas class="wb-canvas" id="bgCanvas"></canvas>
                        <canvas class="wb-canvas" id="mainCanvas"></canvas>
                        <canvas class="wb-canvas" id="fogCanvas"></canvas>
                        <canvas class="wb-canvas" id="uiCanvas"></canvas>
                        <div id="wbGrid"></div>
                        <div id="imagesContainer"></div>
                        <div id="tokensContainer"></div>
                        <!-- Selection Box with Resize Handles -->
                        <div class="wb-select-box" id="selectBox">
                            <div class="wb-resize-handle wb-resize-handle--nw" data-handle="nw"></div>
                            <div class="wb-resize-handle wb-resize-handle--ne" data-handle="ne"></div>
                            <div class="wb-resize-handle wb-resize-handle--sw" data-handle="sw"></div>
                            <div class="wb-resize-handle wb-resize-handle--se" data-handle="se"></div>
                            <div class="wb-resize-handle wb-resize-handle--n" data-handle="n"></div>
                            <div class="wb-resize-handle wb-resize-handle--s" data-handle="s"></div>
                            <div class="wb-resize-handle wb-resize-handle--w" data-handle="w"></div>
                            <div class="wb-resize-handle wb-resize-handle--e" data-handle="e"></div>
                        </div>
                        <!-- Format Toolbar for selected elements -->
                        <div class="wb-format-bar" id="formatBar">
                            <button class="wb-format-bar__btn" id="fmtColorBtn" title="Farbe"><div class="wb-format-bar__color" id="fmtColorPreview" style="background:#ffffff"></div></button>
                            <div class="wb-format-bar__sep"></div>
                            <button class="wb-format-bar__btn" id="fmtSizeDown" title="Kleiner">‚àí</button>
                            <span id="fmtSizeLabel" style="color:white;font-size:11px;min-width:24px;text-align:center">4</span>
                            <button class="wb-format-bar__btn" id="fmtSizeUp" title="Gr√∂√üer">+</button>
                            <div class="wb-format-bar__sep"></div>
                            <button class="wb-format-bar__btn" id="fmtBgToggle" title="Hintergrund">BG</button>
                        </div>
                        <input type="color" id="fmtColorPicker" style="position:absolute;opacity:0;pointer-events:none">
                        <div class="wb-ruler-info" id="rulerInfo"></div>
                        <div class="wb-zoom-controls">
                            <button class="wb-zoom-btn" id="zoomInBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                            <div class="wb-zoom-level" id="zoomLevel">100%</div>
                            <button class="wb-zoom-btn" id="zoomOutBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                            <button class="wb-zoom-btn" id="zoomResetBtn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                        </div>
                    </div>
                </div>
                <div class="wb-stamps-panel" id="stampsPanel"><div class="wb-stamps-panel__title">Sticker</div><div class="wb-stamps-grid" id="stampsGrid"></div></div>
                <input type="text" class="wb-text-input" id="textInput" placeholder="Text...">
                <div class="wb-overlay" id="bgOverlay"><button class="wb-overlay-close" onclick="document.getElementById('bgOverlay').classList.remove('visible')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-upload-box" id="bgUploadBox"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg><h3>Hintergrund</h3><p>Battle Map hochladen</p><div class="wb-upload-actions"><button class="wb-upload-btn" id="bgSelectBtn">Ausw√§hlen</button><button class="wb-upload-btn wb-upload-btn--secondary" id="bgRemoveBtn">Entfernen</button></div><input type="file" id="bgFileInput" accept="image/*" style="display:none"></div></div>
                <div class="wb-overlay" id="imageOverlay"><button class="wb-overlay-close" onclick="document.getElementById('imageOverlay').classList.remove('visible')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button><div class="wb-upload-box" id="imageUploadBox"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg><h3>Bild einf√ºgen</h3><p>Wird platzierbar eingef√ºgt</p><div class="wb-upload-actions"><button class="wb-upload-btn" id="imageSelectBtn">Ausw√§hlen</button></div><input type="file" id="imageFileInput" accept="image/*" style="display:none"></div></div>
                <div class="wb-overlay" id="saveOverlay"><div class="wb-modal__content"><div class="wb-modal__title">Speichern</div><input type="text" class="wb-modal__input" id="saveNameInput" placeholder="Name..."><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('saveOverlay').classList.remove('visible')">Abbrechen</button><button class="wb-upload-btn" id="saveConfirmBtn">Speichern</button></div></div></div>
                <div class="wb-overlay" id="loadOverlay"><div class="wb-modal__content" style="min-width:450px"><div class="wb-modal__title">Laden</div><div id="savedList" style="max-height:350px;overflow-y:auto;margin-bottom:16px"></div><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('loadOverlay').classList.remove('visible')">Schlie√üen</button></div></div></div>
                <div class="wb-overlay" id="tokenOverlay"><div class="wb-modal__content" style="min-width:340px"><div class="wb-modal__title">Token erstellen</div><input type="text" class="wb-modal__input" id="tokenNameInput" placeholder="Name..."><div style="display:flex;gap:16px;margin-bottom:16px"><div id="tokenPortraitPreview" style="width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;cursor:pointer;overflow:hidden;flex-shrink:0;border:3px solid #8b5cf6" title="Portrait hochladen"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></div><div style="flex:1"><div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px">Hintergrund</div><div style="display:flex;gap:6px;flex-wrap:wrap" id="tokenColorPicker"></div></div></div><div style="margin-bottom:16px"><div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:6px">Rahmenfarbe</div><div style="display:flex;gap:6px;flex-wrap:wrap" id="tokenBorderPicker"></div></div><input type="file" id="tokenPortraitInput" accept="image/*" style="display:none"><div class="wb-modal__actions"><button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('tokenOverlay').classList.remove('visible')">Abbrechen</button><button class="wb-upload-btn" id="tokenCreateBtn">Erstellen</button></div></div></div>
                <div class="wb-context-menu" id="contextMenu"><button class="wb-context-item" data-action="duplicate"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>Duplizieren</button><button class="wb-context-item" data-action="front"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>Nach vorne</button><button class="wb-context-item" data-action="back"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>Nach hinten</button><div class="wb-context-divider"></div><button class="wb-context-item" data-action="edit"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>Bearbeiten</button><button class="wb-context-item wb-context-item--danger" data-action="delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>L√∂schen</button></div>
                
                <!-- Initiative Panel -->
                <div class="wb-initiative-panel" id="initiativePanel">
                    <div class="wb-initiative-panel__header">
                        <span class="wb-initiative-panel__title">Initiative</span>
                        <div class="wb-initiative-panel__controls">
                            <button class="wb-initiative-panel__btn" id="initPrevBtn" title="Vorheriger"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initNextBtn" title="N√§chster"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initSortBtn" title="Sortieren"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5h10M11 9h7M11 13h4M3 17l3 3 3-3M6 18V4"/></svg></button>
                            <button class="wb-initiative-panel__btn" id="initResetBtn" title="Zur√ºcksetzen"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                        </div>
                    </div>
                    <div id="initiativeList"></div>
                </div>
                
                <!-- Token Edit Modal -->
                <div class="wb-overlay" id="tokenEditOverlay">
                    <div class="wb-modal__content" style="min-width:380px">
                        <div class="wb-modal__title">Token bearbeiten</div>
                        <input type="text" class="wb-modal__input" id="editTokenName" placeholder="Name...">
                        
                        <div class="wb-token-edit">
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">HP</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenHp" placeholder="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Max HP</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenMaxHp" placeholder="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">Initiative</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenInit" placeholder="0">
                            </div>
                            <div class="wb-token-edit__field">
                                <label class="wb-token-edit__label">AC / R√ºstung</label>
                                <input type="number" class="wb-token-edit__input" id="editTokenAc" placeholder="10">
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Token-Gr√∂√üe</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap" id="tokenSizePresets">
                                <button class="wb-size-preset" data-size="44" data-grid="1">Klein (1√ó1)</button>
                                <button class="wb-size-preset" data-size="70" data-grid="1">Normal (1√ó1)</button>
                                <button class="wb-size-preset" data-size="140" data-grid="2">Gro√ü (2√ó2)</button>
                                <button class="wb-size-preset" data-size="210" data-grid="3">Riesig (3√ó3)</button>
                                <button class="wb-size-preset" data-size="280" data-grid="4">Kolossal (4√ó4)</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Status-Effekte</div>
                            <div class="wb-status-grid" id="statusGrid">
                                <button class="wb-status-btn" data-status="dead" title="Tot">üíÄ</button>
                                <button class="wb-status-btn" data-status="unconscious" title="Bewusstlos">üòµ</button>
                                <button class="wb-status-btn" data-status="poisoned" title="Vergiftet">ü§¢</button>
                                <button class="wb-status-btn" data-status="burning" title="Brennend">üî•</button>
                                <button class="wb-status-btn" data-status="frozen" title="Gefroren">‚ùÑÔ∏è</button>
                                <button class="wb-status-btn" data-status="stunned" title="Bet√§ubt">‚ö°</button>
                                <button class="wb-status-btn" data-status="invisible" title="Unsichtbar">üëÅÔ∏è</button>
                                <button class="wb-status-btn" data-status="blessed" title="Gesegnet">‚ú®</button>
                                <button class="wb-status-btn" data-status="cursed" title="Verflucht">üíú</button>
                                <button class="wb-status-btn" data-status="prone" title="Liegend">üõèÔ∏è</button>
                                <button class="wb-status-btn" data-status="grappled" title="Gepackt">ü§ù</button>
                                <button class="wb-status-btn" data-status="concentrating" title="Konzentriert">üéØ</button>
                            </div>
                        </div>
                        
                        <div class="wb-modal__actions">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('tokenEditOverlay').classList.remove('visible')">Abbrechen</button>
                            <button class="wb-upload-btn" id="tokenEditSaveBtn">Speichern</button>
                        </div>
                    </div>
                </div>
                
                <!-- Grid Settings Overlay -->
                <div class="wb-overlay" id="gridOverlay">
                    <div class="wb-modal__content" style="min-width:380px">
                        <div class="wb-modal__title">Raster-Einstellungen</div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Raster-Gr√∂√üe (px pro Feld)</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px" id="gridPresets">
                                <button class="wb-grid-preset" data-size="40">40</button>
                                <button class="wb-grid-preset" data-size="50">50</button>
                                <button class="wb-grid-preset active" data-size="70">70</button>
                                <button class="wb-grid-preset" data-size="100">100</button>
                                <button class="wb-grid-preset" data-size="140">140</button>
                            </div>
                            <div style="display:flex;align-items:center;gap:8px">
                                <span style="font-size:12px;color:rgba(255,255,255,0.6)">Custom:</span>
                                <input type="number" id="gridSizeInput" class="wb-modal__input" style="width:80px;padding:6px 10px" value="70" min="10" max="500">
                                <span style="font-size:12px;color:rgba(255,255,255,0.4)">px</span>
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Raster-Offset (Verschiebung)</div>
                            <div style="display:flex;gap:16px">
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">X:</label>
                                    <input type="number" id="gridOffsetX" class="wb-modal__input" style="width:100%;padding:6px 10px" value="0">
                                </div>
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">Y:</label>
                                    <input type="number" id="gridOffsetY" class="wb-modal__input" style="width:100%;padding:6px 10px" value="0">
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.05);border-radius:8px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">An Karte anpassen</div>
                            <div style="font-size:11px;color:rgba(255,255,255,0.4);margin-bottom:10px">Gib die Anzahl Felder der Karte ein</div>
                            <div style="display:flex;gap:12px;align-items:end">
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">Breite:</label>
                                    <input type="number" id="gridFitWidth" class="wb-modal__input" style="width:100%;padding:6px 10px" placeholder="z.B. 30">
                                </div>
                                <div style="flex:1">
                                    <label style="font-size:12px;color:rgba(255,255,255,0.6);display:block;margin-bottom:4px">H√∂he:</label>
                                    <input type="number" id="gridFitHeight" class="wb-modal__input" style="width:100%;padding:6px 10px" placeholder="z.B. 20">
                                </div>
                                <button class="wb-upload-btn" id="gridFitBtn" style="white-space:nowrap">Anpassen</button>
                            </div>
                            <div id="gridFitInfo" style="font-size:11px;color:rgba(139,92,246,0.8);margin-top:8px;display:none"></div>
                        </div>
                        
                        <div style="margin-bottom:16px">
                            <div style="font-size:11px;color:rgba(255,255,255,0.5);margin-bottom:8px;text-transform:uppercase">Raster-Farbe</div>
                            <div style="display:flex;gap:6px" id="gridColorPicker">
                                <button class="wb-grid-color active" data-color="rgba(255,255,255,0.12)" style="background:rgba(255,255,255,0.3)"></button>
                                <button class="wb-grid-color" data-color="rgba(0,0,0,0.2)" style="background:rgba(0,0,0,0.5)"></button>
                                <button class="wb-grid-color" data-color="rgba(139,92,246,0.3)" style="background:rgba(139,92,246,0.6)"></button>
                                <button class="wb-grid-color" data-color="rgba(59,130,246,0.3)" style="background:rgba(59,130,246,0.6)"></button>
                                <button class="wb-grid-color" data-color="rgba(234,179,8,0.3)" style="background:rgba(234,179,8,0.6)"></button>
                            </div>
                        </div>
                        
                        <div class="wb-modal__actions">
                            <button class="wb-upload-btn wb-upload-btn--secondary" onclick="document.getElementById('gridOverlay').classList.remove('visible')">Schlie√üen</button>
                            <button class="wb-upload-btn" id="gridApplyBtn">Anwenden</button>
                        </div>
                    </div>
                </div>
                <div class="wb-toast" id="wbToast"></div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Dock Placeholder -->
    <div id="dock-placeholder"></div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    <script src="assets/js/firebase-config.js"></script>
    <script>
        // Auth Guard - redirect to login if not authenticated
        (function() {
            function waitForAuth() {
                // Wait for Firebase SDK
                if (typeof firebase === 'undefined' || !firebase.auth) {
                    return setTimeout(waitForAuth, 50);
                }
                // Wait for Firebase app initialization
                try {
                    var auth = firebase.auth();
                    auth.onAuthStateChanged(function(user) {
                        if (!user) {
                            window.location.href = '/login';
                        } else {
                            document.body.classList.add('auth-ready');
                        }
                    });
                } catch(e) {
                    // Firebase not initialized yet, retry
                    setTimeout(waitForAuth, 50);
                }
            }
            waitForAuth();
        })();
    </script>

    <script src="assets/js/room-service.js"></script>
    <script src="assets/js/user-service.js"></script>
    <script src="assets/js/toast-service.js"></script>
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/ui.js"></script>
    <script src="assets/js/layout.js"></script>
    <script src="assets/js/layout-unified.js"></script>
    <script src="assets/js/settings.js"></script>
    <script src="assets/js/admin.js"></script>
    <script src="assets/js/transitions.js"></script>
    <script src="assets/js/app.js"></script>
    <script>initUnifiedLayout();</script>
    <script src="assets/js/broadcast.js"></script>
    <script>
const WB = {
    // Canvases
    bgCanvas: null, bgCtx: null, mainCanvas: null, mainCtx: null,
    fogCanvas: null, fogCtx: null, uiCanvas: null, uiCtx: null,
    
    // State
    layer: 'main', tool: 'pen', color: '#ffffff', size: 4,
    fill: false, snap: false, gridSize: 70, gridOffsetX: 0, gridOffsetY: 0,
    gridColor: 'rgba(255,255,255,0.12)', zoom: 1, panX: 0, panY: 0,
    
    // Smooth animation targets
    targetZoom: 1, targetPanX: 0, targetPanY: 0,
    animationFrame: null, lastFrameTime: 0,
    
    // Drawing
    isDrawing: false, isPanning: false, isDragging: false, isResizing: false,
    spacePressed: false, // For hand tool (spacebar pan)
    startPoint: null, currentPath: [], polygonPoints: [],
    resizeHandle: null, dragOffset: { x: 0, y: 0 },
    
    // Data
    strokes: [], images: [], tokens: [], fogAreas: [],
    selected: null, // Single selected item
    bgImage: null, history: [], historyIdx: -1,
    
    // User
    roomCode: null, db: null, userId: null, userName: null,
    userColor: '#8b5cf6', isGM: false,
    
    // Stamps
    stamps: ['‚öîÔ∏è','üõ°Ô∏è','üíÄ','üëë','üóùÔ∏è','üíé','üî•','‚ùÑÔ∏è','‚ö°','üíß','üåü','üè∞','üö™','‚¨ÜÔ∏è','‚¨áÔ∏è','‚¨ÖÔ∏è','‚û°Ô∏è','‚ùå','‚úÖ','‚ùì','üí∞','üìú','üß™','üó°Ô∏è','üèπ','ü™Ñ','üé≠','üëÅÔ∏è','üêâ','üßô'],
    selectedStamp: null, pendingTokenColor: '#8b5cf6',
    
    // Initiative tracker
    initiativeActive: null, // Token ID of currently active turn
    initiativeOrder: [], // Sorted list of token IDs
    editingToken: null, // Token being edited in modal
    
    async init() {
        console.log('[WB] Starting...');
        this.bgCanvas = document.getElementById('bgCanvas');
        this.mainCanvas = document.getElementById('mainCanvas');
        this.fogCanvas = document.getElementById('fogCanvas');
        this.uiCanvas = document.getElementById('uiCanvas');
        this.bgCtx = this.bgCanvas.getContext('2d');
        this.mainCtx = this.mainCanvas.getContext('2d');
        this.fogCtx = this.fogCanvas.getContext('2d');
        this.uiCtx = this.uiCanvas.getContext('2d');
        
        // Enable high-quality image rendering
        [this.bgCtx, this.mainCtx, this.fogCtx, this.uiCtx].forEach(ctx => {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        });
        
        this.roomCode = localStorage.getItem('rift_current_room');
        const u = JSON.parse(localStorage.getItem('rift_user') || '{}');
        this.userId = u.odUserId || Math.random().toString(36).substr(2, 9);
        this.userName = u.displayName || 'Anonym';
        this.userColor = u.color || '#8b5cf6';
        this.isGM = u.isGM || u.isCogm || false;
        
        this.addUserColor();
        if (this.isGM) document.getElementById('gmActions').style.display = 'flex';
        else document.getElementById('fogTab').style.display = 'none';
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.setupToolbar();
        this.setupCanvas();
        this.setupKeyboard();
        this.setupUploads();
        this.setupStamps();
        this.setupModals();
        this.setupContextMenu();
        this.setupResizeHandles();
        this.setupFormatBar();
        this.setupTokenEditModal();
        this.setupInitiative();
        
        if (this.roomCode) await this.connectFirebase();
        this.render();
        console.log('[WB] Ready!');
    },
    
    resize() {
        const w = document.getElementById('canvasWrapper');
        const r = w.getBoundingClientRect();
        [this.bgCanvas, this.mainCanvas, this.fogCanvas, this.uiCanvas].forEach(c => {
            c.width = r.width; c.height = r.height;
        });
        this.render();
    },
    
    addUserColor() {
        const p = document.getElementById('colorPalette');
        const cols = [...p.querySelectorAll('.wb-color-btn')].map(b => b.dataset.color.toLowerCase());
        if (!cols.includes(this.userColor.toLowerCase())) {
            const btn = document.createElement('button');
            btn.className = 'wb-color-btn';
            btn.dataset.color = this.userColor;
            btn.style.background = this.userColor;
            btn.onclick = () => this.setColor(this.userColor);
            p.insertBefore(btn, p.firstChild);
        }
    },
    
    // ==================== TOOLBAR ====================
    setupToolbar() {
        document.querySelectorAll('.wb-layer-tab').forEach(t => {
            t.onclick = () => {
                document.querySelectorAll('.wb-layer-tab').forEach(x => x.classList.remove('active'));
                t.classList.add('active');
                this.layer = t.dataset.layer;
                // Show fog reveal hint when on fog layer
                const revealBtn = document.getElementById('fogRevealBtn');
                if (revealBtn) {
                    revealBtn.style.display = (this.layer === 'fog' && this.isGM) ? 'flex' : 'none';
                }
            };
        });
        
        // Fog reveal button just switches to eraser for convenience
        const fogRevealBtn = document.getElementById('fogRevealBtn');
        if (fogRevealBtn) {
            fogRevealBtn.onclick = () => {
                // Switch to fog layer and eraser tool
                document.querySelectorAll('.wb-layer-tab').forEach(x => x.classList.remove('active'));
                document.getElementById('fogTab').classList.add('active');
                this.layer = 'fog';
                
                document.querySelectorAll('[data-tool]').forEach(x => x.classList.remove('active'));
                document.querySelector('[data-tool="eraser"]').classList.add('active');
                this.tool = 'eraser';
                this.updateCursor();
                this.toast('Nebel aufdecken: Male um Nebel zu entfernen');
            };
        }
        
        document.querySelectorAll('[data-tool]').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('[data-tool]').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                this.tool = b.dataset.tool;
                this.updateCursor();
                if (this.tool !== 'polygon') this.finishPolygon();
                if (this.tool !== 'select') this.deselect();
            };
        });
        
        document.querySelectorAll('.wb-color-btn').forEach(b => {
            b.onclick = () => this.setColor(b.dataset.color);
        });
        
        document.querySelectorAll('.wb-size-btn').forEach(b => {
            b.onclick = () => {
                document.querySelectorAll('.wb-size-btn').forEach(x => x.classList.remove('active'));
                b.classList.add('active');
                this.size = parseInt(b.dataset.size);
            };
        });
        
        document.getElementById('fillToggle').onclick = function() {
            this.classList.toggle('active');
            WB.fill = this.classList.contains('active');
        };
        document.getElementById('snapToggle').onclick = function() {
            this.classList.toggle('active');
            WB.snap = this.classList.contains('active');
        };
        document.getElementById('gridToggle').onclick = function() {
            this.classList.toggle('active');
            document.getElementById('wbGrid').classList.toggle('visible');
        };
        document.getElementById('gridSettingsBtn').onclick = () => this.showGridSettings();
        
        document.getElementById('undoBtn').onclick = () => this.undo();
        document.getElementById('redoBtn').onclick = () => this.redo();
        document.getElementById('zoomInBtn').onclick = () => this.setZoom(this.targetZoom + 0.25);
        document.getElementById('zoomOutBtn').onclick = () => this.setZoom(this.targetZoom - 0.25);
        document.getElementById('zoomResetBtn').onclick = () => { 
            this.targetZoom = 1; 
            this.targetPanX = 0; 
            this.targetPanY = 0; 
            this.startAnimation(); 
        };
        document.getElementById('exportBtn').onclick = () => this.exportPNG();
        document.getElementById('clearBtn')?.addEventListener('click', () => { if(confirm('Alles l√∂schen?')) this.clearAll(); });
        document.getElementById('stampBtn').onclick = () => document.getElementById('stampsPanel').classList.toggle('visible');
        document.getElementById('tokenBtn').onclick = () => this.showTokenModal();
    },
    
    setColor(c) {
        this.color = c;
        document.querySelectorAll('.wb-color-btn').forEach(b => b.classList.toggle('active', b.dataset.color === c));
    },
    
    updateCursor() {
        const w = document.getElementById('canvasWrapper');
        w.className = 'wb-canvas-wrapper';
        if (this.tool === 'select') w.classList.add('tool-select');
        else if (this.tool === 'eraser') w.classList.add('tool-eraser');
        else if (this.tool === 'text') w.classList.add('tool-text');
    },
    
    setZoom(z) { 
        this.targetZoom = Math.max(0.25, Math.min(4, z)); 
        this.startAnimation();
    },
    
    smoothZoomTo(z, centerX, centerY) {
        // Zoom towards a point (for wheel zoom)
        const oldZoom = this.zoom;
        const newZoom = Math.max(0.25, Math.min(4, z));
        
        // Calculate pan adjustment to zoom towards cursor
        if (centerX !== undefined && centerY !== undefined) {
            const zoomRatio = newZoom / oldZoom;
            this.targetPanX = centerX - (centerX - this.panX) * zoomRatio;
            this.targetPanY = centerY - (centerY - this.panY) * zoomRatio;
        }
        
        this.targetZoom = newZoom;
        this.startAnimation();
    },
    
    updateZoom() { 
        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%'; 
    },
    
    // ==================== SMOOTH ANIMATION ====================
    startAnimation() {
        if (!this.animationFrame) {
            this.lastFrameTime = performance.now();
            this.animationFrame = requestAnimationFrame(t => this.animateLoop(t));
        }
    },
    
    animateLoop(timestamp) {
        const deltaTime = Math.min((timestamp - this.lastFrameTime) / 1000, 0.1); // Cap at 100ms
        this.lastFrameTime = timestamp;
        
        // Lerp factor - exponential decay for smooth deceleration
        // Higher base = faster animation (0.00001 = very smooth, 0.001 = snappy)
        const lerpFactor = 1 - Math.pow(0.00005, deltaTime);
        
        // Smooth zoom
        const zoomDiff = Math.abs(this.targetZoom - this.zoom);
        if (zoomDiff > 0.001) {
            this.zoom += (this.targetZoom - this.zoom) * lerpFactor;
            this.updateZoom();
        } else {
            this.zoom = this.targetZoom;
        }
        
        // Smooth pan
        const panXDiff = Math.abs(this.targetPanX - this.panX);
        const panYDiff = Math.abs(this.targetPanY - this.panY);
        
        if (panXDiff > 0.5) {
            this.panX += (this.targetPanX - this.panX) * lerpFactor;
        } else {
            this.panX = this.targetPanX;
        }
        
        if (panYDiff > 0.5) {
            this.panY += (this.targetPanY - this.panY) * lerpFactor;
        } else {
            this.panY = this.targetPanY;
        }
        
        // Render
        this.render();
        
        // Continue animation if not settled
        const needsMore = zoomDiff > 0.001 || panXDiff > 0.5 || panYDiff > 0.5;
        if (needsMore) {
            this.animationFrame = requestAnimationFrame(t => this.animateLoop(t));
        } else {
            this.animationFrame = null;
        }
    },
    
    // Immediate pan (for dragging - no animation delay)
    setPanImmediate(x, y) {
        this.panX = x;
        this.panY = y;
        this.targetPanX = x;
        this.targetPanY = y;
        this.scheduleRender();
    },
    
    // Throttled render - max once per frame
    renderScheduled: false,
    scheduleRender() {
        if (!this.renderScheduled) {
            this.renderScheduled = true;
            requestAnimationFrame(() => {
                this.renderScheduled = false;
                this.render();
            });
        }
    },
    
    // ==================== GRID SETTINGS ====================
    showGridSettings() {
        const overlay = document.getElementById('gridOverlay');
        
        // Set current values
        document.getElementById('gridSizeInput').value = this.gridSize;
        document.getElementById('gridOffsetX').value = this.gridOffsetX;
        document.getElementById('gridOffsetY').value = this.gridOffsetY;
        
        // Update preset buttons
        document.querySelectorAll('.wb-grid-preset').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === this.gridSize);
        });
        
        // Update color buttons
        document.querySelectorAll('.wb-grid-color').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.color === this.gridColor);
        });
        
        // Setup event handlers if not already done
        if (!this.gridSettingsInitialized) {
            this.setupGridSettingsEvents();
            this.gridSettingsInitialized = true;
        }
        
        overlay.classList.add('visible');
    },
    
    setupGridSettingsEvents() {
        // Preset buttons
        document.querySelectorAll('.wb-grid-preset').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.wb-grid-preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('gridSizeInput').value = btn.dataset.size;
            };
        });
        
        // Custom input updates presets
        document.getElementById('gridSizeInput').oninput = (e) => {
            const val = parseInt(e.target.value);
            document.querySelectorAll('.wb-grid-preset').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.size) === val);
            });
        };
        
        // Color buttons
        document.querySelectorAll('.wb-grid-color').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.wb-grid-color').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        // Fit to map button
        document.getElementById('gridFitBtn').onclick = () => this.fitGridToMap();
        
        // Apply button
        document.getElementById('gridApplyBtn').onclick = () => this.applyGridSettings();
    },
    
    fitGridToMap() {
        if (!this.bgImage) {
            this.toast('Kein Hintergrund geladen!');
            return;
        }
        
        const widthFields = parseInt(document.getElementById('gridFitWidth').value);
        const heightFields = parseInt(document.getElementById('gridFitHeight').value);
        
        if (!widthFields || !heightFields) {
            this.toast('Bitte Breite und H√∂he eingeben');
            return;
        }
        
        // Calculate grid size based on background image dimensions
        const bgW = this.bgImage.width;
        const bgH = this.bgImage.height;
        
        const gridFromWidth = bgW / widthFields;
        const gridFromHeight = bgH / heightFields;
        
        // Use average or the one that fits better
        const calculatedSize = Math.round((gridFromWidth + gridFromHeight) / 2);
        
        document.getElementById('gridSizeInput').value = calculatedSize;
        
        // Update preset buttons
        document.querySelectorAll('.wb-grid-preset').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.size) === calculatedSize);
        });
        
        // Show info
        const info = document.getElementById('gridFitInfo');
        info.style.display = 'block';
        info.innerHTML = `
            Berechnet: <strong>${calculatedSize}px</strong> pro Feld<br>
            Karte: ${bgW}√ó${bgH}px ‚Üí ${widthFields}√ó${heightFields} Felder
        `;
        
        this.toast(`Grid: ${calculatedSize}px (${widthFields}√ó${heightFields})`);
    },
    
    applyGridSettings() {
        this.gridSize = parseInt(document.getElementById('gridSizeInput').value) || 70;
        this.gridOffsetX = parseInt(document.getElementById('gridOffsetX').value) || 0;
        this.gridOffsetY = parseInt(document.getElementById('gridOffsetY').value) || 0;
        
        // Get selected color
        const activeColor = document.querySelector('.wb-grid-color.active');
        if (activeColor) {
            this.gridColor = activeColor.dataset.color;
        }
        
        this.updateGrid();
        document.getElementById('gridOverlay').classList.remove('visible');
        this.toast(`Raster: ${this.gridSize}px`);
    },
    
    updateGrid() {
        const grid = document.getElementById('wbGrid');
        const size = this.gridSize * this.zoom;
        const offsetX = this.gridOffsetX * this.zoom + this.panX;
        const offsetY = this.gridOffsetY * this.zoom + this.panY;
        
        grid.style.backgroundImage = `
            linear-gradient(${this.gridColor} 1px, transparent 1px),
            linear-gradient(90deg, ${this.gridColor} 1px, transparent 1px)
        `;
        grid.style.backgroundSize = `${size}px ${size}px`;
        grid.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
    },
    
    // ==================== CANVAS EVENTS ====================
    setupCanvas() {
        const ui = this.uiCanvas;
        const wrapper = document.getElementById('canvasWrapper');
        
        // Prevent native drag on all elements in the canvas area
        wrapper.addEventListener('dragstart', e => e.preventDefault());
        
        ui.addEventListener('mousedown', e => this.onDown(e));
        ui.addEventListener('dblclick', e => this.onDblClick(e));
        ui.addEventListener('contextmenu', e => this.onContext(e));
        
        // Mouse move/up on WINDOW so dragging works when mouse leaves canvas or is over DOM elements
        window.addEventListener('mousemove', e => {
            if (this.isDragging || this.isDrawing || this.isResizing) {
                this.onMove(e);
            }
        });
        window.addEventListener('mouseup', e => {
            if (this.isDragging || this.isDrawing || this.isResizing) {
                this.onUp(e);
            }
        });
        
        // Also listen on canvas for regular drawing
        ui.addEventListener('mousemove', e => {
            if (!this.isDragging && !this.isResizing) {
                this.onMove(e);
            }
        });
        ui.addEventListener('mouseleave', e => {
            if (!this.isDragging && !this.isResizing) {
                this.onUp(e);
            }
        });
        
        ui.addEventListener('touchstart', e => { e.preventDefault(); this.onDown(e.touches[0]); }, { passive: false });
        ui.addEventListener('touchmove', e => { e.preventDefault(); this.onMove(e.touches[0]); }, { passive: false });
        ui.addEventListener('touchend', e => { e.preventDefault(); this.onUp(e); }, { passive: false });
        
        // Middle mouse pan
        ui.addEventListener('mousedown', e => {
            if (e.button === 1) { e.preventDefault(); this.isPanning = true; this.lastPan = { x: e.clientX, y: e.clientY }; }
        });
        window.addEventListener('mousemove', e => {
            if (this.isPanning && this.lastPan) {
                const dx = e.clientX - this.lastPan.x;
                const dy = e.clientY - this.lastPan.y;
                this.panX += dx;
                this.panY += dy;
                this.targetPanX = this.panX;
                this.targetPanY = this.panY;
                this.lastPan = { x: e.clientX, y: e.clientY };
                this.scheduleRender();
            }
        });
        window.addEventListener('mouseup', e => { if (e.button === 1) this.isPanning = false; });
        
        // Spacebar hand tool (pan mode)
        window.addEventListener('keydown', e => {
            if (e.code === 'Space' && !this.spacePressed && !e.target.matches('input, textarea')) {
                e.preventDefault();
                this.spacePressed = true;
                wrapper.style.cursor = 'grab';
            }
        });
        window.addEventListener('keyup', e => {
            if (e.code === 'Space') {
                this.spacePressed = false;
                this.isPanning = false;
                this.lastPan = null;
                wrapper.style.cursor = '';
                this.updateCursor();
            }
        });
        // Spacebar + mouse = pan
        wrapper.addEventListener('mousedown', e => {
            if (this.spacePressed && e.button === 0) {
                e.preventDefault();
                e.stopPropagation();
                this.isPanning = true;
                this.lastPan = { x: e.clientX, y: e.clientY };
                wrapper.style.cursor = 'grabbing';
            }
        });
        window.addEventListener('mouseup', e => {
            if (this.spacePressed && e.button === 0) {
                this.isPanning = false;
                this.lastPan = null;
                wrapper.style.cursor = 'grab';
            }
        });
        
        // Wheel zoom (smooth, towards cursor)
        document.getElementById('canvasWrapper').addEventListener('wheel', e => {
            e.preventDefault();
            const rect = wrapper.getBoundingClientRect();
            const cursorX = e.clientX - rect.left;
            const cursorY = e.clientY - rect.top;
            
            // Smaller steps for smoother feel
            const zoomDelta = e.deltaY > 0 ? -0.15 : 0.15;
            this.smoothZoomTo(this.targetZoom + zoomDelta, cursorX, cursorY);
        }, { passive: false });
        
        // Close panels on click outside
        document.addEventListener('click', e => {
            if (!e.target.closest('#stampsPanel') && !e.target.closest('#stampBtn'))
                document.getElementById('stampsPanel').classList.remove('visible');
            if (!e.target.closest('.wb-context-menu'))
                document.getElementById('contextMenu').classList.remove('visible');
        });
    },
    
    getPoint(e) {
        const r = this.uiCanvas.getBoundingClientRect();
        let x = (e.clientX - r.left - this.panX) / this.zoom;
        let y = (e.clientY - r.top - this.panY) / this.zoom;
        if (this.snap) {
            x = Math.round((x - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX;
            y = Math.round((y - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY;
        }
        // rx, ry = relative to canvasWrapper (for DOM elements like ping)
        return { x, y, sx: e.clientX, sy: e.clientY, rx: e.clientX - r.left, ry: e.clientY - r.top };
    },
    
    onDown(e) {
        if (this.isPanning || this.isResizing || this.spacePressed) return;
        const p = this.getPoint(e);
        this.startPoint = p;
        this.currentPath = [p];
        this.lastDragPoint = p; // Track for delta movement
        
        // SELECT TOOL - Main new logic
        if (this.tool === 'select') {
            const hit = this.hitTest(p);
            if (hit) {
                this.select(hit);
                this.isDragging = true;
                this.lastDragPoint = p;
            } else {
                this.deselect();
            }
            return;
        }
        
        if (this.tool === 'ping') { this.createPing(p.rx, p.ry); return; }
        if (this.tool === 'text') { this.showTextInput(p); return; }
        if (this.tool === 'stamp' && this.selectedStamp) { this.placeStamp(p); return; }
        if (this.tool === 'polygon') { this.polygonPoints.push(p); this.renderUI(); return; }
        
        this.isDrawing = true;
    },
    
    onMove(e) {
        const p = this.getPoint(e);
        
        // Dragging selected item - use delta movement
        if (this.isDragging && this.selected && this.lastDragPoint) {
            const dx = p.x - this.lastDragPoint.x;
            const dy = p.y - this.lastDragPoint.y;
            this.lastDragPoint = p;
            this.moveSelected(dx, dy);
            return;
        }
        
        // Resizing selected item
        if (this.isResizing && this.selected && this.resizeHandle) {
            this.handleResize(e);
            return;
        }
        
        if (!this.isDrawing) return;
        this.currentPath.push(p);
        
        if (this.tool === 'pen') this.drawLivePen(p);
        else if (this.tool === 'eraser') this.eraseLive(p);
        else if (this.tool === 'ruler') this.showRuler(this.startPoint, p);
        else this.renderUI();
    },
    
    onUp(e) {
        if (this.isDragging) {
            this.isDragging = false;
            this.lastDragPoint = null;
            // Already synced in real-time via moveSelected()
            return;
        }
        
        if (this.isResizing) {
            this.isResizing = false;
            this.resizeHandle = null;
            return;
        }
        
        if (this.tool === 'ruler') {
            document.getElementById('rulerInfo').style.display = 'none';
            this.renderUI();
        }
        
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        if (this.currentPath.length < 2) return;
        
        const end = this.currentPath[this.currentPath.length - 1];
        const stroke = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: this.layer, tool: this.tool,
            color: this.tool === 'eraser' ? '#0a0a0a' : this.color,
            size: this.tool === 'eraser' ? this.size * 4 : this.size,
            fill: this.fill,
            path: ['pen', 'eraser'].includes(this.tool) ? [...this.currentPath] : null,
            start: this.startPoint, end: end,
            userId: this.userId, ts: Date.now()
        };
        
        this.addStroke(stroke);
        this.syncStroke(stroke);
        this.currentPath = [];
        this.startPoint = null;
        this.renderUI();
    },
    
    onDblClick(e) {
        const p = this.getPoint(e);
        
        // Double-click on text to edit
        if (this.tool === 'select' && this.selected?.type === 'stroke' && this.selected.item.tool === 'text') {
            this.editText(this.selected.item, p);
            return;
        }
        
        if (this.tool === 'polygon' && this.polygonPoints.length >= 3) this.finishPolygon();
        else this.createPing(p.rx, p.ry);
    },
    
    editText(stroke, p) {
        const inp = document.getElementById('textInput');
        const canvasRect = this.uiCanvas.getBoundingClientRect();
        inp.style.left = (stroke.start.x * this.zoom + this.panX + canvasRect.left) + 'px';
        inp.style.top = (stroke.start.y * this.zoom + this.panY + canvasRect.top) + 'px';
        inp.style.display = 'block';
        inp.style.color = stroke.color;
        inp.dataset.strokeId = stroke.id;
        inp.dataset.x = stroke.start.x;
        inp.dataset.y = stroke.start.y;
        inp.value = stroke.text || '';
        setTimeout(() => { inp.focus(); inp.select(); }, 50);
    },
    
    onContext(e) {
        e.preventDefault();
        const p = this.getPoint(e);
        const hit = this.hitTest(p);
        if (hit) {
            this.select(hit);
            const m = document.getElementById('contextMenu');
            m.style.left = e.clientX + 'px';
            m.style.top = e.clientY + 'px';
            m.classList.add('visible');
        }
    },
    
    // ==================== SELECTION ====================
    hitTest(p) {
        // Check tokens first (top layer) - circles
        for (let i = this.tokens.length - 1; i >= 0; i--) {
            const t = this.tokens[i];
            const dx = p.x - t.x, dy = p.y - t.y;
            if (Math.sqrt(dx * dx + dy * dy) < t.size / 2) return { type: 'token', item: t, index: i };
        }
        // Check images - rectangles
        for (let i = this.images.length - 1; i >= 0; i--) {
            const img = this.images[i];
            if (p.x >= img.x && p.x <= img.x + img.w && p.y >= img.y && p.y <= img.y + img.h) 
                return { type: 'image', item: img, index: i };
        }
        // Check strokes (text, stamps, shapes) - reverse order for top-most first
        for (let i = this.strokes.length - 1; i >= 0; i--) {
            const s = this.strokes[i];
            if (s.layer !== 'main') continue;
            if (this.hitTestStroke(s, p)) return { type: 'stroke', item: s, index: i };
        }
        return null;
    },
    
    hitTestStroke(s, p) {
        // More accurate hit testing for each stroke type
        if (s.tool === 'stamp') {
            const size = s.stampSize || 40;
            // fillText: x = left edge, y = baseline (bottom of emoji)
            // Emoji goes from x to x+size horizontally, and from y-size to y vertically
            return p.x >= s.x && p.x <= s.x + size && 
                   p.y >= s.y - size && p.y <= s.y;
        }
        if (s.tool === 'text') {
            const fontSize = s.size * 4 + 12;
            const textWidth = Math.max((s.text?.length || 5) * fontSize * 0.55, 40);
            // Text baseline at start.y - text renders above
            return p.x >= s.start.x && p.x <= s.start.x + textWidth &&
                   p.y >= s.start.y - fontSize * 0.9 && p.y <= s.start.y + fontSize * 0.2;
        }
        if (s.tool === 'pen' && s.path && s.path.length > 0) {
            // Check proximity to any point in path
            const threshold = Math.max(s.size * 2, 15);
            for (const pt of s.path) {
                const dx = p.x - pt.x, dy = p.y - pt.y;
                if (Math.sqrt(dx*dx + dy*dy) < threshold) return true;
            }
            return false;
        }
        if (s.tool === 'polygon' && s.points && s.points.length > 0) {
            // Check if point is inside polygon or near edges
            return this.pointInPolygon(p, s.points) || this.nearPolygonEdge(p, s.points, s.size + 5);
        }
        if (['line', 'rect', 'circle', 'arrow'].includes(s.tool) && s.start && s.end) {
            const bounds = this.getShapeBounds(s);
            const pad = Math.max(s.size, 8);
            return p.x >= bounds.x - pad && p.x <= bounds.x + bounds.w + pad &&
                   p.y >= bounds.y - pad && p.y <= bounds.y + bounds.h + pad;
        }
        return false;
    },
    
    pointInPolygon(p, points) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, yi = points[i].y;
            const xj = points[j].x, yj = points[j].y;
            if (((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    },
    
    nearPolygonEdge(p, points, threshold) {
        for (let i = 0; i < points.length; i++) {
            const a = points[i], b = points[(i + 1) % points.length];
            if (this.distToSegment(p, a, b) < threshold) return true;
        }
        return false;
    },
    
    distToSegment(p, a, b) {
        const l2 = (b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y);
        if (l2 === 0) return Math.sqrt((p.x-a.x)*(p.x-a.x) + (p.y-a.y)*(p.y-a.y));
        let t = ((p.x-a.x)*(b.x-a.x) + (p.y-a.y)*(b.y-a.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const proj = { x: a.x + t*(b.x-a.x), y: a.y + t*(b.y-a.y) };
        return Math.sqrt((p.x-proj.x)*(p.x-proj.x) + (p.y-proj.y)*(p.y-proj.y));
    },
    
    getShapeBounds(s) {
        if (!s.start || !s.end) return null;
        return {
            x: Math.min(s.start.x, s.end.x),
            y: Math.min(s.start.y, s.end.y),
            w: Math.abs(s.end.x - s.start.x),
            h: Math.abs(s.end.y - s.start.y)
        };
    },
    
    getStrokeBounds(s) {
        if (s.tool === 'text') {
            const fontSize = s.size * 4 + 12;
            const textWidth = Math.max((s.text?.length || 5) * fontSize * 0.55, 40);
            return { x: s.start.x, y: s.start.y - fontSize * 0.9, w: textWidth, h: fontSize * 1.1 };
        }
        if (s.tool === 'stamp') {
            const size = s.stampSize || 40;
            // fillText: x = left edge, y = baseline. Emoji goes from y-size to y
            return { x: s.x, y: s.y - size, w: size, h: size };
        }
        if (s.tool === 'pen' && s.path && s.path.length > 0) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            s.path.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
            const pad = Math.max(s.size * 2, 10);
            return { x: minX - pad, y: minY - pad, w: Math.max(maxX - minX + pad*2, 20), h: Math.max(maxY - minY + pad*2, 20) };
        }
        if (s.tool === 'polygon' && s.points && s.points.length > 0) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            s.points.forEach(pt => { minX = Math.min(minX, pt.x); minY = Math.min(minY, pt.y); maxX = Math.max(maxX, pt.x); maxY = Math.max(maxY, pt.y); });
            const pad = Math.max(s.size, 5);
            return { x: minX - pad, y: minY - pad, w: maxX - minX + pad*2, h: maxY - minY + pad*2 };
        }
        if (['line', 'rect', 'circle', 'arrow'].includes(s.tool) && s.start && s.end) {
            const b = this.getShapeBounds(s);
            const pad = Math.max(s.size, 5);
            return { x: b.x - pad, y: b.y - pad, w: b.w + pad*2, h: b.h + pad*2 };
        }
        return null;
    },
    
    select(hit) {
        this.selected = hit;
        this.render();
        this.updateSelectBox();
    },
    
    deselect() {
        this.selected = null;
        document.getElementById('selectBox').classList.remove('visible');
        document.getElementById('formatBar').classList.remove('visible');
        this.render();
    },
    
    updateSelectBox() {
        const box = document.getElementById('selectBox');
        if (!this.selected) { box.classList.remove('visible'); return; }
        
        const bounds = this.getSelectedBounds();
        if (!bounds) { box.classList.remove('visible'); return; }
        
        const x = bounds.x * this.zoom + this.panX;
        const y = bounds.y * this.zoom + this.panY;
        const w = bounds.w * this.zoom;
        const h = bounds.h * this.zoom;
        
        box.style.left = x + 'px';
        box.style.top = y + 'px';
        box.style.width = w + 'px';
        box.style.height = h + 'px';
        box.classList.add('visible');
        
        // Show format bar for text and strokes
        this.updateFormatBar(x, y, w, h);
    },
    
    updateFormatBar(x, y, w, h) {
        const bar = document.getElementById('formatBar');
        if (!this.selected) { bar.classList.remove('visible'); return; }
        
        const { type, item } = this.selected;
        
        // Show format bar for text, stamps, and shapes
        if (type === 'stroke' && ['text', 'stamp', 'rect', 'circle', 'line', 'arrow', 'polygon', 'pen'].includes(item.tool)) {
            bar.style.left = x + 'px';
            bar.style.top = (y - 44) + 'px';
            bar.classList.add('visible');
            
            // Update color preview
            document.getElementById('fmtColorPreview').style.background = item.color || '#ffffff';
            document.getElementById('fmtSizeLabel').textContent = item.tool === 'stamp' ? (item.stampSize || 40) : (item.size || 4);
            
            // Show/hide BG toggle for text
            document.getElementById('fmtBgToggle').style.display = item.tool === 'text' ? 'flex' : 'none';
            if (item.tool === 'text') {
                document.getElementById('fmtBgToggle').classList.toggle('active', !!item.bg);
            }
        } else {
            bar.classList.remove('visible');
        }
    },
    
    setupFormatBar() {
        document.getElementById('fmtColorBtn').onclick = () => {
            const picker = document.getElementById('fmtColorPicker');
            picker.value = this.selected?.item?.color || '#ffffff';
            picker.click();
        };
        
        document.getElementById('fmtColorPicker').oninput = (e) => {
            if (this.selected?.type === 'stroke') {
                this.selected.item.color = e.target.value;
                document.getElementById('fmtColorPreview').style.background = e.target.value;
                this.syncStroke(this.selected.item);
                this.render();
            }
        };
        
        document.getElementById('fmtSizeUp').onclick = () => {
            if (!this.selected?.item) return;
            const item = this.selected.item;
            if (item.tool === 'stamp') {
                item.stampSize = Math.min(120, (item.stampSize || 40) + 5);
            } else {
                item.size = Math.min(32, (item.size || 4) + 1);
            }
            document.getElementById('fmtSizeLabel').textContent = item.tool === 'stamp' ? item.stampSize : item.size;
            this.syncStroke(item);
            this.render();
            this.updateSelectBox();
        };
        
        document.getElementById('fmtSizeDown').onclick = () => {
            if (!this.selected?.item) return;
            const item = this.selected.item;
            if (item.tool === 'stamp') {
                item.stampSize = Math.max(20, (item.stampSize || 40) - 5);
            } else {
                item.size = Math.max(1, (item.size || 4) - 1);
            }
            document.getElementById('fmtSizeLabel').textContent = item.tool === 'stamp' ? item.stampSize : item.size;
            this.syncStroke(item);
            this.render();
            this.updateSelectBox();
        };
        
        document.getElementById('fmtBgToggle').onclick = () => {
            if (!this.selected?.item || this.selected.item.tool !== 'text') return;
            const item = this.selected.item;
            item.bg = !item.bg;
            document.getElementById('fmtBgToggle').classList.toggle('active', item.bg);
            this.syncStroke(item);
            this.render();
        };
    },
    
    getSelectedBounds() {
        if (!this.selected) return null;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            return { x: item.x - item.size/2, y: item.y - item.size/2, w: item.size, h: item.size };
        }
        if (type === 'image') {
            return { x: item.x, y: item.y, w: item.w, h: item.h };
        }
        if (type === 'stroke') {
            return this.getStrokeBounds(item);
        }
        return null;
    },
    
    // Move selected item by delta
    moveSelected(dx, dy) {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            item.x += dx;
            item.y += dy;
            if (this.snap) {
                item.x = Math.round((item.x - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX;
                item.y = Math.round((item.y - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY;
            }
            // Real-time sync
            this.syncToken(item);
        }
        if (type === 'image') {
            item.x += dx;
            item.y += dy;
            if (this.snap) {
                item.x = Math.round((item.x - this.gridOffsetX) / this.gridSize) * this.gridSize + this.gridOffsetX;
                item.y = Math.round((item.y - this.gridOffsetY) / this.gridSize) * this.gridSize + this.gridOffsetY;
            }
        }
        if (type === 'stroke') {
            // Move stroke points
            if (item.start) { item.start.x += dx; item.start.y += dy; }
            if (item.end) { item.end.x += dx; item.end.y += dy; }
            if (item.path) item.path.forEach(p => { p.x += dx; p.y += dy; });
            if (item.points) item.points.forEach(p => { p.x += dx; p.y += dy; });
            if (item.x !== undefined) { item.x += dx; item.y += dy; }
            // Sync stroke
            this.syncStroke(item);
        }
        
        this.scheduleRender();
        this.updateSelectBox();
    },
    
    // ==================== RESIZE HANDLES ====================
    setupResizeHandles() {
        document.querySelectorAll('.wb-resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', e => {
                e.stopPropagation();
                if (!this.selected) return;
                this.isResizing = true;
                this.resizeHandle = handle.dataset.handle;
                // Store original state for resize
                const { type, item } = this.selected;
                this.resizeStart = { 
                    x: e.clientX, 
                    y: e.clientY, 
                    bounds: this.getSelectedBounds(),
                    // Store original item properties
                    origItem: JSON.parse(JSON.stringify(item))
                };
            });
        });
        
        window.addEventListener('mousemove', e => {
            if (this.isResizing) this.handleResize(e);
        });
        
        window.addEventListener('mouseup', () => {
            if (this.isResizing) {
                this.isResizing = false;
                this.resizeHandle = null;
                this.resizeStart = null;
                // Sync after resize
                if (this.selected?.type === 'token') this.syncToken(this.selected.item);
                if (this.selected?.type === 'stroke') this.syncStroke(this.selected.item);
            }
        });
    },
    
    handleResize(e) {
        if (!this.selected || !this.resizeStart) return;
        
        const dx = (e.clientX - this.resizeStart.x) / this.zoom;
        const dy = (e.clientY - this.resizeStart.y) / this.zoom;
        const h = this.resizeHandle;
        const { type, item } = this.selected;
        const orig = this.resizeStart.bounds;
        const origItem = this.resizeStart.origItem;
        
        if (type === 'token') {
            // Token: resize = change size (keep center)
            let sizeDelta = 0;
            if (h.includes('e') || h.includes('s')) sizeDelta = Math.max(dx, dy);
            if (h.includes('w') || h.includes('n')) sizeDelta = -Math.min(dx, dy);
            item.size = Math.max(20, Math.min(200, origItem.size + sizeDelta * 2));
        } 
        else if (type === 'image') {
            // Image: resize by edge/corner
            if (h.includes('e')) item.w = Math.max(30, origItem.w + dx);
            if (h.includes('w')) { item.x = origItem.x + dx; item.w = Math.max(30, origItem.w - dx); }
            if (h.includes('s')) item.h = Math.max(30, origItem.h + dy);
            if (h.includes('n')) { item.y = origItem.y + dy; item.h = Math.max(30, origItem.h - dy); }
        }
        else if (type === 'stroke') {
            // Handle different stroke types
            if (item.tool === 'text') {
                // Text: resize = change font size
                let sizeDelta = Math.max(dx, dy) / 4;
                if (h.includes('w') || h.includes('n')) sizeDelta = -sizeDelta;
                item.size = Math.max(1, Math.min(32, origItem.size + sizeDelta));
            }
            else if (item.tool === 'stamp') {
                // Stamp: resize = change stamp size
                let sizeDelta = Math.max(dx, dy);
                if (h.includes('w') || h.includes('n')) sizeDelta = -sizeDelta;
                item.stampSize = Math.max(20, Math.min(120, (origItem.stampSize || 40) + sizeDelta));
            }
            else if (['rect', 'circle', 'line', 'arrow'].includes(item.tool)) {
                // Shapes: resize by moving start/end points
                if (h.includes('e')) item.end.x = origItem.end.x + dx;
                if (h.includes('w')) item.start.x = origItem.start.x + dx;
                if (h.includes('s')) item.end.y = origItem.end.y + dy;
                if (h.includes('n')) item.start.y = origItem.start.y + dy;
                // Corner handles move both
                if (h === 'se') { item.end.x = origItem.end.x + dx; item.end.y = origItem.end.y + dy; }
                if (h === 'nw') { item.start.x = origItem.start.x + dx; item.start.y = origItem.start.y + dy; }
                if (h === 'ne') { item.end.x = origItem.end.x + dx; item.start.y = origItem.start.y + dy; }
                if (h === 'sw') { item.start.x = origItem.start.x + dx; item.end.y = origItem.end.y + dy; }
            }
        }
        
        this.scheduleRender();
        this.updateSelectBox();
    },
    
    // ==================== DRAWING ====================
    drawLivePen(p) {
        const ctx = this.layer === 'fog' ? this.fogCtx : this.mainCtx;
        ctx.strokeStyle = this.layer === 'fog' ? 'rgba(0,0,0,0.85)' : this.color;
        ctx.lineWidth = this.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (this.currentPath.length >= 2) {
            const prev = this.currentPath[this.currentPath.length - 2];
            ctx.beginPath();
            ctx.moveTo(prev.x * this.zoom + this.panX, prev.y * this.zoom + this.panY);
            ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY);
            ctx.stroke();
        }
    },
    
    eraseLive(p) {
        // Use fog canvas if on fog layer, otherwise main canvas
        const ctx = this.layer === 'fog' ? this.fogCtx : this.mainCtx;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
    },
    
    // Reveal fog with shape tools (rect, circle)
    revealFogShape(start, end) {
        const ctx = this.fogCtx;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'black';
        
        const sx = start.x * this.zoom + this.panX;
        const sy = start.y * this.zoom + this.panY;
        const ex = end.x * this.zoom + this.panX;
        const ey = end.y * this.zoom + this.panY;
        
        ctx.beginPath();
        if (this.tool === 'rect') {
            ctx.fillRect(Math.min(sx, ex), Math.min(sy, ey), Math.abs(ex - sx), Math.abs(ey - sy));
        } else if (this.tool === 'circle') {
            const rx = Math.abs(ex - sx) / 2;
            const ry = Math.abs(ey - sy) / 2;
            ctx.ellipse((sx + ex) / 2, (sy + ey) / 2, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
    },
    
    addStroke(s) {
        if (this.historyIdx < this.history.length - 1) this.history = this.history.slice(0, this.historyIdx + 1);
        this.strokes.push(s);
        this.history.push({ type: 'stroke', data: s });
        this.historyIdx = this.history.length - 1;
        this.render();
    },
    
    finishPolygon() {
        if (this.polygonPoints.length < 3) { this.polygonPoints = []; this.renderUI(); return; }
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: this.layer, tool: 'polygon', color: this.color, size: this.size, fill: this.fill,
            points: [...this.polygonPoints], userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
        this.polygonPoints = [];
        this.renderUI();
    },
    
    // ==================== RENDER ====================
    render() {
        this.renderBg();
        this.renderMain();
        this.renderImages();
        this.renderTokens();
        this.renderFog();
        this.updateGrid();
        if (this.selected) this.updateSelectBox();
    },
    
    renderBg() {
        const ctx = this.bgCtx;
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
        if (this.bgImage && this.bgImage.complete)
            ctx.drawImage(this.bgImage, this.panX, this.panY, this.bgImage.width * this.zoom, this.bgImage.height * this.zoom);
    },
    
    renderMain() {
        const ctx = this.mainCtx;
        ctx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
        this.strokes.filter(s => s.layer === 'main').forEach(s => this.drawStroke(ctx, s));
    },
    
    renderImages() {
        const c = document.getElementById('imagesContainer');
        c.innerHTML = '';
        this.images.forEach((img, i) => {
            const el = document.createElement('div');
            const isSelected = this.selected?.type === 'image' && this.selected?.item === img;
            const x = img.x * this.zoom + this.panX;
            const y = img.y * this.zoom + this.panY;
            const w = img.w * this.zoom;
            const h = img.h * this.zoom;
            
            el.className = 'wb-image' + (isSelected ? ' selected' : '');
            el.style.width = w + 'px';
            el.style.height = h + 'px';
            el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            el.innerHTML = `<img src="${img.src}" draggable="false">`;
            el.dataset.idx = i;
            el.draggable = false;
            el.ondragstart = () => false;
            el.onmousedown = e => {
                e.preventDefault();
                e.stopPropagation();
                if (this.tool === 'select') {
                    this.select({ type: 'image', item: img, index: i });
                    this.isDragging = true;
                    this.lastDragPoint = this.getPoint(e);
                }
            };
            c.appendChild(el);
        });
    },
    
    renderTokens() {
        const c = document.getElementById('tokensContainer');
        c.innerHTML = '';
        this.tokens.forEach((t, i) => {
            const el = document.createElement('div');
            const isSelected = this.selected?.type === 'token' && this.selected?.item === t;
            const isActiveTurn = this.initiativeActive === t.id;
            const isDead = t.status?.includes('dead') || (t.hp !== undefined && t.hp <= 0);
            const displaySize = t.size * this.zoom;
            const x = t.x * this.zoom + this.panX - displaySize / 2;
            const y = t.y * this.zoom + this.panY - displaySize / 2;
            
            el.className = 'wb-token' + (isSelected ? ' selected' : '') + (isActiveTurn ? ' active-turn' : '') + (isDead ? ' dead' : '');
            el.style.width = displaySize + 'px';
            el.style.height = displaySize + 'px';
            el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            el.style.background = t.img ? 'transparent' : t.color;
            el.style.borderColor = t.borderColor || '#8b5cf6';
            el.style.fontSize = (displaySize * 0.4) + 'px';
            
            // Inner content (portrait or letter)
            let html = '';
            if (t.img) {
                html += `<img src="${t.img}" style="width:100%;height:100%;object-fit:cover;border-radius:50%" draggable="false">`;
            } else {
                html += t.label || t.name?.charAt(0) || '?';
            }
            
            // HP bar (only show if maxHp > 0)
            if (t.maxHp && t.maxHp > 0) {
                const hpPercent = Math.max(0, Math.min(100, (t.hp / t.maxHp) * 100));
                const hpClass = hpPercent <= 25 ? 'critical' : hpPercent <= 50 ? 'low' : '';
                html += `<div class="wb-token__hp"><div class="wb-token__hp-fill ${hpClass}" style="width:${hpPercent}%"></div></div>`;
            }
            
            // Name label (moved down if HP bar exists)
            const labelBottom = (t.maxHp && t.maxHp > 0) ? '-28px' : '-20px';
            html += `<span class="wb-token__label" style="bottom:${labelBottom}">${t.name || ''}</span>`;
            
            // Initiative badge
            if (t.initiative !== undefined && t.initiative !== null && t.initiative !== '') {
                html += `<div class="wb-token__initiative">${t.initiative}</div>`;
            }
            
            // Status effects
            if (t.status && t.status.length > 0) {
                const statusIcons = {
                    dead: 'üíÄ', unconscious: 'üòµ', poisoned: 'ü§¢', burning: 'üî•', 
                    frozen: '‚ùÑÔ∏è', stunned: '‚ö°', invisible: 'üëÅÔ∏è', blessed: '‚ú®',
                    cursed: 'üíú', prone: 'üõèÔ∏è', grappled: 'ü§ù', concentrating: 'üéØ'
                };
                html += '<div class="wb-token__status">';
                t.status.forEach(s => {
                    if (statusIcons[s]) html += `<div class="wb-token__status-icon">${statusIcons[s]}</div>`;
                });
                html += '</div>';
            }
            
            el.innerHTML = html;
            el.dataset.idx = i;
            el.draggable = false;
            el.ondragstart = () => false;
            el.onmousedown = e => {
                e.preventDefault();
                e.stopPropagation();
                if (this.tool === 'select') {
                    this.select({ type: 'token', item: t, index: i });
                    this.isDragging = true;
                    this.lastDragPoint = this.getPoint(e);
                }
            };
            el.ondblclick = e => {
                e.preventDefault();
                e.stopPropagation();
                this.showTokenEditModal(t);
            };
            c.appendChild(el);
        });
    },
    
    renderFog() {
        const ctx = this.fogCtx;
        ctx.clearRect(0, 0, this.fogCanvas.width, this.fogCanvas.height);
        this.strokes.filter(s => s.layer === 'fog').forEach(s => this.drawStroke(ctx, s));
    },
    
    renderUI() {
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        
        // Shape preview
        if (this.isDrawing && this.startPoint && this.currentPath.length > 0) {
            const end = this.currentPath[this.currentPath.length - 1];
            this.drawShapePreview(ctx, this.startPoint, end);
        }
        
        // Polygon preview
        if (this.polygonPoints.length > 0) {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(this.polygonPoints[0].x * this.zoom + this.panX, this.polygonPoints[0].y * this.zoom + this.panY);
            this.polygonPoints.forEach(pt => ctx.lineTo(pt.x * this.zoom + this.panX, pt.y * this.zoom + this.panY));
            ctx.stroke();
            ctx.setLineDash([]);
            this.polygonPoints.forEach(pt => {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(pt.x * this.zoom + this.panX, pt.y * this.zoom + this.panY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    },
    
    drawStroke(ctx, s) {
        ctx.strokeStyle = s.color;
        ctx.fillStyle = s.color;
        ctx.lineWidth = s.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (s.tool === 'pen' || s.tool === 'eraser') {
            if (s.path && s.path.length > 1) {
                ctx.beginPath();
                ctx.moveTo(s.path[0].x * this.zoom + this.panX, s.path[0].y * this.zoom + this.panY);
                s.path.forEach(p => ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY));
                ctx.stroke();
            }
        } else if (s.tool === 'text') {
            const fontSize = (s.size * 4 + 12) * this.zoom;
            ctx.font = fontSize + 'px sans-serif';
            const tx = s.start.x * this.zoom + this.panX;
            const ty = s.start.y * this.zoom + this.panY;
            
            // Draw background if enabled
            if (s.bg) {
                const textWidth = ctx.measureText(s.text).width;
                const pad = 4 * this.zoom;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(tx - pad, ty - fontSize * 0.85, textWidth + pad * 2, fontSize * 1.1);
            }
            
            ctx.fillStyle = s.color;
            ctx.fillText(s.text, tx, ty);
        } else if (s.tool === 'stamp') {
            const stampSize = (s.stampSize || 40) * this.zoom;
            ctx.font = stampSize + 'px sans-serif';
            ctx.fillText(s.stamp, s.x * this.zoom + this.panX, s.y * this.zoom + this.panY);
        } else if (s.tool === 'polygon' && s.points) {
            ctx.beginPath();
            ctx.moveTo(s.points[0].x * this.zoom + this.panX, s.points[0].y * this.zoom + this.panY);
            s.points.forEach(p => ctx.lineTo(p.x * this.zoom + this.panX, p.y * this.zoom + this.panY));
            ctx.closePath();
            if (s.fill) ctx.fill();
            ctx.stroke();
        } else {
            this.drawShape(ctx, s);
        }
    },
    
    drawShape(ctx, s) {
        if (!s.start || !s.end) return;
        const sx = s.start.x * this.zoom + this.panX, sy = s.start.y * this.zoom + this.panY;
        const ex = s.end.x * this.zoom + this.panX, ey = s.end.y * this.zoom + this.panY;
        ctx.beginPath();
        switch (s.tool) {
            case 'line': ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); break;
            case 'rect':
                if (s.fill) ctx.fillRect(sx, sy, ex - sx, ey - sy);
                ctx.strokeRect(sx, sy, ex - sx, ey - sy); return;
            case 'circle':
                const rx = Math.abs(ex - sx) / 2, ry = Math.abs(ey - sy) / 2;
                ctx.ellipse(sx + (ex - sx) / 2, sy + (ey - sy) / 2, rx, ry, 0, 0, Math.PI * 2);
                if (s.fill) ctx.fill(); break;
            case 'arrow':
                ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
                const a = Math.atan2(ey - sy, ex - sx), hl = 15 * this.zoom;
                ctx.lineTo(ex - hl * Math.cos(a - Math.PI / 6), ey - hl * Math.sin(a - Math.PI / 6));
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - hl * Math.cos(a + Math.PI / 6), ey - hl * Math.sin(a + Math.PI / 6)); break;
        }
        ctx.stroke();
    },
    
    drawShapePreview(ctx, start, end) {
        ctx.strokeStyle = this.color;
        ctx.fillStyle = this.color + '40';
        ctx.lineWidth = this.size;
        ctx.setLineDash([5, 5]);
        const sx = start.x * this.zoom + this.panX, sy = start.y * this.zoom + this.panY;
        const ex = end.x * this.zoom + this.panX, ey = end.y * this.zoom + this.panY;
        ctx.beginPath();
        switch (this.tool) {
            case 'line': ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); break;
            case 'rect':
                if (this.fill) ctx.fillRect(sx, sy, ex - sx, ey - sy);
                ctx.strokeRect(sx, sy, ex - sx, ey - sy); ctx.setLineDash([]); return;
            case 'circle':
                const rx = Math.abs(ex - sx) / 2, ry = Math.abs(ey - sy) / 2;
                ctx.ellipse(sx + (ex - sx) / 2, sy + (ey - sy) / 2, rx, ry, 0, 0, Math.PI * 2);
                if (this.fill) ctx.fill(); break;
            case 'arrow':
                ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
                const a = Math.atan2(ey - sy, ex - sx);
                ctx.lineTo(ex - 15 * Math.cos(a - Math.PI / 6), ey - 15 * Math.sin(a - Math.PI / 6));
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - 15 * Math.cos(a + Math.PI / 6), ey - 15 * Math.sin(a + Math.PI / 6)); break;
        }
        ctx.stroke();
        ctx.setLineDash([]);
    },
    
    // ==================== TOOLS ====================
    showTextInput(p) {
        const inp = document.getElementById('textInput');
        inp.style.left = p.sx + 'px';
        inp.style.top = p.sy + 'px';
        inp.style.display = 'block';
        inp.style.color = this.color;
        inp.dataset.x = p.x;
        inp.dataset.y = p.y;
        inp.value = '';
        setTimeout(() => inp.focus(), 50);
    },
    
    placeText(text, x, y) {
        if (!text.trim()) return;
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: 'main', tool: 'text', color: this.color, size: this.size, text,
            start: { x: parseFloat(x), y: parseFloat(y) }, userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
    },
    
    createPing(sx, sy) {
        const ping = document.createElement('div');
        ping.className = 'wb-ping';
        ping.style.left = sx + 'px';
        ping.style.top = sy + 'px';
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'wb-ping__ring';
            ring.style.borderColor = this.userColor;
            ring.style.animationDelay = (i * 0.15) + 's';
            ping.appendChild(ring);
        }
        const dot = document.createElement('div');
        dot.className = 'wb-ping__dot';
        dot.style.background = this.userColor;
        ping.appendChild(dot);
        document.getElementById('canvasWrapper').appendChild(ping);
        this.syncPing(sx, sy);
        setTimeout(() => ping.remove(), 1500);
    },
    
    showRuler(start, end) {
        const dx = end.x - start.x, dy = end.y - start.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const grids = Math.round(dist / this.gridSize);
        const info = document.getElementById('rulerInfo');
        info.style.display = 'block';
        info.style.left = (end.sx + 15) + 'px';
        info.style.top = (end.sy - 15) + 'px';
        info.innerHTML = `<strong>${grids}</strong> Felder<br><span style="opacity:0.7;font-size:12px">${Math.round(dist)}px</span>`;
        
        const ctx = this.uiCtx;
        ctx.clearRect(0, 0, this.uiCanvas.width, this.uiCanvas.height);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(start.x * this.zoom + this.panX, start.y * this.zoom + this.panY);
        ctx.lineTo(end.x * this.zoom + this.panX, end.y * this.zoom + this.panY);
        ctx.stroke();
        ctx.setLineDash([]);
    },
    
    setupStamps() {
        const grid = document.getElementById('stampsGrid');
        this.stamps.forEach(st => {
            const btn = document.createElement('button');
            btn.className = 'wb-stamp';
            btn.textContent = st;
            btn.onclick = () => {
                document.querySelectorAll('.wb-stamp').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                this.selectedStamp = st;
                this.tool = 'stamp';
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                document.getElementById('stampsPanel').classList.remove('visible');
            };
            grid.appendChild(btn);
        });
    },
    
    placeStamp(p) {
        const s = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            layer: 'main', tool: 'stamp', stamp: this.selectedStamp,
            x: p.x, y: p.y, stampSize: 40, userId: this.userId, ts: Date.now()
        };
        this.addStroke(s);
        this.syncStroke(s);
    },
    
    showTokenModal() {
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280', this.userColor];
        
        // Background color picker
        const picker = document.getElementById('tokenColorPicker');
        picker.innerHTML = '';
        this.pendingTokenColor = this.pendingTokenColor || this.userColor;
        colors.forEach(c => {
            const btn = document.createElement('button');
            btn.style.cssText = `width:28px;height:28px;border-radius:50%;border:3px solid ${c === this.pendingTokenColor ? 'white' : 'transparent'};background:${c};cursor:pointer`;
            btn.onclick = () => {
                this.pendingTokenColor = c;
                picker.querySelectorAll('button').forEach(b => b.style.borderColor = 'transparent');
                btn.style.borderColor = 'white';
            };
            picker.appendChild(btn);
        });
        
        // Border color picker
        const borderPicker = document.getElementById('tokenBorderPicker');
        borderPicker.innerHTML = '';
        this.pendingTokenBorder = this.pendingTokenBorder || '#8b5cf6';
        colors.forEach(c => {
            const btn = document.createElement('button');
            btn.style.cssText = `width:28px;height:28px;border-radius:50%;border:3px solid ${c === this.pendingTokenBorder ? 'white' : 'transparent'};background:${c};cursor:pointer`;
            btn.onclick = () => {
                this.pendingTokenBorder = c;
                borderPicker.querySelectorAll('button').forEach(b => b.style.borderColor = 'transparent');
                btn.style.borderColor = 'white';
                document.getElementById('tokenPortraitPreview').style.borderColor = c;
            };
            borderPicker.appendChild(btn);
        });
        
        // Portrait preview & upload
        this.pendingTokenImg = null;
        const preview = document.getElementById('tokenPortraitPreview');
        preview.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>';
        preview.style.borderColor = this.pendingTokenBorder;
        preview.onclick = () => document.getElementById('tokenPortraitInput').click();
        
        document.getElementById('tokenPortraitInput').onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                this.pendingTokenImg = ev.target.result;
                preview.innerHTML = `<img src="${ev.target.result}" style="width:100%;height:100%;object-fit:cover">`;
            };
            reader.readAsDataURL(file);
        };
        
        document.getElementById('tokenNameInput').value = '';
        document.getElementById('tokenOverlay').classList.add('visible');
    },
    
    createToken(name, color, x, y, borderColor, img) {
        const t = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            x: x ?? (this.mainCanvas.width / 2 / this.zoom - this.panX / this.zoom),
            y: y ?? (this.mainCanvas.height / 2 / this.zoom - this.panY / this.zoom),
            size: this.gridSize || 70, // Default to grid size for 1x1 token
            color: color || this.userColor,
            borderColor: borderColor || '#8b5cf6',
            name: name || this.userName, 
            label: (name || this.userName).charAt(0).toUpperCase(),
            userId: this.userId,
            hp: 0,
            maxHp: 0,
            initiative: null,
            ac: 10,
            status: []
        };
        if (img) t.img = img;
        this.tokens.push(t);
        this.syncToken(t);
        this.renderTokens();
        this.renderInitiative();
        this.toast('Token: ' + t.name);
    },
    
    // ==================== TOKEN EDIT MODAL ====================
    showTokenEditModal(token) {
        this.editingToken = token;
        document.getElementById('editTokenName').value = token.name || '';
        document.getElementById('editTokenHp').value = token.hp || 0;
        document.getElementById('editTokenMaxHp').value = token.maxHp || 0;
        document.getElementById('editTokenInit').value = token.initiative ?? '';
        document.getElementById('editTokenAc').value = token.ac || 10;
        
        // Size presets
        document.querySelectorAll('#tokenSizePresets .wb-size-preset').forEach(btn => {
            const size = parseInt(btn.dataset.size);
            btn.classList.toggle('active', Math.abs(token.size - size) < 10);
        });
        
        // Status effects
        document.querySelectorAll('#statusGrid .wb-status-btn').forEach(btn => {
            const status = btn.dataset.status;
            btn.classList.toggle('active', token.status?.includes(status));
        });
        
        document.getElementById('tokenEditOverlay').classList.add('visible');
    },
    
    saveTokenEdit() {
        if (!this.editingToken) return;
        
        const t = this.editingToken;
        t.name = document.getElementById('editTokenName').value || t.name;
        t.label = t.name.charAt(0).toUpperCase();
        t.hp = parseInt(document.getElementById('editTokenHp').value) || 0;
        t.maxHp = parseInt(document.getElementById('editTokenMaxHp').value) || 0;
        const initVal = document.getElementById('editTokenInit').value;
        t.initiative = initVal === '' ? null : parseInt(initVal);
        t.ac = parseInt(document.getElementById('editTokenAc').value) || 10;
        
        // Get selected size
        const activeSize = document.querySelector('#tokenSizePresets .wb-size-preset.active');
        if (activeSize) t.size = parseInt(activeSize.dataset.size);
        
        // Get active statuses
        t.status = [];
        document.querySelectorAll('#statusGrid .wb-status-btn.active').forEach(btn => {
            t.status.push(btn.dataset.status);
        });
        
        this.syncToken(t);
        this.renderTokens();
        this.renderInitiative();
        document.getElementById('tokenEditOverlay').classList.remove('visible');
        this.editingToken = null;
        this.toast('Token aktualisiert');
    },
    
    setupTokenEditModal() {
        // Size presets
        document.querySelectorAll('#tokenSizePresets .wb-size-preset').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('#tokenSizePresets .wb-size-preset').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        // Status toggles
        document.querySelectorAll('#statusGrid .wb-status-btn').forEach(btn => {
            btn.onclick = () => btn.classList.toggle('active');
        });
        
        // Save button
        document.getElementById('tokenEditSaveBtn').onclick = () => this.saveTokenEdit();
    },
    
    // ==================== INITIATIVE TRACKER ====================
    setupInitiative() {
        document.getElementById('initiativeBtn').onclick = () => {
            document.getElementById('initiativePanel').classList.toggle('visible');
            this.renderInitiative();
        };
        
        document.getElementById('initNextBtn').onclick = () => this.nextTurn();
        document.getElementById('initPrevBtn').onclick = () => this.prevTurn();
        document.getElementById('initSortBtn').onclick = () => this.sortInitiative();
        document.getElementById('initResetBtn').onclick = () => this.resetInitiative();
    },
    
    renderInitiative() {
        const list = document.getElementById('initiativeList');
        if (!list) return;
        
        // Build initiative order from tokens with initiative values
        const tokensWithInit = this.tokens
            .filter(t => t.initiative !== null && t.initiative !== undefined)
            .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        
        list.innerHTML = '';
        tokensWithInit.forEach(t => {
            const isDead = t.status?.includes('dead') || (t.hp !== undefined && t.hp <= 0);
            const isActive = this.initiativeActive === t.id;
            
            const item = document.createElement('div');
            item.className = 'wb-initiative-item' + (isActive ? ' active' : '') + (isDead ? ' dead' : '');
            item.dataset.id = t.id;
            
            item.innerHTML = `
                <div class="wb-initiative-item__portrait" style="background:${t.img ? 'transparent' : t.color}">
                    ${t.img ? `<img src="${t.img}">` : t.label || '?'}
                </div>
                <div class="wb-initiative-item__info">
                    <div class="wb-initiative-item__name">${t.name || 'Token'}</div>
                    <div class="wb-initiative-item__hp">${t.maxHp ? `HP: ${t.hp}/${t.maxHp}` : ''} ${t.ac ? `AC: ${t.ac}` : ''}</div>
                </div>
                <div class="wb-initiative-item__init">
                    <input type="number" value="${t.initiative ?? ''}" style="width:100%;background:transparent;border:none;color:white;text-align:center;font-weight:700">
                </div>
            `;
            
            // Click to make active turn
            item.onclick = e => {
                if (e.target.tagName === 'INPUT') return;
                this.initiativeActive = t.id;
                this.renderTokens();
                this.renderInitiative();
                // Pan to token
                this.targetPanX = this.mainCanvas.width / 2 - t.x * this.zoom;
                this.targetPanY = this.mainCanvas.height / 2 - t.y * this.zoom;
                this.startAnimation();
            };
            
            // Initiative input change
            const input = item.querySelector('input');
            input.onchange = () => {
                t.initiative = input.value === '' ? null : parseInt(input.value);
                this.syncToken(t);
                this.renderTokens();
            };
            input.onclick = e => e.stopPropagation();
            
            list.appendChild(item);
        });
        
        // If no tokens with initiative, show hint
        if (tokensWithInit.length === 0) {
            list.innerHTML = '<div style="text-align:center;padding:20px;color:rgba(255,255,255,0.4);font-size:12px">Doppelklicke auf Token um Initiative zu setzen</div>';
        }
    },
    
    nextTurn() {
        const tokensWithInit = this.tokens
            .filter(t => t.initiative !== null && t.initiative !== undefined)
            .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        
        if (tokensWithInit.length === 0) return;
        
        const currentIdx = tokensWithInit.findIndex(t => t.id === this.initiativeActive);
        const nextIdx = (currentIdx + 1) % tokensWithInit.length;
        this.initiativeActive = tokensWithInit[nextIdx].id;
        
        // Skip dead tokens
        const nextToken = tokensWithInit[nextIdx];
        if (nextToken.status?.includes('dead') || (nextToken.hp !== undefined && nextToken.hp <= 0)) {
            this.nextTurn(); // Recursive skip
            return;
        }
        
        this.renderTokens();
        this.renderInitiative();
        
        // Pan to active token
        const t = tokensWithInit[nextIdx];
        this.targetPanX = this.mainCanvas.width / 2 - t.x * this.zoom;
        this.targetPanY = this.mainCanvas.height / 2 - t.y * this.zoom;
        this.startAnimation();
        this.toast(`${t.name} ist dran!`);
    },
    
    prevTurn() {
        const tokensWithInit = this.tokens
            .filter(t => t.initiative !== null && t.initiative !== undefined)
            .sort((a, b) => (b.initiative || 0) - (a.initiative || 0));
        
        if (tokensWithInit.length === 0) return;
        
        const currentIdx = tokensWithInit.findIndex(t => t.id === this.initiativeActive);
        const prevIdx = currentIdx <= 0 ? tokensWithInit.length - 1 : currentIdx - 1;
        this.initiativeActive = tokensWithInit[prevIdx].id;
        
        this.renderTokens();
        this.renderInitiative();
        
        const t = tokensWithInit[prevIdx];
        this.targetPanX = this.mainCanvas.width / 2 - t.x * this.zoom;
        this.targetPanY = this.mainCanvas.height / 2 - t.y * this.zoom;
        this.startAnimation();
    },
    
    sortInitiative() {
        // Already sorted in renderInitiative, just re-render
        this.renderInitiative();
        this.toast('Initiative sortiert');
    },
    
    resetInitiative() {
        this.initiativeActive = null;
        this.tokens.forEach(t => {
            t.initiative = null;
        });
        this.renderTokens();
        this.renderInitiative();
        this.toast('Initiative zur√ºckgesetzt');
    },
    
    // ==================== UPLOADS ====================
    setupUploads() {
        document.getElementById('bgBtn').onclick = () => document.getElementById('bgOverlay').classList.add('visible');
        document.getElementById('bgSelectBtn').onclick = () => document.getElementById('bgFileInput').click();
        document.getElementById('bgFileInput').onchange = e => { if (e.target.files[0]) this.loadBg(e.target.files[0]); };
        document.getElementById('bgRemoveBtn').onclick = () => {
            this.bgImage = null; this.render();
            document.getElementById('bgOverlay').classList.remove('visible');
            this.toast('Hintergrund entfernt');
        };
        
        document.getElementById('imageBtn').onclick = () => document.getElementById('imageOverlay').classList.add('visible');
        document.getElementById('imageSelectBtn').onclick = () => document.getElementById('imageFileInput').click();
        document.getElementById('imageFileInput').onchange = e => { if (e.target.files[0]) this.loadImage(e.target.files[0]); };
        
        ['bgUploadBox', 'imageUploadBox'].forEach(id => {
            const box = document.getElementById(id);
            box.ondragover = e => { e.preventDefault(); box.classList.add('dragover'); };
            box.ondragleave = () => box.classList.remove('dragover');
            box.ondrop = e => {
                e.preventDefault(); box.classList.remove('dragover');
                if (e.dataTransfer.files[0]) {
                    if (id === 'bgUploadBox') this.loadBg(e.dataTransfer.files[0]);
                    else this.loadImage(e.dataTransfer.files[0]);
                }
            };
        });
    },
    
    loadBg(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                this.bgImage = img;
                this.render();
                document.getElementById('bgOverlay').classList.remove('visible');
                this.toast('Hintergrund geladen');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    loadImage(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                const maxW = 400, maxH = 400;
                let w = img.width, h = img.height;
                if (w > maxW) { h = h * maxW / w; w = maxW; }
                if (h > maxH) { w = w * maxH / h; h = maxH; }
                this.images.push({
                    id: Date.now(), src: e.target.result,
                    x: 100 - this.panX / this.zoom, y: 100 - this.panY / this.zoom, w, h
                });
                this.renderImages();
                document.getElementById('imageOverlay').classList.remove('visible');
                this.toast('Bild eingef√ºgt');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    },
    
    // ==================== MODALS ====================
    setupModals() {
        const inp = document.getElementById('textInput');
        inp.onkeydown = e => {
            e.stopPropagation();
            if (e.key === 'Enter' && inp.value.trim()) { 
                this.handleTextInput(inp);
                inp.style.display = 'none'; 
            }
            if (e.key === 'Escape') { inp.style.display = 'none'; inp.dataset.strokeId = ''; }
        };
        inp.onblur = () => {
            setTimeout(() => {
                if (inp.style.display !== 'none' && inp.value.trim()) this.handleTextInput(inp);
                inp.style.display = 'none';
                inp.dataset.strokeId = '';
            }, 150);
        };
        
        document.getElementById('saveBtn').onclick = () => {
            document.getElementById('saveOverlay').classList.add('visible');
            document.getElementById('saveNameInput').focus();
        };
        document.getElementById('saveConfirmBtn').onclick = () => this.saveMap();
        document.getElementById('loadBtn').onclick = () => this.showLoadModal();
        document.getElementById('tokenCreateBtn').onclick = () => {
            const name = document.getElementById('tokenNameInput').value.trim() || 'Token';
            this.createToken(name, this.pendingTokenColor, null, null, this.pendingTokenBorder, this.pendingTokenImg);
            document.getElementById('tokenOverlay').classList.remove('visible');
        };
    },
    
    handleTextInput(inp) {
        const strokeId = inp.dataset.strokeId;
        if (strokeId) {
            // Editing existing text
            const stroke = this.strokes.find(s => s.id === strokeId);
            if (stroke) {
                stroke.text = inp.value;
                this.syncStroke(stroke);
                this.render();
            }
        } else {
            // New text
            this.placeText(inp.value, inp.dataset.x, inp.dataset.y);
        }
        inp.dataset.strokeId = '';
    },
    
    saveMap() {
        const name = document.getElementById('saveNameInput').value.trim() || 'Map ' + new Date().toLocaleDateString();
        const data = { name, date: Date.now(), strokes: this.strokes, tokens: this.tokens, images: this.images, fogAreas: this.fogAreas };
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        saves.unshift(data);
        if (saves.length > 20) saves.pop();
        localStorage.setItem('rift_wb_saves', JSON.stringify(saves));
        document.getElementById('saveOverlay').classList.remove('visible');
        this.toast('Gespeichert: ' + name);
    },
    
    showLoadModal() {
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        const list = document.getElementById('savedList');
        if (saves.length === 0) {
            list.innerHTML = '<p style="color:rgba(255,255,255,0.5);text-align:center;padding:30px">Keine Maps</p>';
        } else {
            list.innerHTML = saves.map((s, i) => `<div class="wb-save-item" onclick="WB.loadMap(${i})"><div><div class="wb-save-item__name">${s.name}</div><div class="wb-save-item__date">${new Date(s.date).toLocaleString()}</div></div><button class="wb-save-item__delete" onclick="event.stopPropagation();WB.deleteMap(${i})">L√∂schen</button></div>`).join('');
        }
        document.getElementById('loadOverlay').classList.add('visible');
    },
    
    loadMap(idx) {
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        const save = saves[idx];
        if (!save) return;
        this.strokes = save.strokes || [];
        this.tokens = save.tokens || [];
        this.images = save.images || [];
        this.fogAreas = save.fogAreas || [];
        this.render();
        document.getElementById('loadOverlay').classList.remove('visible');
        this.toast('Geladen: ' + save.name);
    },
    
    deleteMap(idx) {
        if (!confirm('L√∂schen?')) return;
        const saves = JSON.parse(localStorage.getItem('rift_wb_saves') || '[]');
        saves.splice(idx, 1);
        localStorage.setItem('rift_wb_saves', JSON.stringify(saves));
        this.showLoadModal();
    },
    
    // ==================== CONTEXT MENU ====================
    setupContextMenu() {
        document.querySelectorAll('.wb-context-item').forEach(item => {
            item.onclick = () => {
                const action = item.dataset.action;
                if (action === 'delete') this.deleteSelected();
                else if (action === 'duplicate') this.duplicateSelected();
                else if (action === 'front') this.moveToFront();
                else if (action === 'back') this.moveToBack();
                else if (action === 'edit') this.editSelected();
                document.getElementById('contextMenu').classList.remove('visible');
            };
        });
    },
    
    editSelected() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        if (type === 'token') {
            this.showTokenEditModal(item);
        }
    },
    
    deleteSelected() {
        if (!this.selected) return;
        const { type, item, index } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) this.tokens.splice(idx, 1);
            // Delete from Firebase
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + item.id).remove();
            // Update initiative if this token was active
            if (this.initiativeActive === item.id) this.initiativeActive = null;
            this.renderInitiative();
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) this.images.splice(idx, 1);
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) this.strokes.splice(idx, 1);
            // Delete from Firebase
            if (this.db && this.roomCode) this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + item.id).remove();
        }
        
        this.deselect();
        this.render();
        this.toast('Gel√∂scht');
    },
    
    duplicateSelected() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        const newId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        if (type === 'token') {
            const copy = { 
                ...item, 
                id: newId, 
                x: item.x + 50, 
                y: item.y + 50,
                status: item.status ? [...item.status] : [], // Deep copy status array
                initiative: null // Reset initiative for duplicate
            };
            this.tokens.push(copy);
            this.syncToken(copy);
            this.renderInitiative();
        }
        if (type === 'image') {
            const copy = { ...item, id: Date.now(), x: item.x + 50, y: item.y + 50 };
            this.images.push(copy);
        }
        if (type === 'stroke') {
            const copy = JSON.parse(JSON.stringify(item));
            copy.id = newId;
            // Offset the duplicate
            if (copy.start) { copy.start.x += 50; copy.start.y += 50; }
            if (copy.end) { copy.end.x += 50; copy.end.y += 50; }
            if (copy.path) copy.path.forEach(p => { p.x += 50; p.y += 50; });
            if (copy.points) copy.points.forEach(p => { p.x += 50; p.y += 50; });
            if (copy.x !== undefined) { copy.x += 50; copy.y += 50; }
            this.strokes.push(copy);
            this.syncStroke(copy);
        }
        
        this.render();
        this.toast('Dupliziert');
    },
    
    moveToFront() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) { this.tokens.splice(idx, 1); this.tokens.push(item); }
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) { this.images.splice(idx, 1); this.images.push(item); }
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) { this.strokes.splice(idx, 1); this.strokes.push(item); }
        }
        this.render();
    },
    
    moveToBack() {
        if (!this.selected) return;
        const { type, item } = this.selected;
        
        if (type === 'token') {
            const idx = this.tokens.indexOf(item);
            if (idx > -1) { this.tokens.splice(idx, 1); this.tokens.unshift(item); }
        }
        if (type === 'image') {
            const idx = this.images.indexOf(item);
            if (idx > -1) { this.images.splice(idx, 1); this.images.unshift(item); }
        }
        if (type === 'stroke') {
            const idx = this.strokes.indexOf(item);
            if (idx > -1) { this.strokes.splice(idx, 1); this.strokes.unshift(item); }
        }
        this.render();
    },
    
    // ==================== HISTORY ====================
    undo() {
        if (this.historyIdx < 0) return;
        const action = this.history[this.historyIdx];
        if (action.type === 'stroke') this.strokes = this.strokes.filter(s => s.id !== action.data.id);
        this.historyIdx--;
        this.render();
        this.toast('R√ºckg√§ngig');
    },
    
    redo() {
        if (this.historyIdx >= this.history.length - 1) return;
        this.historyIdx++;
        const action = this.history[this.historyIdx];
        if (action.type === 'stroke') this.strokes.push(action.data);
        this.render();
        this.toast('Wiederholt');
    },
    
    clearAll() {
        // Set flag to prevent listeners from re-adding data
        this.isClearing = true;
        
        // Clear local state
        this.strokes = []; 
        this.images = []; 
        this.tokens = []; 
        this.fogAreas = [];
        this.bgImage = null; 
        this.history = []; 
        this.historyIdx = -1;
        this.initiativeActive = null;
        this.initiativeOrder = [];
        this.deselect();
        this.render();
        this.renderInitiative();
        
        // Clear Firebase data for this room
        if (this.db && this.roomCode) {
            const ref = this.db.ref('whiteboard/' + this.roomCode);
            
            // Detach listeners BEFORE deleting to prevent re-sync
            this.detachFirebaseListeners();
            
            // Use remove() instead of set(null) - more explicit
            ref.remove()
                .then(() => {
                    console.log('[WB] ‚úÖ Firebase data REMOVED for room:', this.roomCode);
                    
                    // Re-attach listeners after delete is confirmed
                    setTimeout(() => {
                        this.isClearing = false;
                        this.setupFirebaseListeners();
                        console.log('[WB] Listeners re-attached');
                    }, 1000);
                })
                .catch(err => {
                    console.error('[WB] ‚ùå Error removing Firebase data:', err);
                    this.isClearing = false;
                    // Re-attach listeners anyway
                    this.setupFirebaseListeners();
                });
        } else {
            console.warn('[WB] No Firebase connection, only cleared locally');
            this.isClearing = false;
        }
        
        this.toast('Alles gel√∂scht');
    },
    
    exportPNG() {
        const canvas = document.createElement('canvas');
        canvas.width = this.bgCanvas.width;
        canvas.height = this.bgCanvas.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(this.bgCanvas, 0, 0);
        ctx.drawImage(this.mainCanvas, 0, 0);
        // Draw images
        this.images.forEach(img => {
            const el = new Image();
            el.src = img.src;
            ctx.drawImage(el, img.x * this.zoom + this.panX, img.y * this.zoom + this.panY, img.w * this.zoom, img.h * this.zoom);
        });
        // Draw tokens
        this.tokens.forEach(t => {
            ctx.fillStyle = t.color;
            ctx.beginPath();
            ctx.arc(t.x * this.zoom + this.panX, t.y * this.zoom + this.panY, t.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.font = 'bold ' + (t.size * 0.4) + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(t.label, t.x * this.zoom + this.panX, t.y * this.zoom + this.panY);
        });
        const link = document.createElement('a');
        link.download = 'whiteboard-' + Date.now() + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        this.toast('PNG exportiert');
    },
    
    // ==================== KEYBOARD ====================
    setupKeyboard() {
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); this.undo(); }
            if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); this.redo(); }
            
            const toolMap = { p: 'pen', l: 'line', r: 'rect', c: 'circle', a: 'arrow', t: 'text', e: 'eraser', v: 'select', m: 'ruler' };
            if (toolMap[e.key.toLowerCase()]) document.querySelector(`[data-tool="${toolMap[e.key.toLowerCase()]}"]`)?.click();
            
            if (e.shiftKey && e.key.toLowerCase() === 'p') document.querySelector('[data-tool="polygon"]')?.click();
            if (e.key.toLowerCase() === 'g') document.getElementById('gridToggle').click();
            
            if ((e.key === 'Delete' || e.key === 'Backspace') && this.selected) this.deleteSelected();
            
            if (e.key === 'Escape') {
                this.deselect();
                this.polygonPoints = [];
                document.querySelectorAll('.wb-overlay').forEach(o => o.classList.remove('visible'));
                document.getElementById('stampsPanel').classList.remove('visible');
                document.getElementById('contextMenu').classList.remove('visible');
                this.renderUI();
            }
        });
    },
    
    // ==================== FIREBASE ====================
    firebaseListeners: [], // Track listeners for cleanup
    isClearing: false, // Flag to prevent re-adding during clear
    
    async connectFirebase() {
        try {
            this.db = firebase.database();
            
            // Force server sync, not cache
            const snap = await this.db.ref('whiteboard/' + this.roomCode).once('value');
            const data = snap.val();
            
            console.log('[WB] Firebase data loaded:', data ? 'has data' : 'empty');
            
            if (data) {
                this.strokes = data.strokes ? Object.values(data.strokes) : [];
                this.tokens = data.tokens ? Object.values(data.tokens) : [];
                console.log('[WB] Loaded', this.strokes.length, 'strokes,', this.tokens.length, 'tokens');
                this.render();
            } else {
                // Ensure local state is empty if Firebase is empty
                this.strokes = [];
                this.tokens = [];
                this.render();
                console.log('[WB] Firebase empty, cleared local state');
            }
            
            // Setup listeners and track them
            this.setupFirebaseListeners();
            
            console.log('[WB] Firebase connected');
        } catch (err) {
            console.error('[WB] Firebase error:', err);
        }
    },
    
    setupFirebaseListeners() {
        if (!this.db || !this.roomCode) return;
        
        // Clear existing listeners first
        this.detachFirebaseListeners();
        
        const strokesRef = this.db.ref('whiteboard/' + this.roomCode + '/strokes');
        const tokensRef = this.db.ref('whiteboard/' + this.roomCode + '/tokens');
        const pingsRef = this.db.ref('whiteboard/' + this.roomCode + '/pings');
        
        // Track initial load to ignore cached child_added events
        let strokesInitialized = false;
        
        // Strokes: Use value listener to get current state, then switch to child events
        strokesRef.once('value').then(() => {
            strokesInitialized = true;
            console.log('[WB] Strokes listener initialized');
        });
        
        // Strokes: child_added - only for NEW strokes after init
        strokesRef.on('child_added', snap => {
            if (this.isClearing) return;
            if (!strokesInitialized) return; // Skip initial sync
            
            const s = snap.val();
            if (s && s.userId !== this.userId && !this.strokes.find(x => x.id === s.id)) {
                this.strokes.push(s);
                this.render();
                console.log('[WB] Remote stroke added:', s.id);
            }
        });
        
        // Strokes: child_removed
        strokesRef.on('child_removed', snap => {
            const s = snap.val();
            if (s) {
                const idx = this.strokes.findIndex(x => x.id === s.id);
                if (idx !== -1) {
                    this.strokes.splice(idx, 1);
                    this.render();
                    console.log('[WB] Remote stroke removed:', s.id);
                }
            }
        });
        
        // Tokens: value listener with proper null handling
        tokensRef.on('value', snap => {
            if (this.isClearing) return;
            const tokens = snap.val();
            
            if (!tokens) {
                // Firebase cleared - sync local state
                if (this.tokens.length > 0) {
                    this.tokens = [];
                    this.renderTokens();
                    console.log('[WB] Tokens cleared from remote');
                }
                return;
            }
            
            // Get remote token IDs
            const remoteIds = Object.keys(tokens);
            
            // Remove tokens that no longer exist remotely
            this.tokens = this.tokens.filter(t => {
                if (t.userId === this.userId) return true; // Keep own tokens
                return remoteIds.includes(t.id);
            });
            
            // Add/update remote tokens
            Object.values(tokens).forEach(rt => {
                const existing = this.tokens.find(t => t.id === rt.id);
                if (existing) { 
                    if (rt.userId !== this.userId) Object.assign(existing, rt); 
                } else {
                    this.tokens.push(rt);
                }
            });
            this.renderTokens();
        });
        
        // Pings
        pingsRef.on('child_added', snap => {
            const p = snap.val();
            if (p && p.userId !== this.userId && Date.now() - p.ts < 3000) this.showRemotePing(p);
        });
        
        // Track refs for cleanup
        this.firebaseListeners = [
            { ref: strokesRef, event: 'child_added' },
            { ref: strokesRef, event: 'child_removed' },
            { ref: tokensRef, event: 'value' },
            { ref: pingsRef, event: 'child_added' }
        ];
    },
    
    detachFirebaseListeners() {
        this.firebaseListeners.forEach(l => {
            try { l.ref.off(l.event); } catch(e) {}
        });
        this.firebaseListeners = [];
    },
    
    syncStroke(s) { if (!this.db || !this.roomCode) return; this.db.ref('whiteboard/' + this.roomCode + '/strokes/' + s.id).set(s); },
    syncToken(t) { if (!this.db || !this.roomCode) return; this.db.ref('whiteboard/' + this.roomCode + '/tokens/' + t.id).set(t); },
    syncPing(sx, sy) {
        if (!this.db || !this.roomCode) return;
        const id = Date.now() + '-' + this.userId;
        this.db.ref('whiteboard/' + this.roomCode + '/pings/' + id).set({ sx, sy, color: this.userColor, userId: this.userId, ts: Date.now() });
        setTimeout(() => this.db.ref('whiteboard/' + this.roomCode + '/pings/' + id).remove(), 3000);
    },
    
    showRemotePing(p) {
        const ping = document.createElement('div');
        ping.className = 'wb-ping';
        ping.style.left = p.sx + 'px';
        ping.style.top = p.sy + 'px';
        for (let i = 0; i < 3; i++) {
            const ring = document.createElement('div');
            ring.className = 'wb-ping__ring';
            ring.style.borderColor = p.color;
            ring.style.animationDelay = (i * 0.15) + 's';
            ping.appendChild(ring);
        }
        const dot = document.createElement('div');
        dot.className = 'wb-ping__dot';
        dot.style.background = p.color;
        ping.appendChild(dot);
        document.getElementById('canvasWrapper').appendChild(ping);
        setTimeout(() => ping.remove(), 1500);
    },
    
    toast(msg) {
        const t = document.getElementById('wbToast');
        t.textContent = msg;
        t.classList.add('visible');
        setTimeout(() => t.classList.remove('visible'), 2000);
    }
};

function initWB() {
    if (document.querySelector('.sidebar') && document.querySelector('.topbar')) setTimeout(() => WB.init(), 100);
    else setTimeout(initWB, 100);
}
document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', () => setTimeout(initWB, 200)) : setTimeout(initWB, 200);
    </script>
</body>
</html>
