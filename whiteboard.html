<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="PnP Companion - Whiteboard">
    <meta name="theme-color" content="#6750a4">
    <title>Whiteboard - PnP Companion</title>
    <script>(function(){var t=localStorage.getItem('pnp_theme')||'dark';document.documentElement.setAttribute('data-theme',t)})();</script>
    <link rel="icon" type="image/png" href="assets/icons/icon_favicon.png">
    <link rel="manifest" href="manifest.json">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/global.css">
    
    <style>
        * { box-sizing: border-box; }
        body { padding-top: 60px; overflow: hidden; }
        .whiteboard-container { position: fixed; top: 60px; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; }
        
        /* Toolbar */
        .toolbar { display: flex; align-items: center; gap: var(--space-sm); padding: var(--space-sm) var(--space-md); background: var(--md-surface-container); border-bottom: 1px solid var(--md-outline-variant); flex-shrink: 0; flex-wrap: wrap; }
        .toolbar-group { display: flex; align-items: center; gap: var(--space-xs); }
        .toolbar-divider { width: 1px; height: 28px; background: var(--md-outline-variant); margin: 0 var(--space-xs); }
        .tool-btn { width: 40px; height: 40px; background: transparent; border: none; border-radius: var(--shape-md); color: var(--md-on-surface-variant); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all var(--transition-standard); }
        .tool-btn:hover { background: var(--md-surface-container-high); color: var(--md-on-surface); }
        .tool-btn.active { background: var(--md-primary); color: var(--md-on-primary); }
        .tool-btn svg { width: 22px; height: 22px; }
        .tool-btn-label { display: flex; align-items: center; gap: var(--space-xs); padding: 0 var(--space-md); height: 40px; background: transparent; border: none; border-radius: var(--shape-md); color: var(--md-on-surface-variant); font-family: inherit; font-size: var(--body-medium); cursor: pointer; transition: all var(--transition-standard); }
        .tool-btn-label:hover { background: var(--md-surface-container-high); color: var(--md-on-surface); }
        .tool-btn-label.active { background: var(--md-primary); color: var(--md-on-primary); }
        .tool-btn-label svg { width: 20px; height: 20px; }
        .toolbar-spacer { flex: 1; }
        .zoom-display { font-size: var(--body-small); color: var(--md-on-surface-variant); min-width: 50px; text-align: center; font-weight: 500; }
        #imageInput { display: none; }
        
        /* Canvas */
        .canvas-wrapper { flex: 1; position: relative; overflow: hidden; background: var(--md-surface); }
        .canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform-origin: 0 0; }
        .canvas-grid { position: absolute; inset: 0; pointer-events: none; opacity: 0; transition: opacity 0.2s ease; background-image: linear-gradient(rgba(255,255,255,0.08) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.08) 1px, transparent 1px); background-size: 40px 40px; }
        .canvas-grid.visible { opacity: 1; }
        
        /* Elements */
        .element { position: absolute; cursor: move; user-select: none; }
        .element.selected::after { content: ''; position: absolute; inset: -4px; border: 2px solid var(--md-primary); border-radius: var(--shape-md); pointer-events: none; }
        .element-image { display: flex; flex-direction: column; align-items: center; }
        .element-image img { border-radius: var(--shape-md); box-shadow: var(--elevation-2); pointer-events: none; }
        .element-text { padding: var(--space-sm) var(--space-md); background: var(--md-surface-container); border-radius: var(--shape-md); color: var(--md-on-surface); font-size: 18px; white-space: pre-wrap; box-shadow: var(--elevation-1); min-width: 60px; max-width: 400px; }
        .element-text.editing { outline: none; background: var(--md-surface-container-high); cursor: text; }
        .element-text strong { font-weight: 700; }
        .element-text em { font-style: italic; }
        .element-text code { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        .resize-handle { position: absolute; width: 14px; height: 14px; background: var(--md-primary); border: 2px solid var(--md-on-primary); border-radius: 50%; cursor: nwse-resize; bottom: -7px; right: -7px; opacity: 0; z-index: 10; }
        .element.selected .resize-handle { opacity: 1; }
        .element-delete { position: absolute; top: -12px; right: -12px; width: 24px; height: 24px; background: var(--md-error); border: none; border-radius: 50%; color: var(--md-on-error); cursor: pointer; display: flex; align-items: center; justify-content: center; opacity: 0; z-index: 11; }
        .element-delete svg { width: 14px; height: 14px; }
        .element.selected .element-delete { opacity: 1; }
        .element-delete:hover { transform: scale(1.1); }
        
        /* Tool Mode: Elements don't intercept clicks when tools are active */
        .canvas.tool-active .element { pointer-events: none; }
        .canvas.tool-active .element .resize-handle,
        .canvas.tool-active .element .element-delete { pointer-events: none; }
        
        /* Text Toolbar */
        .text-toolbar { position: fixed; background: var(--md-surface-container-high); border-radius: var(--shape-md); box-shadow: var(--elevation-3); display: flex; gap: 2px; padding: 4px; z-index: 200; opacity: 0; visibility: hidden; transform: translateY(8px); transition: all 0.15s ease; }
        .text-toolbar.active { opacity: 1; visibility: visible; transform: translateY(0); }
        .text-toolbar .md-btn { width: 32px; height: 32px; background: transparent; border: none; border-radius: var(--shape-sm); color: var(--md-on-surface-variant); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; }
        .text-toolbar .md-btn:hover { background: var(--md-surface-container-highest); color: var(--md-on-surface); }
        
        /* Drop Zone */
        .drop-zone { position: absolute; inset: 0; background: rgba(103, 80, 164, 0.1); border: 3px dashed var(--md-primary); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; }
        .drop-zone.active { opacity: 1; visibility: visible; }
        .drop-zone-content { text-align: center; color: var(--md-primary); }
        .drop-zone-content svg { width: 64px; height: 64px; margin-bottom: var(--space-md); }
        .drop-zone-content p { font-size: var(--title-medium); font-weight: 500; }
        
        /* Empty State */
        .empty-state { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--md-on-surface-variant); pointer-events: none; }
        .empty-state svg { width: 80px; height: 80px; margin-bottom: var(--space-md); opacity: 0.5; }
        .empty-state h3 { font-size: var(--title-medium); font-weight: 500; margin-bottom: var(--space-sm); color: var(--md-on-surface); }
        
        /* Toast */
        .toast { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%) translateY(20px); background: var(--md-surface-container-highest); color: var(--md-on-surface); padding: var(--space-sm) var(--space-lg); border-radius: var(--shape-md); box-shadow: var(--elevation-3); z-index: 300; opacity: 0; visibility: hidden; }
        .toast.show { opacity: 1; visibility: visible; transform: translateX(-50%) translateY(0); }
        
        /* Context Menu */
        .context-menu { position: fixed; background: var(--md-surface-container-high); border-radius: var(--shape-md); box-shadow: var(--elevation-3); min-width: 160px; z-index: 500; opacity: 0; visibility: hidden; transform: scale(0.95); }
        .context-menu.active { opacity: 1; visibility: visible; transform: scale(1); }
        .context-menu-item { display: flex; align-items: center; gap: var(--space-sm); padding: var(--space-sm) var(--space-md); color: var(--md-on-surface); font-size: var(--body-medium); cursor: pointer; }
        .context-menu-item:hover { background: var(--md-surface-container-highest); }
        .context-menu-item svg { width: 18px; height: 18px; color: var(--md-on-surface-variant); }
        .context-menu-item.danger { color: var(--md-error); }
        .context-menu-item.danger svg { color: var(--md-error); }
        
        /* Viewer Mode - Non-GM users: hide GM-only tools by default */
        .toolbar.viewer-mode .tool-btn-label.gm-only,
        .toolbar.viewer-mode .tool-btn.gm-only,
        .toolbar.viewer-mode #gmDrawControls { display: none !important; }
        
        /* Tools that can be enabled for players (Draw, Ping) - controlled via JS */
        .toolbar.viewer-mode #drawToggle,
        .toolbar.viewer-mode #pingToggle { display: none; }
        .toolbar.viewer-mode #drawToggle.player-enabled,
        .toolbar.viewer-mode #pingToggle.player-enabled { display: flex !important; }
        
        .viewer-mode-banner {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--md-surface-container-high);
            color: var(--md-on-surface-variant);
            padding: var(--space-sm) var(--space-lg);
            border-radius: var(--shape-full);
            font-size: var(--body-small);
            box-shadow: var(--elevation-2);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .viewer-mode-banner svg { width: 16px; height: 16px; }
        
        /* Drawing Canvas */
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 5;
        }
        .drawing-canvas.active {
            pointer-events: auto;
            cursor: crosshair;
        }
        .drawing-canvas.eraser-mode {
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="white" stroke="black" stroke-width="2"/></svg>') 12 12, crosshair;
        }
        
        /* Drawing Toolbar */
        .draw-toolbar {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: 4px 8px;
            background: var(--md-surface-container-high);
            border-radius: var(--shape-md);
            margin-left: var(--space-xs);
        }
        .draw-toolbar.hidden { display: none; }
        
        .color-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.15s ease;
        }
        .color-btn:hover { transform: scale(1.15); }
        .color-btn.active { border-color: var(--md-on-surface); transform: scale(1.1); }
        
        .size-btn {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            border-radius: var(--shape-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--md-on-surface-variant);
            transition: all 0.15s ease;
        }
        .size-btn:hover { background: var(--md-surface-container-highest); }
        .size-btn.active { background: var(--md-primary); color: var(--md-on-primary); }
        .size-btn .size-dot {
            background: currentColor;
            border-radius: 50%;
        }
        
        .draw-divider {
            width: 1px;
            height: 20px;
            background: var(--md-outline-variant);
            margin: 0 4px;
        }
        
        /* Player Drawing Permission */
        .player-draw-toggle {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: 4px 10px;
            background: var(--md-surface-container);
            border-radius: var(--shape-full);
            font-size: var(--body-small);
            color: var(--md-on-surface-variant);
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid var(--md-outline-variant);
        }
        .player-draw-toggle:hover { background: var(--md-surface-container-high); }
        .player-draw-toggle.active {
            background: var(--md-tertiary-container);
            color: var(--md-on-tertiary-container);
            border-color: var(--md-tertiary);
        }
        .player-draw-toggle svg { width: 14px; height: 14px; }
        
        /* Force Sync Button */
        #forceSyncBtn {
            transition: all 0.2s ease;
        }
        #forceSyncBtn:disabled {
            opacity: 0.6;
            cursor: wait;
        }
        #forceSyncBtn.active {
            animation: pulse 0.5s ease;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Shape Elements */
        .element-shape {
            border: 3px solid currentColor;
            background: transparent;
        }
        .element-shape.filled {
            background: currentColor;
            opacity: 0.3;
        }
        .element-shape.rectangle { border-radius: 4px; }
        .element-shape.circle { border-radius: 50%; }
        .element-shape.arrow {
            border: none;
            background: transparent;
        }
        
        /* Rotation Handle */
        .rotate-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: var(--md-secondary);
            border: 2px solid var(--md-on-secondary);
            border-radius: 50%;
            cursor: grab;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            z-index: 12;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .rotate-handle svg { width: 12px; height: 12px; color: var(--md-on-secondary); }
        .element.selected .rotate-handle { opacity: 1; }
        .rotate-handle:active { cursor: grabbing; }
        
        /* Token System */
        .element-token {
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: visible;
            background: var(--md-surface-container-high);
            border: 3px solid var(--md-primary);
            box-shadow: var(--elevation-2);
        }
        .element-token img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            pointer-events: none;
        }
        .element-token .token-letter {
            font-size: 24px;
            font-weight: 700;
            color: var(--md-on-surface);
        }
        .token-name {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: 500;
            color: var(--md-on-surface);
            background: var(--md-surface-container);
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            box-shadow: var(--elevation-1);
        }
        
        /* Token Status Labels */
        .token-labels {
            position: absolute;
            top: -8px;
            right: -8px;
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            max-width: 80px;
            justify-content: flex-end;
        }
        .token-label {
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: var(--elevation-1);
            cursor: pointer;
        }
        .token-label.red { background: #ef4444; color: white; }
        .token-label.orange { background: #f97316; color: white; }
        .token-label.yellow { background: #eab308; color: #1a1a1a; }
        .token-label.green { background: #22c55e; color: white; }
        .token-label.blue { background: #3b82f6; color: white; }
        .token-label.purple { background: #a855f7; color: white; }
        .token-label.gray { background: #6b7280; color: white; }
        
        /* Locked Elements */
        .element.locked {
            cursor: default !important;
        }
        .element.locked::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            width: 16px;
            height: 16px;
            background: var(--md-surface-container-high);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--elevation-1);
            z-index: 15;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="%239ca3af" stroke-width="3"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>');
            background-repeat: no-repeat;
            background-position: center;
            background-size: 10px;
        }
        .element.locked .element-delete,
        .element.locked .resize-handle,
        .element.locked .rotate-handle { display: none !important; }
        
        /* Pins/Markers */
        .element-pin {
            width: 32px;
            height: 32px;
            cursor: pointer;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: transform 0.15s ease;
        }
        .element-pin:hover { transform: scale(1.1); }
        .element-pin svg { width: 100%; height: 100%; }
        .pin-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--md-surface-container-highest);
            color: var(--md-on-surface);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: var(--elevation-2);
            opacity: 0;
            visibility: hidden;
            transition: all 0.15s ease;
            margin-bottom: 4px;
        }
        .element-pin:hover .pin-tooltip { opacity: 1; visibility: visible; }
        
        /* Measure Tool */
        .measure-line {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        .measure-line svg {
            overflow: visible;
        }
        .measure-label {
            position: absolute;
            background: var(--md-primary);
            color: var(--md-on-primary);
            padding: 4px 10px;
            border-radius: var(--shape-full);
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: var(--elevation-2);
            transform: translate(-50%, -50%);
            z-index: 101;
        }
        
        /* Remote Cursors */
        .remote-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 200;
            transition: left 0.1s linear, top 0.1s linear;
        }
        .remote-cursor svg {
            width: 20px;
            height: 20px;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
        }
        .remote-cursor-name {
            position: absolute;
            top: 18px;
            left: 14px;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            color: white;
        }
        
        /* Cursor Toggle Menu */
        .cursor-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--md-surface-container-high);
            border-radius: var(--shape-md);
            box-shadow: var(--elevation-3);
            min-width: 140px;
            z-index: 500;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.15s ease;
        }
        .cursor-menu.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .cursor-menu-item {
            padding: 10px 14px;
            color: var(--md-on-surface);
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .cursor-menu-item:hover {
            background: var(--md-surface-container-highest);
        }
        .cursor-menu-item:first-child {
            border-radius: var(--shape-md) var(--shape-md) 0 0;
        }
        .cursor-menu-item:last-child {
            border-radius: 0 0 var(--shape-md) var(--shape-md);
        }
        .cursor-menu-item.selected {
            background: var(--md-primary-container);
            color: var(--md-on-primary-container);
        }
        .cursor-menu-item.selected::before {
            content: '✓';
            font-weight: bold;
        }
        
        /* Ping Animation */
        .ping-effect {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            transform: translate(-50%, -50%);
        }
        .ping-effect .ping-ring {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: ping-expand 1.5s ease-out forwards;
        }
        .ping-effect .ping-ring:nth-child(2) { animation-delay: 0.3s; }
        .ping-effect .ping-ring:nth-child(3) { animation-delay: 0.6s; }
        .ping-effect .ping-dot {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: ping-pulse 1.5s ease-out forwards;
        }
        .ping-effect .ping-name {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
            color: white;
            animation: ping-fade 1.5s ease-out forwards;
        }
        @keyframes ping-expand {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }
        @keyframes ping-pulse {
            0%, 50% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }
        @keyframes ping-fade {
            0%, 70% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Measure Tool Toolbar */
        .measure-toolbar {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--md-surface-container-high);
            border-radius: var(--shape-lg);
            padding: 8px 12px;
            display: none;
            align-items: center;
            gap: 12px;
            box-shadow: var(--elevation-3);
            z-index: 180;
        }
        .measure-toolbar.visible { display: flex; }
        .measure-toolbar label { font-size: 13px; color: var(--md-on-surface-variant); }
        .measure-toolbar input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid var(--md-outline);
            border-radius: 4px;
            background: var(--md-surface);
            color: var(--md-on-surface);
            font-size: 13px;
        }
        .measure-toolbar select {
            padding: 4px 8px;
            border: 1px solid var(--md-outline);
            border-radius: 4px;
            background: var(--md-surface);
            color: var(--md-on-surface);
            font-size: 13px;
        }
        
        /* Fog of War */
        .fog-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        .fog-layer.active {
            display: block;
        }
        .fog-layer.editing {
            pointer-events: auto;
            cursor: crosshair;
        }
        /* GM sees through fog with transparency */
        .fog-layer.gm-view .fog-cell:not(.revealed) {
            opacity: 0.5;
        }
        .fog-cell {
            position: absolute;
            background: #0d1117;
            transition: opacity 0.3s ease;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
        }
        .fog-cell.revealed {
            opacity: 0;
            pointer-events: none;
        }
        /* Hover effect only in edit mode */
        .fog-layer.editing .fog-cell:hover {
            outline: 2px solid var(--md-primary);
            outline-offset: -2px;
        }
        
        /* Fog Toggle Button */
        .fog-toggle {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: 4px 10px;
            background: var(--md-surface-container);
            border-radius: var(--shape-full);
            font-size: var(--body-small);
            color: var(--md-on-surface-variant);
            cursor: pointer;
            transition: all 0.15s ease;
            border: 1px solid var(--md-outline-variant);
        }
        .fog-toggle:hover { background: var(--md-surface-container-high); }
        .fog-toggle.active {
            background: var(--md-error-container);
            color: var(--md-on-error-container);
            border-color: var(--md-error);
        }
        .fog-toggle svg { width: 14px; height: 14px; }
        
        /* Shape Toolbar - MOVED TO BOTTOM POPUP */
        .shape-toolbar {
            display: none;
        }
        
        /* Drawing Toolbar - MOVED TO BOTTOM POPUP */
        .draw-toolbar {
            display: none;
        }
        
        /* Bottom Popup Toolbar */
        .bottom-popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--md-surface-container-high);
            border-radius: var(--shape-lg);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--elevation-4);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .bottom-popup.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        .bottom-popup .popup-divider {
            width: 1px;
            height: 28px;
            background: var(--md-outline-variant);
            margin: 0 4px;
        }
        .bottom-popup .popup-title {
            font-size: var(--body-small);
            color: var(--md-on-surface-variant);
            margin-right: 8px;
            font-weight: 500;
        }
        
        /* Token Dialog */
        .token-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--md-surface-container-high);
            border-radius: var(--shape-lg);
            padding: var(--space-lg);
            z-index: 1000;
            box-shadow: var(--elevation-4);
            min-width: 300px;
            display: none;
        }
        .token-dialog.active { display: block; }
        .token-dialog h3 {
            margin: 0 0 var(--space-md);
            font-size: var(--title-medium);
            color: var(--md-on-surface);
        }
        .token-dialog-field {
            margin-bottom: var(--space-md);
        }
        .token-dialog-field label {
            display: block;
            font-size: var(--body-small);
            color: var(--md-on-surface-variant);
            margin-bottom: var(--space-xs);
        }
        .token-dialog-field input {
            width: 100%;
            padding: var(--space-sm);
            border: 1px solid var(--md-outline);
            border-radius: var(--shape-sm);
            background: var(--md-surface);
            color: var(--md-on-surface);
            font-size: var(--body-medium);
        }
        .token-dialog-colors {
            display: flex;
            gap: var(--space-xs);
            flex-wrap: wrap;
        }
        .token-color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .token-color-btn.active { border-color: var(--md-on-surface); }
        .token-dialog-actions {
            display: flex;
            gap: var(--space-sm);
            justify-content: flex-end;
            margin-top: var(--space-lg);
        }
        
        /* Player Characters List in Token Dialog */
        .player-characters-list {
            max-height: 180px;
            overflow-y: auto;
            background: var(--md-surface);
            border-radius: var(--shape-sm);
            border: 1px solid var(--md-outline-variant);
        }
        .player-char-item {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm);
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid var(--md-outline-variant);
        }
        .player-char-item:last-child { border-bottom: none; }
        .player-char-item:hover { background: var(--md-surface-container); }
        .player-char-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            color: white;
            overflow: hidden;
            flex-shrink: 0;
            border: 2px solid;
        }
        .player-char-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .player-char-info {
            flex: 1;
            min-width: 0;
        }
        .player-char-name {
            font-weight: 500;
            font-size: var(--body-medium);
            color: var(--md-on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-char-owner {
            font-size: var(--body-small);
            color: var(--md-on-surface-variant);
        }
        .player-char-loading, .player-char-empty {
            padding: var(--space-md);
            text-align: center;
            color: var(--md-on-surface-variant);
            font-size: var(--body-small);
        }
        .token-dialog-divider {
            display: flex;
            align-items: center;
            margin: var(--space-md) 0;
            color: var(--md-on-surface-variant);
            font-size: var(--body-small);
        }
        .token-dialog-divider::before,
        .token-dialog-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--md-outline-variant);
        }
        .token-dialog-divider span {
            padding: 0 var(--space-sm);
        }
        
        .dialog-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }
        .dialog-backdrop.active { display: block; }
        
        /* Text Color in Text Toolbar */
        .text-color-picker {
            display: flex;
            gap: 2px;
            padding-left: 4px;
            border-left: 1px solid var(--md-outline-variant);
            margin-left: 4px;
        }
        .text-color-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .text-color-btn:hover { transform: scale(1.1); }
        .text-color-btn.active { border-color: var(--md-on-surface); }
        
        /* Undo Button */
        .undo-btn {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            border-radius: var(--shape-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--md-on-surface-variant);
            transition: all 0.15s ease;
        }
        .undo-btn:hover { background: var(--md-surface-container-highest); color: var(--md-on-surface); }
        .undo-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .undo-btn svg { width: 18px; height: 18px; }
        
        @media (max-width: 600px) { .tool-btn-label span { display: none; } }
    </style>
</head>
<body>
    <div id="nav-placeholder"></div>

    <div class="whiteboard-container">
        <div class="toolbar">
            <div class="toolbar-group">
                <button class="tool-btn-label gm-only" onclick="triggerImageUpload()" data-i18n-title="whiteboard.add_image" title="Bild hinzufügen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                    <span data-i18n="whiteboard.image">Bild</span>
                </button>
                <input type="file" id="imageInput" accept="image/*" multiple onchange="handleImageUpload(event)">
                <button class="tool-btn-label gm-only" onclick="addTextElement()" data-i18n-title="whiteboard.add_text" title="Text hinzufügen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
                    <span data-i18n="whiteboard.text">Text</span>
                </button>
                <button class="tool-btn-label gm-only" id="shapeToggle" onclick="toggleShapeMode()" data-i18n-title="whiteboard.shapes" title="Formen zeichnen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
                    <span data-i18n="whiteboard.shapes">Formen</span>
                </button>
                <button class="tool-btn-label gm-only" onclick="openTokenDialog()" data-i18n-title="whiteboard.token" title="Token erstellen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="10" r="3"/><path d="M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662"/></svg>
                    <span data-i18n="whiteboard.token">Token</span>
                </button>
                <button class="tool-btn-label gm-only" onclick="openPinDialog()" data-i18n-title="whiteboard.pin" title="Pin setzen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
                    <span data-i18n="whiteboard.pin">Pin</span>
                </button>
                <button class="tool-btn-label" id="drawToggle" onclick="toggleDrawMode()" data-i18n-title="whiteboard.draw" title="Zeichnen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>
                    <span data-i18n="whiteboard.draw">Zeichnen</span>
                </button>
                <button class="tool-btn-label gm-only" id="measureToggle" onclick="toggleMeasureMode()" data-i18n-title="whiteboard.measure" title="Messen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12h20M2 12l4-4M2 12l4 4M22 12l-4-4M22 12l-4 4"/><line x1="6" y1="8" x2="6" y2="16"/><line x1="18" y1="8" x2="18" y2="16"/></svg>
                    <span data-i18n="whiteboard.measure">Messen</span>
                </button>
                <button class="tool-btn-label" id="pingToggle" onclick="togglePingMode()" data-i18n-title="whiteboard.ping" title="Ping">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="7" stroke-dasharray="4 2"/><circle cx="12" cy="12" r="11" stroke-dasharray="4 2" opacity="0.5"/></svg>
                    <span data-i18n="whiteboard.ping">Ping</span>
                </button>
            </div>
            <div class="toolbar-divider gm-only"></div>
            <div class="toolbar-group gm-only">
                <button class="tool-btn" onclick="bringToFront()" data-i18n-title="whiteboard.bring_front" title="Nach vorne"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="8" y="8" width="12" height="12" rx="2"/><path d="M4 16V6a2 2 0 0 1 2-2h10"/></svg></button>
                <button class="tool-btn" onclick="sendToBack()" data-i18n-title="whiteboard.send_back" title="Nach hinten"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="12" height="12" rx="2"/><path d="M8 20h10a2 2 0 0 0 2-2V8"/></svg></button>
            </div>
            <div class="toolbar-divider"></div>
            <div class="toolbar-group">
                <button class="tool-btn" onclick="zoomOut()" data-i18n-title="whiteboard.zoom_out" title="Rauszoomen (-)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                <span class="zoom-display" id="zoomDisplay">100%</span>
                <button class="tool-btn" onclick="zoomIn()" data-i18n-title="whiteboard.zoom_in" title="Reinzoomen (+)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                <button class="tool-btn" onclick="resetZoom()" data-i18n-title="whiteboard.zoom_reset" title="Zoom zurücksetzen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
            </div>
            <div class="toolbar-divider gm-only"></div>
            <div class="toolbar-group gm-only">
                <button class="tool-btn" id="snapToggle" onclick="toggleSnap()" data-i18n-title="whiteboard.snap_grid" title="Am Raster ausrichten"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg></button>
            </div>
            <div class="toolbar-spacer"></div>
            <div class="toolbar-group" id="gmDrawControls" style="display:none">
                <button class="fog-toggle" id="fogToggle" onclick="toggleFogMode()" data-i18n-title="whiteboard.fog_of_war" title="Fog of War bearbeiten">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>
                    <span data-i18n="whiteboard.fog_of_war">Fog of War</span>
                </button>
                <button class="player-draw-toggle" id="playerDrawToggle" onclick="togglePlayerDrawing()" data-i18n-title="whiteboard.player_draw" title="Spieler dürfen zeichnen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                    <span data-i18n="whiteboard.player_draw">Spieler zeichnen</span>
                </button>
                <div class="cursor-toggle-wrapper" style="position:relative;">
                    <button class="tool-btn" id="cursorToggleBtn" onclick="toggleCursorMenu()" data-i18n-title="whiteboard.cursor_visibility" title="Cursor-Sichtbarkeit">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg>
                    </button>
                    <div class="cursor-menu" id="cursorMenu">
                        <div class="cursor-menu-item" onclick="setCursorVisibility('none')" data-value="none"><span data-i18n="whiteboard.cursor_none">Keinen</span></div>
                        <div class="cursor-menu-item" onclick="setCursorVisibility('gm')" data-value="gm"><span data-i18n="whiteboard.cursor_gm_only">Nur GM</span></div>
                        <div class="cursor-menu-item" onclick="setCursorVisibility('players')" data-value="players"><span data-i18n="whiteboard.cursor_players_only">Nur Spieler</span></div>
                        <div class="cursor-menu-item" onclick="setCursorVisibility('all')" data-value="all"><span data-i18n="whiteboard.cursor_all">Alle</span></div>
                    </div>
                </div>
                <button class="tool-btn" id="forceSyncBtn" onclick="forceSync()" data-i18n-title="whiteboard.force_sync" title="Sync erzwingen">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 0 1-9 9m9-9a9 9 0 0 0-9-9m9 9H3m9 9a9 9 0 0 1-9-9m9 9c-1.66 0-3-4.03-3-9s1.34-9 3-9m0 18c1.66 0 3-4.03 3-9s-1.34-9-3-9m-9 9a9 9 0 0 1 9-9"/></svg>
                </button>
            </div>
            <div class="toolbar-group">
                <button class="tool-btn" onclick="clearCanvas()" data-i18n-title="whiteboard.clear_all" title="Alles löschen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
            </div>
        </div>

        <div class="canvas-wrapper" id="canvasWrapper">
            <div class="canvas" id="canvas">
                <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
                <div class="canvas-grid" id="canvasGrid"></div>
                <div class="fog-layer" id="fogLayer"></div>
            </div>
            <div class="drop-zone" id="dropZone"><div class="drop-zone-content"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg><p data-i18n="whiteboard.drop_images">Bilder hier ablegen</p></div></div>
            <div class="empty-state" id="emptyState"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg><h3 data-i18n="whiteboard.empty">Whiteboard ist leer</h3><p data-i18n="whiteboard.add_content">Füge Bilder oder Text hinzu</p></div>
        </div>
    </div>

    <div class="text-toolbar" id="textToolbar" onmousedown="event.preventDefault()">
        <button class="md-btn" onmousedown="event.preventDefault(); insertTextMarkdown('bold')" data-i18n-title="notes.bold" title="Fett"><strong>B</strong></button>
        <button class="md-btn" onmousedown="event.preventDefault(); insertTextMarkdown('italic')" data-i18n-title="notes.italic" title="Kursiv"><em>I</em></button>
        <button class="md-btn" onmousedown="event.preventDefault(); insertTextMarkdown('code')" data-i18n-title="notes.code" title="Code"><code>&lt;/&gt;</code></button>
        <div class="text-color-picker">
            <button class="text-color-btn active" style="background:var(--md-on-surface)" onmousedown="event.preventDefault(); setTextColor('')" title="Standard"></button>
            <button class="text-color-btn" style="background:#ff4444" onmousedown="event.preventDefault(); setTextColor('#ff4444')" title="Rot"></button>
            <button class="text-color-btn" style="background:#4caf50" onmousedown="event.preventDefault(); setTextColor('#4caf50')" title="Grün"></button>
            <button class="text-color-btn" style="background:#2196f3" onmousedown="event.preventDefault(); setTextColor('#2196f3')" title="Blau"></button>
            <button class="text-color-btn" style="background:#ffeb3b" onmousedown="event.preventDefault(); setTextColor('#ffeb3b')" title="Gelb"></button>
            <button class="text-color-btn" style="background:#ff9800" onmousedown="event.preventDefault(); setTextColor('#ff9800')" title="Orange"></button>
        </div>
    </div>

    <!-- Token Creation/Edit Dialog -->
    <div class="dialog-backdrop" id="dialogBackdrop" onclick="closeTokenDialog()"></div>
    <div class="token-dialog" id="tokenDialog">
        <h3 id="tokenDialogTitle" data-i18n="whiteboard.token_create">Token erstellen</h3>
        
        <!-- Player Characters Section -->
        <div class="token-dialog-field" id="playerCharactersSection">
            <label data-i18n="whiteboard.token_from_character">Aus Charakter erstellen</label>
            <div id="playerCharactersList" class="player-characters-list">
                <div class="player-char-loading">Lade Charaktere...</div>
            </div>
        </div>
        
        <div class="token-dialog-divider"><span data-i18n="whiteboard.token_or_manual">oder manuell</span></div>
        
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.token_name">Name</label>
            <input type="text" id="tokenName" data-i18n-placeholder="whiteboard.token_name" placeholder="Charakter-Name">
        </div>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.token_initials">Initialen (max 2 Zeichen, nur wenn kein Bild)</label>
            <input type="text" id="tokenInitials" placeholder="AB" maxlength="2">
        </div>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.token_portrait">Portrait (optional)</label>
            <div style="display:flex; gap:8px; align-items:center;">
                <div id="tokenPortraitPreview" style="width:60px;height:60px;border-radius:50%;background:var(--md-surface-container);display:flex;align-items:center;justify-content:center;overflow:hidden;border:2px solid var(--md-outline);">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:30px;height:30px;opacity:0.5;"><circle cx="12" cy="10" r="3"/><path d="M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662"/><circle cx="12" cy="12" r="10"/></svg>
                </div>
                <div style="flex:1;">
                    <input type="file" id="tokenPortraitInput" accept="image/*" style="display:none;" onchange="handleTokenPortrait(event)">
                    <button class="md-btn md-btn-outlined" onclick="document.getElementById('tokenPortraitInput').click()" style="width:100%;" data-i18n="whiteboard.token_choose_image">Bild wählen</button>
                    <button class="md-btn md-btn-text" onclick="clearTokenPortrait()" style="width:100%;margin-top:4px;font-size:12px;" data-i18n="whiteboard.token_remove_image">Entfernen</button>
                </div>
            </div>
        </div>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.token_border_color">Rahmenfarbe</label>
            <div class="token-dialog-colors">
                <button class="token-color-btn active" style="background:#6750a4" data-color="#6750a4"></button>
                <button class="token-color-btn" style="background:#ff4444" data-color="#ff4444"></button>
                <button class="token-color-btn" style="background:#4caf50" data-color="#4caf50"></button>
                <button class="token-color-btn" style="background:#2196f3" data-color="#2196f3"></button>
                <button class="token-color-btn" style="background:#ff9800" data-color="#ff9800"></button>
                <button class="token-color-btn" style="background:#9c27b0" data-color="#9c27b0"></button>
                <button class="token-color-btn" style="background:#607d8b" data-color="#607d8b"></button>
                <button class="token-color-btn" style="background:#795548" data-color="#795548"></button>
            </div>
        </div>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.token_size">Größe</label>
            <select id="tokenSize" style="width:100%; padding:8px; border-radius:4px; background:var(--md-surface); color:var(--md-on-surface); border:1px solid var(--md-outline);">
                <option value="40" data-i18n="whiteboard.token_size_small">Klein (1 Feld)</option>
                <option value="60" selected data-i18n="whiteboard.token_size_medium">Mittel</option>
                <option value="80" data-i18n="whiteboard.token_size_large">Groß (2 Felder)</option>
                <option value="120" data-i18n="whiteboard.token_size_huge">Riesig (3 Felder)</option>
            </select>
        </div>
        <div class="token-dialog-actions">
            <button class="md-btn md-btn-text" onclick="closeTokenDialog()" data-i18n="whiteboard.cancel">Abbrechen</button>
            <button class="md-btn md-btn-filled" id="tokenDialogSubmit" onclick="submitToken()" data-i18n="whiteboard.create">Erstellen</button>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Remote Cursors Container -->
    <div id="remoteCursors"></div>

    <!-- Measure Toolbar -->
    <div class="measure-toolbar" id="measureToolbar">
        <label data-i18n="whiteboard.grid_size">Rastergröße:</label>
        <input type="number" id="measureGridSize" value="40" min="10" max="200">
        <label>= </label>
        <input type="number" id="measureUnitSize" value="5" min="1" max="100">
        <select id="measureUnit">
            <option value="ft">ft</option>
            <option value="m">m</option>
            <option value="squares">Felder</option>
        </select>
    </div>

    <!-- Pin Dialog -->
    <div class="dialog-backdrop" id="pinDialogBackdrop" onclick="closePinDialog()"></div>
    <div class="token-dialog" id="pinDialog">
        <h3 data-i18n="whiteboard.pin_create">Pin erstellen</h3>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.pin_text">Beschreibung</label>
            <input type="text" id="pinText" data-i18n-placeholder="whiteboard.pin_placeholder" placeholder="z.B. Falle, Ausgang, Schatz...">
        </div>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.pin_color">Farbe</label>
            <div class="token-dialog-colors">
                <button class="token-color-btn active" style="background:#ef4444" data-color="#ef4444"></button>
                <button class="token-color-btn" style="background:#f97316" data-color="#f97316"></button>
                <button class="token-color-btn" style="background:#eab308" data-color="#eab308"></button>
                <button class="token-color-btn" style="background:#22c55e" data-color="#22c55e"></button>
                <button class="token-color-btn" style="background:#3b82f6" data-color="#3b82f6"></button>
                <button class="token-color-btn" style="background:#a855f7" data-color="#a855f7"></button>
                <button class="token-color-btn" style="background:#6b7280" data-color="#6b7280"></button>
            </div>
        </div>
        <div class="token-dialog-actions">
            <button class="md-btn md-btn-text" onclick="closePinDialog()" data-i18n="whiteboard.cancel">Abbrechen</button>
            <button class="md-btn md-btn-filled" onclick="createPin()" data-i18n="whiteboard.create">Erstellen</button>
        </div>
    </div>

    <!-- Token Label Dialog -->
    <div class="dialog-backdrop" id="labelDialogBackdrop" onclick="closeLabelDialog()"></div>
    <div class="token-dialog" id="labelDialog">
        <h3 data-i18n="whiteboard.label_manage">Status-Labels</h3>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.label_add">Label hinzufügen</label>
            <div style="display:flex; gap:8px;">
                <input type="text" id="labelText" placeholder="z.B. Vergiftet" style="flex:1;" maxlength="12">
                <select id="labelColor" style="width:80px;">
                    <option value="red">Rot</option>
                    <option value="orange">Orange</option>
                    <option value="yellow">Gelb</option>
                    <option value="green">Grün</option>
                    <option value="blue">Blau</option>
                    <option value="purple">Lila</option>
                    <option value="gray">Grau</option>
                </select>
                <button class="md-btn md-btn-filled" onclick="addTokenLabel()" style="padding:0 12px;">+</button>
            </div>
        </div>
        <div class="token-dialog-field">
            <label data-i18n="whiteboard.label_current">Aktuelle Labels</label>
            <div id="currentLabels" style="display:flex; flex-wrap:wrap; gap:4px; min-height:30px; padding:8px; background:var(--md-surface); border-radius:4px;"></div>
        </div>
        <div class="token-dialog-actions">
            <button class="md-btn md-btn-text" onclick="closeLabelDialog()" data-i18n="whiteboard.close">Schließen</button>
        </div>
    </div>

    <!-- Bottom Popup: Drawing Options -->
    <div class="bottom-popup" id="drawPopup">
        <span class="popup-title" data-i18n="whiteboard.draw">Zeichnen</span>
        <button class="color-btn active" style="background:#ffffff" onclick="setDrawColor('#ffffff')" title="Weiß"></button>
        <button class="color-btn" style="background:#ff4444" onclick="setDrawColor('#ff4444')" title="Rot"></button>
        <button class="color-btn" style="background:#ff9800" onclick="setDrawColor('#ff9800')" title="Orange"></button>
        <button class="color-btn" style="background:#ffeb3b" onclick="setDrawColor('#ffeb3b')" title="Gelb"></button>
        <button class="color-btn" style="background:#4caf50" onclick="setDrawColor('#4caf50')" title="Grün"></button>
        <button class="color-btn" style="background:#2196f3" onclick="setDrawColor('#2196f3')" title="Blau"></button>
        <button class="color-btn" style="background:#9c27b0" onclick="setDrawColor('#9c27b0')" title="Lila"></button>
        <button class="color-btn" style="background:#000000; border: 1px solid var(--md-outline-variant);" onclick="setDrawColor('#000000')" title="Schwarz"></button>
        <div class="popup-divider"></div>
        <button class="size-btn" onclick="setDrawSize(2)" title="Fein"><div class="size-dot" style="width:4px;height:4px"></div></button>
        <button class="size-btn active" onclick="setDrawSize(5)" title="Normal"><div class="size-dot" style="width:8px;height:8px"></div></button>
        <button class="size-btn" onclick="setDrawSize(12)" title="Dick"><div class="size-dot" style="width:12px;height:12px"></div></button>
        <button class="size-btn" onclick="setDrawSize(24)" title="Marker"><div class="size-dot" style="width:18px;height:18px"></div></button>
        <div class="popup-divider"></div>
        <button class="tool-btn" id="eraserToggle" onclick="toggleEraser()" data-i18n-title="whiteboard.eraser" title="Radierer">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 2.8c.8-.8 2-.8 2.8 0L21 7.6c.8.8.8 2 0 2.8L12 19"/><path d="M7 20l6-6"/></svg>
        </button>
        <button class="tool-btn" id="undoBtn" onclick="undoLastStroke()" data-i18n-title="whiteboard.undo" title="Rückgängig" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M3 13c0-4.97 4.03-9 9-9s9 4.03 9 9-4.03 9-9 9c-2.12 0-4.07-.74-5.61-1.97"/></svg>
        </button>
        <button class="tool-btn" onclick="clearDrawing()" data-i18n-title="whiteboard.clear_drawing" title="Zeichnung löschen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </button>
    </div>

    <!-- Bottom Popup: Shape Options -->
    <div class="bottom-popup" id="shapePopup">
        <span class="popup-title" data-i18n="whiteboard.shapes">Formen</span>
        <button class="tool-btn active" onclick="setShapeType('rectangle')" data-i18n-title="whiteboard.rectangle" title="Rechteck" id="shapeRect">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
        </button>
        <button class="tool-btn" onclick="setShapeType('circle')" data-i18n-title="whiteboard.circle" title="Kreis" id="shapeCircle">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>
        </button>
        <button class="tool-btn" onclick="setShapeType('line')" data-i18n-title="whiteboard.line" title="Linie" id="shapeLine">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg>
        </button>
        <button class="tool-btn" onclick="setShapeType('arrow')" data-i18n-title="whiteboard.arrow" title="Pfeil" id="shapeArrow">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
        </button>
        <div class="popup-divider"></div>
        <button class="color-btn" style="background:#ff4444" onclick="setShapeColor('#ff4444')"></button>
        <button class="color-btn" style="background:#4caf50" onclick="setShapeColor('#4caf50')"></button>
        <button class="color-btn" style="background:#2196f3" onclick="setShapeColor('#2196f3')"></button>
        <button class="color-btn" style="background:#ffeb3b" onclick="setShapeColor('#ffeb3b')"></button>
        <button class="color-btn active" style="background:#ffffff" onclick="setShapeColor('#ffffff')"></button>
        <div class="popup-divider"></div>
        <button class="size-btn" onclick="setShapeSize(2)" title="Dünn"><div class="size-dot" style="width:4px;height:4px"></div></button>
        <button class="size-btn active" onclick="setShapeSize(4)" title="Normal"><div class="size-dot" style="width:8px;height:8px"></div></button>
        <button class="size-btn" onclick="setShapeSize(8)" title="Dick"><div class="size-dot" style="width:12px;height:12px"></div></button>
    </div>

    <!-- Bottom Popup: Ping Options -->
    <div class="bottom-popup" id="pingPopup">
        <span class="popup-title" data-i18n="whiteboard.ping">Ping</span>
        <button class="color-btn active" style="background:#ff4444" onclick="setPingColor('#ff4444')" title="Rot"></button>
        <button class="color-btn" style="background:#ff9800" onclick="setPingColor('#ff9800')" title="Orange"></button>
        <button class="color-btn" style="background:#ffeb3b" onclick="setPingColor('#ffeb3b')" title="Gelb"></button>
        <button class="color-btn" style="background:#4caf50" onclick="setPingColor('#4caf50')" title="Grün"></button>
        <button class="color-btn" style="background:#2196f3" onclick="setPingColor('#2196f3')" title="Blau"></button>
        <button class="color-btn" style="background:#9c27b0" onclick="setPingColor('#9c27b0')" title="Lila"></button>
        <button class="color-btn" style="background:#ffffff" onclick="setPingColor('#ffffff')" title="Weiß"></button>
        <div class="popup-divider"></div>
        <button class="size-btn" onclick="setPingSize(40)" title="Klein"><div class="size-dot" style="width:8px;height:8px"></div></button>
        <button class="size-btn active" onclick="setPingSize(60)" title="Normal"><div class="size-dot" style="width:12px;height:12px"></div></button>
        <button class="size-btn" onclick="setPingSize(100)" title="Groß"><div class="size-dot" style="width:18px;height:18px"></div></button>
    </div>

    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="bringToFront()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="8" y="8" width="12" height="12" rx="2"/><path d="M4 16V6a2 2 0 0 1 2-2h10"/></svg><span data-i18n="whiteboard.bring_front">Nach vorne</span></div>
        <div class="context-menu-item" onclick="sendToBack()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="12" height="12" rx="2"/><path d="M8 20h10a2 2 0 0 0 2-2V8"/></svg><span data-i18n="whiteboard.send_back">Nach hinten</span></div>
        <div class="context-menu-item" onclick="toggleLock()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg><span data-i18n="whiteboard.lock" id="lockMenuText">Sperren</span></div>
        <div class="context-menu-item" onclick="rotateElement(90)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg><span data-i18n="whiteboard.rotate_cw">90° drehen</span></div>
        <div class="context-menu-item" onclick="rotateElement(-90)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9C9.48 3 7.07 4 5.26 5.74L3 8"/><path d="M3 3v5h5"/></svg><span data-i18n="whiteboard.rotate_ccw">-90° drehen</span></div>
        <div class="context-menu-item token-only" onclick="openLabelDialog()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><span data-i18n="whiteboard.labels">Labels</span></div>
        <div class="context-menu-item" onclick="duplicateElement()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg><span data-i18n="whiteboard.duplicate">Duplizieren</span></div>
        <div class="context-menu-item danger" onclick="deleteSelected()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg><span data-i18n="whiteboard.delete">Löschen</span></div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

    <script src="assets/js/lang.js"></script>
    <script src="assets/js/i18n.js"></script>
    <script src="assets/js/auth.js"></script>
    <script src="assets/js/firebase-sync.js"></script>
    <script src="assets/js/nav.js"></script>
    <script>
        let elements = [], selectedElement = null, isDragging = false, isResizing = false;
        let dragOffset = { x: 0, y: 0 }, zIndexCounter = 1;
        let zoomLevel = 1, snapEnabled = false, editingTextElement = null;
        let isGM = false; // GM-Status
        let unsubscribeWhiteboard = null;
        const ZOOM_MIN = 0.25, ZOOM_MAX = 3, ZOOM_STEP = 0.25, GRID_SIZE = 40;
        
        // Drawing State
        let isDrawMode = false;
        let isDrawing = false;
        let isEraser = false;
        let drawColor = '#ffffff';
        let drawSize = 5;
        let drawingCtx = null;
        let lastX = 0, lastY = 0;
        let strokeHistory = []; // For undo
        let currentStroke = null;
        let playerDrawingAllowed = false;
        let canDraw = false; // Combined permission check
        
        // Throttled Sync State
        let liveStroke = null; // Currently being drawn stroke (synced live)
        let lastSyncTime = 0;
        const SYNC_THROTTLE_DRAW = 150; // ms between drawing syncs
        const SYNC_THROTTLE_DRAG = 200; // ms between drag syncs
        let pendingSync = null;
        
        // Shape Tool State
        let isShapeMode = false;
        let shapeType = 'rectangle';
        let shapeColor = '#ffffff';
        let shapeSize = 4;
        let shapeStartX = 0, shapeStartY = 0;
        let isDrawingShape = false;
        let currentShapeEl = null;
        
        // Ping Tool State
        let isPingMode = false;
        
        // Fog of War State
        let isFogMode = false; // Editing mode
        let isFogEnabled = false; // Fog visible at all
        let fogCells = {}; // {cellId: revealed}
        const FOG_CELL_SIZE = 40;
        
        // Token Dialog State
        let selectedTokenColor = '#6750a4';
        let tokenPortraitData = null;
        let editingToken = null;

        document.addEventListener('DOMContentLoaded', async () => {
            if (!requireAuth()) return;
            
            // Clean up old localStorage to free space (images were stored as base64)
            try {
                const oldData = localStorage.getItem('pnp_whiteboard');
                if (oldData && oldData.length > 100000) { // > 100KB, probably has images
                    console.log('[Whiteboard] Clearing oversized localStorage entry');
                    localStorage.removeItem('pnp_whiteboard');
                }
            } catch (e) {
                console.warn('[Whiteboard] localStorage cleanup failed:', e);
            }
            
            initNavigation(t('module.whiteboard'), '');
            
            // Initialize Firebase first
            await initFirebase();
            
            // Check GM status AFTER Firebase is ready
            isGM = isCurrentUserGM();
            console.log('[Whiteboard] GM Status:', isGM);
            
            // Setup for non-GMs (viewer mode)
            if (!isGM) {
                document.querySelector('.toolbar').classList.add('viewer-mode');
                document.getElementById('emptyState').innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    <h3>Zuschauer-Modus</h3>
                    <p>Warte auf Inhalte vom Spielleiter</p>
                `;
                
                // Add viewer banner
                const banner = document.createElement('div');
                banner.className = 'viewer-mode-banner';
                banner.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    Zuschauer-Modus
                `;
                document.body.appendChild(banner);
            }
            
            loadWhiteboard();
            setupEventListeners();
            setupDrawingCanvas();
            updateEmptyState();
            
            // Show GM controls
            if (isGM) {
                document.getElementById('gmDrawControls').style.display = 'flex';
            }
            
            // Update draw permission
            updateDrawPermission();
            
            // Everyone listens for remote whiteboard changes when online
            if (isFirebaseOnline()) {
                unsubscribeWhiteboard = onWhiteboardChange(handleRemoteWhiteboardUpdate);
                
                // Listen for remote cursors
                if (typeof onCursorsChange === 'function') {
                    onCursorsChange(handleRemoteCursors);
                }
                
                // Listen for pings
                if (typeof onPingChange === 'function') {
                    onPingChange(handleRemotePing);
                }
                
                // Listen for character changes (portrait sync)
                setupCharacterPortraitSync();
            }
        });
        
        // ===== CHARACTER PORTRAIT SYNC =====
        // When a player changes their character portrait, update linked tokens
        
        let characterSyncUnsubscribe = null;
        
        function setupCharacterPortraitSync() {
            if (characterSyncUnsubscribe) return; // Already listening
            
            const charRef = getRef('characters');
            if (!charRef) return;
            
            characterSyncUnsubscribe = charRef.on('value', (snapshot) => {
                const characters = snapshot.val() || {};
                
                // Check each token for linked character
                elements.forEach(el => {
                    if (el.type !== 'token' || !el.characterKey) return;
                    
                    const charData = characters[el.characterKey];
                    if (!charData) return;
                    
                    // Get current portrait from character
                    const newPortrait = charData.narrative?.portrait || charData.portrait || null;
                    const newName = charData.header?.name || charData.name || charData.charakterName || el.name;
                    
                    // Check if portrait changed
                    if (newPortrait !== el.portrait || newName !== el.name) {
                        console.log('[Whiteboard] Character portrait/name changed for token:', el.id, { oldPortrait: !!el.portrait, newPortrait: !!newPortrait, oldName: el.name, newName });
                        
                        // Update element data
                        el.portrait = newPortrait;
                        el.name = newName;
                        el.initials = newName.substring(0, 2).toUpperCase();
                        
                        // Update DOM
                        const dom = el.domElement;
                        if (dom) {
                            // Update portrait/initials
                            const existingImg = dom.querySelector('img');
                            const letterEl = dom.querySelector('.token-letter');
                            
                            if (newPortrait) {
                                if (existingImg) {
                                    existingImg.src = newPortrait;
                                } else {
                                    if (letterEl) letterEl.remove();
                                    const img = document.createElement('img');
                                    img.src = newPortrait;
                                    img.draggable = false;
                                    dom.insertBefore(img, dom.firstChild);
                                }
                            } else {
                                if (existingImg) existingImg.remove();
                                if (!letterEl) {
                                    const newLetter = document.createElement('span');
                                    newLetter.className = 'token-letter';
                                    newLetter.textContent = el.initials;
                                    dom.insertBefore(newLetter, dom.firstChild);
                                } else {
                                    letterEl.textContent = el.initials;
                                }
                            }
                            
                            // Update name
                            const nameEl = dom.querySelector('.token-name');
                            if (nameEl) nameEl.textContent = newName;
                        }
                        
                        // Save if GM (to sync to other clients)
                        if (isGM) {
                            saveWhiteboard();
                        }
                    }
                });
            });
        }

        // Cache for image sources (to avoid re-downloading)
        let imageCache = {};
        
        // Handle remote whiteboard updates
        async function handleRemoteWhiteboardUpdate(state) {
            console.log('[Whiteboard] Remote update received:', {
                elementCount: state.elements?.length || 0,
                drawingCount: state.drawing?.length || 0,
                hasLiveStroke: !!state.liveStroke,
                isQuickSync: !!state._quickSync,
                isGM: isGM,
                isDrawing: isDrawing
            });
            
            // Skip if this is our own update (debounce)
            if (state._localUpdate) {
                console.log('[Whiteboard] Skipping own update');
                return;
            }
            
            // For elements: Only non-GMs receive element updates (GM is authoritative for elements)
            if (!isGM) {
                console.log('[Whiteboard] Non-GM: Updating elements and view');
                
                // Build map of current elements for image cache
                elements.forEach(el => {
                    if (el.type === 'image' && el.src) {
                        imageCache[el.id] = el.src;
                    }
                });
                
                // Clear current elements
                elements.forEach(e => e.domElement.remove());
                elements = [];
                
                // Recreate elements from state
                if (state.elements?.length > 0) {
                    console.log('[Whiteboard] Recreating', state.elements.length, 'elements');
                    
                    for (const el of state.elements) {
                        console.log('[Whiteboard] Creating element:', el.type, el.id);
                        
                        if (el.type === 'image') {
                            // Use src directly from state, or from cache
                            let imgSrc = el.src || imageCache[el.id];
                            
                            if (imgSrc) {
                                imageCache[el.id] = imgSrc; // Update cache
                                const created = createImageElement(imgSrc, el.x, el.y, el.width, el.id, el.zIndex, el.height);
                                if (created && el.rotation) {
                                    created.rotation = el.rotation;
                                    created.domElement.style.transform = `rotate(${el.rotation}deg)`;
                                }
                                if (created && el.locked) {
                                    created.locked = true;
                                    created.domElement.classList.add('locked');
                                }
                            } else {
                                console.warn('[Whiteboard] No image src for:', el.id);
                            }
                        } else if (el.type === 'text') {
                            const created = createTextElement(el.text, el.x, el.y, el.id, el.zIndex, el.rawText);
                            if (created && el.color) {
                                created.domElement.style.color = el.color;
                                created.color = el.color;
                            }
                            if (created && el.locked) {
                                created.locked = true;
                                created.domElement.classList.add('locked');
                            }
                        } else if (el.type === 'token') {
                            const created = createTokenElement(el.name, el.initials, el.color, el.size, el.x, el.y, el.id, el.zIndex, el.portrait, el.characterKey);
                            if (created && el.labels) {
                                created.labels = el.labels;
                                renderTokenLabels(created);
                            }
                            if (created && el.locked) {
                                created.locked = true;
                                created.domElement.classList.add('locked');
                            }
                        } else if (el.type === 'pin') {
                            const created = createPinElement(el.text, el.color, el.x, el.y, el.id, el.zIndex);
                            if (created && el.locked) {
                                created.locked = true;
                                created.domElement.classList.add('locked');
                            }
                        } else if (el.type === 'shape') {
                            // Recreate shape element
                            const shapeEl = document.createElement('div');
                            shapeEl.className = 'element element-shape ' + (el.shapeType || 'rectangle');
                            if (el.locked) shapeEl.classList.add('locked');
                            shapeEl.id = el.id;
                            
                            if (el.shapeType === 'line' || el.shapeType === 'arrow') {
                                // For lines/arrows, create with SVG like in the original creation
                                const width = el.width || 100;
                                const height = el.height || 4;
                                const color = el.color || '#ffffff';
                                const strokeWidth = el.strokeWidth || 4;
                                
                                shapeEl.style.cssText = `left:${el.x}px;top:${el.y}px;width:${width}px;height:${strokeWidth * 4}px;z-index:${el.zIndex};background:transparent;border:none;`;
                                if (el.rotation) shapeEl.style.transform = `rotate(${el.rotation}rad)`;
                                shapeEl.style.transformOrigin = '0 50%';
                                
                                // Create SVG
                                const svgNS = 'http://www.w3.org/2000/svg';
                                const svg = document.createElementNS(svgNS, 'svg');
                                svg.setAttribute('width', width);
                                svg.setAttribute('height', strokeWidth * 4);
                                svg.style.cssText = 'position:absolute;top:0;left:0;overflow:visible;transform:translateY(-' + (strokeWidth * 2 - strokeWidth/2) + 'px)';
                                
                                const line = document.createElementNS(svgNS, 'line');
                                line.setAttribute('x1', 0);
                                line.setAttribute('y1', strokeWidth * 2);
                                line.setAttribute('x2', el.shapeType === 'arrow' ? width - 12 : width);
                                line.setAttribute('y2', strokeWidth * 2);
                                line.setAttribute('stroke', color);
                                line.setAttribute('stroke-width', strokeWidth);
                                line.setAttribute('stroke-linecap', 'round');
                                svg.appendChild(line);
                                
                                if (el.shapeType === 'arrow') {
                                    const arrow = document.createElementNS(svgNS, 'polygon');
                                    const arrowSize = Math.max(12, strokeWidth * 3);
                                    const cy = strokeWidth * 2;
                                    arrow.setAttribute('points', `${width},${cy} ${width - arrowSize},${cy - arrowSize/2} ${width - arrowSize},${cy + arrowSize/2}`);
                                    arrow.setAttribute('fill', color);
                                    svg.appendChild(arrow);
                                }
                                
                                shapeEl.appendChild(svg);
                            } else {
                                shapeEl.style.cssText = `left:${el.x}px;top:${el.y}px;width:${el.width || 100}px;height:${el.height || 100}px;color:${el.color || '#fff'};border-width:${el.strokeWidth || 3}px;z-index:${el.zIndex};`;
                                if (el.rotation) shapeEl.style.transform = `rotate(${el.rotation}deg)`;
                            }
                            document.getElementById('canvas').appendChild(shapeEl);
                            elements.push({ ...el, domElement: shapeEl });
                        }
                    }
                    if (state.elements.length > 0) {
                        zIndexCounter = Math.max(...state.elements.map(e => e.zIndex || 1)) + 1;
                    }
                }
                
                // Apply fog state
                if (state.fog !== undefined || state.fogEnabled !== undefined) {
                    console.log('[Whiteboard] Fog data received:', { fogEnabled: state.fogEnabled, fogCells: state.fog ? Object.keys(state.fog).length : 0 });
                    applyFogState(state.fog, state.fogEnabled);
                }
                
                if (state.zoom) { zoomLevel = state.zoom; applyZoom(); }
                
                // Sync snap/grid for non-GMs
                if (state.snap !== undefined) {
                    snapEnabled = state.snap;
                    document.getElementById('snapToggle')?.classList.toggle('active', snapEnabled);
                    document.getElementById('canvasGrid')?.classList.toggle('visible', snapEnabled);
                }
            }
            
            // Skip drawing updates if we're currently drawing (to avoid overwriting own strokes)
            if (isDrawing) return;
            
            // Everyone syncs drawing (collaborative drawing)
            // Check for drawing update (including from _drawingUpdate trigger)
            if (state.drawing !== undefined || state._drawingUpdate) {
                const oldCount = strokeHistory.length;
                strokeHistory = state.drawing || [];
                console.log('[Whiteboard] Drawing sync:', oldCount, '->', strokeHistory.length, 'strokes', state._drawingUpdate ? '(explicit update)' : '');
                
                // Force clear canvas if drawing is empty
                if (strokeHistory.length === 0) {
                    const canvas = document.getElementById('drawingCanvas');
                    if (canvas) {
                        if (!drawingCtx) {
                            drawingCtx = canvas.getContext('2d');
                        }
                        console.log('[Whiteboard] Force clearing canvas - no strokes');
                        drawingCtx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
            }
            
            // Redraw with remote live stroke (from other users currently drawing)
            const remoteLive = state.liveStroke ? state.liveStroke : null;
            redrawAllStrokes(remoteLive);
            updateUndoButton();
            
            // Sync player drawing permission
            if (state.playerDrawingAllowed !== undefined) {
                const wasAllowed = playerDrawingAllowed;
                console.log('[Whiteboard] playerDrawingAllowed update:', { 
                    from: wasAllowed, 
                    to: state.playerDrawingAllowed,
                    stateKeys: Object.keys(state)
                });
                playerDrawingAllowed = state.playerDrawingAllowed;
                
                // Update UI for GM
                if (isGM) {
                    const toggle = document.getElementById('playerDrawToggle');
                    if (toggle) toggle.classList.toggle('active', playerDrawingAllowed);
                }
                
                updateDrawPermission();
            }
            
            // Sync cursor visibility (controlled by GM)
            if (state.cursorVisibility !== undefined) {
                cursorVisibility = state.cursorVisibility;
                // Update UI
                document.querySelectorAll('.cursor-menu-item').forEach(item => {
                    item.classList.toggle('selected', item.dataset.value === cursorVisibility);
                });
                document.getElementById('cursorToggleBtn')?.classList.toggle('active', cursorVisibility !== 'none');
                
                // Clear cursors if disabled
                if (cursorVisibility === 'none') {
                    document.querySelectorAll('.remote-cursor').forEach(el => el.remove());
                }
            }
            
            updateEmptyState();
        }

        function loadWhiteboard() {
            // Load from localStorage first (for offline support and initial state)
            const saved = loadSharedData('whiteboard', { elements: [], zoom: 1, snap: false, drawing: [], playerDrawingAllowed: false, fog: {}, fogEnabled: false });
            
            console.log('[Whiteboard] Loading saved state:', saved);
            
            // GM loads elements from localStorage, Firebase listener will sync
            if (isGM) {
                if (saved.elements?.length > 0) {
                    saved.elements.forEach(el => {
                        if (el.type === 'image' && el.src) {
                            createImageElement(el.src, el.x, el.y, el.width, el.id, el.zIndex, el.height);
                        } else if (el.type === 'text') {
                            const created = createTextElement(el.text, el.x, el.y, el.id, el.zIndex, el.rawText);
                            if (created && el.color) {
                                created.domElement.style.color = el.color;
                                created.color = el.color;
                            }
                        } else if (el.type === 'token') {
                            createTokenElement(el.name, el.initials, el.color, el.size, el.x, el.y, el.id, el.zIndex, el.portrait, el.characterKey);
                        } else if (el.type === 'shape') {
                            // Recreate shape element
                            const canvas = document.getElementById('canvas');
                            const shapeEl = document.createElement('div');
                            shapeEl.className = 'element element-shape ' + el.shapeType;
                            shapeEl.id = el.id;
                            
                            if (el.shapeType === 'line' || el.shapeType === 'arrow') {
                                // For lines/arrows, create with SVG
                                const width = el.width || 100;
                                const strokeWidth = el.strokeWidth || 4;
                                const color = el.color || '#ffffff';
                                
                                shapeEl.style.cssText = `left:${el.x}px;top:${el.y}px;width:${width}px;height:${strokeWidth * 4}px;z-index:${el.zIndex};background:transparent;border:none;`;
                                if (el.rotation) shapeEl.style.transform = `rotate(${el.rotation}rad)`;
                                shapeEl.style.transformOrigin = '0 50%';
                                
                                // Create SVG
                                const svgNS = 'http://www.w3.org/2000/svg';
                                const svg = document.createElementNS(svgNS, 'svg');
                                svg.setAttribute('width', width);
                                svg.setAttribute('height', strokeWidth * 4);
                                svg.style.cssText = 'position:absolute;top:0;left:0;overflow:visible;transform:translateY(-' + (strokeWidth * 2 - strokeWidth/2) + 'px)';
                                
                                const line = document.createElementNS(svgNS, 'line');
                                line.setAttribute('x1', 0);
                                line.setAttribute('y1', strokeWidth * 2);
                                line.setAttribute('x2', el.shapeType === 'arrow' ? width - 12 : width);
                                line.setAttribute('y2', strokeWidth * 2);
                                line.setAttribute('stroke', color);
                                line.setAttribute('stroke-width', strokeWidth);
                                line.setAttribute('stroke-linecap', 'round');
                                svg.appendChild(line);
                                
                                if (el.shapeType === 'arrow') {
                                    const arrow = document.createElementNS(svgNS, 'polygon');
                                    const arrowSize = Math.max(12, strokeWidth * 3);
                                    const cy = strokeWidth * 2;
                                    arrow.setAttribute('points', `${width},${cy} ${width - arrowSize},${cy - arrowSize/2} ${width - arrowSize},${cy + arrowSize/2}`);
                                    arrow.setAttribute('fill', color);
                                    svg.appendChild(arrow);
                                }
                                
                                shapeEl.appendChild(svg);
                            } else {
                                shapeEl.style.cssText = `left:${el.x}px;top:${el.y}px;width:${el.width}px;height:${el.height}px;color:${el.color};border-width:${el.strokeWidth}px;z-index:${el.zIndex};`;
                                if (el.rotation) shapeEl.style.transform = `rotate(${el.rotation}deg)`;
                            }
                            
                            // Add delete button and event listeners for GM
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'element-delete';
                            deleteBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
                            deleteBtn.onclick = () => deleteElement(el.id);
                            shapeEl.appendChild(deleteBtn);
                            
                            const elementData = { ...el, domElement: shapeEl };
                            elements.push(elementData);
                            
                            shapeEl.addEventListener('mousedown', (ev) => handleElementMouseDown(ev, elementData));
                            shapeEl.addEventListener('contextmenu', (ev) => handleContextMenu(ev, elementData));
                            
                            canvas.appendChild(shapeEl);
                        }
                    });
                    if (saved.elements.length > 0) {
                        zIndexCounter = Math.max(...saved.elements.map(e => e.zIndex || 1)) + 1;
                    }
                }
                
                if (saved.zoom) { zoomLevel = saved.zoom; applyZoom(); }
                if (saved.snap) { snapEnabled = true; document.getElementById('snapToggle').classList.add('active'); document.getElementById('canvasGrid').classList.add('visible'); }
                
                // Load drawing from localStorage
                if (saved.drawing?.length > 0) {
                    strokeHistory = saved.drawing;
                    setTimeout(() => {
                        redrawAllStrokes();
                        updateUndoButton();
                    }, 100);
                }
                
                // Load player drawing permission
                if (saved.playerDrawingAllowed !== undefined) {
                    playerDrawingAllowed = saved.playerDrawingAllowed;
                    const toggle = document.getElementById('playerDrawToggle');
                    if (toggle) toggle.classList.toggle('active', playerDrawingAllowed);
                    updateDrawPermission();
                }
                
                // Load fog state
                if (saved.fog) {
                    fogCells = saved.fog;
                }
                if (saved.fogEnabled) {
                    isFogEnabled = true;
                    const fogLayer = document.getElementById('fogLayer');
                    fogLayer.classList.add('active');
                    document.getElementById('fogToggle')?.classList.add('active');
                    // Apply fog cells after fog is initialized
                    setTimeout(() => {
                        document.querySelectorAll('.fog-cell').forEach(cell => {
                            const cellId = `${cell.dataset.row}-${cell.dataset.col}`;
                            cell.classList.toggle('revealed', !!fogCells[cellId]);
                        });
                    }, 600);
                }
            }
            // Non-GMs: Firebase listener handles everything, but still init permission state
            
            // Always call updateDrawPermission after loading (for both GM and non-GM)
            // This ensures buttons are correctly shown/hidden based on saved state
            updateDrawPermission();
        }

        // Track which images have been uploaded to Firebase
        let uploadedImageIds = new Set();
        
        // Sync-Architektur:
        // - Bilder werden SEPARAT gespeichert (whiteboard/images/{id})
        // - Positions-Updates sind SCHNELL (kein Image-Data)
        // - Force Sync holt alles zusammen
        
        function saveWhiteboard() {
            // Build full state with ALL data - filter out undefined values
            const fullState = {
                elements: elements.map(el => {
                    const base = { 
                        id: el.id, 
                        type: el.type, 
                        x: el.x || 0, 
                        y: el.y || 0, 
                        zIndex: el.zIndex || 1
                    };
                    
                    // Only add width/height/rotation if they exist
                    if (el.width) base.width = el.width;
                    if (el.height) base.height = el.height;
                    if (el.rotation) base.rotation = el.rotation;
                    
                    if (el.type === 'image') {
                        if (el.src) base.src = el.src;
                        if (el.width) base.width = el.width;
                        if (el.height) base.height = el.height;
                    } else if (el.type === 'text') {
                        base.text = el.text || '';
                        if (el.rawText) base.rawText = el.rawText;
                        if (el.color) base.color = el.color;
                    } else if (el.type === 'token') {
                        base.name = el.name || 'Token';
                        base.initials = el.initials || 'T';
                        base.color = el.color || '#6750a4';
                        base.size = el.size || 60;
                        if (el.portrait) base.portrait = el.portrait;
                        if (el.characterKey) base.characterKey = el.characterKey;
                        if (el.labels && el.labels.length > 0) base.labels = el.labels;
                    } else if (el.type === 'shape') {
                        base.shapeType = el.shapeType || 'rectangle';
                        base.width = el.width || 100;
                        base.height = el.height || 100;
                        base.color = el.color || '#ffffff';
                        base.strokeWidth = el.strokeWidth || 3;
                    } else if (el.type === 'pin') {
                        base.text = el.text || 'Pin';
                        base.color = el.color || '#ef4444';
                    }
                    
                    // Add locked state if true
                    if (el.locked) base.locked = true;
                    
                    return base;
                }),
                zoom: zoomLevel || 1, 
                snap: snapEnabled || false,
                drawing: strokeHistory || [],
                liveStroke: liveStroke || null,
                playerDrawingAllowed: playerDrawingAllowed || false,
                cursorVisibility: cursorVisibility || 'none',
                fog: fogCells || {},
                fogEnabled: isFogEnabled || false
            };
            
            // Save to localStorage (try, might fail if too big)
            try {
                saveSharedData('whiteboard', fullState);
            } catch (e) {
                console.warn('[Whiteboard] localStorage save failed (too big?):', e);
                // Try saving without images
                const lightState = { ...fullState, elements: fullState.elements.map(el => 
                    el.type === 'image' ? { ...el, src: undefined } : el
                )};
                try {
                    saveSharedData('whiteboard', lightState);
                } catch (e2) {
                    console.error('[Whiteboard] localStorage save completely failed:', e2);
                }
            }
            
            // Sync to Firebase if online
            if (isFirebaseOnline() && isGM) {
                console.log('[Whiteboard] Saving to Firebase:', fullState.elements.length, 'elements');
                saveWhiteboardState(fullState);
            } else if (isFirebaseOnline() && canDraw) {
                // Players only save drawing updates
                saveWhiteboardState({ drawing: strokeHistory || [], liveStroke: liveStroke || null });
            }
        }
        
        // Quick sync for position changes only (during drag)
        function quickSync() {
            if (!isFirebaseOnline() || !isGM) return;
            saveWhiteboard();
        }
        
        // Throttled sync for live updates (drawing, dragging)
        function throttledSync(type) {
            const now = Date.now();
            const throttle = type === 'draw' ? SYNC_THROTTLE_DRAW : SYNC_THROTTLE_DRAG;
            
            if (now - lastSyncTime >= throttle) {
                lastSyncTime = now;
                // Use quickSync for drag operations (no image data)
                if (type === 'drag') {
                    quickSync();
                } else {
                    saveWhiteboard();
                }
            } else {
                // Schedule a sync for when throttle period ends
                if (pendingSync) clearTimeout(pendingSync);
                pendingSync = setTimeout(() => {
                    lastSyncTime = Date.now();
                    if (type === 'drag') {
                        quickSync();
                    } else {
                        saveWhiteboard();
                    }
                    pendingSync = null;
                }, throttle - (now - lastSyncTime));
            }
        }
        
        // Separate function for GM-only settings (like playerDrawingAllowed toggle)
        function saveGMSettings() {
            if (!isGM || !isFirebaseOnline()) return;
            
            const fullState = {
                elements: elements.map(el => ({ 
                    id: el.id, 
                    type: el.type, 
                    x: el.x, 
                    y: el.y, 
                    zIndex: el.zIndex, 
                    ...(el.type === 'image' ? { src: el.src, width: el.width } : { text: el.text, rawText: el.rawText }) 
                })),
                zoom: zoomLevel, 
                snap: snapEnabled,
                drawing: strokeHistory,
                liveStroke: liveStroke,
                playerDrawingAllowed: playerDrawingAllowed
            };
            
            // Only save to Firebase, not localStorage (to avoid quota issues)
            saveWhiteboardState(fullState);
        }

        function setupEventListeners() {
            const canvas = document.getElementById('canvas'), wrapper = document.getElementById('canvasWrapper');
            canvas.addEventListener('mousedown', (e) => { if (e.target === canvas || e.target.id === 'canvasGrid') { deselectAll(); hideTextToolbar(); } });
            canvas.addEventListener('click', (e) => { 
                // Deselect wenn auf leere Fläche geklickt wird (nicht auf Element oder dessen Kinder)
                if (e.target === canvas || e.target.id === 'canvasGrid') { 
                    deselectAll(); 
                    hideTextToolbar(); 
                }
            });
            document.addEventListener('keydown', (e) => {
                if (editingTextElement) return;
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElement && !e.target.isContentEditable) { e.preventDefault(); deleteSelected(); }
                if (e.key === 'Escape') { deselectAll(); hideContextMenu(); hideTextToolbar(); }
                if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomIn(); }
                if (e.key === '-') { e.preventDefault(); zoomOut(); }
                if (e.key === '0' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); resetZoom(); }
            });
            wrapper.addEventListener('wheel', (e) => { if (e.ctrlKey || e.metaKey) { e.preventDefault(); e.deltaY < 0 ? zoomIn() : zoomOut(); } }, { passive: false });
            document.addEventListener('click', hideContextMenu);
            wrapper.addEventListener('dragover', (e) => { e.preventDefault(); document.getElementById('dropZone').classList.add('active'); });
            wrapper.addEventListener('dragleave', (e) => { if (!e.relatedTarget || !wrapper.contains(e.relatedTarget)) document.getElementById('dropZone').classList.remove('active'); });
            wrapper.addEventListener('drop', (e) => { e.preventDefault(); document.getElementById('dropZone').classList.remove('active'); handleDroppedFiles(e.dataTransfer.files, e.clientX, e.clientY); });
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // Touch events for mobile
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
        }
        
        function handleTouchMove(e) {
            if (!selectedElement || !isDragging) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = document.getElementById('canvas').getBoundingClientRect();
            let x = snapToGrid((touch.clientX - rect.left) / zoomLevel - dragOffset.x);
            let y = snapToGrid((touch.clientY - rect.top) / zoomLevel - dragOffset.y);
            selectedElement.domElement.style.left = x + 'px';
            selectedElement.domElement.style.top = y + 'px';
            selectedElement.x = x;
            selectedElement.y = y;
            // Throttled live sync
            throttledSync('drag');
        }
        
        function handleTouchEnd() {
            if (isDragging || isResizing) saveWhiteboard();
            isDragging = false;
            isResizing = false;
        }

        function zoomIn() { if (zoomLevel < ZOOM_MAX) { zoomLevel = Math.min(ZOOM_MAX, zoomLevel + ZOOM_STEP); applyZoom(); saveWhiteboard(); } }
        function zoomOut() { if (zoomLevel > ZOOM_MIN) { zoomLevel = Math.max(ZOOM_MIN, zoomLevel - ZOOM_STEP); applyZoom(); saveWhiteboard(); } }
        function resetZoom() { zoomLevel = 1; applyZoom(); saveWhiteboard(); }
        function applyZoom() { document.getElementById('canvas').style.transform = `scale(${zoomLevel})`; document.getElementById('zoomDisplay').textContent = Math.round(zoomLevel * 100) + '%'; }

        function toggleSnap() { snapEnabled = !snapEnabled; document.getElementById('snapToggle').classList.toggle('active', snapEnabled); document.getElementById('canvasGrid').classList.toggle('visible', snapEnabled); showToast(snapEnabled ? t('whiteboard.snap_enabled') : t('whiteboard.snap_disabled')); saveWhiteboard(); }
        function snapToGrid(v) { return snapEnabled ? Math.round(v / GRID_SIZE) * GRID_SIZE : v; }

        function triggerImageUpload() { 
            if (!isGM) return; // Block for non-GMs
            document.getElementById('imageInput').click(); 
        }
        function handleImageUpload(e) {
            if (!isGM) return; // Block for non-GMs
            const files = e.target.files; if (!files.length) return;
            Array.from(files).forEach((f, i) => {
                if (!f.type.startsWith('image/')) return;
                compressAndLoadImage(f, null, null, i);
            });
            e.target.value = '';
        }
        function handleDroppedFiles(files, clientX, clientY) {
            if (!isGM) return; // Block for non-GMs
            const rect = document.getElementById('canvas').getBoundingClientRect();
            const dropX = (clientX - rect.left) / zoomLevel, dropY = (clientY - rect.top) / zoomLevel;
            Array.from(files).forEach((f, i) => {
                if (!f.type.startsWith('image/')) return;
                compressAndLoadImage(f, dropX + i*20, dropY + i*20, i);
            });
        }
        
        // Compress image before adding to whiteboard
        function compressAndLoadImage(file, dropX, dropY, offset) {
            const img = new Image();
            const reader = new FileReader();
            
            reader.onload = (e) => {
                img.onload = () => {
                    // Compress using canvas
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Max dimensions for whiteboard (smaller = faster sync)
                    const MAX_DIM = 1200;
                    let w = img.naturalWidth;
                    let h = img.naturalHeight;
                    
                    // Scale down if too large
                    if (w > MAX_DIM || h > MAX_DIM) {
                        if (w > h) {
                            h = Math.round(h * (MAX_DIM / w));
                            w = MAX_DIM;
                        } else {
                            w = Math.round(w * (MAX_DIM / h));
                            h = MAX_DIM;
                        }
                    }
                    
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage(img, 0, 0, w, h);
                    
                    // Compress to JPEG with quality 0.7 (good balance)
                    const compressedSrc = canvas.toDataURL('image/jpeg', 0.7);
                    
                    const originalSize = e.target.result.length;
                    const compressedSize = compressedSrc.length;
                    console.log('[Whiteboard] Image compressed:', 
                        (originalSize/1024).toFixed(0) + 'KB →', 
                        (compressedSize/1024).toFixed(0) + 'KB',
                        '(' + Math.round((1 - compressedSize/originalSize) * 100) + '% smaller)');
                    
                    loadImageWithSize(compressedSrc, dropX, dropY, offset);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function loadImageWithSize(src, dropX, dropY, offset) {
            const img = new Image();
            img.onload = () => {
                const wrapper = document.getElementById('canvasWrapper');
                const maxW = wrapper.clientWidth * 0.6, maxH = wrapper.clientHeight * 0.6;
                let w = img.naturalWidth, h = img.naturalHeight;
                if (w > maxW) { h = h * (maxW / w); w = maxW; }
                if (h > maxH) { w = w * (maxH / h); h = maxH; }
                const x = dropX !== null ? dropX - w/2 : (wrapper.clientWidth / 2 / zoomLevel) - w/2 + offset*30;
                const y = dropY !== null ? dropY - h/2 : (wrapper.clientHeight / 2 / zoomLevel) - h/2 + offset*30;
                createImageElement(src, x, y, Math.round(w));
            };
            img.src = src;
        }

        function createImageElement(src, x = 100, y = 100, width = null, id = null, zIndex = null, height = null) {
            const canvas = document.getElementById('canvas'), elementId = id || 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5), elementZIndex = zIndex || zIndexCounter++;
            x = snapToGrid(x); y = snapToGrid(y);
            const el = document.createElement('div'); el.className = 'element element-image'; el.id = elementId;
            el.style.cssText = `left:${x}px;top:${y}px;z-index:${elementZIndex}` + (width ? `;width:${width}px` : '');
            
            // Build img style
            let imgStyle = '';
            if (width) imgStyle += `width:${width}px;`;
            if (height) imgStyle += `height:${height}px;`;
            
            // Only show controls for GM
            if (isGM) {
                el.innerHTML = `<img src="${src}" draggable="false" style="${imgStyle}"><div class="resize-handle"></div><button class="element-delete" onclick="deleteElement('${elementId}')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>`;
            } else {
                el.innerHTML = `<img src="${src}" draggable="false" style="${imgStyle}">`;
                el.style.pointerEvents = 'none';
            }
            
            const elementData = { id: elementId, type: 'image', src, x, y, width, height, zIndex: elementZIndex, domElement: el };
            elements.push(elementData);
            
            if (isGM) {
                el.addEventListener('mousedown', (e) => handleElementMouseDown(e, elementData));
                el.addEventListener('touchstart', (e) => handleElementTouchStart(e, elementData), { passive: false });
                el.addEventListener('contextmenu', (e) => handleContextMenu(e, elementData));
                const resizeHandle = el.querySelector('.resize-handle');
                if (resizeHandle) {
                    resizeHandle.addEventListener('mousedown', (e) => { 
                        e.stopPropagation(); 
                        isResizing = true; 
                        selectElement(elementData);
                        // Store starting dimensions and aspect ratio for resize
                        const img = el.querySelector('img');
                        const currentWidth = img ? img.offsetWidth : (elementData.width || 200);
                        const currentHeight = img ? img.offsetHeight : (elementData.height || 200);
                        elementData._resizeStart = { 
                            width: currentWidth, 
                            height: currentHeight,
                            aspectRatio: currentWidth / currentHeight
                        };
                    });
                    resizeHandle.addEventListener('touchstart', (e) => { 
                        e.stopPropagation(); 
                        e.preventDefault(); 
                        isResizing = true; 
                        selectElement(elementData);
                        const img = el.querySelector('img');
                        const currentWidth = img ? img.offsetWidth : (elementData.width || 200);
                        const currentHeight = img ? img.offsetHeight : (elementData.height || 200);
                        elementData._resizeStart = { 
                            width: currentWidth, 
                            height: currentHeight,
                            aspectRatio: currentWidth / currentHeight
                        };
                    }, { passive: false });
                }
                canvas.appendChild(el); selectElement(elementData);
            } else {
                canvas.appendChild(el);
            }
            updateEmptyState(); 
            if (isGM) saveWhiteboard();
        }

        function addTextElement() { 
            if (!isGM) return; // Block for non-GMs
            const rect = document.getElementById('canvas').getBoundingClientRect(); 
            createTextElement('Text eingeben', (rect.width / 2 / zoomLevel) - 60, (rect.height / 2 / zoomLevel) - 20); 
        }
        function createTextElement(text = 'Text', x = 100, y = 100, id = null, zIndex = null, rawText = null) {
            const canvas = document.getElementById('canvas'), elementId = id || 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5), elementZIndex = zIndex || zIndexCounter++;
            x = snapToGrid(x); y = snapToGrid(y);
            const el = document.createElement('div'); el.className = 'element element-text'; el.id = elementId; el.style.cssText = `left:${x}px;top:${y}px;z-index:${elementZIndex}`;
            el.innerHTML = renderMarkdown(rawText || text);
            
            // Only add controls for GM
            if (isGM) {
                const delBtn = document.createElement('button'); delBtn.className = 'element-delete'; delBtn.onclick = () => deleteElement(elementId);
                delBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                el.appendChild(delBtn);
            } else {
                el.style.pointerEvents = 'none';
            }
            
            const elementData = { id: elementId, type: 'text', text, rawText: rawText || text, x, y, zIndex: elementZIndex, domElement: el };
            elements.push(elementData);
            
            if (isGM) {
                el.addEventListener('mousedown', (e) => handleElementMouseDown(e, elementData));
                el.addEventListener('touchstart', (e) => handleElementTouchStart(e, elementData), { passive: false });
                el.addEventListener('contextmenu', (e) => handleContextMenu(e, elementData));
                el.addEventListener('dblclick', () => startTextEditing(elementData));
                canvas.appendChild(el); selectElement(elementData);
            } else {
                canvas.appendChild(el);
            }
            updateEmptyState(); 
            if (isGM) saveWhiteboard();
            if (isGM && text === 'Text eingeben') setTimeout(() => startTextEditing(elementData), 100);
            
            return elementData;
        }

        function renderMarkdown(t) { if (!t) return ''; let h = escapeHtml(t); h = h.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>'); h = h.replace(/\*([^*]+)\*/g, '<em>$1</em>'); h = h.replace(/`([^`]+)`/g, '<code>$1</code>'); return h.replace(/\n/g, '<br>'); }
        function escapeHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

        function startTextEditing(elementData) {
            const el = elementData.domElement; editingTextElement = elementData;
            el.textContent = elementData.rawText; el.contentEditable = true; el.classList.add('editing'); el.focus();
            const range = document.createRange(); range.selectNodeContents(el); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
            showTextToolbar(el);
            el.onblur = () => stopTextEditing(elementData);
            el.onkeydown = (e) => { if (e.ctrlKey && e.key === 'b') { e.preventDefault(); insertTextMarkdown('bold'); } if (e.ctrlKey && e.key === 'i') { e.preventDefault(); insertTextMarkdown('italic'); } if (e.key === 'Escape') el.blur(); };
        }

        function stopTextEditing(elementData) {
            const el = elementData.domElement; el.contentEditable = false; el.classList.remove('editing');
            let raw = el.innerText.trim() || 'Text'; elementData.rawText = raw; elementData.text = raw;
            el.innerHTML = renderMarkdown(raw);
            const delBtn = document.createElement('button'); delBtn.className = 'element-delete'; delBtn.onclick = () => deleteElement(elementData.id);
            delBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
            el.appendChild(delBtn);
            editingTextElement = null; hideTextToolbar(); saveWhiteboard();
        }

        function showTextToolbar(el) { const tb = document.getElementById('textToolbar'), rect = el.getBoundingClientRect(); tb.style.left = rect.left + 'px'; tb.style.top = (rect.top - 44) + 'px'; tb.classList.add('active'); }
        function hideTextToolbar() { document.getElementById('textToolbar').classList.remove('active'); }
        function insertTextMarkdown(type) {
            if (!editingTextElement) return;
            const el = editingTextElement.domElement;
            const sel = window.getSelection();
            
            // Save selection before any DOM changes
            if (!sel.rangeCount) {
                el.focus();
                return;
            }
            
            const range = sel.getRangeAt(0);
            const txt = range.toString();
            
            let b = '', a = '', p = '';
            if (type === 'bold') { b = '**'; a = '**'; p = 'fett'; }
            else if (type === 'italic') { b = '*'; a = '*'; p = 'kursiv'; }
            else if (type === 'code') { b = '`'; a = '`'; p = 'code'; }
            
            range.deleteContents();
            range.insertNode(document.createTextNode(b + (txt || p) + a));
            sel.collapseToEnd();
            
            // Ensure focus stays on text element
            el.focus();
            
            // Update data
            editingTextElement.rawText = el.innerText;
            editingTextElement.text = parseMarkdown(el.innerText);
        }

        function selectElement(d) { deselectAll(); selectedElement = d; d.domElement.classList.add('selected'); }
        function deselectAll() { if (selectedElement) { selectedElement.domElement.classList.remove('selected'); selectedElement = null; } }

        function handleElementMouseDown(e, d) {
            if (e.target.classList.contains('element-delete') || e.target.contentEditable === 'true') return;
            e.preventDefault(); selectElement(d); hideTextToolbar();
            // Don't allow dragging locked elements
            if (d.locked) return;
            if (!e.target.classList.contains('resize-handle')) { isDragging = true; const r = d.domElement.getBoundingClientRect(); dragOffset.x = (e.clientX - r.left) / zoomLevel; dragOffset.y = (e.clientY - r.top) / zoomLevel; }
        }
        
        function handleElementTouchStart(e, d) {
            if (e.target.classList.contains('element-delete') || e.target.contentEditable === 'true') return;
            e.preventDefault(); 
            selectElement(d); 
            hideTextToolbar();
            // Don't allow dragging locked elements
            if (d.locked) return;
            if (!e.target.classList.contains('resize-handle')) { 
                isDragging = true; 
                const touch = e.touches[0];
                const r = d.domElement.getBoundingClientRect(); 
                dragOffset.x = (touch.clientX - r.left) / zoomLevel; 
                dragOffset.y = (touch.clientY - r.top) / zoomLevel; 
            }
        }

        function handleMouseMove(e) {
            if (!selectedElement) return;
            const rect = document.getElementById('canvas').getBoundingClientRect();
            if (isDragging) { 
                let x = snapToGrid((e.clientX - rect.left) / zoomLevel - dragOffset.x);
                let y = snapToGrid((e.clientY - rect.top) / zoomLevel - dragOffset.y);
                selectedElement.domElement.style.left = x + 'px';
                selectedElement.domElement.style.top = y + 'px';
                selectedElement.x = x;
                selectedElement.y = y;
                // Throttled live sync
                throttledSync('drag');
            }
            if (isResizing && selectedElement.type === 'image') { 
                const el = selectedElement.domElement;
                const img = el.querySelector('img');
                const startRect = selectedElement._resizeStart;
                
                if (startRect && img) {
                    // Calculate new dimensions based on mouse position
                    const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                    const mouseX = (e.clientX - canvasRect.left) / zoomLevel;
                    const mouseY = (e.clientY - canvasRect.top) / zoomLevel;
                    
                    // Calculate distance from element origin
                    const deltaX = mouseX - selectedElement.x;
                    
                    // Get aspect ratio from the actual image or stored dimensions
                    const aspectRatio = startRect.aspectRatio || 1;
                    
                    // Calculate new size based on width delta only (proportional)
                    let newWidth = Math.max(50, deltaX);
                    let newHeight = newWidth / aspectRatio;
                    
                    // Minimum size
                    if (newHeight < 50) {
                        newHeight = 50;
                        newWidth = newHeight * aspectRatio;
                    }
                    
                    // Apply new dimensions
                    el.style.width = newWidth + 'px';
                    img.style.width = newWidth + 'px';
                    img.style.height = newHeight + 'px';
                    
                    selectedElement.width = newWidth;
                    selectedElement.height = newHeight;
                    
                    // Throttled live sync
                    throttledSync('drag');
                }
            }
        }

        function handleMouseUp(e) { 
            if (isDragging || isResizing) saveWhiteboard(); 
            isDragging = false; 
            isResizing = false; 
        }
        
        // Globaler Click-Handler für Deselect
        document.addEventListener('click', (e) => {
            const canvas = document.getElementById('canvas');
            const target = e.target;
            
            // Nicht deselecten wenn auf Toolbar, Menüs oder Element-Controls geklickt
            if (target.closest('.toolbar') || target.closest('.context-menu') || target.closest('.text-toolbar') || 
                target.closest('.element-delete') || target.closest('.resize-handle')) {
                return;
            }
            
            // Wenn auf Canvas/Grid geklickt wird (nicht auf ein Element)
            if (target === canvas || target.id === 'canvasGrid' || target.id === 'canvasWrapper' || target.id === 'dropZone' || target.id === 'emptyState') {
                deselectAll();
                hideTextToolbar();
            }
        });

        function handleContextMenu(e, d) { 
            e.preventDefault(); 
            selectElement(d); 
            const m = document.getElementById('contextMenu'); 
            m.style.left = e.clientX + 'px'; 
            m.style.top = e.clientY + 'px'; 
            m.classList.add('active');
            
            // Show/hide token-only items
            document.querySelectorAll('.context-menu-item.token-only').forEach(item => {
                item.style.display = d.type === 'token' ? 'flex' : 'none';
            });
            
            // Update lock text
            const lockText = document.getElementById('lockMenuText');
            if (lockText) {
                lockText.textContent = d.locked ? t('whiteboard.unlock') : t('whiteboard.lock');
            }
        }
        function hideContextMenu() { document.getElementById('contextMenu').classList.remove('active'); }

        function deleteElement(id) { const i = elements.findIndex(e => e.id === id); if (i === -1) return; elements[i].domElement.remove(); elements.splice(i, 1); if (selectedElement?.id === id) selectedElement = null; updateEmptyState(); saveWhiteboard(); }
        function deleteSelected() { if (selectedElement) { deleteElement(selectedElement.id); hideContextMenu(); } }
        function bringToFront() { if (selectedElement) { selectedElement.zIndex = zIndexCounter++; selectedElement.domElement.style.zIndex = selectedElement.zIndex; hideContextMenu(); saveWhiteboard(); } }
        function sendToBack() { if (selectedElement) { selectedElement.zIndex = 0; selectedElement.domElement.style.zIndex = 0; hideContextMenu(); saveWhiteboard(); } }
        function duplicateElement() { if (!selectedElement) return; if (selectedElement.type === 'image') createImageElement(selectedElement.src, selectedElement.x + 30, selectedElement.y + 30, selectedElement.width); else createTextElement(selectedElement.text, selectedElement.x + 30, selectedElement.y + 30, null, null, selectedElement.rawText); hideContextMenu(); }
        function clearCanvas() { 
            if (!isGM) return; // Block for non-GMs
            
            const hasElements = elements && elements.length > 0;
            const hasDrawings = strokeHistory && strokeHistory.length > 0;
            
            if (!hasElements && !hasDrawings) {
                showToast(t('whiteboard.nothing_to_clear'));
                return;
            }
            
            if (!confirm(t('whiteboard.confirm_clear'))) return; 
            
            // Clear DOM elements
            elements.forEach(e => e.domElement.remove()); 
            elements = []; 
            selectedElement = null; 
            zIndexCounter = 1; 
            
            // Clear drawings
            strokeHistory = [];
            liveStroke = null;
            const drawingCanvas = document.getElementById('drawingCanvas');
            if (drawingCtx) {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }
            updateUndoButton();
            
            // Clear fog
            fogCells = {};
            isFogEnabled = false;
            isFogMode = false;
            const fogLayer = document.getElementById('fogLayer');
            fogLayer?.classList.remove('active', 'editing');
            document.getElementById('fogToggle')?.classList.remove('active');
            document.getElementById('fogToggle').style.background = '';
            document.querySelectorAll('.fog-cell').forEach(cell => cell.classList.remove('revealed'));
            
            // Clear measure lines
            if (typeof clearMeasure === 'function') clearMeasure();
            
            updateEmptyState();
            
            // Force immediate sync to Firebase
            if (isFirebaseOnline()) {
                const clearState = {
                    elements: [],
                    zoom: zoomLevel || 1,
                    snap: snapEnabled || false,
                    drawing: [],
                    liveStroke: null,
                    playerDrawingAllowed: playerDrawingAllowed || false,
                    fog: {},
                    fogEnabled: false,
                    _cleared: Date.now()
                };
                console.log('[Whiteboard] Clearing all - sending empty state to Firebase');
                saveWhiteboardState(clearState);
            }
            
            // Also save to localStorage
            saveWhiteboard();
            showToast(t('whiteboard.cleared')); 
        }

        function updateEmptyState() { document.getElementById('emptyState').style.display = (elements.length || strokeHistory.length) ? 'none' : 'block'; }
        function showToast(m) { const t = document.getElementById('toast'); t.textContent = m; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2500); }
        
        // ===== DRAWING FUNCTIONS =====
        
        function setupDrawingCanvas() {
            const canvas = document.getElementById('drawingCanvas');
            const wrapper = document.getElementById('canvasWrapper');
            
            // Set canvas size - use a large fixed size that covers the workspace
            // The canvas is inside .canvas div which gets scaled by zoom
            const CANVAS_SIZE = 4000; // Large enough for most use cases
            
            function initCanvas() {
                canvas.width = CANVAS_SIZE;
                canvas.height = CANVAS_SIZE;
                canvas.style.width = CANVAS_SIZE + 'px';
                canvas.style.height = CANVAS_SIZE + 'px';
                
                drawingCtx = canvas.getContext('2d');
                drawingCtx.lineCap = 'round';
                drawingCtx.lineJoin = 'round';
                
                // Redraw existing strokes
                redrawAllStrokes();
            }
            
            initCanvas();
            
            // Mouse events
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseleave', endDraw);
            
            // Touch events
            canvas.addEventListener('touchstart', handleTouchDraw, { passive: false });
            canvas.addEventListener('touchmove', handleTouchDrawMove, { passive: false });
            canvas.addEventListener('touchend', endDraw);
            canvas.addEventListener('touchcancel', endDraw);
        }
        
        function updateDrawPermission() {
            const wasCanDraw = canDraw;
            canDraw = isGM || playerDrawingAllowed;
            
            console.log('[Whiteboard] updateDrawPermission:', { isGM, playerDrawingAllowed, canDraw, wasCanDraw });
            
            // Update draw toggle visibility for non-GMs using player-enabled class
            const drawToggle = document.getElementById('drawToggle');
            const pingToggle = document.getElementById('pingToggle');
            const drawPopup = document.getElementById('drawPopup');
            const pingPopup = document.getElementById('pingPopup');
            
            if (drawToggle) {
                drawToggle.classList.toggle('player-enabled', canDraw);
                console.log('[Whiteboard] drawToggle player-enabled:', canDraw);
            }
            if (pingToggle) {
                pingToggle.classList.toggle('player-enabled', canDraw);
            }
            
            // Only close modes if player actually loses permission (was true, now false)
            // AND they were actually in a mode
            if (!canDraw && (isDrawMode || isPingMode)) {
                console.log('[Whiteboard] Permission lost while in mode, closing');
                
                if (isDrawMode) {
                    isDrawMode = false;
                    document.getElementById('drawingCanvas')?.classList.remove('active');
                    drawToggle?.classList.remove('active');
                    if (drawPopup) drawPopup.classList.remove('visible');
                }
                if (isPingMode) {
                    isPingMode = false;
                    pingToggle?.classList.remove('active');
                    document.getElementById('canvasWrapper').style.cursor = '';
                    if (pingPopup) pingPopup.classList.remove('visible');
                }
                
                updateToolActiveState();
            }
        }
        
        function toggleDrawMode() {
            if (!canDraw) return;
            
            const willBeActive = !isDrawMode;
            
            // Close other modes first
            if (willBeActive) {
                closeAllToolModes('draw');
            }
            
            isDrawMode = willBeActive;
            const canvas = document.getElementById('drawingCanvas');
            const toggle = document.getElementById('drawToggle');
            const popup = document.getElementById('drawPopup');
            
            canvas.classList.toggle('active', isDrawMode);
            toggle.classList.toggle('active', isDrawMode);
            popup.classList.toggle('visible', isDrawMode);
            
            // Update tool-active state
            updateToolActiveState();
            
            if (isDrawMode) {
                deselectAll();
                hideTextToolbar();
                // Disable eraser when entering draw mode
                isEraser = false;
                document.getElementById('eraserToggle')?.classList.remove('active');
                canvas.classList.remove('eraser-mode');
            }
        }
        
        // Helper to update tool-active class on canvas
        function updateToolActiveState() {
            const canvasContainer = document.getElementById('canvas');
            const isToolActive = isDrawMode || isShapeMode || isMeasureMode || isPingMode;
            canvasContainer.classList.toggle('tool-active', isToolActive);
        }
        
        // Central function to close all tool modes
        function closeAllToolModes(except = null) {
            if (except !== 'draw' && isDrawMode) {
                isDrawMode = false;
                document.getElementById('drawingCanvas')?.classList.remove('active');
                document.getElementById('drawToggle')?.classList.remove('active');
                document.getElementById('drawPopup')?.classList.remove('visible');
            }
            if (except !== 'shape' && isShapeMode) {
                isShapeMode = false;
                document.getElementById('shapeToggle')?.classList.remove('active');
                document.getElementById('shapePopup')?.classList.remove('visible');
                const canvas = document.getElementById('canvas');
                canvas?.removeEventListener('mousedown', startShape);
                canvas?.removeEventListener('mousemove', drawShape);
                canvas?.removeEventListener('mouseup', endShape);
            }
            if (except !== 'measure' && isMeasureMode) {
                isMeasureMode = false;
                document.getElementById('measureToggle')?.classList.remove('active');
                document.getElementById('measureToolbar')?.classList.remove('visible');
                document.getElementById('canvas')?.removeEventListener('mousedown', startMeasure);
                document.getElementById('canvas')?.removeEventListener('mousemove', updateMeasure);
                document.getElementById('canvas')?.removeEventListener('mouseup', endMeasure);
                document.getElementById('canvasWrapper').style.cursor = '';
                clearMeasure();
            }
            if (except !== 'ping' && isPingMode) {
                isPingMode = false;
                document.getElementById('pingToggle')?.classList.remove('active');
                document.getElementById('pingPopup')?.classList.remove('visible');
                document.getElementById('canvasWrapper').style.cursor = '';
            }
            updateToolActiveState();
        }
        
        function toggleEraser() {
            isEraser = !isEraser;
            const canvas = document.getElementById('drawingCanvas');
            document.getElementById('eraserToggle').classList.toggle('active', isEraser);
            canvas.classList.toggle('eraser-mode', isEraser);
        }
        
        function setDrawColor(color) {
            drawColor = color;
            document.querySelectorAll('#drawPopup .color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.style.background === color || btn.style.backgroundColor === color);
            });
            // Exit eraser mode when selecting color
            if (isEraser) toggleEraser();
        }
        
        function setDrawSize(size) {
            drawSize = size;
            document.querySelectorAll('#drawPopup .size-btn').forEach((btn, i) => {
                const sizes = [2, 5, 12, 24];
                btn.classList.toggle('active', sizes[i] === size);
            });
        }
        
        function startDraw(e) {
            if (!isDrawMode || !canDraw) return;
            
            isDrawing = true;
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            // Divide by zoom to get canvas-space coordinates
            lastX = (e.clientX - rect.left) / zoomLevel;
            lastY = (e.clientY - rect.top) / zoomLevel;
            
            // Start new stroke (live synced)
            liveStroke = {
                color: isEraser ? 'eraser' : drawColor,
                size: isEraser ? drawSize * 3 : drawSize,
                points: [{ x: lastX, y: lastY }]
            };
            currentStroke = liveStroke;
        }
        
        function handleTouchDraw(e) {
            if (!isDrawMode || !canDraw) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            isDrawing = true;
            // Divide by zoom to get canvas-space coordinates
            lastX = (touch.clientX - rect.left) / zoomLevel;
            lastY = (touch.clientY - rect.top) / zoomLevel;
            
            // Start new stroke (live synced)
            liveStroke = {
                color: isEraser ? 'eraser' : drawColor,
                size: isEraser ? drawSize * 3 : drawSize,
                points: [{ x: lastX, y: lastY }]
            };
            currentStroke = liveStroke;
        }
        
        function handleTouchDrawMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            // Divide by zoom to get canvas-space coordinates
            const x = (touch.clientX - rect.left) / zoomLevel;
            const y = (touch.clientY - rect.top) / zoomLevel;
            
            drawLine(lastX, lastY, x, y);
            
            if (currentStroke) {
                currentStroke.points.push({ x, y });
                // Throttled live sync
                throttledSync('draw');
            }
            
            lastX = x;
            lastY = y;
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            // Divide by zoom to get canvas-space coordinates
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            drawLine(lastX, lastY, x, y);
            
            if (currentStroke) {
                currentStroke.points.push({ x, y });
                // Throttled live sync
                throttledSync('draw');
            }
            
            lastX = x;
            lastY = y;
        }
        
        function drawLine(x1, y1, x2, y2) {
            if (!drawingCtx) return;
            
            drawingCtx.beginPath();
            
            if (isEraser) {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.lineWidth = drawSize * 3;
            } else {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = drawColor;
                drawingCtx.lineWidth = drawSize;
            }
            
            drawingCtx.moveTo(x1, y1);
            drawingCtx.lineTo(x2, y2);
            drawingCtx.stroke();
        }
        
        function endDraw() {
            if (isDrawing && currentStroke && currentStroke.points.length > 1) {
                strokeHistory.push(currentStroke);
                updateUndoButton();
                updateEmptyState();
            }
            isDrawing = false;
            currentStroke = null;
            liveStroke = null; // Clear live stroke
            saveWhiteboard(); // Final sync with liveStroke cleared
        }
        
        function redrawAllStrokes(remoteLiveStroke = null) {
            const canvas = document.getElementById('drawingCanvas');
            
            // Ensure drawingCtx exists
            if (!drawingCtx && canvas) {
                console.log('[Whiteboard] Initializing drawingCtx');
                drawingCtx = canvas.getContext('2d');
            }
            
            if (!drawingCtx || !canvas) {
                console.warn('[Whiteboard] Drawing context not ready, canvas:', !!canvas, 'ctx:', !!drawingCtx);
                return;
            }
            
            // Clear the entire canvas - use actual canvas dimensions
            console.log('[Whiteboard] Clearing canvas:', canvas.width, 'x', canvas.height);
            drawingCtx.clearRect(0, 0, canvas.width, canvas.height);
            
            console.log('[Whiteboard] Redrawing', strokeHistory.length, 'strokes');
            
            // Draw completed strokes
            strokeHistory.forEach(stroke => {
                drawStroke(stroke);
            });
            
            // Draw remote live stroke (from other users)
            if (remoteLiveStroke && remoteLiveStroke.points?.length > 1) {
                drawStroke(remoteLiveStroke);
            }
            
            // Reset composite operation
            drawingCtx.globalCompositeOperation = 'source-over';
        }
        
        function drawStroke(stroke) {
            if (!stroke || stroke.points.length < 2) return;
            
            drawingCtx.beginPath();
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            
            if (stroke.color === 'eraser') {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.lineWidth = stroke.size;
            } else {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = stroke.color;
                drawingCtx.lineWidth = stroke.size;
            }
            
            drawingCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                drawingCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            drawingCtx.stroke();
        }
        
        function undoLastStroke() {
            if (strokeHistory.length === 0) return;
            
            strokeHistory.pop();
            redrawAllStrokes();
            updateUndoButton();
            updateEmptyState();
            
            // Immediate sync to Firebase for drawing changes
            if (isFirebaseOnline()) {
                console.log('[Whiteboard] Undo - syncing', strokeHistory.length, 'strokes');
                saveWhiteboardState({ 
                    drawing: strokeHistory, 
                    liveStroke: null,
                    _drawingUpdate: Date.now()
                });
            }
            saveWhiteboard();
        }
        
        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) btn.disabled = strokeHistory.length === 0;
        }
        
        function clearDrawing() {
            if (!canDraw) return;
            if (strokeHistory.length === 0) return;
            if (!confirm('Zeichnung löschen?')) return;
            
            strokeHistory = [];
            liveStroke = null;
            const canvas = document.getElementById('drawingCanvas');
            if (drawingCtx) {
                drawingCtx.clearRect(0, 0, canvas.width, canvas.height);
            }
            updateUndoButton();
            updateEmptyState();
            
            // Immediate sync to Firebase for drawing clear
            if (isFirebaseOnline()) {
                console.log('[Whiteboard] Clear drawing - syncing empty strokes');
                saveWhiteboardState({ 
                    drawing: [], 
                    liveStroke: null,
                    _drawingUpdate: Date.now()
                });
            }
            saveWhiteboard();
            showToast('Zeichnung gelöscht');
        }
        
        function togglePlayerDrawing() {
            if (!isGM) return;
            
            playerDrawingAllowed = !playerDrawingAllowed;
            const toggle = document.getElementById('playerDrawToggle');
            toggle.classList.toggle('active', playerDrawingAllowed);
            
            // Save GM settings (preserves existing drawings)
            saveGMSettings();
            showToast(playerDrawingAllowed ? 'Spieler können jetzt zeichnen' : 'Spieler können nicht mehr zeichnen');
        }
        
        async function forceSync() {
            if (!isGM) {
                showToast('Nur GM kann synchronisieren');
                return;
            }
            
            const btn = document.getElementById('forceSyncBtn');
            
            // Disable button during sync
            if (btn) {
                btn.disabled = true;
                btn.classList.add('active');
            }
            
            showToast('Synchronisiere...');
            
            const isOnline = isFirebaseOnline();
            console.log('[Whiteboard] === FORCE SYNC START ===');
            console.log('[Whiteboard] Elements:', elements.length);
            console.log('[Whiteboard] Drawings:', strokeHistory?.length || 0);
            console.log('[Whiteboard] Firebase online:', isOnline);
            
            if (!isOnline) {
                console.error('[Whiteboard] Firebase is offline!');
                showToast('✗ Firebase offline!');
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('active');
                    btn.style.background = 'var(--md-error)';
                    setTimeout(() => btn.style.background = '', 1000);
                }
                return;
            }
            
            try {
                const startTime = Date.now();
                
                // Build COMPLETE state with ALL data - NO undefined values
                const fullState = {
                    elements: elements.map(el => {
                        const base = { 
                            id: el.id, 
                            type: el.type, 
                            x: el.x || 0, 
                            y: el.y || 0, 
                            zIndex: el.zIndex || 1
                        };
                        
                        if (el.width) base.width = el.width;
                        if (el.height) base.height = el.height;
                        if (el.rotation) base.rotation = el.rotation;
                        
                        if (el.type === 'image') {
                            if (el.src) base.src = el.src;
                        } else if (el.type === 'text') {
                            base.text = el.text || '';
                            if (el.rawText) base.rawText = el.rawText;
                            if (el.color) base.color = el.color;
                        } else if (el.type === 'token') {
                            base.name = el.name || 'Token';
                            base.initials = el.initials || 'T';
                            base.color = el.color || '#6750a4';
                            base.size = el.size || 60;
                            if (el.portrait) base.portrait = el.portrait;
                        } else if (el.type === 'shape') {
                            base.shapeType = el.shapeType || 'rectangle';
                            base.width = el.width || 100;
                            base.height = el.height || 100;
                            base.color = el.color || '#ffffff';
                            base.strokeWidth = el.strokeWidth || 3;
                        }
                        return base;
                    }),
                    zoom: zoomLevel || 1, 
                    snap: snapEnabled || false,
                    drawing: strokeHistory || [],
                    playerDrawingAllowed: playerDrawingAllowed || false,
                    fog: fogCells || {},
                    fogEnabled: isFogEnabled || false,
                    _forceSync: Date.now()
                };
                
                // Log what we're sending
                console.log('[Whiteboard] Sending full state:', {
                    elementCount: fullState.elements.length,
                    elementTypes: fullState.elements.map(e => e.type),
                    drawingCount: fullState.drawing.length,
                    fogEnabled: fullState.fogEnabled
                });
                
                await saveWhiteboardState(fullState);
                
                const duration = Date.now() - startTime;
                console.log('[Whiteboard] === FORCE SYNC SUCCESS ===');
                console.log('[Whiteboard] Sync took:', duration + 'ms');
                showToast('✓ Sync OK (' + duration + 'ms)');
                
                // Success animation
                if (btn) {
                    btn.style.background = 'var(--md-tertiary)';
                    setTimeout(() => btn.style.background = '', 1000);
                }
                
            } catch (error) {
                console.error('[Whiteboard] === FORCE SYNC FAILED ===');
                console.error('[Whiteboard] Error:', error);
                showToast('✗ Sync fehlgeschlagen!');
                
                if (btn) {
                    btn.style.background = 'var(--md-error)';
                    setTimeout(() => btn.style.background = '', 1000);
                }
            } finally {
                if (btn) {
                    btn.disabled = false;
                    setTimeout(() => btn.classList.remove('active'), 500);
                }
            }
        }
        
        // ===== END DRAWING FUNCTIONS =====
        
        // ===== SHAPE TOOL FUNCTIONS =====
        
        function toggleShapeMode() {
            const willBeActive = !isShapeMode;
            
            // Close other modes first
            if (willBeActive) {
                closeAllToolModes('shape');
            }
            
            isShapeMode = willBeActive;
            const toggle = document.getElementById('shapeToggle');
            const popup = document.getElementById('shapePopup');
            
            toggle.classList.toggle('active', isShapeMode);
            popup.classList.toggle('visible', isShapeMode);
            
            // Update tool-active state
            updateToolActiveState();
            
            const canvas = document.getElementById('canvas');
            if (isShapeMode) {
                deselectAll();
                canvas.addEventListener('mousedown', startShape);
                canvas.addEventListener('mousemove', drawShape);
                canvas.addEventListener('mouseup', endShape);
            } else {
                canvas.removeEventListener('mousedown', startShape);
                canvas.removeEventListener('mousemove', drawShape);
                canvas.removeEventListener('mouseup', endShape);
            }
        }
        
        function setShapeType(type) {
            shapeType = type;
            document.querySelectorAll('#shapePopup .tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('shape' + type.charAt(0).toUpperCase() + type.slice(1))?.classList.add('active');
        }
        
        function setShapeColor(color) {
            shapeColor = color;
            document.querySelectorAll('#shapePopup .color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.style.background === color || btn.style.backgroundColor === color);
            });
        }
        
        function setShapeSize(size) {
            shapeSize = size;
            document.querySelectorAll('#shapePopup .size-btn').forEach((btn, i) => {
                const sizes = [2, 4, 8];
                btn.classList.toggle('active', sizes[i] === size);
            });
        }
        
        function startShape(e) {
            if (!isShapeMode || !isGM) return;
            if (e.target.closest('.element')) return; // Don't start on existing elements
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            shapeStartX = (e.clientX - rect.left) / zoomLevel;
            shapeStartY = (e.clientY - rect.top) / zoomLevel;
            isDrawingShape = true;
            
            // Create preview element
            currentShapeEl = document.createElement('div');
            currentShapeEl.className = 'element element-shape ' + shapeType;
            currentShapeEl.style.cssText = `left:${shapeStartX}px;top:${shapeStartY}px;width:0;height:0;color:${shapeColor};border-width:${shapeSize}px;pointer-events:none;`;
            canvas.appendChild(currentShapeEl);
        }
        
        function drawShape(e) {
            if (!isDrawingShape || !currentShapeEl) return;
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            const width = Math.abs(x - shapeStartX);
            const height = Math.abs(y - shapeStartY);
            const left = Math.min(x, shapeStartX);
            const top = Math.min(y, shapeStartY);
            
            if (shapeType === 'line' || shapeType === 'arrow') {
                // For lines/arrows, use SVG
                const angle = Math.atan2(y - shapeStartY, x - shapeStartX);
                const length = Math.sqrt(width * width + height * height);
                
                // Create SVG for proper arrow rendering
                const svgNS = 'http://www.w3.org/2000/svg';
                let svg = currentShapeEl.querySelector('svg');
                if (!svg) {
                    currentShapeEl.innerHTML = '';
                    svg = document.createElementNS(svgNS, 'svg');
                    svg.style.cssText = 'position:absolute;top:0;left:0;overflow:visible;';
                    currentShapeEl.appendChild(svg);
                }
                
                svg.setAttribute('width', length);
                svg.setAttribute('height', shapeSize * 4);
                svg.style.transform = `translateY(-${shapeSize * 2 - shapeSize/2}px)`;
                
                // Line
                let line = svg.querySelector('line');
                if (!line) {
                    line = document.createElementNS(svgNS, 'line');
                    svg.appendChild(line);
                }
                line.setAttribute('x1', 0);
                line.setAttribute('y1', shapeSize * 2);
                line.setAttribute('x2', shapeType === 'arrow' ? length - 12 : length);
                line.setAttribute('y2', shapeSize * 2);
                line.setAttribute('stroke', shapeColor);
                line.setAttribute('stroke-width', shapeSize);
                line.setAttribute('stroke-linecap', 'round');
                
                // Arrow head
                if (shapeType === 'arrow') {
                    let arrow = svg.querySelector('polygon');
                    if (!arrow) {
                        arrow = document.createElementNS(svgNS, 'polygon');
                        svg.appendChild(arrow);
                    }
                    const arrowSize = Math.max(12, shapeSize * 3);
                    const cy = shapeSize * 2;
                    arrow.setAttribute('points', `${length},${cy} ${length - arrowSize},${cy - arrowSize/2} ${length - arrowSize},${cy + arrowSize/2}`);
                    arrow.setAttribute('fill', shapeColor);
                }
                
                currentShapeEl.style.width = length + 'px';
                currentShapeEl.style.height = (shapeSize * 4) + 'px';
                currentShapeEl.style.left = shapeStartX + 'px';
                currentShapeEl.style.top = shapeStartY + 'px';
                currentShapeEl.style.transformOrigin = '0 50%';
                currentShapeEl.style.transform = `rotate(${angle}rad)`;
                currentShapeEl.style.background = 'transparent';
                currentShapeEl.style.border = 'none';
            } else {
                currentShapeEl.style.left = left + 'px';
                currentShapeEl.style.top = top + 'px';
                currentShapeEl.style.width = width + 'px';
                currentShapeEl.style.height = height + 'px';
            }
        }
        
        function endShape(e) {
            if (!isDrawingShape || !currentShapeEl) return;
            isDrawingShape = false;
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            const width = Math.abs(x - shapeStartX);
            const height = Math.abs(y - shapeStartY);
            
            // Only create if big enough
            if (width < 10 && height < 10) {
                currentShapeEl.remove();
                currentShapeEl = null;
                return;
            }
            
            // Convert preview to permanent element
            const elementId = 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            currentShapeEl.id = elementId;
            currentShapeEl.style.pointerEvents = 'auto';
            
            const elementData = {
                id: elementId,
                type: 'shape',
                shapeType: shapeType,
                x: parseFloat(currentShapeEl.style.left),
                y: parseFloat(currentShapeEl.style.top),
                width: parseFloat(currentShapeEl.style.width),
                height: parseFloat(currentShapeEl.style.height),
                color: shapeColor,
                strokeWidth: shapeSize,
                zIndex: zIndexCounter++,
                domElement: currentShapeEl
            };
            
            // For lines/arrows, extract rotation angle from transform
            if (shapeType === 'line' || shapeType === 'arrow') {
                const transform = currentShapeEl.style.transform;
                const match = transform.match(/rotate\(([-\d.]+)rad\)/);
                if (match) {
                    elementData.rotation = parseFloat(match[1]);
                }
            }
            
            elements.push(elementData);
            
            // Add delete button and event listeners
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'element-delete';
            deleteBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
            deleteBtn.onclick = () => deleteElement(elementId);
            currentShapeEl.appendChild(deleteBtn);
            
            currentShapeEl.addEventListener('mousedown', (ev) => handleElementMouseDown(ev, elementData));
            currentShapeEl.addEventListener('contextmenu', (ev) => handleContextMenu(ev, elementData));
            
            selectElement(elementData);
            currentShapeEl = null;
            updateEmptyState();
            saveWhiteboard();
        }
        
        // ===== TOKEN SYSTEM =====
        
        // Load player characters for token creation
        async function loadPlayerCharactersForToken() {
            const list = document.getElementById('playerCharactersList');
            if (!list) return;
            
            list.innerHTML = '<div class="player-char-loading">Lade Charaktere...</div>';
            
            try {
                // Get characters and players from Firebase
                const [charSnapshot, playersSnapshot] = await Promise.all([
                    getRef('characters').once('value'),
                    getRef('players').once('value')
                ]);
                
                const characters = charSnapshot.val() || {};
                const players = playersSnapshot.val() || {};
                
                console.log('[Whiteboard] Loaded characters:', Object.keys(characters).length);
                console.log('[Whiteboard] Loaded players:', Object.keys(players).length);
                
                if (Object.keys(characters).length === 0 && Object.keys(players).length === 0) {
                    list.innerHTML = '<div class="player-char-empty">Keine Spieler oder Charaktere vorhanden</div>';
                    return;
                }
                
                // Build combined list - characters with their player data
                const items = [];
                
                // Add characters (from charakterbogen)
                Object.entries(characters).forEach(([key, charData]) => {
                    // 5e 2024 format: char.header.name, char.narrative.portrait
                    const charName = charData.header?.name || charData.name || charData.charakterName || 'Unbenannt';
                    const portrait = charData.narrative?.portrait || charData.portrait || null;
                    
                    // Find matching player by key (username)
                    const player = players[key] || {};
                    const ownerName = player.username || key;
                    const playerColor = player.color || '#6750a4';
                    const initials = charName.substring(0, 2).toUpperCase();
                    
                    items.push({
                        characterKey: key, // Store key for portrait sync
                        name: charName,
                        initials: initials,
                        color: playerColor,
                        portrait: portrait,
                        owner: ownerName,
                        hasCharacter: true
                    });
                });
                
                // Also add players without characters (they can still be tokens)
                Object.entries(players).forEach(([key, player]) => {
                    // Skip if already added via character
                    if (characters[key]) return;
                    
                    const playerName = player.username || key;
                    const playerColor = player.color || '#6750a4';
                    const initials = playerName.substring(0, 2).toUpperCase();
                    
                    items.push({
                        characterKey: null, // No character linked
                        name: playerName,
                        initials: initials,
                        color: playerColor,
                        portrait: null,
                        owner: playerName,
                        hasCharacter: false
                    });
                });
                
                if (items.length === 0) {
                    list.innerHTML = '<div class="player-char-empty">Keine Spieler gefunden</div>';
                    return;
                }
                
                // Render list
                list.innerHTML = items.map(item => {
                    // Escape data for onclick
                    const charData = JSON.stringify({
                        characterKey: item.characterKey,
                        name: item.name,
                        initials: item.initials,
                        color: item.color,
                        portrait: item.portrait,
                        owner: item.owner
                    }).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                    
                    return `
                        <div class="player-char-item" onclick='selectCharacterForToken(${charData})'>
                            <div class="player-char-avatar" style="background:${item.color};border-color:${item.color}">
                                ${item.portrait ? `<img src="${item.portrait}" alt="${item.name}">` : item.initials}
                            </div>
                            <div class="player-char-info">
                                <div class="player-char-name">${item.name}</div>
                                <div class="player-char-owner">${item.owner}${item.hasCharacter ? '' : ' (kein Charakter)'}</div>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('[Whiteboard] Failed to load characters:', error);
                list.innerHTML = '<div class="player-char-empty">Fehler beim Laden</div>';
            }
        }
        
        // Track selected character key for portrait sync
        let selectedCharacterKey = null;
        
        // Select a character and fill the token form
        function selectCharacterForToken(charData) {
            console.log('[Whiteboard] Selected character for token:', charData);
            
            selectedCharacterKey = charData.characterKey || null;
            document.getElementById('tokenName').value = charData.name || '';
            document.getElementById('tokenInitials').value = charData.initials || '';
            selectedTokenColor = charData.color || '#6750a4';
            tokenPortraitData = charData.portrait || null;
            
            // Update color button selection
            document.querySelectorAll('.token-color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === selectedTokenColor);
            });
            
            // Update portrait preview
            updatePortraitPreview();
            
            // Focus on create button
            document.getElementById('tokenDialogSubmit').focus();
        }
        
        function openTokenDialog(editElement = null) {
            if (!isGM) return;
            
            editingToken = editElement;
            
            // Set dialog title and button text
            document.getElementById('tokenDialogTitle').textContent = editElement ? 'Token bearbeiten' : 'Token erstellen';
            document.getElementById('tokenDialogSubmit').textContent = editElement ? 'Speichern' : 'Erstellen';
            
            // Show/hide player characters section (only for new tokens)
            const charSection = document.getElementById('playerCharactersSection');
            if (charSection) {
                charSection.style.display = editElement ? 'none' : 'block';
            }
            
            // Load player characters for new tokens
            if (!editElement) {
                loadPlayerCharactersForToken();
            }
            
            // Pre-fill values if editing
            if (editElement) {
                document.getElementById('tokenName').value = editElement.name || '';
                document.getElementById('tokenInitials').value = editElement.initials || '';
                document.getElementById('tokenSize').value = editElement.size || 60;
                selectedTokenColor = editElement.color || '#6750a4';
                tokenPortraitData = editElement.portrait || null;
                
                // Show portrait preview
                updatePortraitPreview();
                
                // Highlight selected color
                document.querySelectorAll('.token-color-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.color === selectedTokenColor);
                });
            } else {
                // Reset for new token
                tokenPortraitData = null;
                updatePortraitPreview();
            }
            
            document.getElementById('dialogBackdrop').classList.add('active');
            document.getElementById('tokenDialog').classList.add('active');
            document.getElementById('tokenName').focus();
            
            // Setup color buttons
            document.querySelectorAll('.token-color-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.token-color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    selectedTokenColor = btn.dataset.color;
                };
            });
        }
        
        function closeTokenDialog() {
            document.getElementById('dialogBackdrop').classList.remove('active');
            document.getElementById('tokenDialog').classList.remove('active');
            // Reset form
            document.getElementById('tokenName').value = '';
            document.getElementById('tokenInitials').value = '';
            document.getElementById('tokenSize').value = '60';
            tokenPortraitData = null;
            editingToken = null;
            updatePortraitPreview();
        }
        
        function handleTokenPortrait(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                // Compress portrait
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const size = 200; // Small size for token portrait
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw cropped square from center
                    const minDim = Math.min(img.width, img.height);
                    const sx = (img.width - minDim) / 2;
                    const sy = (img.height - minDim) / 2;
                    ctx.drawImage(img, sx, sy, minDim, minDim, 0, 0, size, size);
                    
                    tokenPortraitData = canvas.toDataURL('image/jpeg', 0.8);
                    updatePortraitPreview();
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        }
        
        function clearTokenPortrait() {
            tokenPortraitData = null;
            updatePortraitPreview();
        }
        
        function updatePortraitPreview() {
            const preview = document.getElementById('tokenPortraitPreview');
            if (tokenPortraitData) {
                preview.innerHTML = `<img src="${tokenPortraitData}" style="width:100%;height:100%;object-fit:cover;">`;
            } else {
                preview.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:30px;height:30px;opacity:0.5;"><circle cx="12" cy="10" r="3"/><path d="M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662"/><circle cx="12" cy="12" r="10"/></svg>`;
            }
        }
        
        function submitToken() {
            const name = document.getElementById('tokenName').value || 'Token';
            const initials = document.getElementById('tokenInitials').value || name.substring(0, 2).toUpperCase();
            const size = parseInt(document.getElementById('tokenSize').value) || 60;
            
            if (editingToken) {
                // Update existing token
                editingToken.name = name;
                editingToken.initials = initials;
                editingToken.color = selectedTokenColor;
                editingToken.size = size;
                editingToken.portrait = tokenPortraitData;
                // Keep characterKey if editing (don't change link)
                
                // Update DOM
                const el = editingToken.domElement;
                el.style.borderColor = selectedTokenColor;
                el.style.width = size + 'px';
                el.style.height = size + 'px';
                
                // Update content
                if (tokenPortraitData) {
                    const existingImg = el.querySelector('img');
                    const letterEl = el.querySelector('.token-letter');
                    if (existingImg) {
                        existingImg.src = tokenPortraitData;
                    } else {
                        if (letterEl) letterEl.remove();
                        const img = document.createElement('img');
                        img.src = tokenPortraitData;
                        img.draggable = false;
                        el.insertBefore(img, el.firstChild);
                    }
                } else {
                    const existingImg = el.querySelector('img');
                    if (existingImg) existingImg.remove();
                    let letterEl = el.querySelector('.token-letter');
                    if (!letterEl) {
                        letterEl = document.createElement('span');
                        letterEl.className = 'token-letter';
                        el.insertBefore(letterEl, el.firstChild);
                    }
                    letterEl.textContent = initials;
                }
                
                el.querySelector('.token-name').textContent = name;
                
                saveWhiteboard();
            } else {
                // Create new token with characterKey for portrait sync
                const wrapper = document.getElementById('canvasWrapper');
                const x = (wrapper.clientWidth / 2 / zoomLevel) - size/2;
                const y = (wrapper.clientHeight / 2 / zoomLevel) - size/2;
                
                createTokenElement(name, initials, selectedTokenColor, size, x, y, null, null, tokenPortraitData, selectedCharacterKey);
            }
            
            // Reset selectedCharacterKey after creating
            selectedCharacterKey = null;
            closeTokenDialog();
        }
        
        function createTokenElement(name, initials, color, size, x, y, id = null, zIndex = null, portrait = null, characterKey = null) {
            const canvas = document.getElementById('canvas');
            const elementId = id || 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            const elementZIndex = zIndex || zIndexCounter++;
            
            const el = document.createElement('div');
            el.className = 'element element-token';
            el.id = elementId;
            el.style.cssText = `left:${x}px;top:${y}px;width:${size}px;height:${size}px;z-index:${elementZIndex};border-color:${color}`;
            
            // Content: either portrait image or initials
            const contentHtml = portrait 
                ? `<img src="${portrait}" draggable="false">`
                : `<span class="token-letter">${initials}</span>`;
            
            el.innerHTML = `
                ${contentHtml}
                <span class="token-name">${name}</span>
                ${isGM ? '<button class="element-delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>' : ''}
            `;
            
            if (!isGM) {
                el.style.pointerEvents = 'none';
            }
            
            const elementData = {
                id: elementId,
                type: 'token',
                name: name,
                initials: initials,
                color: color,
                size: size,
                portrait: portrait,
                characterKey: characterKey, // Link to character for auto-sync
                x: x,
                y: y,
                zIndex: elementZIndex,
                domElement: el
            };
            
            elements.push(elementData);
            
            if (isGM) {
                el.querySelector('.element-delete').onclick = () => deleteElement(elementId);
                el.addEventListener('mousedown', (e) => handleElementMouseDown(e, elementData));
                el.addEventListener('touchstart', (e) => handleElementTouchStart(e, elementData), { passive: false });
                el.addEventListener('contextmenu', (e) => handleContextMenu(e, elementData));
                el.addEventListener('dblclick', () => openTokenDialog(elementData));
            }
            
            canvas.appendChild(el);
            if (isGM && !id) selectElement(elementData);
            updateEmptyState();
            if (!id) saveWhiteboard();
            
            return elementData;
        }
        
        // ===== FOG OF WAR =====
        
        function initFogOfWar() {
            const fogLayer = document.getElementById('fogLayer');
            fogLayer.innerHTML = '';
            
            // Add GM view class if GM
            if (isGM) {
                fogLayer.classList.add('gm-view');
            }
            
            // Cover a large area (will be inside the scaled canvas)
            const fogWidth = 6000;
            const fogHeight = 4000;
            
            fogLayer.style.width = fogWidth + 'px';
            fogLayer.style.height = fogHeight + 'px';
            
            const cols = Math.ceil(fogWidth / FOG_CELL_SIZE);
            const rows = Math.ceil(fogHeight / FOG_CELL_SIZE);
            
            // Create fog cells
            const fragment = document.createDocumentFragment();
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'fog-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.style.cssText = `left:${col * FOG_CELL_SIZE}px;top:${row * FOG_CELL_SIZE}px;width:${FOG_CELL_SIZE}px;height:${FOG_CELL_SIZE}px;`;
                    
                    const cellId = `${row}-${col}`;
                    if (fogCells[cellId]) {
                        cell.classList.add('revealed');
                    }
                    
                    fragment.appendChild(cell);
                }
            }
            
            fogLayer.appendChild(fragment);
            
            // Single event listener on fog layer for better performance
            fogLayer.addEventListener('mousedown', handleFogMouseDown);
            fogLayer.addEventListener('mousemove', handleFogMouseMove);
            fogLayer.addEventListener('mouseup', handleFogMouseUp);
        }
        
        let isFogPainting = false;
        let fogPaintMode = 'reveal'; // 'reveal' or 'hide'
        
        function handleFogMouseDown(e) {
            if (!isFogMode || !isGM) return;
            
            const cell = e.target.closest('.fog-cell');
            if (!cell) return;
            
            e.preventDefault();
            isFogPainting = true;
            
            // Determine paint mode based on current cell state
            fogPaintMode = cell.classList.contains('revealed') ? 'hide' : 'reveal';
            
            toggleFogCell(cell);
        }
        
        function handleFogMouseMove(e) {
            if (!isFogPainting || !isFogMode || !isGM) return;
            
            const cell = e.target.closest('.fog-cell');
            if (!cell) return;
            
            toggleFogCell(cell);
        }
        
        function handleFogMouseUp() {
            if (isFogPainting) {
                isFogPainting = false;
                saveWhiteboard();
            }
        }
        
        function toggleFogCell(cell) {
            const cellId = `${cell.dataset.row}-${cell.dataset.col}`;
            
            if (fogPaintMode === 'reveal') {
                cell.classList.add('revealed');
                fogCells[cellId] = true;
            } else {
                cell.classList.remove('revealed');
                delete fogCells[cellId];
            }
        }
        
        function toggleFogMode() {
            if (!isGM) return;
            
            const toggle = document.getElementById('fogToggle');
            const fogLayer = document.getElementById('fogLayer');
            
            // 3 states: OFF -> ON+EDIT -> ON (no edit) -> OFF
            if (!isFogEnabled) {
                // State: OFF -> ON+EDIT
                isFogEnabled = true;
                isFogMode = true;
                
                fogLayer.classList.add('active', 'editing');
                toggle.classList.add('active');
                toggle.style.background = 'var(--md-error)'; // Red = editing
                
                showToast(t('whiteboard.fog_edit_active'));
            } else if (isFogMode) {
                // State: ON+EDIT -> ON (no edit)
                isFogMode = false;
                
                fogLayer.classList.remove('editing');
                toggle.style.background = ''; // Normal active color
                
                showToast(t('whiteboard.fog_edit_done'));
            } else {
                // State: ON -> OFF
                isFogEnabled = false;
                isFogMode = false;
                fogCells = {};
                
                fogLayer.classList.remove('active', 'editing');
                toggle.classList.remove('active');
                toggle.style.background = '';
                
                // Reset all cells
                document.querySelectorAll('.fog-cell').forEach(cell => {
                    cell.classList.remove('revealed');
                });
                
                showToast(t('whiteboard.fog_disabled'));
            }
            
            saveWhiteboard();
        }
        
        // Toggle just the editing mode (for when you want to stop editing but keep fog visible)
        function toggleFogEditing() {
            if (!isGM || !isFogEnabled) return;
            
            isFogMode = !isFogMode;
            const fogLayer = document.getElementById('fogLayer');
            const toggle = document.getElementById('fogToggle');
            
            fogLayer.classList.toggle('editing', isFogMode);
            toggle.style.background = isFogMode ? 'var(--md-error)' : '';
            
            if (isFogMode) {
                showToast('Fog-Bearbeitung aktiv');
            } else {
                showToast('Fog-Bearbeitung beendet');
            }
        }
        
        function disableFog() {
            if (!isGM) return;
            
            isFogEnabled = false;
            isFogMode = false;
            fogCells = {};
            
            const fogLayer = document.getElementById('fogLayer');
            fogLayer.classList.remove('active', 'editing');
            document.getElementById('fogToggle')?.classList.remove('active');
            
            // Reset all cells
            document.querySelectorAll('.fog-cell').forEach(cell => {
                cell.classList.remove('revealed');
            });
            
            saveWhiteboard();
            showToast(t('whiteboard.fog_disabled'));
        }
        
        function applyFogState(fogState, fogEnabled) {
            console.log('[Whiteboard] Applying fog state:', { fogEnabled, cellCount: fogState ? Object.keys(fogState).length : 0 });
            
            const fogLayer = document.getElementById('fogLayer');
            
            // Store state
            if (fogState) {
                fogCells = fogState;
            }
            isFogEnabled = fogEnabled || false;
            
            // Check if fog cells exist, if not wait for them
            const existingCells = document.querySelectorAll('.fog-cell');
            if (existingCells.length === 0) {
                console.log('[Whiteboard] Fog cells not ready, waiting...');
                // Wait for initFogOfWar to complete, then apply
                setTimeout(() => applyFogState(fogState, fogEnabled), 600);
                return;
            }
            
            // Apply enabled state
            if (isFogEnabled) {
                fogLayer.classList.add('active');
                // Don't add 'editing' for non-GMs
                if (!isGM) {
                    fogLayer.classList.remove('editing');
                }
            } else {
                fogLayer.classList.remove('active', 'editing');
            }
            
            // Apply revealed cells
            existingCells.forEach(cell => {
                const cellId = `${cell.dataset.row}-${cell.dataset.col}`;
                cell.classList.toggle('revealed', !!fogCells[cellId]);
            });
            
            console.log('[Whiteboard] Fog applied:', { enabled: isFogEnabled, revealed: Object.keys(fogCells).length });
        }
        
        // ===== ROTATION =====
        
        function rotateElement(degrees) {
            if (!selectedElement) return;
            
            const currentRotation = selectedElement.rotation || 0;
            const newRotation = currentRotation + degrees;
            selectedElement.rotation = newRotation;
            
            selectedElement.domElement.style.transform = `rotate(${newRotation}deg)`;
            hideContextMenu();
            saveWhiteboard();
        }
        
        // ===== TEXT COLOR =====
        
        function setTextColor(color) {
            document.querySelectorAll('.text-color-btn').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            if (editingTextElement) {
                if (color) {
                    editingTextElement.domElement.style.color = color;
                    editingTextElement.color = color;
                } else {
                    editingTextElement.domElement.style.color = '';
                    editingTextElement.color = null;
                }
                
                // Keep focus on text element
                editingTextElement.domElement.focus();
                saveWhiteboard();
            }
        }
        
        // ===== LOCK/UNLOCK ELEMENTS =====
        
        function toggleLock() {
            if (!selectedElement) return;
            selectedElement.locked = !selectedElement.locked;
            selectedElement.domElement.classList.toggle('locked', selectedElement.locked);
            hideContextMenu();
            saveWhiteboard();
            showToast(selectedElement.locked ? t('whiteboard.element_locked') : t('whiteboard.element_unlocked'));
        }
        
        // ===== PIN SYSTEM =====
        
        let selectedPinColor = '#ef4444';
        
        function openPinDialog() {
            if (!isGM) return;
            document.getElementById('pinDialog').classList.add('active');
            document.getElementById('pinDialogBackdrop').classList.add('active');
            document.getElementById('pinText').value = '';
            document.getElementById('pinText').focus();
            
            // Setup color buttons
            document.querySelectorAll('#pinDialog .token-color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === selectedPinColor);
                btn.onclick = () => {
                    selectedPinColor = btn.dataset.color;
                    document.querySelectorAll('#pinDialog .token-color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
            });
        }
        
        function closePinDialog() {
            document.getElementById('pinDialog').classList.remove('active');
            document.getElementById('pinDialogBackdrop').classList.remove('active');
        }
        
        function createPin() {
            const text = document.getElementById('pinText').value.trim() || 'Pin';
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const x = (rect.width / 2 - 16) / zoomLevel;
            const y = (rect.height / 2 - 32) / zoomLevel;
            
            createPinElement(text, selectedPinColor, x, y);
            closePinDialog();
            saveWhiteboard();
        }
        
        function createPinElement(text, color, x, y, id = null, zIndex = null) {
            const canvas = document.getElementById('canvas');
            const elementId = id || 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            const elementZIndex = zIndex || zIndexCounter++;
            
            const el = document.createElement('div');
            el.className = 'element element-pin';
            el.id = elementId;
            el.style.cssText = `left:${x}px;top:${y}px;z-index:${elementZIndex}`;
            el.innerHTML = `
                <svg viewBox="0 0 24 24" fill="${color}" stroke="${color}" stroke-width="1">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                    <circle cx="12" cy="10" r="3" fill="white"/>
                </svg>
                <div class="pin-tooltip">${text}</div>
            `;
            
            const elementData = { id: elementId, type: 'pin', text, color, x, y, zIndex: elementZIndex, domElement: el };
            elements.push(elementData);
            
            if (isGM) {
                el.addEventListener('mousedown', (e) => handleElementMouseDown(e, elementData));
                el.addEventListener('touchstart', (e) => handleElementTouchStart(e, elementData), { passive: false });
                el.addEventListener('contextmenu', (e) => handleContextMenu(e, elementData));
                el.addEventListener('dblclick', () => {
                    const newText = prompt(t('whiteboard.pin_edit'), text);
                    if (newText !== null) {
                        elementData.text = newText;
                        el.querySelector('.pin-tooltip').textContent = newText;
                        saveWhiteboard();
                    }
                });
            }
            
            canvas.appendChild(el);
            updateEmptyState();
            return elementData;
        }
        
        // ===== TOKEN LABELS =====
        
        let labelEditingToken = null;
        
        function openLabelDialog() {
            if (!selectedElement || selectedElement.type !== 'token') return;
            labelEditingToken = selectedElement;
            document.getElementById('labelDialog').classList.add('active');
            document.getElementById('labelDialogBackdrop').classList.add('active');
            document.getElementById('labelText').value = '';
            hideContextMenu();
            updateLabelDisplay();
        }
        
        function closeLabelDialog() {
            document.getElementById('labelDialog').classList.remove('active');
            document.getElementById('labelDialogBackdrop').classList.remove('active');
            labelEditingToken = null;
        }
        
        function addTokenLabel() {
            if (!labelEditingToken) return;
            const text = document.getElementById('labelText').value.trim();
            if (!text) return;
            
            const color = document.getElementById('labelColor').value;
            if (!labelEditingToken.labels) labelEditingToken.labels = [];
            labelEditingToken.labels.push({ text, color });
            
            document.getElementById('labelText').value = '';
            updateLabelDisplay();
            renderTokenLabels(labelEditingToken);
            saveWhiteboard();
        }
        
        function removeTokenLabel(index) {
            if (!labelEditingToken || !labelEditingToken.labels) return;
            labelEditingToken.labels.splice(index, 1);
            updateLabelDisplay();
            renderTokenLabels(labelEditingToken);
            saveWhiteboard();
        }
        
        function updateLabelDisplay() {
            const container = document.getElementById('currentLabels');
            if (!labelEditingToken || !labelEditingToken.labels || labelEditingToken.labels.length === 0) {
                container.innerHTML = '<span style="color:var(--md-on-surface-variant);font-size:12px;">Keine Labels</span>';
                return;
            }
            
            container.innerHTML = labelEditingToken.labels.map((label, i) => 
                `<span class="token-label ${label.color}" onclick="removeTokenLabel(${i})" style="cursor:pointer;" title="Klicken zum Entfernen">${label.text}</span>`
            ).join('');
        }
        
        function renderTokenLabels(tokenData) {
            const el = tokenData.domElement;
            let labelsContainer = el.querySelector('.token-labels');
            
            if (!tokenData.labels || tokenData.labels.length === 0) {
                if (labelsContainer) labelsContainer.remove();
                return;
            }
            
            if (!labelsContainer) {
                labelsContainer = document.createElement('div');
                labelsContainer.className = 'token-labels';
                el.appendChild(labelsContainer);
            }
            
            labelsContainer.innerHTML = tokenData.labels.map(label => 
                `<span class="token-label ${label.color}">${label.text}</span>`
            ).join('');
        }
        
        // ===== MEASURE TOOL =====
        
        let isMeasureMode = false;
        let measureStart = null;
        let measureLine = null;
        let measureLabel = null;
        let measureTimeout = null;
        
        function toggleMeasureMode() {
            const willBeActive = !isMeasureMode;
            
            // Close other modes first
            if (willBeActive) {
                closeAllToolModes('measure');
            }
            
            isMeasureMode = willBeActive;
            const toggle = document.getElementById('measureToggle');
            const toolbar = document.getElementById('measureToolbar');
            
            toggle.classList.toggle('active', isMeasureMode);
            toolbar.classList.toggle('visible', isMeasureMode);
            
            if (isMeasureMode) {
                deselectAll();
                document.getElementById('canvas').addEventListener('mousedown', startMeasure);
                document.getElementById('canvas').addEventListener('mousemove', updateMeasure);
                document.getElementById('canvas').addEventListener('mouseup', endMeasure);
                document.getElementById('canvasWrapper').style.cursor = 'crosshair';
            } else {
                document.getElementById('canvas').removeEventListener('mousedown', startMeasure);
                document.getElementById('canvas').removeEventListener('mousemove', updateMeasure);
                document.getElementById('canvas').removeEventListener('mouseup', endMeasure);
                document.getElementById('canvasWrapper').style.cursor = '';
                clearMeasure();
            }
            
            // Update tool-active state
            updateToolActiveState();
        }
        
        function startMeasure(e) {
            if (!isMeasureMode) return;
            
            // Clear any existing measure first
            clearMeasure();
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            measureStart = {
                x: (e.clientX - rect.left) / zoomLevel,
                y: (e.clientY - rect.top) / zoomLevel
            };
            
            // Create measure line SVG
            measureLine = document.createElement('div');
            measureLine.className = 'measure-line';
            measureLine.innerHTML = '<svg><line stroke="var(--md-primary)" stroke-width="3" stroke-dasharray="8,4"/></svg>';
            canvas.appendChild(measureLine);
            
            // Create label
            measureLabel = document.createElement('div');
            measureLabel.className = 'measure-label';
            canvas.appendChild(measureLabel);
        }
        
        function updateMeasure(e) {
            if (!measureStart || !measureLine) return;
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const endX = (e.clientX - rect.left) / zoomLevel;
            const endY = (e.clientY - rect.top) / zoomLevel;
            
            // Calculate distance
            const dx = endX - measureStart.x;
            const dy = endY - measureStart.y;
            const pixelDist = Math.sqrt(dx * dx + dy * dy);
            
            // Convert to units
            const gridSize = parseInt(document.getElementById('measureGridSize').value) || 40;
            const unitSize = parseFloat(document.getElementById('measureUnitSize').value) || 5;
            const unit = document.getElementById('measureUnit').value;
            const distance = (pixelDist / gridSize) * unitSize;
            
            // Update line
            const svg = measureLine.querySelector('svg');
            const minX = Math.min(measureStart.x, endX);
            const minY = Math.min(measureStart.y, endY);
            const width = Math.abs(dx) + 10;
            const height = Math.abs(dy) + 10;
            
            measureLine.style.left = minX - 5 + 'px';
            measureLine.style.top = minY - 5 + 'px';
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            const line = svg.querySelector('line');
            line.setAttribute('x1', measureStart.x - minX + 5);
            line.setAttribute('y1', measureStart.y - minY + 5);
            line.setAttribute('x2', endX - minX + 5);
            line.setAttribute('y2', endY - minY + 5);
            
            // Update label
            measureLabel.textContent = distance.toFixed(1) + ' ' + unit;
            measureLabel.style.left = (measureStart.x + endX) / 2 + 'px';
            measureLabel.style.top = (measureStart.y + endY) / 2 + 'px';
        }
        
        function endMeasure() {
            measureStart = null;
            
            // Clear any existing timeout
            if (measureTimeout) {
                clearTimeout(measureTimeout);
            }
            
            // Store references to current elements
            const lineToRemove = measureLine;
            const labelToRemove = measureLabel;
            
            // Reset references immediately so new measures can be started
            measureLine = null;
            measureLabel = null;
            
            // Keep showing result for 2 seconds, then remove
            measureTimeout = setTimeout(() => {
                if (lineToRemove) lineToRemove.remove();
                if (labelToRemove) labelToRemove.remove();
            }, 2000);
        }
        
        function clearMeasure() {
            // Clear timeout
            if (measureTimeout) {
                clearTimeout(measureTimeout);
                measureTimeout = null;
            }
            
            // Remove current measure elements
            if (measureLine) { measureLine.remove(); measureLine = null; }
            if (measureLabel) { measureLabel.remove(); measureLabel = null; }
            
            // Also clean up any orphaned measure elements
            document.querySelectorAll('.measure-line, .measure-label').forEach(el => el.remove());
            
            measureStart = null;
        }
        
        // ===== REMOTE CURSORS =====
        
        let remoteCursors = {};
        let lastCursorUpdate = 0;
        let cursorVisibility = 'none'; // 'none', 'gm', 'players', 'all'
        
        function toggleCursorMenu() {
            const menu = document.getElementById('cursorMenu');
            menu.classList.toggle('active');
            
            // Close on click outside
            if (menu.classList.contains('active')) {
                setTimeout(() => {
                    document.addEventListener('click', closeCursorMenuOnClickOutside);
                }, 10);
            }
        }
        
        function closeCursorMenuOnClickOutside(e) {
            const menu = document.getElementById('cursorMenu');
            const btn = document.getElementById('cursorToggleBtn');
            if (!menu.contains(e.target) && !btn.contains(e.target)) {
                menu.classList.remove('active');
                document.removeEventListener('click', closeCursorMenuOnClickOutside);
            }
        }
        
        function setCursorVisibility(value) {
            cursorVisibility = value;
            
            // Update menu UI
            document.querySelectorAll('.cursor-menu-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.value === value);
            });
            
            // Update button state
            document.getElementById('cursorToggleBtn').classList.toggle('active', value !== 'none');
            
            // Close menu
            document.getElementById('cursorMenu').classList.remove('active');
            document.removeEventListener('click', closeCursorMenuOnClickOutside);
            
            // Sync to Firebase
            if (isFirebaseOnline() && isGM) {
                saveWhiteboardState({ cursorVisibility: value });
            }
            
            // Clear existing cursors if disabled
            if (value === 'none') {
                document.querySelectorAll('.remote-cursor').forEach(el => el.remove());
            }
            
            saveWhiteboard();
        }
        
        function shouldShowCursor(cursorIsGM) {
            if (cursorVisibility === 'none') return false;
            if (cursorVisibility === 'all') return true;
            if (cursorVisibility === 'gm' && cursorIsGM) return true;
            if (cursorVisibility === 'players' && !cursorIsGM) return true;
            return false;
        }
        
        function updateMyCursor(e) {
            // Only send if cursor visibility is enabled and includes us
            if (cursorVisibility === 'none') return;
            if (cursorVisibility === 'gm' && !isGM) return;
            if (cursorVisibility === 'players' && isGM) return;
            
            if (!isFirebaseOnline() || Date.now() - lastCursorUpdate < 50) return; // Throttle
            lastCursorUpdate = Date.now();
            
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;
            
            const userData = getCurrentUser();
            if (!userData) return;
            
            // Send cursor position
            if (typeof saveCursorPosition === 'function') {
                saveCursorPosition({
                    x: x,
                    y: y,
                    name: userData.username,
                    color: userData.color,
                    isGM: isGM,
                    timestamp: Date.now()
                });
            }
        }
        
        function renderRemoteCursor(id, data) {
            // Check if we should show this cursor
            if (!shouldShowCursor(data.isGM)) {
                const existing = document.getElementById('cursor_' + id);
                if (existing) existing.remove();
                return;
            }
            
            let cursor = document.getElementById('cursor_' + id);
            
            // Remove old cursors (> 3 seconds)
            if (Date.now() - data.timestamp > 3000) {
                if (cursor) cursor.remove();
                return;
            }
            
            if (!cursor) {
                cursor = document.createElement('div');
                cursor.id = 'cursor_' + id;
                cursor.className = 'remote-cursor';
                cursor.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="${data.color}" stroke="white" stroke-width="1.5">
                        <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                    </svg>
                    <span class="remote-cursor-name" style="background:${data.color}">${data.name}</span>
                `;
                document.getElementById('remoteCursors').appendChild(cursor);
            }
            
            cursor.style.left = (data.x * zoomLevel) + 'px';
            cursor.style.top = (data.y * zoomLevel) + 'px';
        }
        
        function handleRemoteCursors(cursors) {
            if (!cursors) return;
            const myId = getCurrentUser()?.username || 'anonymous';
            
            Object.keys(cursors).forEach(id => {
                if (id !== myId) {
                    renderRemoteCursor(id, cursors[id]);
                }
            });
            
            // Clean up old cursor elements
            document.querySelectorAll('.remote-cursor').forEach(el => {
                const id = el.id.replace('cursor_', '');
                if (!cursors[id] || Date.now() - cursors[id].timestamp > 3000) {
                    el.remove();
                }
            });
        }
        
        // ===== PING SYSTEM =====
        
        function sendPing(x, y) {
            const userData = getCurrentUser();
            if (!userData || !isFirebaseOnline()) return;
            
            // Show local ping
            showPing(x, y, userData.username, userData.color);
            
            // Send to others
            if (typeof savePing === 'function') {
                savePing({
                    x: x,
                    y: y,
                    name: userData.username,
                    color: userData.color,
                    senderId: userData.username || 'anonymous',
                    timestamp: Date.now()
                });
            }
        }
        
        function showPing(x, y, name, color, size = 60) {
            const ping = document.createElement('div');
            ping.className = 'ping-effect';
            ping.style.left = (x * zoomLevel) + 'px';
            ping.style.top = (y * zoomLevel) + 'px';
            ping.innerHTML = `
                <div class="ping-ring" style="border-color:${color};width:${size}px;height:${size}px;"></div>
                <div class="ping-ring" style="border-color:${color};width:${size}px;height:${size}px;"></div>
                <div class="ping-ring" style="border-color:${color};width:${size}px;height:${size}px;"></div>
                <div class="ping-dot" style="background:${color};width:${size/4}px;height:${size/4}px;"></div>
                <span class="ping-name" style="background:${color}">${name}</span>
            `;
            
            document.getElementById('canvas').appendChild(ping);
            setTimeout(() => ping.remove(), 1500);
        }
        
        let lastPingTimestamp = 0;
        
        function handleRemotePing(ping) {
            if (!ping || !ping.timestamp) return;
            // Ignore old pings or pings we already showed
            if (ping.timestamp <= lastPingTimestamp) return;
            if (Date.now() - ping.timestamp > 2000) return;
            
            // Ignore our own pings
            const myId = getCurrentUser()?.username || 'anonymous';
            if (ping.senderId === myId) return;
            
            lastPingTimestamp = ping.timestamp;
            showPing(ping.x, ping.y, ping.name, ping.color, ping.size);
        }
        
        // ===== PING MODE =====
        
        let pingColor = '#ff4444';
        let pingSize = 60;
        
        function togglePingMode() {
            if (!canDraw) {
                console.log('[Whiteboard] Ping blocked - no draw permission');
                return;
            }
            
            const willBeActive = !isPingMode;
            
            // Close other modes first
            if (willBeActive) {
                closeAllToolModes('ping');
            }
            
            isPingMode = willBeActive;
            const toggle = document.getElementById('pingToggle');
            const popup = document.getElementById('pingPopup');
            const wrapper = document.getElementById('canvasWrapper');
            
            console.log('[Whiteboard] togglePingMode:', isPingMode);
            
            toggle?.classList.toggle('active', isPingMode);
            popup?.classList.toggle('visible', isPingMode);
            
            // Update tool-active state
            updateToolActiveState();
            
            if (isPingMode) {
                deselectAll();
                wrapper.style.cursor = 'crosshair';
            } else {
                wrapper.style.cursor = '';
            }
        }
        
        // Global ping handler - registered once at init
        function initPingHandler() {
            const wrapper = document.getElementById('canvasWrapper');
            if (!wrapper) return;
            
            wrapper.addEventListener('mousedown', function(e) {
                if (!isPingMode) return;
                if (e.button !== 0) return; // Only left click
                
                // Don't ping on toolbar or popup clicks
                if (e.target.closest('.toolbar') || e.target.closest('.bottom-popup') || 
                    e.target.closest('.context-menu') || e.target.closest('.dialog')) return;
                
                e.preventDefault();
                
                const canvas = document.getElementById('canvas');
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / zoomLevel;
                const y = (e.clientY - rect.top) / zoomLevel;
                
                console.log('[Whiteboard] PING at:', x, y, 'color:', pingColor, 'size:', pingSize);
                sendPingWithSettings(x, y);
            });
        }
        
        // Initialize ping handler
        initPingHandler();
        
        function sendPingWithSettings(x, y) {
            const userData = getCurrentUser();
            if (!userData) return;
            
            // Show local ping with custom settings
            showPing(x, y, userData.username, pingColor, pingSize);
            
            // Send to others via Firebase
            if (isFirebaseOnline() && typeof savePing === 'function') {
                savePing({
                    x: x,
                    y: y,
                    name: userData.username,
                    color: pingColor,
                    size: pingSize,
                    senderId: userData.username || 'anonymous',
                    timestamp: Date.now()
                });
            }
        }
        
        function setPingColor(color) {
            pingColor = color;
            document.querySelectorAll('#pingPopup .color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.style.background === color || btn.style.backgroundColor === color);
            });
        }
        
        function setPingSize(size) {
            pingSize = size;
            document.querySelectorAll('#pingPopup .size-btn').forEach((btn, i) => {
                const sizes = [40, 60, 100];
                btn.classList.toggle('active', sizes[i] === size);
            });
        }
        
        // Track cursor movement
        document.getElementById('canvasWrapper')?.addEventListener('mousemove', updateMyCursor);
        
        // ===== INIT FOG ON LOAD =====
        
        // Initialize fog grid (but keep it hidden until enabled)
        setTimeout(() => {
            initFogOfWar();
            // Fog stays hidden (.fog-layer has display:none by default)
        }, 500);
        
        // Footer nicht auf Whiteboard - spezielles Layout
    </script>
</body>
</html>
