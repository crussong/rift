<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/icon_rift_r.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="view-transition" content="same-origin">
    <title>RIFT – Sessions</title>
    
    <link rel="stylesheet" href="/assets/css/core.css">
    <link rel="stylesheet" href="/assets/css/ui.css">
    <link rel="stylesheet" href="/assets/css/dock.css">
    <link rel="stylesheet" href="/assets/css/hub.css">
    <link rel="stylesheet" href="/assets/css/hub-features.css">
    <link rel="stylesheet" href="/assets/css/settings.css">
    <link rel="stylesheet" href="/assets/css/sessions.css?v=2">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css">

    <!-- Auth Guard: Hide until authenticated -->
    <style>
        body:not(.auth-ready) .app { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) .sheet-container { opacity: 0; pointer-events: none; }
        body:not(.auth-ready) main { opacity: 0; pointer-events: none; }
        body.auth-ready .app { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready .sheet-container { opacity: 1; transition: opacity 0.15s ease; }
        body.auth-ready main { opacity: 1; transition: opacity 0.15s ease; }
        select option:disabled { color: #555; opacity: 0.4; }
    </style>
</head>
<body>
    <!-- Unified Layout Placeholders -->
    <div id="topnav-placeholder"></div>
    <div id="meganav-placeholder"></div>
    
    <div class="app">
        <main class="main main--hub">
            <div class="main__content">
                
                <!-- Page Header -->
                <div class="page-header">
                    <div class="page-header__icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M21.8382 11.1263L21.609 13.5616C21.2313 17.5742 21.0425 19.5805 19.8599 20.7902C18.6773 22 16.9048 22 13.3599 22H10.6401C7.09517 22 5.32271 22 4.14009 20.7902C2.95748 19.5805 2.76865 17.5742 2.391 13.5616L2.16181 11.1263C1.9818 9.2137 1.8918 8.25739 2.21899 7.86207C2.39598 7.64823 2.63666 7.5172 2.89399 7.4946C3.36968 7.45282 3.96708 8.1329 5.16187 9.49307C5.77977 10.1965 6.08872 10.5482 6.43337 10.6027C6.62434 10.6328 6.81892 10.6018 6.99526 10.5131C7.31351 10.3529 7.5257 9.91812 7.95007 9.04852L10.1869 4.46486C10.9888 2.82162 11.3898 2 12 2C12.6102 2 13.0112 2.82162 13.8131 4.46485L16.0499 9.04851C16.4743 9.91812 16.6865 10.3529 17.0047 10.5131C17.1811 10.6018 17.3757 10.6328 17.5666 10.6027C17.9113 10.5482 18.2202 10.1965 18.8381 9.49307C20.0329 8.1329 20.6303 7.45282 21.106 7.4946C21.3633 7.5172 21.604 7.64823 21.781 7.86207C22.1082 8.25739 22.0182 9.2137 21.8382 11.1263ZM12.9524 12.699L12.8541 12.5227C12.4741 11.841 12.2841 11.5002 12 11.5002C11.7159 11.5002 11.5259 11.841 11.1459 12.5227L11.0476 12.699C10.9397 12.8927 10.8857 12.9896 10.8015 13.0535C10.7173 13.1174 10.6125 13.1411 10.4028 13.1886L10.2119 13.2318C9.47396 13.3987 9.10501 13.4822 9.01723 13.7645C8.92945 14.0468 9.18097 14.3409 9.68403 14.9291L9.81418 15.0813C9.95713 15.2485 10.0286 15.3321 10.0608 15.4355C10.0929 15.5389 10.0821 15.6504 10.0605 15.8734L10.0408 16.0765C9.96476 16.8613 9.92674 17.2538 10.1565 17.4282C10.3864 17.6027 10.7318 17.4436 11.4227 17.1255L11.6014 17.0432C11.7978 16.9528 11.8959 16.9076 12 16.9076C12.1041 16.9076 12.2022 16.9528 12.3986 17.0432L12.5773 17.1255C13.2682 17.4436 13.6136 17.6027 13.8435 17.4282C14.0733 17.2538 14.0352 16.8613 13.9592 16.0765L13.9395 15.8734C13.9179 15.6504 13.9071 15.5389 13.9392 15.4355C13.9714 15.3321 14.0429 15.2485 14.1858 15.0813L14.316 14.9291C14.819 14.3409 15.0706 14.0468 14.9828 13.7645C14.895 13.4822 14.526 13.3987 13.7881 13.2318L13.5972 13.1886C13.3875 13.1411 13.2827 13.1174 13.1985 13.0535C13.1143 12.9896 13.0603 12.8927 12.9524 12.699Z"/>
                        </svg>
                    </div>
                    <div class="page-header__divider"></div>
                    <h1 class="page-header__title">Sessions</h1>
                    <span class="page-header__tagline">Plane, spiele, erinnere dich</span>
                </div>
                
                <!-- Hero Carousel (Admin-editable via Firebase session_slides) -->
                <div class="hero-carousel" id="sessionsCarousel" style="margin-top: 30px;">
                    <div class="hero-carousel__slides" id="sessionsCarouselSlides">
                        <!-- Slides werden dynamisch aus Firebase session_slides geladen -->
                        <div class="hero-carousel__slide active" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.2));">
                            <div class="hero-carousel__content">
                                <span class="hero-carousel__badge hero-carousel__badge--new">Willkommen</span>
                                <h2 class="hero-carousel__title">Sessions</h2>
                                <p class="hero-carousel__desc">Verwalte deine Spielsitzungen und starte neue Abenteuer.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Navigation Arrows -->
                    <button class="hero-carousel__nav hero-carousel__nav--prev" aria-label="Vorherige Slide">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
                    </button>
                    <button class="hero-carousel__nav hero-carousel__nav--next" aria-label="Nächste Slide">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
                    </button>
                    
                    <!-- Tab Navigation -->
                    <div class="hero-carousel__tabs" id="sessionsCarouselTabs">
                        <!-- Tabs werden dynamisch generiert -->
                    </div>
                    
                    <!-- Dots (Mobile) -->
                    <div class="hero-carousel__dots" id="sessionsCarouselDots">
                        <!-- Dots werden dynamisch generiert -->
                    </div>
                </div>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Active Session (if running) -->
                <section class="active-session" id="activeSessionSection" style="display: none;">
                    <div class="active-session__header">
                        <span class="active-session__live" id="activeSessionStatus">● Live</span>
                        <h2 class="active-session__title" id="activeSessionTitle">Session läuft gerade</h2>
                    </div>
                    <div class="active-session__card">
                        <!-- Cover -->
                        <div class="active-session__cover" id="activeSessionCover">
                            <img src="" alt="" id="activeSessionCoverImg">
                            <div class="active-session__cover-fallback">
                                <svg width="64" height="64" viewBox="0 0 100 100">
                                    <path d="M20 20h25v60h-25zM55 20h25v25h-25zM55 55h25l-25 25z" fill="currentColor"/>
                                </svg>
                            </div>
                        </div>
                        
                        <div class="active-session__info">
                            <div class="ruleset-badge ruleset-badge--worldsapart" id="activeSessionRuleset">
                                <img src="/assets/img/rulesets/ruleset_worldsapart.svg" alt="" id="activeSessionRulesetIcon">
                                <span id="activeSessionRulesetName">Worlds Apart</span>
                            </div>
                            <a href="#" class="active-session__name-link" id="activeSessionNameLink">
                                <h3 class="active-session__name" id="activeSessionName">Session laden...</h3>
                            </a>
                            <span class="active-session__meta" id="activeSessionMeta">Session 5 · 4 Teilnehmer online</span>
                        </div>
                        <div class="active-session__timer">
                            <span class="active-session__time" id="activeSessionTime">0:00:00</span>
                            <span class="active-session__label">Spielzeit</span>
                        </div>
                        <div class="active-session__actions">
                            <a href="#" class="active-session__btn active-session__btn--primary" id="goToActiveSessionBtn">
                                Zur Session
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                            </a>
                            <!-- GM Only Actions -->
                            <div class="active-session__gm-actions" id="activeSessionGmActions">
                                <button class="active-session__btn active-session__btn--secondary" id="pauseActiveSessionBtn" style="display: none;">
                                    Pausieren
                                </button>
                                <button class="active-session__btn active-session__btn--primary" id="resumeActiveSessionBtn" style="display: none;">
                                    Fortsetzen
                                </button>
                                <button class="active-session__btn active-session__btn--stop" id="endSessionBtn">
                                    Session beenden
                                </button>
                            </div>
                        </div>
                    </div>
                </section>
                
                <!-- Divider (only if active session) -->
                <div class="section-divider" id="activeSessionDivider" style="display: none;"></div>
                
                <!-- Upcoming Sessions -->
                <section class="sessions-section">
                    <div class="sessions-section__header">
                        <h2 class="sessions-section__title">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                                <line x1="16" y1="2" x2="16" y2="6"/>
                                <line x1="8" y1="2" x2="8" y2="6"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                            </svg>
                            Geplante Sessions
                        </h2>
                        <div style="display:flex;align-items:center;gap:10px;">
                            <span class="sessions-section__count" id="upcomingCount">0 geplant</span>
                            <button class="sessions-section__add-btn" id="createSessionBtn" onclick="openCreateModal()" title="Neue Session planen">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                                    <circle cx="12" cy="12" r="10"/>
                                    <line x1="12" y1="8" x2="12" y2="16"/>
                                    <line x1="8" y1="12" x2="16" y2="12"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    
                    <div class="sessions-list" id="upcomingSessions">
                        <!-- Sessions werden dynamisch geladen -->
                    </div>
                    
                    <!-- Empty State -->
                    <div class="sessions-empty" id="upcomingEmpty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                            <line x1="16" y1="2" x2="16" y2="6"/>
                            <line x1="8" y1="2" x2="8" y2="6"/>
                            <line x1="3" y1="10" x2="21" y2="10"/>
                        </svg>
                        <p>Keine Sessions geplant</p>
                        <button class="sessions-empty__btn" onclick="openCreateModal()">Session planen</button>
                    </div>
                </section>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Session History -->
                <section class="sessions-section">
                    <div class="sessions-section__header">
                        <h2 class="sessions-section__title">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <polyline points="12 6 12 12 16 14"/>
                            </svg>
                            Vergangene Sessions
                        </h2>
                        <div class="sessions-section__filter">
                            <select id="historyFilter" class="sessions-filter">
                                <option value="all">Alle Kampagnen</option>
                                <option value="worldsapart">Worlds Apart</option>
                                <option value="5e2024">D&D 5e</option>
                                <option value="htbah">How To Be A Hero</option>
                                <option value="cyberpunk">Cyberpunk Red</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="sessions-list sessions-list--history" id="pastSessions">
                        <!-- Sessions werden dynamisch geladen -->
                    </div>
                    
                    <!-- Empty State -->
                    <div class="sessions-empty" id="pastEmpty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12 6 12 12 16 14"/>
                        </svg>
                        <p>Noch keine vergangenen Sessions</p>
                        <span class="sessions-empty__hint">Abgeschlossene Sessions erscheinen hier</span>
                    </div>
                    
                    <!-- Load More (initial versteckt) -->
                    <div class="sessions-load-more" id="loadMoreContainer" style="display: none;">
                        <button class="sessions-load-more__btn" id="loadMoreSessions">
                            Ältere Sessions laden
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                        </button>
                    </div>
                </section>
                
                <!-- Divider -->
                <div class="section-divider"></div>
                
                <!-- Stats Overview -->
                <section class="sessions-stats">
                    <h2 class="sessions-stats__title">Deine Statistiken</h2>
                    <div class="sessions-stats__grid">
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statSessionsPlayed">0</span>
                            <span class="sessions-stat__label">Sessions gespielt</span>
                        </div>
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statTotalTime">0h</span>
                            <span class="sessions-stat__label">Gesamte Spielzeit</span>
                        </div>
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statAvgDuration">--</span>
                            <span class="sessions-stat__label">Ø Session-Dauer</span>
                        </div>
                        <div class="sessions-stat">
                            <span class="sessions-stat__value" id="statTotalDice">0</span>
                            <span class="sessions-stat__label">Würfe insgesamt</span>
                        </div>
                    </div>
                </section>
                
            </div>
        </main>
    </div>
    
    <!-- Dock Placeholder -->
    <div id="dock-placeholder"></div>
    
    <!-- Footer Placeholder -->
    <div id="footer-placeholder"></div>
    
    <!-- Create/Edit Session Modal -->
    <div class="session-modal" id="createSessionModal">
        <div class="session-modal__backdrop"></div>
        <div class="session-modal__content session-modal__content--large">
            <div class="session-modal__header">
                <h2 class="session-modal__title" id="sessionModalTitle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="16"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                    </svg>
                    Neue Session erstellen
                </h2>
                <button class="session-modal__close" id="closeSessionModal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            
            <!-- Tabs -->
            <div class="session-modal__tabs">
                <button class="session-modal__tab session-modal__tab--active" data-create-tab="basics">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                    </svg>
                    Grundlagen
                </button>
                <button class="session-modal__tab" data-create-tab="schedule">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                        <line x1="16" y1="2" x2="16" y2="6"/>
                        <line x1="8" y1="2" x2="8" y2="6"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                    </svg>
                    Termin
                </button>
                <button class="session-modal__tab" data-create-tab="style">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                        <line x1="7" y1="7" x2="7.01" y2="7"/>
                    </svg>
                    Stil & Tags
                </button>
            </div>
            
            <div class="session-modal__body">
                
                <!-- Tab: Basics -->
                <div class="session-modal__tab-content session-modal__tab-content--active" id="createTab-basics">
                    
                    <!-- Cover Upload -->
                    <div class="form-group">
                        <label class="form-label">Cover (2:3)</label>
                        <div class="create-cover-upload" id="createCoverArea">
                            <input type="file" id="createCoverInput" accept="image/*" hidden>
                            <div class="create-cover-upload__preview" id="createCoverPreview">
                                <div class="create-cover-upload__placeholder">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" width="32" height="32">
                                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                        <circle cx="8.5" cy="8.5" r="1.5"/>
                                        <polyline points="21 15 16 10 5 21"/>
                                    </svg>
                                    <span>Cover hochladen</span>
                                </div>
                            </div>
                            <button type="button" class="create-cover-upload__remove" id="createCoverRemove" style="display: none;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Regelwerk *</label>
                        <div class="ruleset-select" id="rulesetSelect">
                            <label class="ruleset-option">
                                <input type="radio" name="createRuleset" value="worldsapart">
                                <div class="ruleset-option__box">
                                    <img src="/assets/img/rulesets/ruleset_worldsapart.svg" alt="">
                                    <span>Worlds Apart</span>
                                </div>
                            </label>
                            <label class="ruleset-option">
                                <input type="radio" name="createRuleset" value="5e2024">
                                <div class="ruleset-option__box">
                                    <img src="/assets/img/rulesets/ruleset_5e_2024.svg" alt="">
                                    <span>D&D 5e (2024)</span>
                                </div>
                            </label>
                            <label class="ruleset-option">
                                <input type="radio" name="createRuleset" value="htbah">
                                <div class="ruleset-option__box">
                                    <img src="/assets/img/rulesets/ruleset_htbah.svg" alt="">
                                    <span>How To Be A Hero</span>
                                </div>
                            </label>
                            <label class="ruleset-option">
                                <input type="radio" name="createRuleset" value="cyberpunk">
                                <div class="ruleset-option__box">
                                    <img src="/assets/img/rulesets/ruleset_cyberpunkred.svg" alt="">
                                    <span>Cyberpunk Red</span>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Name des Abenteuers *</label>
                        <input type="text" class="form-input" id="sessionName" placeholder="z.B. Die verlorene Mine von Phandelver" required>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Untertitel / Episode</label>
                        <input type="text" class="form-input" id="sessionSubtitle" placeholder="z.B. Kapitel 1: Ein Hilferuf">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Beschreibung</label>
                        <textarea class="form-textarea" id="sessionDescription" placeholder="Worum geht es? Was erwartet die Spieler?" rows="4"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Voice Chat Link</label>
                        <div class="form-input-with-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                                <line x1="12" y1="19" x2="12" y2="23"/>
                                <line x1="8" y1="23" x2="16" y2="23"/>
                            </svg>
                            <input type="url" class="form-input" id="sessionVoiceLink" placeholder="Discord, TeamSpeak, Zoom...">
                        </div>
                    </div>
                    
                </div>
                
                <!-- Tab: Schedule -->
                <div class="session-modal__tab-content" id="createTab-schedule">
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Datum *</label>
                            <input type="date" class="form-input" id="sessionDate" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Uhrzeit *</label>
                            <input type="time" class="form-input" id="sessionTime" value="20:00" required>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Wiederholen</label>
                            <select class="form-select" id="sessionRecurring">
                                <option value="once">Einmalig</option>
                                <option value="spontan">Spontan / Flexibel</option>
                                <option value="weekly">Wöchentlich</option>
                                <option value="biweekly">Alle 2 Wochen</option>
                                <option value="monthly">Monatlich</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Geschätzte Dauer</label>
                            <select class="form-select" id="sessionDuration">
                                <option value="1">~1 Stunde</option>
                                <option value="2">~2 Stunden</option>
                                <option value="3" selected>~3 Stunden</option>
                                <option value="4">~4 Stunden</option>
                                <option value="5">5+ Stunden</option>
                                <option value="8">Ganztägig (8h+)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Geplante Sessions</label>
                            <input type="number" class="form-input" id="sessionCount" min="1" max="100" value="1" placeholder="Anzahl">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max. Teilnehmer</label>
                            <select class="form-input" id="sessionMaxPlayers">
                                <option value="2">2 Teilnehmer</option>
                                <option value="3">3 Teilnehmer</option>
                                <option value="4" selected>4 Teilnehmer</option>
                                <option value="5">5 Teilnehmer</option>
                                <option value="6">6 Teilnehmer</option>
                                <option value="7">7 Teilnehmer</option>
                                <option value="8">8 Teilnehmer</option>
                                <option value="10">10 Teilnehmer</option>
                            </select>
                            <p class="form-hint" id="maxPlayersCreateHint" style="display:none; color:#f0d060; margin-top:4px;"></p>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Tab: Style & Tags -->
                <div class="session-modal__tab-content" id="createTab-style">
                    
                    <div class="form-group">
                        <label class="form-label">Tags</label>
                        <p class="form-hint">Wähle passende Tags für deine Session</p>
                        <div class="create-tags-grid" id="sessionTags">
                            <label class="create-tag"><input type="checkbox" value="roleplay"><span>Roleplay</span></label>
                            <label class="create-tag"><input type="checkbox" value="combat"><span>Combat</span></label>
                            <label class="create-tag"><input type="checkbox" value="exploration"><span>Exploration</span></label>
                            <label class="create-tag"><input type="checkbox" value="puzzle"><span>Rätsel</span></label>
                            <label class="create-tag"><input type="checkbox" value="horror"><span>Horror</span></label>
                            <label class="create-tag"><input type="checkbox" value="comedy"><span>Comedy</span></label>
                            <label class="create-tag"><input type="checkbox" value="newbie"><span>Anfänger</span></label>
                            <label class="create-tag"><input type="checkbox" value="oneshot"><span>One-Shot</span></label>
                            <label class="create-tag"><input type="checkbox" value="campaign"><span>Kampagne</span></label>
                            <label class="create-tag"><input type="checkbox" value="sandbox"><span>Sandbox</span></label>
                            <label class="create-tag"><input type="checkbox" value="mystery"><span>Mystery</span></label>
                            <label class="create-tag"><input type="checkbox" value="social"><span>Social</span></label>
                            <label class="create-tag"><input type="checkbox" value="stealth"><span>Stealth</span></label>
                            <label class="create-tag"><input type="checkbox" value="dungeon"><span>Dungeon</span></label>
                            <label class="create-tag"><input type="checkbox" value="boss"><span>Bosskampf</span></label>
                            <label class="create-tag"><input type="checkbox" value="homebrew"><span>Homebrew</span></label>
                            <label class="create-tag"><input type="checkbox" value="pvp"><span>PvP</span></label>
                            <label class="create-tag"><input type="checkbox" value="mature"><span>18+</span></label>
                        </div>
                    </div>
                    
                    <!-- Custom Tags -->
                    <div class="form-group">
                        <label class="form-label">Eigene Tags</label>
                        <div class="create-custom-tags">
                            <div class="create-custom-tags__list" id="customTagsList"></div>
                            <div class="create-custom-tags__input">
                                <input type="text" class="form-input form-input--sm" id="customTagInput" placeholder="Eigenen Tag hinzufügen..." maxlength="20">
                                <button type="button" class="create-custom-tags__add" id="addCustomTagBtn">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Sichtbarkeit</label>
                        <div class="form-toggle-group">
                            <label class="form-toggle">
                                <input type="radio" name="visibility" value="public" checked>
                                <span class="form-toggle__box">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"/>
                                        <line x1="2" y1="12" x2="22" y2="12"/>
                                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                                    </svg>
                                    <span>Öffentlich</span>
                                    <small>Im Raum sichtbar</small>
                                </span>
                            </label>
                            <label class="form-toggle">
                                <input type="radio" name="visibility" value="private">
                                <span class="form-toggle__box">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                    </svg>
                                    <span>Privat</span>
                                    <small>Nur mit Link</small>
                                </span>
                            </label>
                        </div>
                    </div>
                    
                </div>
                
            </div>
            <div class="session-modal__footer">
                <button class="session-modal__btn session-modal__btn--secondary" id="cancelSessionBtn">Abbrechen</button>
                <button class="session-modal__btn session-modal__btn--primary" id="saveSessionBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Session erstellen
                </button>
            </div>
        </div>
    </div>
    
    <!-- Session Created Modal (Erfolg mit Link) -->
    <div class="session-modal" id="sessionCreatedModal">
        <div class="session-modal__backdrop"></div>
        <div class="session-modal__content">
            <div class="session-modal__header">
                <h2 class="session-modal__title">Session erstellt!</h2>
                <button class="session-modal__close" id="closeCreatedModal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="session-modal__body">
                <div class="session-created">
                    <div class="session-created__icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                            <polyline points="22 4 12 14.01 9 11.01"/>
                        </svg>
                    </div>
                    <h3 class="session-created__title" id="createdSessionName">Die verlorene Mine</h3>
                    <p class="session-created__meta" id="createdSessionMeta">Worlds Apart · Sa, 18. Jan · 20:00 Uhr</p>
                    
                    <div class="session-created__link">
                        <label class="form-label">Einladungslink</label>
                        <div class="session-created__link-box">
                            <input type="text" class="form-input" id="sessionShareLink" readonly>
                            <button class="btn btn--icon" id="copySessionLink" title="Link kopieren">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                            </button>
                        </div>
                        <p class="form-hint">Teile diesen Link mit deinen Spielern</p>
                    </div>
                </div>
            </div>
            <div class="session-modal__footer">
                <button class="session-modal__btn session-modal__btn--secondary" id="closeCreatedBtn">Schließen</button>
                <button class="session-modal__btn session-modal__btn--primary" id="goToSessionBtn">
                    Zur Session
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="9 18 15 12 9 6"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Cropper Modal -->
    <div class="rift-crop-modal" id="cropperModal">
        <div class="rift-crop-modal__content">
            <div class="rift-crop-modal__header">
                <h3 class="rift-crop-modal__title" id="cropperTitle">Bild zuschneiden</h3>
                <button class="rift-crop-modal__close" id="closeCropper">×</button>
            </div>
            <div class="rift-crop-modal__body">
                <img id="cropperImage" src="" alt="">
            </div>
            <div class="rift-crop-modal__footer">
                <button class="rift-crop-modal__btn rift-crop-modal__btn--cancel" id="cancelCrop">Abbrechen</button>
                <button class="rift-crop-modal__btn rift-crop-modal__btn--save" id="saveCrop">Übernehmen</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- RIFT Services -->
    <script src="/assets/js/firebase-config.js"></script>
    <script src="/assets/js/rift-state.js"></script>
    <script src="/assets/js/room-focus.js?v=1"></script>
    <script>
        // Auth Guard - redirect to login if not authenticated
        (function() {
            function waitForAuth() {
                // Wait for Firebase SDK
                if (typeof firebase === 'undefined' || !firebase.auth) {
                    return setTimeout(waitForAuth, 50);
                }
                // Wait for Firebase app initialization
                try {
                    var auth = firebase.auth();
                    auth.onAuthStateChanged(function(user) {
                        if (!user) {
                            window.location.href = '/login';
                        } else {
                            document.body.classList.add('auth-ready');
                        }
                    });
                } catch(e) {
                    // Firebase not initialized yet, retry
                    setTimeout(waitForAuth, 50);
                }
            }
            waitForAuth();
        })();
    </script>

    <script src="/assets/js/room-service.js"></script>
    <script src="/assets/js/user-service.js"></script>
    <script src="/assets/js/pro-status.js"></script>
    
    <script src="/assets/js/auth.js"></script>
    <script src="/assets/js/ui.js"></script>
    <script src="/assets/js/layout-unified.js"></script>
    <script src="/assets/js/settings.js"></script>
    <script src="/assets/js/admin.js"></script>
    <script src="/assets/js/transitions.js"></script>
    <script src="/assets/js/app.js"></script>
    <script>
        initUnifiedLayout();
        
        // ========================================
        // SESSIONS PAGE CAROUSEL (Full Featured)
        // ========================================
        // Guard against transitions.js re-execution
        if (window._sessionsPageInit) { console.log('[Sessions] Already initialized, skipping re-execution'); }
        else { window._sessionsPageInit = true;
        
        const SessionsCarousel = {
            slides: [],
            currentIndex: 0,
            autoplayInterval: null,
            countdownIntervals: [],
            
            async init() {
                await this.loadSlides();
                this.render();
                this.initNavigation();
                this.initCountdowns();
            },
            
            async loadSlides() {
                try {
                    if (typeof firebase === 'undefined' || !firebase.apps?.length) {
                        console.log('[SessionsCarousel] Firebase not ready, using defaults');
                        return;
                    }
                    
                    const db = firebase.firestore();
                    const snapshot = await db.collection('session_slides').get();
                    
                    if (!snapshot.empty) {
                        this.slides = snapshot.docs
                            .map(doc => ({ id: doc.id, ...doc.data() }))
                            .filter(s => s.active !== false)
                            .sort((a, b) => (a.order || 0) - (b.order || 0));
                        console.log('[SessionsCarousel] Loaded', this.slides.length, 'slides');
                    }
                } catch (e) {
                    console.error('[SessionsCarousel] Could not load slides:', e);
                }
            },
            
            getOverlayStyle(slide) {
                const opacity = (slide.overlayOpacity ?? 50) / 100;
                let color = 'rgba(0,0,0,' + opacity + ')';
                
                if (slide.overlayColor === 'white') {
                    color = 'rgba(255,255,255,' + opacity + ')';
                } else if (slide.overlayColor === 'accent') {
                    color = 'rgba(255,70,85,' + opacity + ')';
                } else if (slide.overlayColor === 'custom' && slide.overlayCustomColor) {
                    const hex = slide.overlayCustomColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    color = `rgba(${r},${g},${b},${opacity})`;
                }
                
                // Gradient direction
                let direction = 'to right';
                switch (slide.gradientDirection) {
                    case 'to-left': direction = 'to left'; break;
                    case 'to-bottom': direction = 'to bottom'; break;
                    case 'to-top': direction = 'to top'; break;
                    case 'radial': return `radial-gradient(circle at center, transparent 0%, ${color} 100%)`;
                }
                
                return `linear-gradient(${direction}, ${color} 0%, transparent 60%)`;
            },
            
            getBackgroundStyle(slide) {
                if (slide.videoUrl) {
                    return 'transparent';
                }
                if (slide.bgImageUrl) {
                    return `url('${slide.bgImageUrl}') center/cover no-repeat`;
                }
                return slide.background || 'linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.2))';
            },
            
            render() {
                if (this.slides.length === 0) return;
                
                const carousel = document.getElementById('sessionsCarousel');
                const container = document.getElementById('sessionsCarouselSlides');
                const tabsContainer = document.getElementById('sessionsCarouselTabs');
                const dotsContainer = document.getElementById('sessionsCarouselDots');
                if (!container) return;
                
                // Get first slide settings for global carousel options
                const firstSlide = this.slides[0] || {};
                const showArrows = firstSlide.carouselShowArrows !== false;
                const showTabs = firstSlide.carouselShowTabs !== false;
                const showDots = firstSlide.carouselShowDots !== false;
                const autoplay = firstSlide.carouselAutoplay !== false;
                
                // Render slides
                container.innerHTML = this.slides.map((slide, i) => `
                    <div class="hero-carousel__slide ${i === 0 ? 'active' : ''}" data-index="${i}">
                        <!-- Background -->
                        <div class="hero-carousel__bg" style="background: ${this.getBackgroundStyle(slide)};"></div>
                        
                        <!-- Video Background -->
                        ${slide.videoUrl ? `
                            <video class="hero-carousel__video" autoplay muted loop playsinline>
                                <source src="${slide.videoUrl}" type="video/mp4">
                            </video>
                        ` : ''}
                        
                        <!-- Overlay -->
                        <div class="hero-carousel__overlay" style="background: ${this.getOverlayStyle(slide)};"></div>
                        
                        <!-- Content -->
                        <div class="hero-carousel__content">
                            ${slide.showLiveIndicator ? '<div class="hero-carousel__live"><span class="hero-carousel__live-dot"></span>Live</div>' : ''}
                            
                            ${slide.showBadge !== false && slide.badge ? `
                                <span class="hero-carousel__badge hero-carousel__badge--${slide.badgeType || 'new'}">${slide.badge}</span>
                            ` : ''}
                            
                            ${slide.showTitle !== false && slide.title ? `
                                <h2 class="hero-carousel__title">${slide.title}</h2>
                            ` : ''}
                            
                            ${slide.showDescription !== false && slide.description ? `
                                <p class="hero-carousel__desc">${slide.description}</p>
                            ` : ''}
                            
                            ${slide.countdownDate ? `
                                <div class="hero-carousel__countdown" data-date="${slide.countdownDate}" data-slide="${i}">
                                    ${slide.countdownLabel ? `<span class="hero-carousel__countdown-label">${slide.countdownLabel}</span>` : ''}
                                    <span class="hero-carousel__countdown-time">--:--:--</span>
                                </div>
                            ` : ''}
                            
                            ${slide.showCta !== false && slide.ctaText ? `
                                <a href="${slide.ctaLink || '#'}" class="hero-carousel__cta">${slide.ctaText}</a>
                            ` : ''}
                        </div>
                    </div>
                `).join('');
                
                // Show/hide arrows
                carousel.querySelectorAll('.hero-carousel__nav').forEach(nav => {
                    nav.style.display = showArrows && this.slides.length > 1 ? '' : 'none';
                });
                
                // Render tabs
                if (tabsContainer) {
                    if (showTabs && this.slides.length > 1) {
                        tabsContainer.innerHTML = this.slides.map((slide, i) => `
                            <button class="hero-carousel__tab ${i === 0 ? 'active' : ''}" data-index="${i}">
                                ${slide.tabLabel || slide.badge || `Slide ${i + 1}`}
                            </button>
                        `).join('');
                        tabsContainer.style.display = '';
                    } else {
                        tabsContainer.style.display = 'none';
                    }
                }
                
                // Render dots
                if (dotsContainer) {
                    if (showDots && this.slides.length > 1) {
                        dotsContainer.innerHTML = this.slides.map((_, i) => `
                            <button class="hero-carousel__dot ${i === 0 ? 'active' : ''}" data-index="${i}"></button>
                        `).join('');
                        dotsContainer.style.display = '';
                    } else {
                        dotsContainer.style.display = 'none';
                    }
                }
                
                // Start autoplay if enabled
                if (autoplay && this.slides.length > 1) {
                    const duration = (firstSlide.autoplay || 6) * 1000;
                    this.startAutoplay(duration);
                }
            },
            
            initNavigation() {
                const carousel = document.getElementById('sessionsCarousel');
                if (!carousel || this.slides.length <= 1) return;
                
                // Arrows
                carousel.querySelector('.hero-carousel__nav--prev')?.addEventListener('click', () => this.goTo(this.currentIndex - 1));
                carousel.querySelector('.hero-carousel__nav--next')?.addEventListener('click', () => this.goTo(this.currentIndex + 1));
                
                // Tabs
                carousel.querySelectorAll('.hero-carousel__tab').forEach(tab => {
                    tab.addEventListener('click', () => this.goTo(parseInt(tab.dataset.index)));
                });
                
                // Dots
                carousel.querySelectorAll('.hero-carousel__dot').forEach(dot => {
                    dot.addEventListener('click', () => this.goTo(parseInt(dot.dataset.index)));
                });
                
                // Pause on hover
                carousel.addEventListener('mouseenter', () => this.stopAutoplay());
                carousel.addEventListener('mouseleave', () => {
                    const firstSlide = this.slides[0] || {};
                    if (firstSlide.carouselAutoplay !== false) {
                        this.startAutoplay((firstSlide.autoplay || 6) * 1000);
                    }
                });
            },
            
            initCountdowns() {
                document.querySelectorAll('.hero-carousel__countdown').forEach(el => {
                    const targetDate = new Date(el.dataset.date).getTime();
                    const timeEl = el.querySelector('.hero-carousel__countdown-time');
                    
                    const update = () => {
                        const now = Date.now();
                        const diff = targetDate - now;
                        
                        if (diff <= 0) {
                            timeEl.textContent = 'Jetzt!';
                            return;
                        }
                        
                        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                        const secs = Math.floor((diff % (1000 * 60)) / 1000);
                        
                        if (days > 0) {
                            timeEl.textContent = `${days}T ${hours}h ${mins}m`;
                        } else {
                            timeEl.textContent = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                        }
                    };
                    
                    update();
                    this.countdownIntervals.push(setInterval(update, 1000));
                });
            },
            
            goTo(index) {
                if (index < 0) index = this.slides.length - 1;
                if (index >= this.slides.length) index = 0;
                this.currentIndex = index;
                
                const carousel = document.getElementById('sessionsCarousel');
                if (!carousel) return;
                
                carousel.querySelectorAll('.hero-carousel__slide').forEach((slide, i) => {
                    slide.classList.toggle('active', i === index);
                });
                carousel.querySelectorAll('.hero-carousel__tab').forEach((tab, i) => {
                    tab.classList.toggle('active', i === index);
                });
                carousel.querySelectorAll('.hero-carousel__dot').forEach((dot, i) => {
                    dot.classList.toggle('active', i === index);
                });
            },
            
            startAutoplay(duration = 6000) {
                this.stopAutoplay();
                this.autoplayInterval = setInterval(() => this.goTo(this.currentIndex + 1), duration);
            },
            
            stopAutoplay() {
                if (this.autoplayInterval) {
                    clearInterval(this.autoplayInterval);
                    this.autoplayInterval = null;
                }
            }
        };
        
        // Initialize when Firebase is ready
        function initSessionsCarousel() {
            if (typeof firebase !== 'undefined' && firebase.apps?.length > 0) {
                SessionsCarousel.init();
            } else {
                setTimeout(initSessionsCarousel, 200);
            }
        }
        initSessionsCarousel();
        
        // Get current room code
        const currentRoomCode = localStorage.getItem('rift_current_room') || null;
        console.log('[Sessions] Current room code:', currentRoomCode);
        
        // GM detection - only GM can create sessions
        let isRoomGM = false;
        
        async function detectGMRole() {
            // Check localStorage first
            const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
            if (userData.isGM === true) {
                isRoomGM = true;
            }
            
            // Check room membership (more reliable)
            if (currentRoomCode && typeof RIFT !== 'undefined' && RIFT.rooms?.getCurrentMembership) {
                try {
                    const membership = await RIFT.rooms.getCurrentMembership(currentRoomCode);
                    if (membership) {
                        isRoomGM = membership.isGM === true;
                    }
                } catch (e) {
                    console.warn('[Sessions] Could not check room membership:', e);
                }
            }
            
            console.log('[Sessions] Is GM:', isRoomGM);
            updateGMVisibility();
        }
        
        function updateGMVisibility() {
            // Create session button - only GM
            const createBtn = document.getElementById('createSessionBtn');
            if (createBtn) {
                createBtn.style.display = isRoomGM ? '' : 'none';
            }
            
            // Empty state create button
            const emptyBtn = document.querySelector('.sessions-empty__btn');
            if (emptyBtn && emptyBtn.textContent.trim() === 'Session planen') {
                emptyBtn.style.display = isRoomGM ? '' : 'none';
            }
            
            // Edit buttons on session cards - only GM
            document.querySelectorAll('.session-card__edit-btn').forEach(btn => {
                btn.style.display = isRoomGM ? '' : 'none';
            });
        }
        
        // Run after RIFT is ready
        function initGMDetection() {
            if (typeof RIFT !== 'undefined' && RIFT.rooms) {
                detectGMRole();
            } else {
                setTimeout(initGMDetection, 500);
            }
        }
        setTimeout(initGMDetection, 600);
        
        // ========================================
        // FIREBASE SESSIONS SYNC
        // ========================================
        
        let firebaseSessions = [];
        let sessionsUnsubscribe = null;
        
        // Initialize Firebase Sessions
        async function initFirebaseSessions() {
            if (!currentRoomCode) {
                console.log('[Sessions] No room code - using local mode');
                // Fallback to localStorage for solo mode
                firebaseSessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
                renderSessions();
                return;
            }
            
            // Wait for RIFT.rooms to be available
            if (typeof RIFT === 'undefined' || !RIFT.rooms) {
                setTimeout(initFirebaseSessions, 500);
                return;
            }
            
            console.log('[Sessions] Subscribing to Firebase sessions for room:', currentRoomCode);
            
            // Subscribe to realtime updates
            sessionsUnsubscribe = RIFT.rooms.subscribeToSessions(currentRoomCode, (sessions) => {
                console.log('[Sessions] Firebase update - received', sessions.length, 'sessions');
                firebaseSessions = sessions;
                renderSessions();
                loadSessionCovers();
                checkActiveSession();
            });
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (sessionsUnsubscribe) sessionsUnsubscribe();
        });
        
        // Start initialization
        setTimeout(initFirebaseSessions, 500);
        
        // Re-render when Pro status initializes (to update slot counts)
        function waitForProAndRerender() {
            if (typeof RIFT !== 'undefined' && RIFT.pro && RIFT.pro.initialized) {
                renderSessions();
            } else {
                setTimeout(waitForProAndRerender, 1000);
            }
        }
        setTimeout(waitForProAndRerender, 1500);
        
        // ========================================
        // INDEXEDDB FOR COVER IMAGES
        // ========================================
        
        const CoverDB = {
            dbName: 'rift_covers',
            storeName: 'covers',
            
            async open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName, { keyPath: 'id' });
                        }
                    };
                });
            },
            
            async save(sessionId, imageData) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const request = store.put({ id: sessionId, image: imageData, timestamp: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            
            async get(sessionId) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    const request = store.get(sessionId);
                    request.onsuccess = () => resolve(request.result?.image || null);
                    request.onerror = () => reject(request.error);
                });
            },
            
            async delete(sessionId) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    const request = store.delete(sessionId);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        };
        
        // ========================================
        // MODAL HANDLING
        // ========================================
        
        const createModal = document.getElementById('createSessionModal');
        const createdModal = document.getElementById('sessionCreatedModal');
        const createBtn = document.getElementById('createSessionBtn');
        
        let editingSessionId = null;
        
        // Pro/Free gating helper for max participants selects
        function applyMaxPlayersGating(selectId, hintId) {
            const sel = document.getElementById(selectId);
            const hint = hintId ? document.getElementById(hintId) : null;
            if (!sel) return;
            
            const pro = (typeof RIFT !== 'undefined' && RIFT.pro && RIFT.pro.initialized) ? RIFT.pro : null;
            
            // Always enforce absolute max of 10 (Pro limit)
            const absoluteMax = 10;
            Array.from(sel.options).forEach(opt => {
                const val = parseInt(opt.value);
                if (val > absoluteMax) {
                    opt.style.display = 'none'; // Hide completely
                    opt.disabled = true;
                } else {
                    opt.style.display = '';
                }
            });
            
            if (!pro) {
                Array.from(sel.options).forEach(opt => {
                    const val = parseInt(opt.value);
                    if (val <= absoluteMax) opt.disabled = false;
                });
                if (hint) hint.style.display = 'none';
                return;
            }
            
            const limit = pro.getLimit('participantsPerSession');
            const comparison = pro.getLimitComparison('participantsPerSession');
            
            Array.from(sel.options).forEach(opt => {
                const val = parseInt(opt.value);
                if (val > absoluteMax) {
                    opt.style.display = 'none';
                    opt.disabled = true;
                } else {
                    opt.disabled = val > limit;
                    opt.style.display = '';
                }
            });
            
            if (!pro.isPro && hint) {
                hint.style.display = 'block';
                hint.innerHTML = `Free: max. ${comparison.free} Teilnehmer · <a href="/donate" style="color:var(--text-muted);display:inline-flex;align-items:center;gap:4px;"><img src="/assets/rift_pro/img/svg/rift_pro_badge02_gold.svg" alt="Pro" style="height:14px;vertical-align:middle;"> Bis zu ${comparison.pro === Infinity ? '∞' : comparison.pro}</a>`;
            } else if (hint) {
                hint.style.display = 'none';
            }
        }
        
        function openSessionModal(sessionToEdit = null) {
            editingSessionId = sessionToEdit?.id || null;
            
            // Reset cover removed flag
            if (typeof coverRemoved !== 'undefined') {
                coverRemoved = false;
            }
            
            // Reset to first tab
            document.querySelectorAll('.session-modal__tab').forEach(t => t.classList.remove('session-modal__tab--active'));
            document.querySelectorAll('.session-modal__tab-content').forEach(c => c.classList.remove('session-modal__tab-content--active'));
            document.querySelector('[data-create-tab="basics"]')?.classList.add('session-modal__tab--active');
            document.getElementById('createTab-basics')?.classList.add('session-modal__tab-content--active');
            
            // Update modal title
            const titleEl = document.getElementById('sessionModalTitle');
            titleEl.innerHTML = editingSessionId 
                ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
                     <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                     <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                   </svg>
                   Session bearbeiten`
                : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
                     <circle cx="12" cy="12" r="10"/>
                     <line x1="12" y1="8" x2="12" y2="16"/>
                     <line x1="8" y1="12" x2="16" y2="12"/>
                   </svg>
                   Neue Session erstellen`;
            
            // Update save button text
            const saveBtn = document.getElementById('saveSessionBtn');
            saveBtn.innerHTML = editingSessionId 
                ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                     <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                     <polyline points="17 21 17 13 7 13 7 21"/>
                     <polyline points="7 3 7 8 15 8"/>
                   </svg>
                   Änderungen speichern`
                : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                     <line x1="12" y1="5" x2="12" y2="19"/>
                     <line x1="5" y1="12" x2="19" y2="12"/>
                   </svg>
                   Session erstellen`;
            
            createModal.classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // Reset cover preview
            const coverPreview = document.getElementById('createCoverPreview');
            const coverRemoveBtn = document.getElementById('createCoverRemove');
            coverPreview.innerHTML = `<div class="create-cover-upload__placeholder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" width="32" height="32">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                </svg>
                <span>Cover hochladen</span>
            </div>`;
            coverRemoveBtn.style.display = 'none';
            createCoverDataUrl = null;
            
            if (sessionToEdit) {
                // Fill form with existing data - Ruleset via radio
                const rulesetRadio = document.querySelector(`input[name="createRuleset"][value="${sessionToEdit.ruleset}"]`);
                if (rulesetRadio) rulesetRadio.checked = true;
                
                document.getElementById('sessionName').value = sessionToEdit.name || '';
                document.getElementById('sessionSubtitle').value = sessionToEdit.subtitle || '';
                document.getElementById('sessionDescription').value = sessionToEdit.description || '';
                document.getElementById('sessionVoiceLink').value = sessionToEdit.voiceLink || '';
                document.getElementById('sessionCount').value = sessionToEdit.sessionCount || '1';
                document.getElementById('sessionMaxPlayers').value = sessionToEdit.maxPlayers || '4';
                document.getElementById('sessionDate').value = sessionToEdit.date || '';
                document.getElementById('sessionTime').value = sessionToEdit.time || '20:00';
                document.getElementById('sessionRecurring').value = sessionToEdit.recurring || 'once';
                document.getElementById('sessionDuration').value = sessionToEdit.duration || '3';
                
                // Tags - check predefined ones and collect custom ones
                const predefinedTagValues = [];
                document.querySelectorAll('#sessionTags input').forEach(cb => {
                    predefinedTagValues.push(cb.value);
                    cb.checked = sessionToEdit.tags?.includes(cb.value) || false;
                });
                
                // Load custom tags (tags that are not predefined)
                if (typeof customTags !== 'undefined') {
                    customTags = sessionToEdit.tags?.filter(t => !predefinedTagValues.includes(t)) || [];
                    if (typeof renderCustomTags === 'function') renderCustomTags();
                }
                
                // Visibility
                const visibilityRadio = document.querySelector(`input[name="visibility"][value="${sessionToEdit.visibility || 'public'}"]`);
                if (visibilityRadio) visibilityRadio.checked = true;
                
                // Load cover from Cloudinary URL if exists
                if (sessionToEdit.coverUrl) {
                    coverPreview.innerHTML = `<img src="${sessionToEdit.coverUrl}" alt="Cover">`;
                    coverRemoveBtn.style.display = 'flex';
                    createCoverDataUrl = sessionToEdit.coverUrl; // Keep existing URL
                }
                
            } else {
                // Reset form for new session
                // Set default date to next Saturday
                const today = new Date();
                const daysUntilSat = (6 - today.getDay() + 7) % 7 || 7;
                const nextSat = new Date(today);
                nextSat.setDate(today.getDate() + daysUntilSat);
                document.getElementById('sessionDate').value = nextSat.toISOString().split('T')[0];
                
                // Reset ruleset radio buttons
                document.querySelectorAll('input[name="createRuleset"]').forEach(r => r.checked = false);
                
                document.getElementById('sessionName').value = '';
                document.getElementById('sessionSubtitle').value = '';
                document.getElementById('sessionDescription').value = '';
                document.getElementById('sessionVoiceLink').value = '';
                document.getElementById('sessionCount').value = '1';
                document.getElementById('sessionMaxPlayers').value = '4';
                
                // Pro/Free gating for max participants
                applyMaxPlayersGating('sessionMaxPlayers', 'maxPlayersCreateHint');
                document.getElementById('sessionTime').value = '20:00';
                document.getElementById('sessionRecurring').value = 'once';
                document.getElementById('sessionDuration').value = '3';
                
                // Reset tags (predefined and custom)
                document.querySelectorAll('#sessionTags input').forEach(cb => cb.checked = false);
                if (typeof customTags !== 'undefined') {
                    customTags = [];
                    if (typeof renderCustomTags === 'function') renderCustomTags();
                }
                
                // Reset visibility (default: public)
                document.querySelector('input[name="visibility"][value="public"]').checked = true;
            }
            
            // Reset cover (always - cover upload is separate)
            const oldCoverPreview = document.getElementById('coverPreview');
            const oldCoverPlaceholder = document.getElementById('coverPlaceholder');
            if (oldCoverPreview) oldCoverPreview.style.display = 'none';
            if (oldCoverPlaceholder) oldCoverPlaceholder.style.display = 'flex';
            
            // Reset thumbnail
            const thumbPreview = document.getElementById('thumbnailPreview');
            const thumbPlaceholder = document.getElementById('thumbnailPlaceholder');
            if (thumbPreview) thumbPreview.style.display = 'none';
            if (thumbPlaceholder) thumbPlaceholder.style.display = 'flex';
        }
        
        // Alias for backwards compatibility
        function openCreateModal() {
            // Only GM can create sessions
            if (!isRoomGM) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.info('Nur der Spielleiter kann Sessions erstellen.');
                }
                return;
            }
            
            // Check session creation limit (use Firebase sessions if available)
            if (typeof RIFT !== 'undefined' && RIFT.pro && RIFT.pro.initialized) {
                const sessions = (typeof firebaseSessions !== 'undefined' && firebaseSessions.length > 0)
                    ? firebaseSessions
                    : JSON.parse(localStorage.getItem('rift_sessions') || '[]');
                const activeSessions = sessions.filter(s => s.status !== 'ended').length;
                if (!RIFT.pro.checkLimitOrUpsell('sessionsPerRoom', activeSessions, 'Session-Limit erreicht. Mit RIFT Pro mehr Sessions erstellen.')) {
                    return;
                }
            }
            openSessionModal(null);
        }
        
        function closeCreateModal() {
            createModal.classList.remove('open');
            document.body.style.overflow = '';
            editingSessionId = null;
        }
        
        // Edit session function (called from onclick)
        function editSession(sessionId) {
            if (!isRoomGM) return;
            // Read from Firestore data (primary) with localStorage fallback
            const sessionData = firebaseSessions.find(s => s.id === sessionId)
                || JSON.parse(localStorage.getItem('rift_sessions') || '[]').find(s => s.id === sessionId);
            
            if (sessionData) {
                openSessionModal(sessionData);
            } else {
                console.error('Session not found:', sessionId);
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Session nicht gefunden');
                }
            }
        }
        
        // Check URL for edit parameter on page load
        const urlParams = new URLSearchParams(window.location.search);
        const editId = urlParams.get('edit');
        if (editId) {
            // Small delay to ensure DOM is ready
            setTimeout(() => editSession(editId), 100);
        }
        
        let lastCreatedSessionId = null;
        
        function openCreatedModal(sessionData) {
            lastCreatedSessionId = sessionData.id;
            createdModal.classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // Update display
            document.getElementById('createdSessionName').textContent = sessionData.name;
            
            const rulesetNames = {
                '5e2024': 'D&D 5e (2024)',
                'worldsapart': 'Worlds Apart',
                'htbah': 'How To Be A Hero',
                'cyberpunk': 'Cyberpunk Red'
            };
            
            const dateObj = new Date(sessionData.date + 'T' + sessionData.time);
            const weekdays = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
            const months = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
            const formattedDate = `${weekdays[dateObj.getDay()]}, ${dateObj.getDate()}. ${months[dateObj.getMonth()]}`;
            
            document.getElementById('createdSessionMeta').textContent = 
                `${rulesetNames[sessionData.ruleset] || sessionData.ruleset} · ${formattedDate} · ${sessionData.time} Uhr`;
            
            // Generate share link
            const roomCode = localStorage.getItem('rift_current_room') || '';
            const shareLink = `${window.location.origin}/login.html?room=${roomCode}`;
            document.getElementById('sessionShareLink').value = shareLink;
        }
        
        function closeCreatedModal() {
            createdModal.classList.remove('open');
            document.body.style.overflow = '';
        }
        
        // Event Listeners
        createBtn?.addEventListener('click', openCreateModal);
        
        document.getElementById('closeSessionModal')?.addEventListener('click', closeCreateModal);
        document.getElementById('cancelSessionBtn')?.addEventListener('click', closeCreateModal);
        createModal?.querySelector('.modal__backdrop')?.addEventListener('click', closeCreateModal);
        
        document.getElementById('closeCreatedModal')?.addEventListener('click', closeCreatedModal);
        document.getElementById('closeCreatedBtn')?.addEventListener('click', closeCreatedModal);
        createdModal?.querySelector('.modal__backdrop')?.addEventListener('click', closeCreatedModal);
        
        // ========================================
        // TAB SWITCHING
        // ========================================
        
        document.querySelectorAll('.session-modal__tab[data-create-tab]').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.createTab;
                
                // Update tab buttons
                document.querySelectorAll('.session-modal__tab[data-create-tab]').forEach(t => 
                    t.classList.remove('session-modal__tab--active'));
                tab.classList.add('session-modal__tab--active');
                
                // Update tab content
                document.querySelectorAll('.session-modal__tab-content').forEach(c => 
                    c.classList.remove('session-modal__tab-content--active'));
                document.getElementById(`createTab-${tabName}`)?.classList.add('session-modal__tab-content--active');
            });
        });
        
        // ========================================
        // COVER UPLOAD (Cloudinary)
        // ========================================
        
        let createCoverDataUrl = null;
        
        const createCoverArea = document.getElementById('createCoverArea');
        const createCoverInput = document.getElementById('createCoverInput');
        const createCoverPreview = document.getElementById('createCoverPreview');
        const createCoverRemove = document.getElementById('createCoverRemove');
        
        // Cloudinary config (same as session-lobby)
        const CreateCoverStorage = {
            cloudName: 'dza4jgreq',
            uploadPreset: 'RIFTapp',
            
            async upload(sessionId, imageDataUrl) {
                const response = await fetch(imageDataUrl);
                const blob = await response.blob();
                
                const timestamp = Date.now();
                const formData = new FormData();
                formData.append('file', blob);
                formData.append('upload_preset', this.uploadPreset);
                formData.append('public_id', `session-covers/${sessionId}_${timestamp}`);
                
                const uploadResponse = await fetch(`https://api.cloudinary.com/v1_1/${this.cloudName}/image/upload`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await uploadResponse.json();
                return result.secure_url + '?v=' + timestamp;
            }
        };
        
        createCoverArea?.addEventListener('click', (e) => {
            if (e.target !== createCoverRemove && !createCoverRemove.contains(e.target)) {
                createCoverInput.click();
            }
        });
        
        createCoverInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                // Open cropper for 2:3 aspect ratio
                openCropper(event.target.result, 'createCover', 2/3, 'Cover zuschneiden (2:3)');
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });
        
        createCoverRemove?.addEventListener('click', (e) => {
            e.stopPropagation();
            createCoverDataUrl = null;
            createCoverPreview.innerHTML = `<div class="create-cover-upload__placeholder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" width="32" height="32">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                </svg>
                <span>Cover hochladen</span>
            </div>`;
            createCoverRemove.style.display = 'none';
        });
        
        // ========================================
        // CROPPER SETUP
        // ========================================
        
        const cropperModal = document.getElementById('cropperModal');
        const cropperImage = document.getElementById('cropperImage');
        const cropperTitle = document.getElementById('cropperTitle');
        let currentCropper = null;
        let currentCropTarget = null; // 'cover' or 'thumbnail'
        
        function openCropper(imageSrc, target, aspectRatio, title) {
            currentCropTarget = target;
            cropperTitle.textContent = title;
            cropperImage.src = imageSrc;
            cropperModal.classList.add('open');
            document.body.style.overflow = 'hidden';
            
            // Destroy existing cropper first
            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }
            
            // Wait for image to load
            cropperImage.onload = () => {
                currentCropper = new Cropper(cropperImage, {
                    aspectRatio: aspectRatio,
                    viewMode: 2,
                    dragMode: 'crop',
                    autoCropArea: 0.9,
                    restore: false,
                    guides: true,
                    center: true,
                    highlight: true,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    toggleDragModeOnDblclick: false,
                    background: true,
                    modal: true,
                    responsive: true,
                    checkCrossOrigin: false,
                });
            };
        }
        
        function closeCropper() {
            cropperModal.classList.remove('open');
            document.body.style.overflow = '';
            if (currentCropper) {
                currentCropper.destroy();
                currentCropper = null;
            }
            currentCropTarget = null;
            // Reset input so same file can be selected again
            coverInput.value = '';
            thumbnailInput.value = '';
        }
        
        document.getElementById('closeCropper')?.addEventListener('click', closeCropper);
        document.getElementById('cancelCrop')?.addEventListener('click', closeCropper);
        
        document.getElementById('saveCrop')?.addEventListener('click', () => {
            if (!currentCropper || !currentCropTarget) return;
            
            // Different sizes based on target
            let maxWidth, maxHeight;
            if (currentCropTarget === 'createCover') {
                maxWidth = 600;
                maxHeight = 900;
            } else if (currentCropTarget === 'cover') {
                maxWidth = 1200;
                maxHeight = 400;
            } else {
                maxWidth = 200;
                maxHeight = 300;
            }
            
            const canvas = currentCropper.getCroppedCanvas({
                maxWidth,
                maxHeight,
            });
            
            const croppedData = canvas.toDataURL('image/jpeg', 0.85);
            
            if (currentCropTarget === 'createCover') {
                // New cover upload
                createCoverDataUrl = croppedData;
                createCoverPreview.innerHTML = `<img src="${croppedData}" alt="Cover">`;
                createCoverRemove.style.display = 'flex';
            } else if (currentCropTarget === 'cover') {
                if (coverPreviewImg) coverPreviewImg.src = croppedData;
                if (coverPreview) { coverPreview.style.display = 'block'; }
                if (coverPlaceholder) { coverPlaceholder.style.display = 'none'; }
                coverRemoved = false;
            } else if (currentCropTarget === 'thumbnail') {
                if (thumbnailPreviewImg) thumbnailPreviewImg.src = croppedData;
                if (thumbnailPreview) { thumbnailPreview.style.display = 'block'; }
                if (thumbnailPlaceholder) { thumbnailPlaceholder.style.display = 'none'; }
                thumbnailRemoved = false;
            }
            
            closeCropper();
        });
        
        // ========================================
        // COVER IMAGE UPLOAD
        // ========================================
        
        const coverUploadArea = document.getElementById('coverUploadArea');
        const coverInput = document.getElementById('sessionCover');
        const coverPreview = document.getElementById('coverPreview');
        const coverPreviewImg = document.getElementById('coverPreviewImg');
        const coverPlaceholder = document.getElementById('coverPlaceholder');
        const removeCoverBtn = document.getElementById('removeCover');
        
        // Track if cover was explicitly removed
        let coverRemoved = false;
        
        coverUploadArea?.addEventListener('click', () => {
            if (!coverPreview.style.display || coverPreview.style.display === 'none') {
                coverInput.click();
            }
        });
        
        coverInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Open cropper with 3:1 aspect ratio
                    openCropper(e.target.result, 'cover', 3/1, 'Header-Cover zuschneiden (3:1)');
                };
                reader.readAsDataURL(file);
            }
        });
        
        removeCoverBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            coverInput.value = '';
            if (coverPreviewImg) coverPreviewImg.src = '';
            coverPreview.style.display = 'none';
            coverPlaceholder.style.display = 'flex';
            coverRemoved = true; // Mark as explicitly removed
        });
        
        // ========================================
        // THUMBNAIL IMAGE UPLOAD
        // ========================================
        
        const thumbnailUploadArea = document.getElementById('thumbnailUploadArea');
        const thumbnailInput = document.getElementById('sessionThumbnail');
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        const thumbnailPreviewImg = document.getElementById('thumbnailPreviewImg');
        const thumbnailPlaceholder = document.getElementById('thumbnailPlaceholder');
        const removeThumbnailBtn = document.getElementById('removeThumbnail');
        
        let thumbnailRemoved = false;
        
        thumbnailUploadArea?.addEventListener('click', () => {
            if (!thumbnailPreview.style.display || thumbnailPreview.style.display === 'none') {
                thumbnailInput.click();
            }
        });
        
        thumbnailInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Open cropper with 2:3 aspect ratio (portrait)
                    openCropper(e.target.result, 'thumbnail', 2/3, 'Thumbnail zuschneiden (2:3 hochkant)');
                };
                reader.readAsDataURL(file);
            }
        });
        
        removeThumbnailBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            thumbnailInput.value = '';
            if (thumbnailPreviewImg) thumbnailPreviewImg.src = '';
            thumbnailPreview.style.display = 'none';
            thumbnailPlaceholder.style.display = 'flex';
            thumbnailRemoved = true;
        });
        
        // ========================================
        // CUSTOM TAGS
        // ========================================
        
        let customTags = [];
        const customTagsList = document.getElementById('customTagsList');
        const customTagInput = document.getElementById('customTagInput');
        const addCustomTagBtn = document.getElementById('addCustomTagBtn');
        
        function renderCustomTags() {
            customTagsList.innerHTML = customTags.map((tag, index) => `
                <span class="form-custom-tag">
                    ${tag}
                    <button type="button" onclick="removeCustomTag(${index})">×</button>
                </span>
            `).join('');
        }
        
        function addCustomTag() {
            const value = customTagInput.value.trim();
            if (value && !customTags.includes(value) && customTags.length < 10) {
                customTags.push(value);
                renderCustomTags();
                customTagInput.value = '';
            }
        }
        
        window.removeCustomTag = function(index) {
            customTags.splice(index, 1);
            renderCustomTags();
        };
        
        addCustomTagBtn?.addEventListener('click', addCustomTag);
        customTagInput?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addCustomTag();
            }
        });
        
        // ========================================
        // SAVE SESSION (CREATE OR UPDATE)
        // ========================================
        
        document.getElementById('saveSessionBtn')?.addEventListener('click', async () => {
            const ruleset = document.querySelector('input[name="createRuleset"]:checked')?.value || '';
            const name = document.getElementById('sessionName').value.trim();
            const subtitle = document.getElementById('sessionSubtitle')?.value.trim() || '';
            const description = document.getElementById('sessionDescription').value.trim();
            const voiceLink = document.getElementById('sessionVoiceLink').value.trim();
            const sessionCount = document.getElementById('sessionCount').value;
            const maxPlayers = document.getElementById('sessionMaxPlayers').value;
            const date = document.getElementById('sessionDate').value;
            const time = document.getElementById('sessionTime').value;
            const recurring = document.getElementById('sessionRecurring').value;
            const duration = document.getElementById('sessionDuration').value;
            const visibility = document.querySelector('input[name="visibility"]:checked')?.value || 'public';
            
            // Get selected tags (predefined + custom)
            const tags = [];
            document.querySelectorAll('#sessionTags input:checked').forEach(cb => {
                tags.push(cb.value);
            });
            // Add custom tags
            customTags.forEach(tag => tags.push(tag));
            
            // Validation
            if (!ruleset) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Bitte wähle ein Regelwerk', 'Fehler');
                } else {
                    alert('Bitte wähle ein Regelwerk');
                }
                return;
            }
            
            if (!name) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Bitte gib einen Namen ein', 'Fehler');
                } else {
                    alert('Bitte gib einen Namen ein');
                }
                return;
            }
            
            if (!date) {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.error('Bitte wähle ein Datum', 'Fehler');
                } else {
                    alert('Bitte wähle ein Datum');
                }
                return;
            }
            
            // Use firebaseSessions for lookup
            const sessions = firebaseSessions;
            
            if (editingSessionId) {
                // UPDATE existing session
                const existing = sessions.find(s => s.id === editingSessionId);
                if (existing) {
                    // Handle cover URL
                    let coverUrl = existing.coverUrl || null;
                    
                    // New cover uploaded (base64)?
                    if (createCoverDataUrl && createCoverDataUrl.startsWith('data:')) {
                        try {
                            coverUrl = await CreateCoverStorage.upload(editingSessionId, createCoverDataUrl);
                            console.log('[Sessions] Cover uploaded to Cloudinary:', coverUrl);
                        } catch (err) {
                            console.error('[Sessions] Failed to upload cover:', err);
                            RIFT.ui.Toast?.error('Cover konnte nicht hochgeladen werden');
                        }
                    } else if (createCoverDataUrl === null && existing.coverUrl) {
                        // Cover was explicitly removed
                        coverUrl = null;
                    } else if (createCoverDataUrl && createCoverDataUrl.startsWith('http')) {
                        // Keep existing URL
                        coverUrl = createCoverDataUrl;
                    }
                    
                    const updates = {
                        ruleset,
                        name,
                        subtitle,
                        description,
                        voiceLink,
                        sessionCount: parseInt(sessionCount) || 1,
                        maxPlayers: parseInt(maxPlayers) || 4,
                        date,
                        time,
                        recurring,
                        duration: parseInt(duration),
                        visibility,
                        tags,
                        coverUrl
                    };
                    
                    // Update in Firebase (if in room) or localStorage (solo mode)
                    try {
                        if (currentRoomCode && RIFT?.rooms?.updateSession) {
                            await RIFT.rooms.updateSession(currentRoomCode, editingSessionId, updates);
                            console.log('[Sessions] Updated session in Firebase:', editingSessionId);
                        } else {
                            // Fallback to localStorage
                            const localSessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
                            const index = localSessions.findIndex(s => s.id === editingSessionId);
                            if (index >= 0) {
                                localSessions[index] = { ...existing, ...updates, updatedAt: Date.now() };
                                localStorage.setItem('rift_sessions', JSON.stringify(localSessions));
                            }
                        }
                    } catch (err) {
                        console.error('[Sessions] Failed to update session:', err);
                        if (window.RIFT?.ui?.Toast) {
                            RIFT.ui.Toast.error('Fehler beim Aktualisieren der Session');
                        }
                        return;
                    }
                    
                    // Save cover image to IndexedDB (if new cover uploaded)
                    if (coverPreviewImg && coverPreviewImg.src && coverPreviewImg.src.startsWith('data:')) {
                        CoverDB.save(editingSessionId, coverPreviewImg.src).catch(err => {
                            console.warn('Failed to save cover:', err);
                        });
                    }
                    
                    // Delete cover from IndexedDB if explicitly removed
                    if (coverRemoved && existing.hasCover) {
                        CoverDB.delete(editingSessionId).catch(err => {
                            console.warn('Failed to delete cover:', err);
                        });
                    }
                    
                    // Save thumbnail to IndexedDB (if new thumbnail uploaded)
                    if (thumbnailPreviewImg && thumbnailPreviewImg.src && thumbnailPreviewImg.src.startsWith('data:')) {
                        CoverDB.save('thumb_' + editingSessionId, thumbnailPreviewImg.src).catch(err => {
                            console.warn('Failed to save thumbnail:', err);
                        });
                    }
                    
                    // Delete thumbnail from IndexedDB if explicitly removed
                    if (thumbnailRemoved && existing.hasThumbnail) {
                        CoverDB.delete('thumb_' + editingSessionId).catch(err => {
                            console.warn('Failed to delete thumbnail:', err);
                        });
                    }
                    
                    console.log('Session updated:', editingSessionId);
                    
                    closeCreateModal();
                    
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.success('Session aktualisiert!');
                    }
                }
            } else {
                // CREATE new session
                
                // ── Pro Limit Check ──
                if (window.RIFT?.pro?.initialized) {
                    const activeCount = RIFT.pro.getActiveSessionCount(firebaseSessions);
                    if (!RIFT.pro.checkLimit('activeSessions', activeCount)) {
                        const limit = RIFT.pro.getLimit('activeSessions');
                        const comparison = RIFT.pro.getLimitComparison('activeSessions');
                        
                        // Show upsell
                        if (window.RIFT?.ui?.Toast) {
                            RIFT.ui.Toast.warning(
                                `Du hast bereits ${activeCount} von ${limit} aktiven Sessions. ` +
                                `Mit RIFT Pro: unbegrenzt.`
                            );
                        }
                        RIFT.pro.showUpsell(
                            `Session-Limit erreicht (${activeCount}/${limit})`,
                            { limitKey: 'activeSessions' }
                        );
                        return;
                    }
                }
                
                const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const currentUserId = window.currentUser?.uid || localStorage.getItem('rift_user_uid') || null;
                
                // Get current user data for GM info
                const userData = JSON.parse(localStorage.getItem('rift_user') || '{}');
                const gmName = userData.name || userData.displayName || window.currentUser?.displayName || 'Game Master';
                const gmColor = userData.color || '#FF4655';
                const gmAvatar = userData.avatar || userData.photoURL || window.currentUser?.photoURL || null;
                
                // Upload cover to Cloudinary if exists
                let coverUrl = null;
                if (createCoverDataUrl && createCoverDataUrl.startsWith('data:')) {
                    try {
                        coverUrl = await CreateCoverStorage.upload(sessionId, createCoverDataUrl);
                        console.log('[Sessions] Cover uploaded to Cloudinary:', coverUrl);
                    } catch (err) {
                        console.error('[Sessions] Failed to upload cover:', err);
                        // Continue without cover
                    }
                }
                
                const sessionData = {
                    id: sessionId,
                    roomCode: currentRoomCode,
                    ownerId: currentUserId,
                    gmName: gmName,
                    gmColor: gmColor,
                    gm: { name: gmName, color: gmColor, avatar: gmAvatar },
                    ruleset,
                    name,
                    subtitle,
                    description,
                    voiceLink,
                    sessionCount: parseInt(sessionCount) || 1,
                    maxPlayers: parseInt(maxPlayers) || 4,
                    date,
                    time,
                    recurring,
                    duration: parseInt(duration),
                    visibility,
                    tags,
                    status: 'planned',
                    coverUrl,
                    currentSession: 1
                };
                
                // Save to Firebase (if in room) or localStorage (solo mode)
                try {
                    if (currentRoomCode && RIFT?.rooms?.createSession) {
                        await RIFT.rooms.createSession(currentRoomCode, sessionData);
                        console.log('[Sessions] Created session in Firebase:', sessionId);
                    } else {
                        // Fallback to localStorage
                        sessions.push(sessionData);
                        localStorage.setItem('rift_sessions', JSON.stringify(sessions));
                        console.log('[Sessions] Created session in localStorage:', sessionId);
                    }
                } catch (err) {
                    console.error('[Sessions] Failed to create session:', err);
                    if (window.RIFT?.ui?.Toast) {
                        RIFT.ui.Toast.error('Fehler beim Erstellen der Session');
                    }
                    return;
                }
                
                console.log('Session created:', sessionData);
                
                // Close create modal, open success modal
                closeCreateModal();
                openCreatedModal(sessionData);
            }
        });
        
        // ========================================
        // COPY SHARE LINK
        // ========================================
        
        document.getElementById('copySessionLink')?.addEventListener('click', () => {
            const linkInput = document.getElementById('sessionShareLink');
            linkInput.select();
            navigator.clipboard.writeText(linkInput.value).then(() => {
                if (window.RIFT?.ui?.Toast) {
                    RIFT.ui.Toast.success('Link kopiert!', 'Einladungslink');
                }
            });
        });
        
        // ========================================
        // GO TO SESSION
        // ========================================
        
        document.getElementById('goToSessionBtn')?.addEventListener('click', () => {
            closeCreatedModal();
            if (lastCreatedSessionId) {
                window.location.href = `/session?id=${lastCreatedSessionId}`;
            }
        });
        
        // ========================================
        // RENDER SESSIONS
        // ========================================
        
        const rulesetConfig = {
            '5e2024': { name: 'D&D 5e (2024)', icon: 'ruleset_5e_2024.svg', class: '5e' },
            'worldsapart': { name: 'Worlds Apart', icon: 'ruleset_worldsapart.svg', class: 'worldsapart' },
            'htbah': { name: 'How To Be A Hero', icon: 'ruleset_htbah.svg', class: 'htbah' },
            'cyberpunk': { name: 'Cyberpunk Red', icon: 'ruleset_cyberpunkred.svg', class: 'cyberpunk' }
        };
        
        const weekdaysShort = ['SO', 'MO', 'DI', 'MI', 'DO', 'FR', 'SA'];
        const monthsShort = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
        
        function renderSessionCard(session, isPast = false) {
            const dateObj = new Date(session.date);
            const ruleset = rulesetConfig[session.ruleset] || { name: session.ruleset, icon: 'ruleset_worldsapart.svg', class: 'worldsapart' };
            
            // Build meta info for top row
            const sessionInfo = session.sessionCount > 1 
                ? `Session ${session.currentSession || 1}/${session.sessionCount}`
                : '';
            const playerInfo = `${session.maxPlayers || 4} Teilnehmer`;
            
            // Description preview (truncate to ~100 chars)
            const descPreview = session.description 
                ? session.description.substring(0, 120) + (session.description.length > 120 ? '...' : '')
                : 'Keine Beschreibung vorhanden.';
            
            // RIFT Logo SVG for fallback
            const riftLogoSvg = `<svg width="64" height="64" viewBox="0 0 100 100" fill="currentColor" opacity="0.4">
                <path d="M20 20h25v60h-25zM55 20h25v25h-25zM55 55h25l-25 25z"/>
            </svg>`;
            
            // Check for Cloudinary coverUrl first, then fallback to IndexedDB
            const hasCoverUrl = !!session.coverUrl;
            const thumbKey = session.hasThumbnail ? 'thumb_' + session.id : (session.hasCover ? session.id : null);
            
            return `
                <a href="/session?id=${session.id}" class="session-card session-card--${isPast ? 'past' : 'upcoming'}" data-session-id="${session.id}">
                    <div class="session-card__cover session-card__cover--${ruleset.class}" data-cover-id="${session.id}">
                        ${hasCoverUrl ? `
                            <img class="session-card__cover-img loaded" src="${session.coverUrl}" alt="">
                        ` : `
                            <img class="session-card__cover-img" src="" alt="" data-cover-img="${thumbKey || session.id}" data-has-image="${thumbKey ? 'true' : 'false'}">
                        `}
                        <div class="session-card__cover-fallback" ${hasCoverUrl ? 'style="display: none;"' : ''}>
                            ${riftLogoSvg}
                        </div>
                    </div>
                    <div class="session-card__date">
                        <span class="session-card__day">${weekdaysShort[dateObj.getDay()]}</span>
                        <span class="session-card__num">${String(dateObj.getDate()).padStart(2, '0')}</span>
                        <span class="session-card__month">${monthsShort[dateObj.getMonth()]}</span>
                    </div>
                    <div class="session-card__content">
                        <div class="session-card__top">
                            <div class="ruleset-badge ruleset-badge--${ruleset.class} ruleset-badge--sm">
                                <img src="/assets/img/rulesets/${ruleset.icon}" alt="">
                                <span>${ruleset.name}</span>
                            </div>
                            <div class="session-card__meta">
                                <span>${session.time || '20:00'} Uhr</span>
                                ${sessionInfo ? `<span class="session-card__meta-divider"></span><span>${sessionInfo}</span>` : ''}
                                <span class="session-card__meta-divider"></span>
                                <span>${playerInfo}</span>
                                <span class="session-card__meta-divider"></span>
                                <span>GM: ${session.gm?.name || session.gmName || 'Game Master'}</span>
                            </div>
                        </div>
                        <h3 class="session-card__title">${session.name}</h3>
                        ${session.subtitle ? `<span class="session-card__subtitle">${session.subtitle}</span>` : ''}
                        <p class="session-card__desc">${descPreview}</p>
                    </div>
                    <div class="session-card__actions">
                        <button class="session-card__btn session-card__btn--primary" title="Session öffnen" onclick="event.stopPropagation(); window.location.href='/session?id=${session.id}';">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                        </button>
                        <button class="session-card__btn session-card__edit-btn" title="Bearbeiten" onclick="event.preventDefault(); event.stopPropagation(); editSession('${session.id}');">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                    </div>
                </a>
            `;
        }
        
        function renderSessions() {
            // Use Firebase sessions (already filtered by room via subscription)
            // Deduplicate by session ID (safety net against double-creation)
            const seen = new Set();
            const sessions = firebaseSessions.filter(s => {
                if (seen.has(s.id)) return false;
                seen.add(s.id);
                return true;
            });
            const currentUserId = window.currentUser?.uid || null;
            
            console.log('[Sessions] Rendering', sessions.length, 'sessions (deduped from', firebaseSessions.length, ')');
            
            // Separate upcoming and past sessions
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const upcoming = sessions.filter(s => {
                const sessionDate = new Date(s.date);
                return sessionDate >= today && s.status !== 'ended';
            }).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const past = sessions.filter(s => {
                const sessionDate = new Date(s.date);
                return sessionDate < today || s.status === 'ended';
            }).sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Render upcoming sessions
            const upcomingContainer = document.getElementById('upcomingSessions');
            const upcomingEmpty = document.getElementById('upcomingEmpty');
            const upcomingCount = document.getElementById('upcomingCount');
            
            if (upcoming.length > 0) {
                upcomingContainer.innerHTML = upcoming.map(s => renderSessionCard(s, false)).join('');
                upcomingEmpty.style.display = 'none';
            } else {
                upcomingContainer.innerHTML = '';
                upcomingEmpty.style.display = 'flex';
            }
            upcomingCount.textContent = `${upcoming.length} geplant`;
            
            // Show session slot info with Pro/Free limits
            const pro = (typeof RIFT !== 'undefined' && RIFT.pro && RIFT.pro.initialized) ? RIFT.pro : null;
            const maxSessions = pro ? pro.getLimit('sessionsPerRoom') : 2; // Default Free: 2
            const allActive = sessions.filter(s => s.status !== 'ended').length;
            
            if (maxSessions !== Infinity) {
                upcomingCount.innerHTML = `${allActive} / ${maxSessions} Slots belegt`;
                if ((!pro || !pro.isPro) && allActive >= maxSessions) {
                    upcomingCount.innerHTML += ` · <a href="/donate" style="color:var(--text-muted);font-size:11px;display:inline-flex;align-items:center;gap:3px;"><img src="/assets/rift_pro/img/svg/rift_pro_badge02_gold.svg" alt="Pro" style="height:12px;"> Mehr</a>`;
                }
            }
            
            // Render past sessions
            const pastContainer = document.getElementById('pastSessions');
            const pastEmpty = document.getElementById('pastEmpty');
            
            if (pastContainer && pastEmpty) {
                // Apply ruleset filter
                const historyFilter = document.getElementById('historyFilter');
                const filterValue = historyFilter?.value || 'all';
                const filteredPast = filterValue === 'all' 
                    ? past 
                    : past.filter(s => s.ruleset === filterValue);
                
                if (filteredPast.length > 0) {
                    pastEmpty.style.display = 'none';
                    pastContainer.innerHTML = filteredPast.map(s => renderSessionCard(s, true)).join('');
                } else {
                    pastEmpty.style.display = 'flex';
                    pastContainer.innerHTML = '';
                }
            }
            
            // Update GM visibility after render
            if (typeof updateGMVisibility === 'function') updateGMVisibility();
        }
        
        // Load cover images from IndexedDB after rendering
        async function loadSessionCovers() {
            const coverImgs = document.querySelectorAll('[data-cover-img]');
            
            for (const img of coverImgs) {
                const coverKey = img.dataset.coverImg;
                const hasImage = img.dataset.hasImage === 'true';
                
                if (!hasImage) continue; // No image to load
                
                try {
                    const coverData = await CoverDB.get(coverKey);
                    if (coverData) {
                        img.src = coverData;
                        img.classList.add('loaded');
                    }
                } catch (err) {
                    // No cover or error - fallback stays visible
                }
            }
        }
        
        // Initial render will be triggered by initFirebaseSessions callback
        // renderSessions();
        // loadSessionCovers();
        
        // ========================================
        // ACTIVE SESSION (Firestore-based)
        // ========================================
        
        let activeTimerInterval = null;
        let _activeSessionId = null;
        
        // Ruleset config
        const RULESET_CONFIG = {
            'worldsapart': { name: 'Worlds Apart', icon: 'ruleset_worldsapart.svg', cls: 'worldsapart', gradient: 'linear-gradient(135deg, #7c3aed 0%, #4c1d95 100%)' },
            'dnd5e':       { name: 'D&D 5e',       icon: 'ruleset_5e_2024.svg',     cls: '5e',          gradient: 'linear-gradient(135deg, #dc2626 0%, #7f1d1d 100%)' },
            '5e2024':      { name: 'D&D 5e',       icon: 'ruleset_5e_2024.svg',     cls: '5e',          gradient: 'linear-gradient(135deg, #dc2626 0%, #7f1d1d 100%)' },
            'htbah':       { name: 'How To Be A Hero', icon: 'ruleset_htbah.svg',   cls: 'htbah',       gradient: 'linear-gradient(135deg, #059669 0%, #064e3b 100%)' },
            'cyberpunkred':{ name: 'Cyberpunk RED', icon: 'ruleset_cyberpunkred.svg',cls: 'cyberpunk',   gradient: 'linear-gradient(135deg, #eab308 0%, #854d0e 100%)' },
            'cyberpunk':   { name: 'Cyberpunk RED', icon: 'ruleset_cyberpunkred.svg',cls: 'cyberpunk',   gradient: 'linear-gradient(135deg, #eab308 0%, #854d0e 100%)' }
        };
        
        /**
         * Check firebaseSessions for any live/paused session and render the banner.
         * Called after every Firebase subscription update.
         */
        function checkActiveSession() {
            // Find live or paused session from Firestore data
            const liveSession = firebaseSessions.find(s => s.status === 'live' || s.status === 'paused');
            
            const section = document.getElementById('activeSessionSection');
            const divider = document.getElementById('activeSessionDivider');
            
            if (!liveSession) {
                // No active session — hide banner
                section.style.display = 'none';
                divider.style.display = 'none';
                if (activeTimerInterval) { clearInterval(activeTimerInterval); activeTimerInterval = null; }
                _activeSessionId = null;
                // Sync localStorage (for legacy consumers)
                localStorage.removeItem('rift_active_session');
                return;
            }
            
            _activeSessionId = liveSession.id;
            section.style.display = 'block';
            divider.style.display = 'block';
            
            // Sync to localStorage for cross-page awareness
            localStorage.setItem('rift_active_session', JSON.stringify({
                id: liveSession.id,
                name: liveSession.name,
                startTime: liveSession.startTime,
                status: liveSession.status,
                pausedTime: liveSession.pausedTime || null,
                totalPausedMs: liveSession.totalPausedMs || 0
            }));
            
            const isPaused = liveSession.status === 'paused';
            
            // --- Session name ---
            document.getElementById('activeSessionName').textContent = liveSession.name || 'Session';
            
            // --- Link ---
            const sessionUrl = `/session?id=${liveSession.id}`;
            const goBtn = document.getElementById('goToActiveSessionBtn');
            const nameLink = document.getElementById('activeSessionNameLink');
            if (goBtn) goBtn.href = sessionUrl;
            if (nameLink) nameLink.href = sessionUrl;
            
            // --- Meta ---
            const sessionNum = liveSession.currentSession || 1;
            const totalSessions = liveSession.sessionCount || 1;
            const maxPlayers = liveSession.maxPlayers || 4;
            const metaText = `Session ${sessionNum}${totalSessions > 1 ? '/' + totalSessions : ''} · ${maxPlayers} Teilnehmer`;
            document.getElementById('activeSessionMeta').textContent = metaText;
            
            // --- Ruleset badge ---
            const rs = RULESET_CONFIG[liveSession.ruleset] || RULESET_CONFIG['worldsapart'];
            const rulesetBadge = document.getElementById('activeSessionRuleset');
            const rulesetIcon = document.getElementById('activeSessionRulesetIcon');
            const rulesetName = document.getElementById('activeSessionRulesetName');
            if (rulesetBadge) rulesetBadge.className = `ruleset-badge ruleset-badge--${rs.cls}`;
            if (rulesetIcon) rulesetIcon.src = `/assets/img/rulesets/${rs.icon}`;
            if (rulesetName) rulesetName.textContent = rs.name;
            
            // --- Cover ---
            const coverEl = document.getElementById('activeSessionCover');
            const coverImg = document.getElementById('activeSessionCoverImg');
            if (liveSession.coverUrl) {
                coverImg.src = liveSession.coverUrl;
                coverImg.classList.add('loaded');
            } else if (coverEl) {
                coverEl.style.background = isPaused ? 'linear-gradient(135deg, #374151 0%, #1f2937 100%)' : rs.gradient;
            }
            
            // --- Status & GM actions ---
            const statusEl = document.getElementById('activeSessionStatus');
            const titleEl = document.getElementById('activeSessionTitle');
            const pauseBtn = document.getElementById('pauseActiveSessionBtn');
            const resumeBtn = document.getElementById('resumeActiveSessionBtn');
            
            if (isPaused) {
                statusEl.textContent = '⏸ Pausiert';
                statusEl.className = 'active-session__live active-session__live--paused';
                titleEl.textContent = 'Session pausiert';
                section.classList.add('active-session--paused');
                if (pauseBtn) pauseBtn.style.display = 'none';
                if (resumeBtn) resumeBtn.style.display = 'flex';
            } else {
                statusEl.textContent = '● Live';
                statusEl.className = 'active-session__live';
                titleEl.textContent = 'Session läuft gerade';
                section.classList.remove('active-session--paused');
                if (pauseBtn) pauseBtn.style.display = 'flex';
                if (resumeBtn) resumeBtn.style.display = 'none';
            }
            
            // --- GM check ---
            const currentUserId = firebase?.auth()?.currentUser?.uid || localStorage.getItem('rift_user_uid') || null;
            const isSessionGM = currentUserId && liveSession.ownerId === currentUserId;
            const gmActions = document.getElementById('activeSessionGmActions');
            if (gmActions) gmActions.style.display = isSessionGM ? '' : 'none';
            
            // --- Timer ---
            if (activeTimerInterval) { clearInterval(activeTimerInterval); activeTimerInterval = null; }
            
            if (liveSession.startTime) {
                const startMs = typeof liveSession.startTime === 'number' ? liveSession.startTime : new Date(liveSession.startTime).getTime();
                const totalPausedMs = liveSession.totalPausedMs || 0;
                
                if (isPaused) {
                    // Show frozen time
                    const pausedAt = liveSession.pausedTime || Date.now();
                    const pausedMs = typeof pausedAt === 'number' ? pausedAt : new Date(pausedAt).getTime();
                    const elapsed = Math.max(0, pausedMs - startMs - totalPausedMs);
                    document.getElementById('activeSessionTime').textContent = formatElapsed(elapsed);
                } else {
                    // Live timer
                    function tick() {
                        const elapsed = Math.max(0, Date.now() - startMs - totalPausedMs);
                        const el = document.getElementById('activeSessionTime');
                        if (el) el.textContent = formatElapsed(elapsed);
                    }
                    tick();
                    activeTimerInterval = setInterval(tick, 1000);
                }
            } else {
                document.getElementById('activeSessionTime').textContent = '0:00:00';
            }
        }
        
        function formatElapsed(ms) {
            const h = Math.floor(ms / 3600000);
            const m = Math.floor((ms % 3600000) / 60000);
            const s = Math.floor((ms % 60000) / 1000);
            return h + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
        }
        
        // --- Pause button ---
        document.getElementById('pauseActiveSessionBtn')?.addEventListener('click', async () => {
            if (!_activeSessionId || !currentRoomCode) return;
            try {
                await RIFT.rooms.updateSession(currentRoomCode, _activeSessionId, {
                    status: 'paused',
                    pausedTime: Date.now()
                });
                if (window.RIFT?.focus?.updateStatus) RIFT.focus.updateStatus('paused');
                if (window.RIFT?.ui?.Toast) RIFT.ui.Toast.info('Session pausiert');
            } catch (e) {
                console.error('[Sessions] Pause failed:', e);
                if (window.RIFT?.ui?.Toast) RIFT.ui.Toast.error('Pausieren fehlgeschlagen');
            }
        });
        
        // --- Resume button ---
        document.getElementById('resumeActiveSessionBtn')?.addEventListener('click', async () => {
            if (!_activeSessionId || !currentRoomCode) return;
            const session = firebaseSessions.find(s => s.id === _activeSessionId);
            if (!session) return;
            
            // Calculate paused duration
            let newTotalPaused = session.totalPausedMs || 0;
            if (session.pausedTime) {
                const pausedMs = typeof session.pausedTime === 'number' ? session.pausedTime : new Date(session.pausedTime).getTime();
                newTotalPaused += Date.now() - pausedMs;
            }
            
            try {
                await RIFT.rooms.updateSession(currentRoomCode, _activeSessionId, {
                    status: 'live',
                    pausedTime: null,
                    totalPausedMs: newTotalPaused
                });
                if (window.RIFT?.focus?.updateStatus) RIFT.focus.updateStatus('live');
                if (window.RIFT?.ui?.Toast) RIFT.ui.Toast.success('Session fortgesetzt!');
            } catch (e) {
                console.error('[Sessions] Resume failed:', e);
                if (window.RIFT?.ui?.Toast) RIFT.ui.Toast.error('Fortsetzen fehlgeschlagen');
            }
        });
        
        // --- End session button ---
        document.getElementById('endSessionBtn')?.addEventListener('click', async () => {
            if (!_activeSessionId || !currentRoomCode) return;
            if (!confirm('Session wirklich beenden?')) return;
            
            const session = firebaseSessions.find(s => s.id === _activeSessionId);
            const startMs = session?.startTime ? (typeof session.startTime === 'number' ? session.startTime : new Date(session.startTime).getTime()) : Date.now();
            let totalDuration = Date.now() - startMs;
            if (session?.pausedTime) {
                const pausedMs = typeof session.pausedTime === 'number' ? session.pausedTime : new Date(session.pausedTime).getTime();
                totalDuration -= (Date.now() - pausedMs);
            }
            totalDuration -= (session?.totalPausedMs || 0);
            
            try {
                await RIFT.rooms.updateSession(currentRoomCode, _activeSessionId, {
                    status: 'ended',
                    endTime: Date.now(),
                    duration: Math.round(totalDuration / 60000)
                });
                if (window.RIFT?.focus?.clear) RIFT.focus.clear();
                localStorage.removeItem('rift_active_session');
                if (window.RIFT?.ui?.Toast) RIFT.ui.Toast.success('Session beendet!');
                // subscribeToSessions will auto-update the UI
            } catch (e) {
                console.error('[Sessions] End failed:', e);
                if (window.RIFT?.ui?.Toast) RIFT.ui.Toast.error('Beenden fehlgeschlagen');
            }
        });
        
        // ========================================
        // LOAD SESSIONS FROM LOCALSTORAGE
        // ========================================
        
        function loadSessions() {
            const allSessions = JSON.parse(localStorage.getItem('rift_sessions') || '[]');
            const now = new Date();
            const currentUserId = window.currentUser?.uid || null;
            
            console.log('[Sessions] Loading sessions, roomCode:', currentRoomCode, 'userId:', currentUserId);
            console.log('[Sessions] Total sessions in storage:', allSessions.length);
            allSessions.forEach(s => console.log('[Sessions] Session:', s.id, s.name, 'status:', s.status, 'roomCode:', s.roomCode, 'ownerId:', s.ownerId));
            
            // Filter sessions for current room AND/OR current user
            const sessions = allSessions.filter(s => {
                // If no filtering criteria, show all sessions
                if (!currentRoomCode && !currentUserId) {
                    return true;
                }
                
                // Always show sessions owned by current user
                if (currentUserId && s.ownerId === currentUserId) {
                    return true;
                }
                
                // If we have a room code, also show sessions for this room
                if (currentRoomCode && s.roomCode === currentRoomCode) {
                    return true;
                }
                
                // If no room code, show sessions without room code
                if (!currentRoomCode && !s.roomCode) {
                    return true;
                }
                
                return false;
            });
            
            console.log('[Sessions] Filtered sessions:', sessions.length);
            
            // Separate upcoming and past
            const upcoming = sessions.filter(s => {
                const sessionDate = new Date(s.date + 'T' + (s.time || '00:00'));
                return sessionDate >= now && s.status !== 'ended';
            }).sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const past = sessions.filter(s => {
                const sessionDate = new Date(s.date + 'T' + (s.time || '00:00'));
                return sessionDate < now || s.status === 'ended';
            }).sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Update counts
            document.getElementById('upcomingCount').textContent = `${upcoming.length} geplant`;
            
            // Show session slot info
            const pro2 = (typeof RIFT !== 'undefined' && RIFT.pro && RIFT.pro.initialized) ? RIFT.pro : null;
            const maxSessions2 = pro2 ? pro2.getLimit('sessionsPerRoom') : 2;
            const allActive2 = sessions.filter(s => s.status !== 'ended').length;
            if (maxSessions2 !== Infinity) {
                const countEl = document.getElementById('upcomingCount');
                countEl.innerHTML = `${allActive2} / ${maxSessions2} Slots belegt`;
                if ((!pro2 || !pro2.isPro) && allActive2 >= maxSessions2) {
                        countEl.innerHTML += ` · <a href="/donate" style="color:var(--text-muted);font-size:11px;display:inline-flex;align-items:center;gap:3px;"><img src="/assets/rift_pro/img/svg/rift_pro_badge02_gold.svg" alt="Pro" style="height:12px;"> Mehr</a>`;
                    }
            }
            
            // Render upcoming
            const upcomingContainer = document.getElementById('upcomingSessions');
            const upcomingEmpty = document.getElementById('upcomingEmpty');
            
            if (upcoming.length > 0) {
                upcomingEmpty.style.display = 'none';
                upcomingContainer.innerHTML = upcoming.map(s => renderSessionCard(s, false)).join('');
            } else {
                upcomingEmpty.style.display = 'flex';
                upcomingContainer.innerHTML = '';
            }
            
            // Render past
            const pastContainer = document.getElementById('pastSessions');
            const pastEmpty = document.getElementById('pastEmpty');
            
            // Apply ruleset filter
            const historyFilter = document.getElementById('historyFilter');
            const filterValue = historyFilter?.value || 'all';
            const filteredPast = filterValue === 'all' 
                ? past 
                : past.filter(s => s.ruleset === filterValue);
            
            if (filteredPast.length > 0) {
                pastEmpty.style.display = 'none';
                pastContainer.innerHTML = filteredPast.map(s => renderSessionCard(s, true)).join('');
                document.getElementById('loadMoreContainer').style.display = filteredPast.length > 5 ? 'flex' : 'none';
            } else {
                pastEmpty.style.display = 'flex';
                pastContainer.innerHTML = '';
            }
            
            // Update stats
            document.getElementById('statSessionsPlayed').textContent = past.length;
            
            // Load cover images
            loadSessionCovers();
        }
        
        // Load sessions on page load
        loadSessions();
        
        // Filter event listener
        document.getElementById('historyFilter')?.addEventListener('change', () => {
            loadSessions();
        });
        
        // Make functions globally available for onclick handlers
        window.openCreateModal = openCreateModal;
        window.closeCreateModal = closeCreateModal;
        window.editSession = editSession;
        window.addCustomTag = addCustomTag;
        } // end re-execution guard
    </script>
    <script src="/assets/js/broadcast.js"></script>
</body>
</html>
